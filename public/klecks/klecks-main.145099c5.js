// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      if (res === false) {
        return {};
      }
      // Synthesize a module to follow re-exports.
      if (Array.isArray(res)) {
        var m = {__esModule: true};
        res.forEach(function (v) {
          var key = v[0];
          var id = v[1];
          var exp = v[2] || v[0];
          var x = newRequire(id);
          if (key === '*') {
            Object.keys(x).forEach(function (key) {
              if (
                key === 'default' ||
                key === '__esModule' ||
                Object.prototype.hasOwnProperty.call(m, key)
              ) {
                return;
              }

              Object.defineProperty(m, key, {
                enumerable: true,
                get: function () {
                  return x[key];
                },
              });
            });
          } else if (exp === '*') {
            Object.defineProperty(m, key, {
              enumerable: true,
              value: x,
            });
          } else {
            Object.defineProperty(m, key, {
              enumerable: true,
              get: function () {
                if (exp === 'default') {
                  return x.__esModule ? x.default : x;
                }
                return x[exp];
              },
            });
          }
        });
        return m;
      }
      return newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  function $parcel$resolve(url) {  url = importMap[url] || url;  return import.meta.resolve(distDir + url);}newRequire.resolve = $parcel$resolve;

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"fsWvP":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "6aa113ac145099c5";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"jcEgk":[function(require,module,exports,__globalThis) {
/**
 * by bitbof (bitbof.com)
 */ var _polyfills = require("./polyfills/polyfills");
var _klApp = require("./app/kl-app");
var _language = require("./language/language");
var _theme = require("../script/theme/theme");
var _klIndexedDb = require("./klecks/storage/kl-indexed-db");
var _klRecoveryManager = require("./klecks/storage/kl-recovery-manager");
function showInitError(e) {
    const el = document.createElement('div');
    el.style.textAlign = 'center';
    el.style.background = '#fff';
    el.style.padding = '20px';
    el.innerHTML = '<h1>App failed to initialize</h1>';
    const errorMsg = document.createElement('div');
    errorMsg.textContent = 'Error: ' + (e.message ? e.message : '' + e);
    el.append(errorMsg);
    document.body.append(el);
    console.error(e);
}
(async ()=>{
    try {
        const outQueue = [];
        await (0, _language.initLANG)();
        (0, _klIndexedDb.KL_INDEXED_DB).init((0, _klIndexedDb.getKlIndexedDbName)(), (0, _klIndexedDb.KL_INDEXED_DB_STORES), (0, _klIndexedDb.KL_INDEXED_DB_VERSION), (0, _klIndexedDb.KL_INDEXED_DB_UPGRADER));
        if (!await (0, _klIndexedDb.KL_INDEXED_DB).testConnection()) outQueue.push((0, _language.LANG)('file-storage-cant-access'));
        const klRecoveryManager = (0, _klIndexedDb.KL_INDEXED_DB).getIsAvailable() ? new (0, _klRecoveryManager.KlRecoveryManager)({}) : undefined;
        let project = undefined;
        try {
            const readResult = klRecoveryManager ? await klRecoveryManager.getRecovery() : undefined;
            if (readResult) {
                project = readResult.project;
                outQueue.push((0, _language.LANG)('tab-recovery-recovered'));
            }
        } catch (e) {
            setTimeout(()=>{
                throw e;
            });
            outQueue.push((0, _language.LANG)('tab-recovery-failed-to-recover'));
        }
        // in case an extension manipulated the page
        const loadingScreenEl = document.getElementById('loading-screen');
        loadingScreenEl?.remove();
        const klApp = new (0, _klApp.KlApp)({
            project,
            klRecoveryManager
        });
        document.body.append(klApp.getElement());
        setTimeout(()=>{
            outQueue.forEach((msg)=>{
                klApp.out(msg);
            });
        }, 100);
    } catch (e) {
        showInitError(e);
    }
})();

},{"./polyfills/polyfills":"e89GR","./app/kl-app":"8ph4M","./language/language":"mcywn","../script/theme/theme":"cVh0j","./klecks/storage/kl-indexed-db":"iz3yu","./klecks/storage/kl-recovery-manager":"htaZX"}],"e89GR":[function(require,module,exports,__globalThis) {
var _polyfillsNomodule = require("./polyfills-nomodule");
/*
 * ---- Below ----------------------
 * features that didn't have support until *after* browsers supported the modules script tag:
 * Chrome 61
 * Edge 16
 * Safari 11
 * Firefox 60
 * https://caniuse.com/es6-module
 */ // chrome 61, edge 79, safari 16, firefox 107
if (!('scrollTo' in Element.prototype)) Object.defineProperty(Element.prototype, 'scrollTo', {
    value: function(x, y) {
        this.scrollLeft = x;
        this.scrollTop = y;
    }
});
// chrome 61, edge 79, safari 16, firefox 107
if (!('scrollBy' in Element.prototype)) Object.defineProperty(Element.prototype, 'scrollBy', {
    value: function(x, y) {
        this.scrollLeft += x;
        this.scrollTop += y;
    }
});
// chrome 69, edge 79, safari 12, firefox 62
if (!Array.prototype.flat) Object.defineProperty(Array.prototype, 'flat', {
    configurable: true,
    value: function flat(...args) {
        const depth = isNaN(args[0]) ? 1 : Number(args[0]);
        return depth ? Array.prototype.reduce.call(this, function(acc, cur) {
            if (Array.isArray(cur)) // eslint-disable-next-line prefer-spread
            acc.push.apply(acc, flat.call(cur, depth - 1));
            else acc.push(cur);
            return acc;
        }, []) : Array.prototype.slice.call(this);
    },
    writable: true
});
// chrome 69, edge 79, safari 12, firefox 62
if (!Array.prototype.flatMap) Object.defineProperty(Array.prototype, 'flatMap', {
    configurable: true,
    writable: true,
    value: function(callback, thisArg) {
        if (typeof callback !== 'function') throw new TypeError(callback + ' is not a function');
        const result = [];
        for(let i = 0; i < this.length; i++)if (i in this) {
            const mapped = callback.call(thisArg, this[i], i, this);
            if (Array.isArray(mapped)) result.push(...mapped);
            else result.push(mapped);
        }
        return result;
    }
});
// Chrome 85, Firefox 77, Safari 13.1
// if there are problems, maybe use core-js
if (!String.prototype.replaceAll) Object.defineProperty(String.prototype, 'replaceAll', {
    value: function(searchValue, replaceValue) {
        if (typeof replaceValue === 'function') throw new Error('replaceAll polyfill does not support replaceValue: function');
        return this.replace(new RegExp(searchValue, 'g'), replaceValue);
    }
});
// Chrome 92, Firefox 90, Safari 15.4
if (!('at' in Array.prototype)) Object.defineProperty(Array.prototype, 'at', {
    value: function(index) {
        if (index > 0) return this[index];
        if (index < 0) return this[index + this.length];
    }
});
/*
    Copyright 2018  Alfredo Mungo <alfredo.mungo@protonmail.ch>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.
*/ if (!Object.fromEntries) Object.defineProperty(Object, 'fromEntries', {
    value (entries) {
        if (!entries || !entries[Symbol.iterator]) throw new Error('Object.fromEntries() requires a single iterable argument');
        const o = {};
        Object.keys(entries).forEach((key)=>{
            const [k, v] = entries[key];
            o[k] = v;
        });
        return o;
    }
});
// sometimes Android WebView has no localStorage
if (!('localStorage' in window)) try {
    window.localStorage = {
        getItem: ()=>null,
        setItem: ()=>{},
        removeItem: ()=>{}
    };
} catch (e) {
// maybe it fails?
}

},{"./polyfills-nomodule":"kpGki"}],"kpGki":[function(require,module,exports,__globalThis) {
/**
 * features that were available before module script tags:
 * chrome 61
 * edge 16
 * safari 11
 * firefox 60
 * https://caniuse.com/es6-module
 */ var _nodePrototypeAppend = require("mdn-polyfills/Node.prototype.append");
var _nodePrototypePrepend = require("mdn-polyfills/Node.prototype.prepend"); // edge 17 (one version after module)
var _stringPrototypePadStart = require("mdn-polyfills/String.prototype.padStart");
var _arrayPrototypeFindIndex = require("mdn-polyfills/Array.prototype.findIndex");

},{"mdn-polyfills/Node.prototype.append":"gEmpX","mdn-polyfills/Node.prototype.prepend":"2Gkt3","mdn-polyfills/String.prototype.padStart":"e93mK","mdn-polyfills/Array.prototype.findIndex":"5Rbzl"}],"gEmpX":[function(require,module,exports,__globalThis) {
!function() {
    function t() {
        var e = Array.prototype.slice.call(arguments), n = document.createDocumentFragment();
        e.forEach(function(e) {
            var t = e instanceof Node;
            n.appendChild(t ? e : document.createTextNode(String(e)));
        }), this.appendChild(n);
    }
    [
        Element.prototype,
        Document.prototype,
        DocumentFragment.prototype
    ].forEach(function(e) {
        e.hasOwnProperty("append") || Object.defineProperty(e, "append", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t
        });
    });
}();

},{}],"2Gkt3":[function(require,module,exports,__globalThis) {
!function() {
    function t() {
        var e = Array.prototype.slice.call(arguments), n = document.createDocumentFragment();
        e.forEach(function(e) {
            var t = e instanceof Node;
            n.appendChild(t ? e : document.createTextNode(String(e)));
        }), this.insertBefore(n, this.firstChild);
    }
    [
        Element.prototype,
        Document.prototype,
        DocumentFragment.prototype
    ].forEach(function(e) {
        e.hasOwnProperty("prepend") || Object.defineProperty(e, "prepend", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t
        });
    });
}();

},{}],"e93mK":[function(require,module,exports,__globalThis) {
String.prototype.padStart || (String.prototype.padStart = function(t, n) {
    return t >>= 0, n = String(n || " "), this.length > t ? String(this) : ((t -= this.length) > n.length && (n += n.repeat(t / n.length)), n.slice(0, t) + String(this));
});

},{}],"5Rbzl":[function(require,module,exports,__globalThis) {
Array.prototype.findIndex || Object.defineProperty(Array.prototype, "findIndex", {
    value: function(r) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var e = Object(this), t = e.length >>> 0;
        if ("function" != typeof r) throw new TypeError("predicate must be a function");
        for(var n = arguments[1], o = 0; o < t;){
            var i = e[o];
            if (r.call(n, i, o, e)) return o;
            o++;
        }
        return -1;
    }
});

},{}],"8ph4M":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlApp", ()=>KlApp);
var _kl = require("../klecks/kl");
var _bb = require("../bb/bb");
var _showIframeModal = require("../klecks/ui/modals/show-iframe-modal");
var _embedToolspaceTopRow = require("../embed/embed-toolspace-top-row");
var _filtersLazy = require("../klecks/filters/filters-lazy");
var _klCanvasToPsdBlob = require("../klecks/storage/kl-canvas-to-psd-blob");
var _projectStore = require("../klecks/storage/project-store");
var _saveReminder = require("../klecks/ui/components/save-reminder");
var _language = require("../language/language");
var _localStorage = require("../bb/base/local-storage");
var _lineSmoothing = require("../klecks/events/line-smoothing");
var _lineSanitizer = require("../klecks/events/line-sanitizer");
var _translateSmoothing = require("../klecks/utils/translate-smoothing");
var _klAppImportHandler = require("./kl-app-import-handler");
var _toolPaintSvg = require("url:/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
var _toolHandSvg = require("url:/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
var _toolFillSvg = require("url:/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
var _toolGradientSvg = require("url:/src/app/img/ui/tool-gradient.svg");
var _toolGradientSvgDefault = parcelHelpers.interopDefault(_toolGradientSvg);
var _toolTextSvg = require("url:/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
var _toolShapeSvg = require("url:/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
var _toolSelectSvg = require("url:/src/app/img/ui/tool-select.svg");
var _toolSelectSvgDefault = parcelHelpers.interopDefault(_toolSelectSvg);
var _tabSettingsSvg = require("url:/src/app/img/ui/tab-settings.svg");
var _tabSettingsSvgDefault = parcelHelpers.interopDefault(_tabSettingsSvg);
var _tabLayersSvg = require("url:/src/app/img/ui/tab-layers.svg");
var _tabLayersSvgDefault = parcelHelpers.interopDefault(_tabLayersSvg);
var _tabEditSvg = require("url:/src/app/img/ui/tab-edit.svg");
var _tabEditSvgDefault = parcelHelpers.interopDefault(_tabEditSvg);
var _consoleApi = require("./console-api");
var _klConfig = require("../klecks/kl-config");
var _easel = require("../klecks/ui/easel/easel");
var _easelHand = require("../klecks/ui/easel/tools/easel-hand");
var _easelBrush = require("../klecks/ui/easel/tools/easel-brush");
var _easelProjectUpdater = require("../klecks/ui/easel/easel-project-updater");
var _zoomByStep = require("../klecks/ui/project-viewport/utils/zoom-by-step");
var _easelEyedropper = require("../klecks/ui/easel/tools/easel-eyedropper");
var _easelPaintBucket = require("../klecks/ui/easel/tools/easel-paint-bucket");
var _easelGradient = require("../klecks/ui/easel/tools/easel-gradient");
var _easelText = require("../klecks/ui/easel/tools/easel-text");
var _easelShape = require("../klecks/ui/easel/tools/easel-shape");
var _easelRotate = require("../klecks/ui/easel/tools/easel-rotate");
var _easelZoom = require("../klecks/ui/easel/tools/easel-zoom");
var _klAppSelect = require("./kl-app-select");
var _klTempHistory = require("../klecks/history/kl-temp-history");
var _pinchZoomWatcher = require("../klecks/ui/components/pinch-zoom-watcher");
var _easelConfig = require("../klecks/ui/easel/easel.config");
var _klHistoryExecutor = require("../klecks/history/kl-history-executor");
var _klHistory = require("../klecks/history/kl-history");
var _isHistoryEntryActiveLayerChange = require("../klecks/history/push-helpers/is-history-entry-active-layer-change");
var _mobileUi = require("../klecks/ui/mobile/mobile-ui");
var _mobileBrushUi = require("../klecks/ui/mobile/mobile-brush-ui");
var _canvas = require("../bb/base/canvas");
var _projectToComposed = require("../klecks/history/push-helpers/project-to-composed");
var _eraseColor = require("../klecks/brushes/erase-color");
var _drawProject = require("../klecks/canvas/draw-project");
var _base = require("../bb/base/base");
var _unloadWarningTrigger = require("../klecks/ui/components/unload-warning-trigger");
var _klIndexedDb = require("../klecks/storage/kl-indexed-db");
var _showModal = require("../klecks/ui/modals/base/showModal");
var _browserStorageBanner = require("../klecks/ui/components/browser-storage-banner");
var _requestPersistentStorage = require("../klecks/storage/request-persistent-storage");
var _crossTabChannel = require("../bb/base/cross-tab-channel");
var _mobileColorUi = require("../klecks/ui/mobile/mobile-color-ui");
var _getSelectionPath2D = require("../bb/multi-polygon/get-selection-path-2d");
(0, _filtersLazy.importFilters)();
class KlApp {
    updateLastSaved() {
        this.lastSavedHistoryIndex = this.klHistory.getTotalIndex();
        this.saveReminder?.reset();
        this.unloadWarningTrigger?.update();
    }
    updateCollapse(isInitial) {
        if (isInitial) {
            const isMobile = Boolean((0, _localStorage.LocalStorage).getItem('uiShowMobile') ?? false);
            if (isMobile) this.mobileUi.setToolspaceIsOpen(false);
        }
        this.mobileUi.setOrientation(this.uiLayout);
        if (this.uiWidth < this.collapseThreshold) {
            this.mobileUi.setIsVisible(true);
            if (this.mobileUi.getToolspaceIsOpen()) {
                if (this.uiLayout === 'left') (0, _base.css)(this.easel.getElement(), {
                    left: '271px'
                });
                else (0, _base.css)(this.easel.getElement(), {
                    left: '0'
                });
                this.toolspace.style.display = 'block';
                this.easel.setSize(Math.max(0, this.uiWidth - this.toolWidth), this.uiHeight);
                this.statusOverlay.setWide(false);
            } else {
                if (this.uiLayout === 'left') (0, _base.css)(this.easel.getElement(), {
                    left: '0'
                });
                else (0, _base.css)(this.easel.getElement(), {
                    left: '0'
                });
                this.toolspace.style.display = 'none';
                this.easel.setSize(Math.max(0, this.uiWidth), this.uiHeight);
                this.statusOverlay.setWide(true);
            }
        } else {
            this.mobileColorUi.closeColorPicker();
            this.mobileUi.setIsVisible(false);
            if (this.uiLayout === 'left') (0, _base.css)(this.easel.getElement(), {
                left: '271px'
            });
            this.toolspace.style.display = 'block';
            this.easel.setSize(Math.max(0, this.uiWidth - this.toolWidth), this.uiHeight);
            this.statusOverlay.setWide(false);
        }
        this.mobileUi.update();
    }
    updateBottomBar() {
        if (!this.bottomBar) return;
        const isVisible = this.toolspaceInner.scrollHeight + 40 < window.innerHeight;
        const newDisplay = isVisible ? '' : 'none';
        // check to prevent infinite MutationObserver loop in Pale Moon
        if (newDisplay !== this.bottomBarWrapper.style.display) this.bottomBarWrapper.style.display = newDisplay;
    }
    updateUi() {
        this.toolspace.classList.toggle('kl-toolspace--left', this.uiLayout === 'left');
        this.toolspace.classList.toggle('kl-toolspace--right', this.uiLayout === 'right');
        if (this.uiLayout === 'left') {
            (0, _base.css)(this.toolspace, {
                left: '0',
                right: ''
            });
            (0, _base.css)(this.easel.getElement(), {
                left: '271px'
            });
        } else {
            (0, _base.css)(this.toolspace, {
                left: '',
                right: '0'
            });
            (0, _base.css)(this.easel.getElement(), {
                left: '0'
            });
        }
        this.statusOverlay.setUiState(this.uiLayout);
        this.layerPreview.setUiState(this.uiLayout);
        this.layersUi.setUiState(this.uiLayout);
        this.updateCollapse();
        this.toolspaceScroller.updateUiState(this.uiLayout);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.collapseThreshold = 820;
        this.toolWidth = 271;
        this.lastSavedHistoryIndex = 0;
        this.getPSD = async ()=>{
            return await (0, _klCanvasToPsdBlob.klCanvasToPsdBlob)(this.klCanvas);
        };
        this.embed = p.embed;
        // default 2048, unless your screen is bigger than that (that computer then probably has the horsepower for that)
        // but not larger than 4096 - a fairly arbitrary decision
        const maxCanvasSize = Math.min(4096, Math.max(2048, Math.max(window.screen.width, window.screen.height)));
        this.uiLayout = this.embed ? 'left' : (0, _localStorage.LocalStorage).getItem('uiState') ? (0, _localStorage.LocalStorage).getItem('uiState') : 'right';
        const projectStore = (0, _klIndexedDb.KL_INDEXED_DB).getIsAvailable() ? new (0, _projectStore.ProjectStore)() : undefined;
        this.rootEl = (0, _bb.BB).el({
            className: 'g-root',
            css: {
                position: 'absolute',
                left: '0',
                top: '0',
                right: '0',
                bottom: '0'
            }
        });
        this.uiWidth = Math.max(0, window.innerWidth);
        this.uiHeight = Math.max(0, window.innerHeight);
        let exportType = 'png';
        const initialWidth = Math.max(10, Math.min(maxCanvasSize, window.innerWidth < this.collapseThreshold ? this.uiWidth : this.uiWidth - this.toolWidth));
        const initialHeight = Math.max(10, Math.min(maxCanvasSize, this.uiHeight));
        this.klHistory = new (0, _klHistory.KlHistory)({
            oldest: (0, _projectToComposed.projectToComposed)(p.project ?? {
                projectId: (0, _base.randomUuid)(),
                width: initialWidth,
                height: initialHeight,
                layers: [
                    {
                        name: (0, _language.LANG)('layers-layer') + ' 1',
                        opacity: 1,
                        isVisible: true,
                        mixModeStr: 'source-over',
                        image: {
                            fill: (0, _bb.BB).ColorConverter.toRgbStr({
                                r: (0, _eraseColor.ERASE_COLOR),
                                g: (0, _eraseColor.ERASE_COLOR),
                                b: (0, _eraseColor.ERASE_COLOR)
                            })
                        }
                    }
                ]
            })
        });
        const klRecoveryManager = p.klRecoveryManager;
        if (klRecoveryManager) {
            klRecoveryManager.setKlHistory(this.klHistory);
            klRecoveryManager.setGetThumbnail((factor)=>{
                return (0, _drawProject.drawProject)(this.klCanvas.getProject(), factor);
            });
        }
        if (p.project) // attempt at freeing memory
        p.project.layers.forEach((layer)=>{
            if (layer.image instanceof HTMLCanvasElement) (0, _bb.BB).freeCanvas(layer.image);
            layer.image = null;
        });
        this.klCanvas = new (0, _kl.KL).KlCanvas(this.klHistory, this.embed ? -1 : 1);
        const tempHistory = new (0, _klTempHistory.KlTempHistory)();
        let mainTabRow = undefined;
        const clearLayer = (showStatus, ignoreSelection)=>{
            applyUncommitted();
            const layerIndex = currentLayer.index;
            this.klCanvas.eraseLayer({
                layerIndex,
                useAlphaLock: layerIndex === 0 && !brushUiMap.eraserBrush.getIsTransparentBg(),
                useSelection: !ignoreSelection
            });
            showStatus && this.statusOverlay.out(this.klCanvas.getSelection() ? (0, _language.LANG)('cleared-selected-area') : (0, _language.LANG)('cleared-layer'), true);
        };
        let currentColor = new (0, _bb.BB).RGB(0, 0, 0);
        let currentBrushUi;
        let currentBrushId;
        let lastNonEraserBrushId;
        let currentLayer = this.klCanvas.getLayer(this.klCanvas.getLayerCount() - 1);
        // when cycling through brushes you need to know the next non-eraser brush
        const getNextBrushId = ()=>{
            if (currentBrushId === 'eraserBrush') return lastNonEraserBrushId;
            const keyArr = Object.keys(brushUiMap).filter((item)=>item !== 'eraserBrush');
            const i = keyArr.findIndex((item)=>item === currentBrushId);
            return keyArr[(i + 1) % keyArr.length];
        };
        const sizeWatcher = (val)=>{
            brushSettingService.emitSize(val);
            if (this.easelBrush) this.easelBrush.setBrush({
                radius: val
            });
        };
        const brushSettingService = new (0, _kl.KL).BrushSettingService({
            onSetColor: (color)=>{
                this.klColorSlider.setColor(color);
                currentBrushUi.setColor(color);
                this.mobileColorUi.setColor(color);
                currentColor = (0, _bb.BB).copyObj(color);
            },
            onSetSize: (size)=>{
                currentBrushUi.setSize(size);
                this.easelBrush.setBrush({
                    radius: size
                });
            },
            onSetOpacity: (opacity)=>{
                currentBrushUi.setOpacity(opacity);
            },
            onSetScatter: (scatter)=>{
                currentBrushUi.setScatter(scatter);
            },
            onGetColor: ()=>this.klColorSlider.getColor(),
            onGetSize: ()=>brushUiMap[currentBrushId].getSize(),
            onGetOpacity: ()=>brushUiMap[currentBrushId].getOpacity(),
            onGetScatter: ()=>brushUiMap[currentBrushId].getScatter(),
            onGetSliderConfig: ()=>{
                return {
                    sizeSlider: (0, _kl.KL).BRUSHES_UI[currentBrushId].sizeSlider,
                    opacitySlider: (0, _kl.KL).BRUSHES_UI[currentBrushId].opacitySlider,
                    scatterSlider: (0, _kl.KL).BRUSHES_UI[currentBrushId].scatterSlider
                };
            }
        });
        const lineSmoothing = new (0, _lineSmoothing.LineSmoothing)({
            smoothing: (0, _translateSmoothing.translateSmoothing)(1)
        });
        this.lineSanitizer = new (0, _lineSanitizer.LineSanitizer)();
        const drawEventChain = new (0, _bb.BB).EventChain({
            chainArr: [
                this.lineSanitizer,
                lineSmoothing
            ]
        });
        drawEventChain.setChainOut((event)=>{
            if (event.type === 'down') {
                this.toolspace.style.pointerEvents = 'none';
                currentBrushUi.startLine(event.x, event.y, event.pressure);
                this.easelBrush.setLastDrawEvent({
                    x: event.x,
                    y: event.y
                });
                this.easel.requestRender();
            }
            if (event.type === 'move') {
                currentBrushUi.goLine(event.x, event.y, event.pressure, event.isCoalesced);
                this.easelBrush.setLastDrawEvent({
                    x: event.x,
                    y: event.y
                });
                this.easel.requestRender();
            }
            if (event.type === 'up') {
                this.toolspace.style.pointerEvents = '';
                currentBrushUi.endLine();
                this.easel.requestRender();
            }
            if (event.type === 'line') {
                currentBrushUi.getBrush().drawLineSegment(event.x0, event.y0, event.x1, event.y1);
                this.easelBrush.setLastDrawEvent({
                    x: event.x1,
                    y: event.y1
                });
                this.easel.requestRender();
            }
        });
        let textToolSettings = {
            size: 20,
            align: 'left',
            isBold: false,
            isItalic: false,
            font: 'sans-serif',
            letterSpacing: 0,
            lineHeight: 1,
            fill: {
                color: {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                }
            }
        };
        /**
         * Uncommited action is something like select tool > transform which puts the canvas and UI into
         * a temporary state. Changes need to be committed or discarded *before* doing something else.
         *
         * returns true if something was applied
         */ const applyUncommitted = ()=>{
            let didApply = false;
            if (this.easel.getTool() === 'select') didApply = klAppSelect.commitTransform();
            return didApply;
        };
        /** see applyUncommitted **/ const discardUncommitted = ()=>{
            if (this.easel.getTool() === 'select') return klAppSelect.discardTransform();
            return false;
        };
        const propagateUndoRedoChanges = (type, composedBefore)=>{
            if ([
                'undo',
                'redo'
            ].includes(type)) {
                const composedAfter = this.klHistory.getComposed();
                this.klCanvas.updateViaComposed(composedBefore, composedAfter);
                setCurrentLayer(this.klCanvas.getLayer(composedAfter.layerMap[composedAfter.activeLayerId].index));
                this.easelProjectUpdater.update(); // triggers render
                const dimensionChanged = composedBefore.size.width !== composedAfter.size.width || composedBefore.size.height !== composedAfter.size.height;
                if (dimensionChanged) this.easel.resetOrFitTransform(true);
                this.easelBrush.setLastDrawEvent();
                this.layersUi.update(currentLayer.index);
            }
            klAppSelect.onHistory(type);
        };
        const undo = (showMessage)=>{
            if (!tempHistory.canDecreaseIndex()) discardUncommitted();
            const composedBefore = this.klHistory.getComposed();
            const result = klHistoryExecutor.undo();
            if (!result) // didn't do anything
            return;
            propagateUndoRedoChanges(result.type, composedBefore);
            if (showMessage) this.statusOverlay.out((0, _language.LANG)('undo'), true);
        };
        const redo = (showMessage)=>{
            const composedBefore = this.klHistory.getComposed();
            const result = klHistoryExecutor.redo();
            if (!result) // didn't do anything
            return;
            propagateUndoRedoChanges(result.type, composedBefore);
            if (showMessage) this.statusOverlay.out((0, _language.LANG)('redo'), true);
        };
        this.statusOverlay = new (0, _kl.KL).StatusOverlay();
        const klAppSelect = new (0, _klAppSelect.KlAppSelect)({
            klCanvas: this.klCanvas,
            getCurrentLayerCtx: ()=>currentLayer.context,
            onUpdateProject: ()=>this.easelProjectUpdater.update(),
            klHistory: this.klHistory,
            tempHistory,
            statusOverlay: this.statusOverlay,
            onFill: ()=>{
                this.klCanvas.layerFill(currentLayer.index, this.klColorSlider.getColor(), undefined, true);
                this.statusOverlay.out(this.klCanvas.getSelection() ? (0, _language.LANG)('filled-selected-area') : (0, _language.LANG)('filled'), true);
            },
            onErase: ()=>{
                const layerIndex = currentLayer.index;
                this.klCanvas.eraseLayer({
                    layerIndex,
                    useAlphaLock: layerIndex === 0 && !brushUiMap.eraserBrush.getIsTransparentBg(),
                    useSelection: true
                });
                this.statusOverlay.out(this.klCanvas.getSelection() ? (0, _language.LANG)('cleared-selected-area') : (0, _language.LANG)('cleared-layer'), true);
            }
        });
        this.easelBrush = new (0, _easelBrush.EaselBrush)({
            radius: 5,
            onLineStart: (e)=>{
                // expects TDrawEvent
                drawEventChain.chainIn({
                    type: 'down',
                    scale: this.easel.getTransform().scale,
                    shiftIsPressed: keyListener.isPressed('shift'),
                    pressure: e.pressure,
                    isCoalesced: e.isCoalesced,
                    x: e.x,
                    y: e.y
                });
            },
            onLineGo: (e)=>{
                // expects TDrawEvent
                drawEventChain.chainIn({
                    type: 'move',
                    scale: this.easel.getTransform().scale,
                    shiftIsPressed: keyListener.isPressed('shift'),
                    pressure: e.pressure,
                    isCoalesced: e.isCoalesced,
                    x: e.x,
                    y: e.y
                });
            },
            onLineEnd: ()=>{
                // expects TDrawEvent
                drawEventChain.chainIn({
                    type: 'up',
                    scale: this.easel.getTransform().scale,
                    shiftIsPressed: keyListener.isPressed('shift'),
                    isCoalesced: false
                });
            },
            onLine: (p1, p2)=>{
                // expects TDrawEvent
                drawEventChain.chainIn({
                    type: 'line',
                    x0: p1.x,
                    y0: p1.y,
                    x1: p2.x,
                    y1: p2.y,
                    pressure0: 1,
                    pressure1: 1
                });
            }
        });
        const easelHand = new (0, _easelHand.EaselHand)({});
        const easelShape = new (0, _easelShape.EaselShape)({
            onDown: (p, angleRad)=>{
                shapeTool.onDown(p.x, p.y, angleRad);
            },
            onMove: (p)=>{
                shapeTool.onMove(p.x, p.y);
            },
            onUp: (p)=>{
                shapeTool.onUp(p.x, p.y);
            }
        });
        let isFirstTransform = true;
        this.easel = new (0, _easel.Easel)({
            width: Math.max(0, this.uiWidth - this.toolWidth),
            height: this.uiHeight,
            project: {
                width: this.klCanvas.getWidth(),
                height: this.klCanvas.getHeight(),
                layers: []
            },
            tools: {
                brush: this.easelBrush,
                hand: easelHand,
                select: klAppSelect.getEaselSelect(),
                eyedropper: new (0, _easelEyedropper.EaselEyedropper)({
                    onPick: (p)=>{
                        const color = this.klCanvas.getColorAt(p.x, p.y);
                        brushSettingService.setColor(color);
                        return color;
                    },
                    onPickEnd: ()=>{
                        if (this.klColorSlider.getIsEyedropping() || this.mobileColorUi.getIsEyedropping()) {
                            this.klColorSlider.setIsEyedropping(false);
                            this.mobileColorUi.setIsEyedropping(false);
                            this.easel.setTool(this.toolspaceToolRow.getActive());
                        }
                    }
                }),
                paintBucket: new (0, _easelPaintBucket.EaselPaintBucket)({
                    onFill: (p)=>{
                        this.klCanvas.floodFill(currentLayer.index, p.x, p.y, fillUi.getIsEraser() ? null : this.klColorSlider.getColor(), fillUi.getOpacity(), fillUi.getTolerance(), fillUi.getSample(), fillUi.getGrow(), fillUi.getContiguous());
                        this.easel.requestRender();
                    }
                }),
                gradient: new (0, _easelGradient.EaselGradient)({
                    onDown: (p, angleRad)=>{
                        gradientTool.onDown(p.x, p.y, angleRad);
                    },
                    onMove: (p)=>{
                        gradientTool.onMove(p.x, p.y);
                    },
                    onUp: (p)=>{
                        gradientTool.onUp(p.x, p.y);
                    }
                }),
                text: new (0, _easelText.EaselText)({
                    onDown: (p, angleRad)=>{
                        if ((0, _kl.KL).DIALOG_COUNTER.get() > 0) return;
                        (0, _kl.KL).textToolDialog({
                            klCanvas: this.klCanvas,
                            layerIndex: currentLayer.index,
                            primaryColor: this.klColorSlider.getColor(),
                            secondaryColor: this.klColorSlider.getSecondaryRGB(),
                            text: {
                                ...textToolSettings,
                                text: '',
                                x: p.x,
                                y: p.y,
                                angleRad: angleRad,
                                fill: textToolSettings.fill ? {
                                    color: {
                                        ...this.klColorSlider.getColor(),
                                        a: textToolSettings.fill.color.a
                                    }
                                } : undefined,
                                stroke: textToolSettings.stroke ? {
                                    ...textToolSettings.stroke,
                                    color: {
                                        ...this.klColorSlider.getSecondaryRGB(),
                                        a: textToolSettings.stroke.color.a
                                    }
                                } : undefined
                            },
                            onConfirm: (val)=>{
                                textToolSettings = {
                                    ...val,
                                    text: ''
                                };
                                this.klCanvas.text(currentLayer.index, val);
                            }
                        });
                    }
                }),
                shape: easelShape,
                rotate: new (0, _easelRotate.EaselRotate)({}),
                zoom: new (0, _easelZoom.EaselZoom)({})
            },
            tool: 'brush',
            onChangeTool: (toolId)=>{
                this.mobileBrushUi.setIsVisible(toolId === 'brush');
                this.mobileColorUi.setIsVisible(toolId !== 'select');
            },
            onTransformChange: (transform, isScaleOrAngleChanged)=>{
                handUi.update(transform.scale, transform.angleDeg);
                this.toolspaceToolRow.setEnableZoomIn(transform.scale !== (0, _easelConfig.EASEL_MAX_SCALE));
                this.toolspaceToolRow.setEnableZoomOut(transform.scale !== (0, _easelConfig.EASEL_MIN_SCALE));
                if (isScaleOrAngleChanged && !isFirstTransform) this.statusOverlay.out({
                    type: 'transform',
                    scale: transform.scale,
                    angleDeg: transform.angleDeg
                });
                if (isFirstTransform) isFirstTransform = false;
            },
            onUndo: ()=>{
                undo(true);
            },
            onRedo: ()=>{
                redo(true);
            }
        });
        (0, _base.css)(this.easel.getElement(), {
            position: 'absolute',
            left: '0',
            top: '0'
        });
        this.easelProjectUpdater = new (0, _easelProjectUpdater.EaselProjectUpdater)({
            klCanvas: this.klCanvas,
            easel: this.easel
        });
        this.klHistory.addListener(()=>{
            this.easelProjectUpdater.update();
        });
        (0, _kl.KL).DIALOG_COUNTER.subscribe((count)=>{
            this.easel.setIsFrozen(count > 0);
        });
        const updateMainTabVisibility = ()=>{
            if (!mainTabRow) return;
            const toolObj = {
                brush: {},
                hand: {},
                paintBucket: {},
                gradient: {},
                text: {},
                shape: {},
                select: {}
            };
            const activeStr = this.toolspaceToolRow.getActive();
            const oldTabId = mainTabRow.getOpenedTabId();
            const keysArr = Object.keys(toolObj);
            for(let i = 0; i < keysArr.length; i++)if (activeStr === keysArr[i]) mainTabRow.setIsVisible(keysArr[i], true);
            else {
                mainTabRow.setIsVisible(keysArr[i], false);
                if (oldTabId === keysArr[i]) mainTabRow.open(activeStr);
            }
        };
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, event, comboStr)=>{
                if ((0, _kl.KL).DIALOG_COUNTER.get() > 0 || (0, _bb.BB).isInputFocused(true)) return;
                const isDrawing = this.lineSanitizer.getIsDrawing() || this.easel.getIsLocked();
                if (isDrawing) return;
                if (comboStr === 'home') this.easel.fitTransform();
                if (comboStr === 'end') this.easel.resetTransform();
                if ([
                    'ctrl+z',
                    'cmd+z'
                ].includes(comboStr)) {
                    event.preventDefault();
                    undo();
                }
                if ([
                    'ctrl+y',
                    'cmd+y'
                ].includes(comboStr) || ((0, _bb.BB).sameKeys('ctrl+shift+z', comboStr) || (0, _bb.BB).sameKeys('cmd+shift+z', comboStr)) && keyStr === 'z') {
                    event.preventDefault();
                    redo();
                }
                if (!this.embed) {
                    if ([
                        'ctrl+s',
                        'cmd+s'
                    ].includes(comboStr)) {
                        event.preventDefault();
                        applyUncommitted();
                        this.saveToComputer.save();
                    }
                    if ([
                        'ctrl+shift+s',
                        'cmd+shift+s'
                    ].includes(comboStr)) {
                        event.preventDefault();
                        applyUncommitted();
                        if (projectStore) (async ()=>{
                            await (0, _requestPersistentStorage.requestPersistentStorage)();
                            const meta = projectStore.getCurrentMeta();
                            const project = this.getProject();
                            if (meta && meta.projectId !== project.projectId) {
                                const doOverwrite = await new Promise((resolve, reject)=>{
                                    (0, _showModal.showModal)({
                                        target: document.body,
                                        type: 'warning',
                                        message: (0, _language.LANG)('file-storage-overwrite-confirm'),
                                        buttons: [
                                            (0, _language.LANG)('file-storage-overwrite'),
                                            'Cancel'
                                        ],
                                        callback: async (result)=>{
                                            if (result === 'Cancel') {
                                                resolve(false);
                                                return;
                                            }
                                            resolve(true);
                                        }
                                    });
                                });
                                if (!doOverwrite) return;
                            }
                            let success = true;
                            try {
                                await projectStore.store(this.klCanvas.getProject());
                            } catch (e) {
                                success = false;
                                setTimeout(()=>{
                                    throw new Error('keyboard-shortcut: failed to store browser storage, ' + e);
                                }, 0);
                                this.statusOverlay.out("\u274C " + (0, _language.LANG)('file-storage-failed'), true);
                            }
                            if (success) {
                                this.updateLastSaved();
                                this.statusOverlay.out((0, _language.LANG)('file-storage-stored'), true);
                            }
                        })();
                        else this.statusOverlay.out("\u274C " + (0, _language.LANG)('file-storage-failed'), true);
                    }
                    if ([
                        'ctrl+c',
                        'cmd+c'
                    ].includes(comboStr)) {
                        event.preventDefault();
                        applyUncommitted();
                        copyToClipboard(true);
                    }
                }
                if ([
                    'ctrl+a',
                    'cmd+a'
                ].includes(comboStr)) event.preventDefault();
                if (comboStr === 'sqbr_open') currentBrushUi.decreaseSize(Math.max(0.005, 0.03 / this.easel.getTransform().scale));
                if (comboStr === 'sqbr_close') currentBrushUi.increaseSize(Math.max(0.005, 0.03 / this.easel.getTransform().scale));
                if (comboStr === 'enter') {
                    if (!applyUncommitted()) {
                        this.klCanvas.layerFill(currentLayer.index, this.klColorSlider.getColor(), undefined, true);
                        this.statusOverlay.out(this.klCanvas.getSelection() ? (0, _language.LANG)('filled-selected-area') : (0, _language.LANG)('filled'), true);
                    }
                }
                if (comboStr === 'esc') {
                    if (discardUncommitted()) event.preventDefault();
                }
                if ([
                    'delete',
                    'backspace'
                ].includes(comboStr)) clearLayer(true);
                if (comboStr === 'shift+e') {
                    event.preventDefault();
                    currentBrushUi.toggleEraser?.();
                } else if (comboStr === 'e') {
                    event.preventDefault();
                    applyUncommitted();
                    this.easel.setTool('brush');
                    this.toolspaceToolRow.setActive('brush');
                    mainTabRow?.open('brush');
                    updateMainTabVisibility();
                    brushTabRow.open('eraserBrush');
                }
                if (comboStr === 'b') {
                    event.preventDefault();
                    applyUncommitted();
                    const prevMode = this.easel.getTool();
                    this.easel.setTool('brush');
                    this.toolspaceToolRow.setActive('brush');
                    mainTabRow?.open('brush');
                    updateMainTabVisibility();
                    brushTabRow.open(prevMode === 'brush' ? getNextBrushId() : currentBrushId);
                }
                if (comboStr === 'g') {
                    event.preventDefault();
                    applyUncommitted();
                    const newMode = this.easel.getTool() === 'paintBucket' ? 'gradient' : 'paintBucket';
                    this.easel.setTool(newMode);
                    this.toolspaceToolRow.setActive(newMode);
                    mainTabRow?.open(newMode);
                    updateMainTabVisibility();
                }
                if (comboStr === 't') {
                    event.preventDefault();
                    applyUncommitted();
                    this.easel.setTool('text');
                    this.toolspaceToolRow.setActive('text');
                    mainTabRow?.open('text');
                    updateMainTabVisibility();
                }
                if (comboStr === 'u') {
                    event.preventDefault();
                    applyUncommitted();
                    this.easel.setTool('shape');
                    this.toolspaceToolRow.setActive('shape');
                    mainTabRow?.open('shape');
                    updateMainTabVisibility();
                }
                if (comboStr === 'l') {
                    event.preventDefault();
                    applyUncommitted();
                    this.easel.setTool('select');
                    this.toolspaceToolRow.setActive('select');
                    mainTabRow?.open('select');
                    updateMainTabVisibility();
                }
                if (comboStr === 'x') {
                    event.preventDefault();
                    this.klColorSlider.swapColors();
                }
            },
            onUp: (keyStr, event)=>{}
        });
        const brushUiMap = {};
        // create brush UIs
        Object.entries((0, _kl.KL).BRUSHES_UI).forEach(([b, brushUi])=>{
            const ui = new brushUi.Ui({
                klHistory: this.klHistory,
                onSizeChange: sizeWatcher,
                onScatterChange: (scatter)=>{
                    brushSettingService.emitScatter(scatter);
                },
                onOpacityChange: (opacity)=>{
                    brushSettingService.emitOpacity(opacity);
                },
                onConfigChange: ()=>{
                    brushSettingService.emitSliderConfig({
                        sizeSlider: (0, _kl.KL).BRUSHES_UI[currentBrushId].sizeSlider,
                        opacitySlider: (0, _kl.KL).BRUSHES_UI[currentBrushId].opacitySlider,
                        scatterSlider: (0, _kl.KL).BRUSHES_UI[currentBrushId].scatterSlider
                    });
                }
            });
            brushUiMap[b] = ui;
            ui.getElement().style.padding = "10px";
        });
        this.toolspace = (0, _bb.BB).el({
            className: 'kl-toolspace',
            css: {
                position: 'absolute',
                right: '0',
                top: '0',
                bottom: '0',
                width: this.toolWidth + 'px',
                overflow: 'hidden',
                userSelect: 'none',
                touchAction: 'none'
            }
        });
        this.toolspaceInner = (0, _bb.BB).el({
            parent: this.toolspace
        });
        this.toolspace.oncontextmenu = ()=>{
            return false;
        };
        this.toolspace.onclick = (0, _bb.BB).handleClick;
        this.mobileBrushUi = new (0, _mobileBrushUi.MobileBrushUi)({
            onBrush: ()=>{
                brushTabRow.open(lastNonEraserBrushId);
            },
            onEraser: ()=>{
                brushTabRow.open('eraserBrush');
            }
        });
        this.mobileColorUi = new (0, _mobileColorUi.MobileColorUi)({
            onEyedropper: (isActive)=>{
                if (isActive) {
                    this.klColorSlider.setIsEyedropping(true);
                    this.easel.setTool('eyedropper');
                } else {
                    this.klColorSlider.setIsEyedropping(false);
                    this.easel.setTool(this.toolspaceToolRow.getActive());
                }
            },
            color: currentColor,
            onColorChange: (c)=>{
                brushSettingService.setColor(c);
            }
        });
        this.mobileUi = new (0, _mobileUi.MobileUi)({
            onShowToolspace: (b)=>{
                this.mobileColorUi.closeColorPicker();
                this.updateCollapse();
            },
            toolUis: [
                this.mobileBrushUi.getElement(),
                this.mobileColorUi.getElement()
            ]
        });
        this.updateCollapse(true);
        let overlayToolspace;
        setTimeout(()=>{
            overlayToolspace = new (0, _kl.KL).OverlayToolspace({
                enabledTest: ()=>{
                    return (0, _kl.KL).DIALOG_COUNTER.get() === 0 && !this.easel.getIsLocked();
                },
                brushSettingService
            });
            this.rootEl.append(overlayToolspace.getElement());
        }, 0);
        (0, _bb.BB).append(this.rootEl, [
            this.easel.getElement(),
            // this.klCanvasWorkspace.getElement(),
            this.toolspace,
            this.mobileUi.getElement()
        ]);
        let toolspaceTopRow;
        if (this.embed) toolspaceTopRow = new (0, _embedToolspaceTopRow.EmbedToolspaceTopRow)({
            onHelp: ()=>{
                (0, _showIframeModal.showIframeModal)(this.embed.url + '/help.html', !!this.embed);
            },
            onSubmit: ()=>{
                applyUncommitted();
                const onFailure = ()=>{
                    let closeFunc;
                    const saveBtn = (0, _bb.BB).el({
                        tagName: 'button',
                        textContent: (0, _language.LANG)('save-reminder-save-psd'),
                        css: {
                            display: 'block'
                        }
                    });
                    saveBtn.onclick = ()=>{
                        this.saveAsPsd();
                        closeFunc();
                    };
                    (0, _kl.KL).popup({
                        target: this.rootEl,
                        message: '<b>' + (0, _language.LANG)('upload-failed') + '</b>',
                        div: (0, _bb.BB).el({
                            content: [
                                (0, _bb.BB).el({
                                    content: (0, _language.LANG)('backup-drawing'),
                                    css: {
                                        marginBottom: '10px'
                                    }
                                }),
                                saveBtn
                            ]
                        }),
                        ignoreBackground: true,
                        closeFunc: (f)=>{
                            closeFunc = f;
                        }
                    });
                };
                (0, _kl.KL).popup({
                    target: this.rootEl,
                    message: (0, _language.LANG)('submit-prompt'),
                    buttons: [
                        (0, _language.LANG)('submit'),
                        'Cancel'
                    ],
                    callback: async (result)=>{
                        if (result !== (0, _language.LANG)('submit')) return;
                        const overlay = (0, _bb.BB).el({
                            parent: this.rootEl,
                            className: 'upload-overlay',
                            content: '<div class="spinner"></div> ' + (0, _language.LANG)('submit-submitting')
                        });
                        this.embed.onSubmit(()=>{
                            this.updateLastSaved();
                            overlay.remove();
                        }, ()=>{
                            overlay.remove();
                            onFailure();
                        });
                    }
                });
            },
            onLeftRight: ()=>{
                this.uiLayout = this.uiLayout === 'left' ? 'right' : 'left';
                this.updateUi();
            }
        });
        else toolspaceTopRow = new (0, _kl.KL).ToolspaceTopRow({
            logoImg: p.logoImg,
            onLogo: ()=>{
                (0, _showIframeModal.showIframeModal)('./home/', !!this.embed);
            },
            onNew: ()=>{
                showNewImageDialog();
            },
            onImport: ()=>{
                fileUi.triggerImport();
            },
            onSave: ()=>{
                this.saveToComputer.save();
            },
            onShare: ()=>{
                shareImage();
            },
            onHelp: ()=>{
                (0, _showIframeModal.showIframeModal)('./help/', !!this.embed);
            }
        });
        toolspaceTopRow.getElement().style.marginBottom = '10px';
        this.toolspaceInner.append(toolspaceTopRow.getElement());
        this.toolspaceToolRow = new (0, _kl.KL).ToolspaceToolRow({
            onActivate: (activeStr)=>{
                if (activeStr !== 'hand') // hand only one that doesn't cause changes
                applyUncommitted();
                if (activeStr === 'brush') this.easel.setTool('brush');
                else if (activeStr === 'hand') this.easel.setTool('hand');
                else if (activeStr === 'paintBucket') this.easel.setTool('paintBucket');
                else if (activeStr === 'gradient') this.easel.setTool('gradient');
                else if (activeStr === 'text') this.easel.setTool('text');
                else if (activeStr === 'shape') this.easel.setTool('shape');
                else if (activeStr === 'select') // this.klCanvasWorkspace.setMode('shape');
                this.easel.setTool('select');
                else throw new Error('unknown activeStr');
                mainTabRow?.open(activeStr);
                updateMainTabVisibility();
                this.klColorSlider.setIsEyedropping(false);
                this.mobileColorUi.setIsEyedropping(false);
            },
            onZoomIn: ()=>{
                const oldScale = this.easel.getTransform().scale;
                const newScale = (0, _zoomByStep.zoomByStep)(oldScale, keyListener.isPressed('shift') ? 1 / 8 : 0.5);
                this.easel.scale(newScale / oldScale);
            },
            onZoomOut: ()=>{
                const oldScale = this.easel.getTransform().scale;
                const newScale = (0, _zoomByStep.zoomByStep)(oldScale, keyListener.isPressed('shift') ? -1 / 8 : -0.5);
                this.easel.scale(newScale / oldScale);
            },
            onUndo: ()=>{
                undo();
            },
            onRedo: ()=>{
                redo();
            }
        });
        this.toolspaceToolRow.setIsSmall(this.uiHeight < 540);
        this.toolspaceInner.append(this.toolspaceToolRow.getElement());
        const setBrushColor = (p_color)=>{
            currentColor = p_color;
            currentBrushUi.setColor(p_color);
            brushSettingService.emitColor(p_color);
            this.mobileColorUi.setColor(p_color);
            this.klColorSlider.setIsEyedropping(false);
            this.mobileColorUi.setIsEyedropping(false);
        };
        this.klColorSlider = new (0, _kl.KL).KlColorSlider({
            width: 250,
            height: 30,
            svHeight: 100,
            startValue: new (0, _bb.BB).RGB(0, 0, 0),
            onPick: setBrushColor,
            onEyedropper: (isActive)=>{
                if (isActive) {
                    this.mobileColorUi.setIsEyedropping(true);
                    this.easel.setTool('eyedropper');
                } else {
                    this.mobileColorUi.setIsEyedropping(false);
                    this.easel.setTool(this.toolspaceToolRow.getActive());
                }
            }
        });
        this.klColorSlider.setHeight(Math.max(163, Math.min(400, this.uiHeight - 505)));
        const setCurrentBrush = (brushId)=>{
            if (brushId !== 'eraserBrush') lastNonEraserBrushId = brushId;
            if (this.klColorSlider) {
                if (brushId === 'eraserBrush') this.klColorSlider.enable(false);
                else this.klColorSlider.enable(true);
            }
            currentBrushId = brushId;
            currentBrushUi = brushUiMap[brushId];
            currentBrushUi.setColor(currentColor);
            currentBrushUi.setLayer(currentLayer);
            this.easelBrush.setBrush({
                type: currentBrushId === 'pixelBrush' ? 'pixel-square' : 'round'
            });
            this.toolspaceToolRow.setActive('brush');
            updateMainTabVisibility();
        };
        const setCurrentLayer = (layer)=>{
            currentLayer = layer;
            currentBrushUi.setLayer(currentLayer);
            this.layerPreview.setLayer(currentLayer);
        };
        const brushDiv = (0, _bb.BB).el();
        const colorDiv = (0, _bb.BB).el({
            css: {
                margin: '10px',
                display: 'flex',
                flexWrap: 'wrap',
                justifyContent: 'space-between',
                alignItems: 'flex-end'
            }
        });
        const toolspaceStabilizerRow = new (0, _kl.KL).ToolspaceStabilizerRow({
            smoothing: 1,
            onSelect: (v)=>{
                lineSmoothing.setSmoothing((0, _translateSmoothing.translateSmoothing)(v));
            }
        });
        brushDiv.append(colorDiv);
        (0, _bb.BB).append(colorDiv, [
            this.klColorSlider.getElement(),
            this.klColorSlider.getOutputElement(),
            toolspaceStabilizerRow.getElement()
        ]);
        const brushTabRow = new (0, _kl.KL).TabRow({
            initialId: 'penBrush',
            useAccent: true,
            tabArr: (()=>{
                const result = [];
                const createTab = (keyStr)=>{
                    return {
                        id: keyStr,
                        image: (0, _kl.KL).BRUSHES_UI[keyStr].image,
                        title: (0, _kl.KL).BRUSHES_UI[keyStr].tooltip,
                        onOpen: ()=>{
                            brushUiMap[keyStr].getElement().style.display = 'block';
                            setCurrentBrush(keyStr);
                            this.klColorSlider.setIsEyedropping(false);
                            this.mobileColorUi.setIsEyedropping(false);
                            brushSettingService.emitSliderConfig({
                                sizeSlider: (0, _kl.KL).BRUSHES_UI[keyStr].sizeSlider,
                                opacitySlider: (0, _kl.KL).BRUSHES_UI[keyStr].opacitySlider,
                                scatterSlider: (0, _kl.KL).BRUSHES_UI[keyStr].scatterSlider
                            });
                            sizeWatcher(brushUiMap[keyStr].getSize());
                            brushSettingService.emitOpacity(brushUiMap[keyStr].getOpacity());
                            this.mobileBrushUi.setType(keyStr === 'eraserBrush' ? 'eraser' : 'brush');
                        },
                        onClose: ()=>{
                            brushUiMap[keyStr].getElement().style.display = 'none';
                        }
                    };
                };
                const keyArr = Object.keys(brushUiMap);
                for(let i = 0; i < keyArr.length; i++)result.push(createTab(keyArr[i]));
                return result;
            })()
        });
        (0, _bb.BB).append(brushDiv, [
            brushTabRow.getElement(),
            ...Object.entries((0, _kl.KL).BRUSHES_UI).map(([b])=>brushUiMap[b].getElement())
        ]);
        const handUi = new (0, _kl.KL).HandUi({
            scale: this.easel.getTransform().scale,
            angleDeg: 0,
            onReset: ()=>{
                this.easel.resetTransform();
            },
            onFit: ()=>{
                this.easel.fitTransform();
            },
            onAngleChange: (angleDeg, isRelative)=>{
                this.easel.setAngleDeg(angleDeg, isRelative);
            },
            onChangeUseInertiaScrolling: (b)=>{
                easelHand.setUseInertiaScrolling(b);
            }
        });
        const fillUi = new (0, _kl.KL).FillUi({
            colorSlider: this.klColorSlider
        });
        const gradientUi = new (0, _kl.KL).GradientUi({
            colorSlider: this.klColorSlider
        });
        const textUi = new (0, _kl.KL).TextUi({
            colorSlider: this.klColorSlider
        });
        const shapeUi = new (0, _kl.KL).ShapeUi({
            colorSlider: this.klColorSlider,
            onChangePanning: (doPan)=>easelShape.setPanning(doPan)
        });
        const gradientTool = new (0, _kl.KL).GradientTool({
            onGradient: (isDone, x1, y1, x2, y2, angleRad)=>{
                const layerIndex = currentLayer.index;
                const settings = gradientUi.getSettings();
                const gradientObj = {
                    type: settings.type,
                    color1: this.klColorSlider.getColor(),
                    isReversed: settings.isReversed,
                    opacity: settings.opacity,
                    doLockAlpha: settings.doLockAlpha,
                    isEraser: settings.isEraser,
                    doSnap: keyListener.isPressed('shift') || settings.doSnap,
                    x1,
                    y1,
                    x2,
                    y2,
                    angleRad
                };
                if (isDone) {
                    this.klCanvas.setComposite(layerIndex, undefined);
                    this.klCanvas.drawGradient(layerIndex, gradientObj);
                } else {
                    const selection = this.klCanvas.getSelection();
                    const selectionPath = selection ? new Path2D((0, _getSelectionPath2D.getSelectionPath2d)(selection)) : undefined;
                    this.klCanvas.setComposite(layerIndex, {
                        draw: (ctx)=>{
                            (0, _kl.KL).drawGradient(ctx, gradientObj, selectionPath);
                        }
                    });
                }
                this.easelProjectUpdater.update();
            }
        });
        const shapeTool = new (0, _kl.KL).ShapeTool({
            onShape: (isDone, x1, y1, x2, y2, angleRad)=>{
                const layerIndex = currentLayer.index;
                const shapeObj = {
                    type: shapeUi.getShape(),
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    angleRad: angleRad,
                    isOutwards: shapeUi.getIsOutwards(),
                    opacity: shapeUi.getOpacity(),
                    isEraser: shapeUi.getIsEraser(),
                    doLockAlpha: shapeUi.getDoLockAlpha()
                };
                if (shapeUi.getShape() === 'line') {
                    shapeObj.strokeRgb = this.klColorSlider.getColor();
                    shapeObj.lineWidth = shapeUi.getLineWidth();
                    shapeObj.isAngleSnap = shapeUi.getIsSnap() || keyListener.isPressed('shift');
                } else {
                    shapeObj.isFixedRatio = shapeUi.getIsFixed() || keyListener.isPressed('shift');
                    if (shapeUi.getMode() === 'stroke') {
                        shapeObj.strokeRgb = this.klColorSlider.getColor();
                        shapeObj.lineWidth = shapeUi.getLineWidth();
                    } else shapeObj.fillRgb = this.klColorSlider.getColor();
                }
                if (isDone) {
                    this.klCanvas.setComposite(layerIndex, undefined);
                    this.klCanvas.drawShape(layerIndex, shapeObj);
                } else {
                    const selection = this.klCanvas.getSelection();
                    const selectionPath = selection ? new Path2D((0, _getSelectionPath2D.getSelectionPath2d)(selection)) : undefined;
                    this.klCanvas.setComposite(layerIndex, {
                        draw: (ctx)=>{
                            (0, _kl.KL).drawShape(ctx, shapeObj, selectionPath);
                        }
                    });
                }
                this.easelProjectUpdater.update();
            }
        });
        this.layersUi = new (0, _kl.KL).LayersUi({
            klCanvas: this.klCanvas,
            onSelect: (layerIndex)=>{
                const activeLayer = this.klCanvas.getLayer(layerIndex);
                setCurrentLayer(activeLayer);
                const topEntry = this.klHistory.getEntries().at(-1).data;
                const replaceTop = (0, _isHistoryEntryActiveLayerChange.isHistoryEntryActiveLayerChange)(topEntry);
                this.klHistory.push({
                    activeLayerId: activeLayer.id
                }, replaceTop);
            },
            parentEl: this.rootEl,
            uiState: this.uiLayout,
            applyUncommitted: ()=>applyUncommitted(),
            klHistory: this.klHistory,
            onUpdateProject: ()=>this.easelProjectUpdater.update(),
            onClearLayer: ()=>clearLayer(false, true)
        });
        this.layerPreview = new (0, _kl.KL).LayerPreview({
            klRootEl: this.rootEl,
            onClick: ()=>{
                mainTabRow?.open('layers');
            },
            uiState: this.uiLayout,
            klHistory: this.klHistory
        });
        this.layerPreview.setIsVisible(this.uiHeight >= 579);
        this.layerPreview.setLayer(currentLayer);
        const editUi = new (0, _kl.KL).EditUi({
            klRootEl: this.rootEl,
            klColorSlider: this.klColorSlider,
            layersUi: this.layersUi,
            getCurrentColor: ()=>currentColor,
            maxCanvasSize,
            klCanvas: this.klCanvas,
            getCurrentLayer: ()=>currentLayer,
            isEmbed: !!this.embed,
            statusOverlay: this.statusOverlay,
            onCanvasChanged: ()=>{
                this.easelProjectUpdater.update();
                this.easel.resetOrFitTransform(true);
            },
            applyUncommitted: ()=>applyUncommitted(),
            klHistory: this.klHistory,
            onCopyToClipboard: ()=>{
                applyUncommitted();
                copyToClipboard(false, false);
            },
            onPaste: ()=>importHandler.readClipboard()
        });
        const klHistoryExecutor = new (0, _klHistoryExecutor.KlHistoryExecutor)({
            klHistory: this.klHistory,
            tempHistory,
            onCanUndoRedoChange: (canUndo, canRedo)=>{
                this.toolspaceToolRow.setEnableUndo(canUndo);
                this.toolspaceToolRow.setEnableRedo(canRedo);
            }
        });
        const showNewImageDialog = ()=>{
            applyUncommitted();
            (0, _kl.KL).newImageDialog({
                currentColor: currentColor,
                secondaryColor: this.klColorSlider.getSecondaryRGB(),
                maxCanvasSize,
                canvasWidth: this.klCanvas.getWidth(),
                canvasHeight: this.klCanvas.getHeight(),
                workspaceWidth: window.innerWidth < this.collapseThreshold ? this.uiWidth : this.uiWidth - this.toolWidth,
                workspaceHeight: this.uiHeight,
                onConfirm: (width, height, color)=>{
                    this.klCanvas.reset({
                        width: width,
                        height: height,
                        color: color.a === 1 ? color : undefined
                    });
                    this.layersUi.update(0);
                    setCurrentLayer(this.klCanvas.getLayer(0));
                    this.easelProjectUpdater.update();
                    this.easel.resetOrFitTransform(true);
                },
                onCancel: ()=>{}
            });
        };
        const shareImage = (callback)=>{
            applyUncommitted();
            (0, _bb.BB).shareCanvas({
                canvas: this.klCanvas.getCompleteCanvas(1),
                fileName: (0, _bb.BB).getDate() + (0, _klConfig.KL_CONFIG).filenameBase + '.png',
                title: (0, _bb.BB).getDate() + (0, _klConfig.KL_CONFIG).filenameBase + '.png',
                callback: callback ? callback : ()=>{}
            });
        };
        this.saveToComputer = new (0, _kl.KL).SaveToComputer(()=>exportType, this.klCanvas, ()=>{
            this.updateLastSaved();
        });
        const copyToClipboard = (showCrop = false, closeOnBlur = true)=>{
            (0, _kl.KL).clipboardDialog(this.rootEl, (maskSelection)=>{
                return this.klCanvas.getCompleteCanvas(1, maskSelection);
            }, (inputObj)=>{
                if (inputObj.left === 0 && inputObj.right === 0 && inputObj.top === 0 && inputObj.bottom === 0) return;
                //do a crop
                (0, _kl.KL).FILTER_LIB.cropExtend.apply({
                    layer: currentLayer,
                    klCanvas: this.klCanvas,
                    input: inputObj,
                    klHistory: this.klHistory
                });
                this.layersUi.update();
                this.easelProjectUpdater.update();
                this.easel.resetOrFitTransform(true);
            }, this.statusOverlay, showCrop || false, closeOnBlur, this.klCanvas.getSelection());
        };
        const onOpenBrowserStorage = async ()=>{
            const showFailureMessage = ()=>{
                (0, _kl.KL).popup({
                    target: this.rootEl,
                    message: (0, _language.LANG)('file-storage-open-failed'),
                    type: 'error'
                });
            };
            if (!projectStore) {
                showFailureMessage();
                return;
            }
            const meta = projectStore.getCurrentMeta();
            // Check is project already opened in other tab.
            // (if it's already open in the current tab, user showed intentionality. Don't ask again.)
            if (meta && this.klHistory.getComposed().projectId.value !== meta.projectId) {
                let doOpen = true;
                const crossTabChannel = new (0, _crossTabChannel.CrossTabChannel)('kl-tab-communication');
                const openedProjectIds = [];
                const otherIdListener = (message)=>{
                    if (message.type === 'response-project-id') openedProjectIds.push(message.id);
                };
                crossTabChannel.subscribe(otherIdListener);
                crossTabChannel.postMessage({
                    type: 'request-project-ids'
                });
                await (0, _base.sleep)(100);
                crossTabChannel.unsubscribe(otherIdListener);
                if (meta && openedProjectIds.includes(meta.projectId)) doOpen = await new Promise((resolve, reject)=>{
                    (0, _showModal.showModal)({
                        target: document.body,
                        message: (0, _language.LANG)('file-storage-open-confirmation'),
                        buttons: [
                            (0, _language.LANG)('file-storage-open'),
                            'Cancel'
                        ],
                        callback: async (result)=>{
                            if (result === 'Cancel') {
                                resolve(false);
                                return;
                            }
                            resolve(true);
                        }
                    });
                });
                crossTabChannel.close();
                if (!doOpen) return;
            }
            let closeLoader;
            (0, _kl.KL).popup({
                target: this.rootEl,
                message: (0, _language.LANG)('loading'),
                callback: (result)=>{
                    closeLoader = undefined;
                },
                closeFunc: (f)=>{
                    closeLoader = f;
                }
            });
            let project;
            try {
                project = await projectStore?.read();
            } catch (e) {
                setTimeout(()=>{
                    throw e;
                });
            }
            if (!project) {
                closeLoader?.();
                showFailureMessage();
                return;
            }
            applyUncommitted();
            const layerIndex = this.klCanvas.reset({
                projectId: project.project.projectId,
                width: project.project.width,
                height: project.project.height,
                layers: project.project.layers.map((item)=>{
                    let image = item.image;
                    if (!(image instanceof HTMLCanvasElement)) {
                        image = (0, _bb.BB).canvas(project.project.width, project.project.height);
                        if (item.image instanceof HTMLImageElement) {
                            const ctx = (0, _bb.BB).ctx(image);
                            ctx.drawImage(item.image, 0, 0);
                        }
                    }
                    return {
                        ...item,
                        id: (0, _base.randomUuid)(),
                        image,
                        mixModeStr: item.mixModeStr ?? 'source-over'
                    };
                })
            });
            this.layersUi.update(layerIndex);
            setCurrentLayer(this.klCanvas.getLayer(layerIndex));
            this.easelProjectUpdater.update();
            this.easel.resetOrFitTransform(true);
            setTimeout(()=>{
                // timeout to overwrite zoom overlay msg
                this.statusOverlay.out((0, _language.LANG)('file-storage-restored'));
            });
            closeLoader?.();
        };
        const fileUi = this.embed ? null : new (0, _kl.KL).FileUi({
            klRootEl: this.rootEl,
            projectStore: projectStore,
            getProject: ()=>this.klCanvas.getProject(),
            exportType: exportType,
            onExportTypeChange: (type)=>{
                exportType = type;
            },
            onFileSelect: (files, optionsStr)=>importHandler.handleFileSelect(files, optionsStr),
            onSaveImageToComputer: ()=>{
                applyUncommitted();
                this.saveToComputer.save();
            },
            onNewImage: showNewImageDialog,
            onShareImage: (callback)=>{
                applyUncommitted();
                shareImage(callback);
            },
            onUpload: ()=>{
                // on upload
                applyUncommitted();
                (0, _kl.KL).imgurUpload(this.klCanvas, this.rootEl, p.app && p.app.imgurKey ? p.app.imgurKey : '', ()=>this.updateLastSaved());
            },
            applyUncommitted: ()=>applyUncommitted(),
            onChangeShowSaveDialog: (b)=>{
                this.saveToComputer.setShowSaveDialog(b);
            },
            klRecoveryManager,
            onOpenBrowserStorage,
            onStoredToBrowserStorage: ()=>{
                this.updateLastSaved();
            }
        });
        if (!this.embed && projectStore) this.saveReminder = new (0, _saveReminder.SaveReminder)({
            onSaveAsPsd: ()=>{
                if (!this.embed) this.saveAsPsd();
            },
            isDrawing: ()=>{
                return this.isDrawing();
            },
            projectStore,
            getProject: ()=>this.getProject(),
            onStored: ()=>{
                this.updateLastSaved();
            },
            applyUncommitted,
            klHistory: this.klHistory
        });
        const settingsUi = new (0, _kl.KL).SettingsUi({
            onLeftRight: ()=>{
                this.uiLayout = this.uiLayout === 'left' ? 'right' : 'left';
                this.updateUi();
                if (!this.embed) (0, _localStorage.LocalStorage).setItem('uiState', this.uiLayout);
            },
            saveReminder: this.saveReminder,
            customAbout: p.aboutEl
        });
        mainTabRow = new (0, _kl.KL).TabRow({
            initialId: 'brush',
            tabArr: [
                {
                    id: 'brush',
                    title: (0, _language.LANG)('tool-brush'),
                    image: (0, _toolPaintSvgDefault.default),
                    onOpen: ()=>{
                        if (currentBrushId === 'eraserBrush') this.klColorSlider.enable(false);
                        (0, _bb.BB).append(colorDiv, [
                            this.klColorSlider.getElement(),
                            this.klColorSlider.getOutputElement(),
                            toolspaceStabilizerRow.getElement()
                        ]);
                        brushDiv.style.display = 'block';
                    },
                    onClose: ()=>{
                        brushDiv.style.display = 'none';
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'hand',
                    title: (0, _language.LANG)('tool-hand'),
                    image: (0, _toolHandSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        handUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        handUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'paintBucket',
                    title: (0, _language.LANG)('tool-paint-bucket'),
                    image: (0, _toolFillSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        fillUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        fillUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'gradient',
                    title: (0, _language.LANG)('tool-gradient'),
                    image: (0, _toolGradientSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        gradientUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        gradientUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'text',
                    title: (0, _language.LANG)('tool-text'),
                    image: (0, _toolTextSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        textUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        textUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'shape',
                    title: (0, _language.LANG)('tool-shape'),
                    image: (0, _toolShapeSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        shapeUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        shapeUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'select',
                    title: (0, _language.LANG)('tool-select'),
                    image: (0, _toolSelectSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        klAppSelect.getSelectUi().setIsVisible(true);
                    },
                    onClose: ()=>{
                        klAppSelect.getSelectUi().setIsVisible(false);
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'layers',
                    title: (0, _language.LANG)('layers'),
                    image: (0, _tabLayersSvgDefault.default),
                    onOpen: ()=>{
                        this.layersUi.update();
                        this.layersUi.getElement().style.display = 'block';
                    },
                    onClose: ()=>{
                        this.layersUi.getElement().style.display = 'none';
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'edit',
                    title: (0, _language.LANG)('tab-edit'),
                    image: (0, _tabEditSvgDefault.default),
                    onOpen: ()=>{
                        editUi.show();
                    },
                    onClose: ()=>{
                        editUi.hide();
                    },
                    css: {
                        minWidth: '45px'
                    }
                },
                {
                    id: 'file',
                    label: (0, _language.LANG)('tab-file'),
                    isVisible: !!fileUi,
                    onOpen: ()=>{
                        if (!fileUi) return;
                        fileUi.getElement().style.display = 'block';
                        fileUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        if (!fileUi) return;
                        fileUi.getElement().style.display = 'none';
                        fileUi.setIsVisible(false);
                    },
                    css: {
                        padding: '0 7px'
                    }
                },
                {
                    id: 'settings',
                    title: (0, _language.LANG)('tab-settings'),
                    image: (0, _tabSettingsSvgDefault.default),
                    onOpen: ()=>{
                        settingsUi.getElement().style.display = 'block';
                    // settingsTab.setIsVisible(true);
                    },
                    onClose: ()=>{
                        settingsUi.getElement().style.display = 'none';
                    // settingsTab.setIsVisible(false);
                    },
                    css: {
                        minWidth: '45px'
                    }
                }
            ]
        });
        this.bottomBarWrapper = (0, _bb.BB).el({
            css: {
                width: '270px',
                position: 'absolute',
                bottom: '0',
                left: '0'
            }
        });
        if (p.bottomBar) {
            this.bottomBar = p.bottomBar;
            this.bottomBarWrapper.append(this.bottomBar);
            const observer = new MutationObserver(()=>this.updateBottomBar());
            observer.observe(this.toolspaceInner, {
                attributes: true,
                childList: true,
                subtree: true
            });
        }
        (0, _bb.BB).append(this.toolspaceInner, [
            this.layerPreview.getElement(),
            mainTabRow.getElement(),
            brushDiv,
            handUi.getElement(),
            fillUi.getElement(),
            gradientUi.getElement(),
            textUi.getElement(),
            shapeUi.getElement(),
            klAppSelect.getSelectUi().getElement(),
            this.layersUi.getElement(),
            editUi.getElement(),
            fileUi ? fileUi.getElement() : undefined,
            settingsUi.getElement(),
            (0, _bb.BB).el({
                css: {
                    height: '10px'
                }
            }),
            this.bottomBarWrapper ? this.bottomBarWrapper : undefined
        ]);
        this.toolspaceScroller = new (0, _kl.KL).ToolspaceScroller({
            toolspace: this.toolspace,
            uiState: this.uiLayout
        });
        if (!this.embed) Object.defineProperty(window, 'KL', {
            value: (0, _consoleApi.createConsoleApi)({
                onDraw: (path)=>{
                    if (!path || path.length === 0) return;
                    path.forEach((p, index)=>{
                        if (index === 0) currentBrushUi.startLine(p.x, p.y, 1);
                        else currentBrushUi.goLine(p.x, p.y, 1);
                    });
                    currentBrushUi.endLine();
                }
            }),
            writable: false
        });
        this.resize(this.uiWidth, this.uiHeight);
        this.updateUi();
        const importHandler = new (0, _klAppImportHandler.KlAppImportHandler)({
            klRootEl: this.rootEl,
            maxCanvasSize,
            layersUi: this.layersUi,
            setCurrentLayer,
            klCanvas: this.klCanvas,
            onImportConfirm: ()=>{
                this.easelProjectUpdater.update();
                this.easel.resetOrFitTransform(true);
            },
            applyUncommitted: ()=>applyUncommitted()
        }, {
            onColor: (rgb)=>brushSettingService.setColor(rgb)
        });
        if (!this.embed || this.embed.enableImageDropperImport) {
            new (0, _kl.KL).KlImageDropper({
                target: document.body,
                onDrop: (files, optionStr)=>{
                    if ((0, _kl.KL).DIALOG_COUNTER.get() > 0) return;
                    applyUncommitted();
                    importHandler.handleFileSelect(files, optionStr);
                },
                enabledTest: ()=>{
                    return (0, _kl.KL).DIALOG_COUNTER.get() === 0;
                }
            });
            window.document.addEventListener('paste', (e)=>importHandler.onPaste(e), false);
        }
        this.unloadWarningTrigger = new (0, _unloadWarningTrigger.UnloadWarningTrigger)({
            klHistory: this.klHistory,
            getLastSavedHistoryIndex: ()=>this.lastSavedHistoryIndex
        });
        {
            window.addEventListener('resize', ()=>{
                this.resize(window.innerWidth, window.innerHeight);
            });
            window.addEventListener('orientationchange', ()=>{
                this.resize(window.innerWidth, window.innerHeight);
            });
            // 2024-08: window.resize doesn't fire on iPad Safari when:
            // pinch zoomed page, then reload, and un-pinch-zoom page
            // therefor also listen to visualViewport.
            if ('visualViewport' in window && visualViewport !== null) visualViewport.addEventListener('resize', ()=>{
                this.resize(window.innerWidth, window.innerHeight);
            });
            // iPad doesn't trigger 'resize' event when using text zoom, although it's resizing the window.
            // Workaround: place a div in the body that fills the window, and use a ResizeObserver
            const windowResizeWatcher = (0, _bb.BB).el({
                parent: document.body,
                css: {
                    position: 'fixed',
                    left: '0',
                    top: '0',
                    right: '0',
                    bottom: '0',
                    pointerEvents: 'none',
                    zIndex: '-1',
                    userSelect: 'none'
                }
            });
            try {
                // Not all browsers support ResizeObserver. Not critical though.
                const observer = new ResizeObserver(()=>this.resize(window.innerWidth, window.innerHeight));
                observer.observe(windowResizeWatcher);
            } catch (e) {
                windowResizeWatcher.remove();
            }
            // prevent ctrl scroll -> zooming page
            this.rootEl.addEventListener('wheel', (event)=>{
                if (keyListener.isPressed('ctrl')) event.preventDefault();
            }, {
                passive: false
            });
            //maybe prevent zooming on safari mac os - todo still needed?
            const prevent = (e)=>{
                e.preventDefault();
            };
            window.addEventListener('gesturestart', prevent, {
                passive: false
            });
            window.addEventListener('gesturechange', prevent, {
                passive: false
            });
            window.addEventListener('gestureend', prevent, {
                passive: false
            });
            const pinchZoomWatcher = new (0, _pinchZoomWatcher.PinchZoomWatcher)();
        }
        if (!this.embed) setTimeout(()=>{
            (0, _browserStorageBanner.runBrowserStorageBanner)({
                projectStore,
                klRecoveryManager,
                onOpenBrowserStorage,
                klHistory: this.klHistory
            });
        });
        this.saveReminder?.init();
    }
    // -------- interface --------
    getElement() {
        return this.rootEl;
    }
    resize(w, h) {
        // iPad scrolls down when increasing text zoom
        if (window.scrollY > 0) window.scrollTo(0, 0);
        if (this.uiWidth === Math.max(0, w) && this.uiHeight === Math.max(0, h)) return;
        this.uiWidth = Math.max(0, w);
        this.uiHeight = Math.max(0, h);
        this.updateCollapse();
        this.updateBottomBar();
        this.layerPreview.setIsVisible(this.uiHeight >= 579);
        this.klColorSlider.setHeight(Math.max(163, Math.min(400, this.uiHeight - 505)));
        this.toolspaceToolRow.setIsSmall(this.uiHeight < 540);
    }
    out(msg) {
        this.statusOverlay.out(msg);
    }
    async getPNG() {
        return await (0, _canvas.canvasToBlob)(this.klCanvas.getCompleteCanvas(1), 'image/png');
    }
    getProject() {
        return this.klCanvas.getProject();
    }
    swapUiLeftRight() {
        this.uiLayout = this.uiLayout === 'left' ? 'right' : 'left';
        if (!this.embed) (0, _localStorage.LocalStorage).setItem('uiState', this.uiLayout);
        this.updateUi();
    }
    saveAsPsd() {
        this.saveToComputer.save('psd');
    }
    isDrawing() {
        return this.lineSanitizer.getIsDrawing() || this.easel.getIsLocked();
    }
}

},{"../klecks/kl":"lHQKw","../bb/bb":"3zOvT","../klecks/ui/modals/show-iframe-modal":"e3aiU","../embed/embed-toolspace-top-row":"fdJcF","../klecks/filters/filters-lazy":"1RciL","../klecks/storage/kl-canvas-to-psd-blob":"5AFDo","../klecks/storage/project-store":"6Zcnn","../klecks/ui/components/save-reminder":"ge4nE","../language/language":"mcywn","../bb/base/local-storage":"itqB1","../klecks/events/line-smoothing":"bOWFD","../klecks/events/line-sanitizer":"lV9Cb","../klecks/utils/translate-smoothing":"6gQ7b","./kl-app-import-handler":"hOkpf","url:/src/app/img/ui/tool-paint.svg":"kLnEj","url:/src/app/img/ui/tool-hand.svg":"3vXJO","url:/src/app/img/ui/tool-fill.svg":"kD7Tz","url:/src/app/img/ui/tool-gradient.svg":"hOixx","url:/src/app/img/ui/tool-text.svg":"9MRtp","url:/src/app/img/ui/tool-shape.svg":"1cHcj","url:/src/app/img/ui/tool-select.svg":"lLXhX","url:/src/app/img/ui/tab-settings.svg":"isNYb","url:/src/app/img/ui/tab-layers.svg":"fe0Eb","url:/src/app/img/ui/tab-edit.svg":"gqmdn","./console-api":"4llEN","../klecks/kl-config":"4KrR1","../klecks/ui/easel/easel":"kvtTs","../klecks/ui/easel/tools/easel-hand":"krX6f","../klecks/ui/easel/tools/easel-brush":"fF49U","../klecks/ui/easel/easel-project-updater":"8cv9J","../klecks/ui/project-viewport/utils/zoom-by-step":"f7IyB","../klecks/ui/easel/tools/easel-eyedropper":"fQvEK","../klecks/ui/easel/tools/easel-paint-bucket":"bdCpZ","../klecks/ui/easel/tools/easel-gradient":"4vmMl","../klecks/ui/easel/tools/easel-text":"lbC4o","../klecks/ui/easel/tools/easel-shape":"2VHOF","../klecks/ui/easel/tools/easel-rotate":"8Wzzw","../klecks/ui/easel/tools/easel-zoom":"iu2pb","./kl-app-select":"45gaA","../klecks/history/kl-temp-history":"gAbL2","../klecks/ui/components/pinch-zoom-watcher":"7hFUN","../klecks/ui/easel/easel.config":"8wpI3","../klecks/history/kl-history-executor":"kXB2m","../klecks/history/kl-history":"l5YQK","../klecks/history/push-helpers/is-history-entry-active-layer-change":"cB30s","../klecks/ui/mobile/mobile-ui":"7HnFm","../klecks/ui/mobile/mobile-brush-ui":"89Xkb","../bb/base/canvas":"86XNv","../klecks/history/push-helpers/project-to-composed":"bTdY6","../klecks/brushes/erase-color":"4wlOt","../klecks/canvas/draw-project":"8dpes","../bb/base/base":"it3mQ","../klecks/ui/components/unload-warning-trigger":"f7U4Z","../klecks/storage/kl-indexed-db":"iz3yu","../klecks/ui/modals/base/showModal":"gy3iL","../klecks/ui/components/browser-storage-banner":"fUcDD","../klecks/storage/request-persistent-storage":"gBKae","../bb/base/cross-tab-channel":"czgd6","../klecks/ui/mobile/mobile-color-ui":"hmxZ7","../bb/multi-polygon/get-selection-path-2d":"hDCCZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lHQKw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KL", ()=>KL);
var _showModal = require("./ui/modals/base/showModal");
var _dynamicModal = require("./ui/modals/base/dynamic-modal");
var _modalCount = require("./ui/modals/modal-count");
var _checkbox = require("./ui/components/checkbox");
var _input = require("./ui/components/input");
var _select = require("./ui/components/select");
var _imageToggle = require("./ui/components/image-toggle");
var _imageRadioList = require("./ui/components/image-radio-list");
var _createPenPressureToggle = require("./ui/components/create-pen-pressure-toggle");
var _klSlider = require("./ui/components/kl-slider");
var _colorSliderHexDialog = require("./ui/modals/color-slider-hex-dialog");
var _klColorSlider = require("./ui/components/kl-color-slider");
var _klColorSliderSmall = require("./ui/components/kl-color-slider-small");
var _pointSlider = require("./ui/components/point-slider");
var _colorOptions = require("./ui/components/color-options");
var _options = require("./ui/components/options");
var _statusOverlay = require("./ui/components/status-overlay");
var _cropCopy = require("./ui/components/crop-copy");
var _clipboardDialog = require("./ui/modals/clipboard-dialog");
var _layersUi = require("./ui/tool-tabs/layers-ui/layers-ui");
var _klCanvasPreview = require("./ui/project-viewport/kl-canvas-preview");
var _freeTransform = require("./ui/components/free-transform");
var _freeTransformCanvas = require("./ui/components/free-transform-canvas");
var _cropper = require("./ui/components/cropper");
var _layerPreview = require("./ui/components/layer-preview");
var _showImportAsLayerDialog = require("./ui/modals/show-import-as-layer-dialog");
var _klImageDropper = require("./ui/components/kl-image-dropper");
var _overlayToolspace = require("./ui/components/overlay-toolspace");
var _toolspaceTopRow = require("./ui/components/toolspace-top-row");
var _toolDropdown = require("./ui/components/tool-dropdown");
var _toolspaceToolRow = require("./ui/components/toolspace-tool-row");
var _toolspaceStabilizerRow = require("./ui/components/toolspace-stabilizer-row");
var _tabRow = require("./ui/components/tab-row");
var _handUi = require("./ui/tool-tabs/hand-ui");
var _fillUi = require("./ui/tool-tabs/fill-ui");
var _textUi = require("./ui/tool-tabs/text-ui");
var _shapeUi = require("./ui/tool-tabs/shape-ui");
var _newImageDialog = require("./ui/modals/new-image-dialog");
var _toolspaceCollapser = require("./ui/mobile/toolspace-collapser");
var _textToolDialog = require("./ui/modals/text-tool-dialog/text-tool-dialog");
var _showImportImageDialog = require("./ui/modals/show-import-image-dialog");
var _psd = require("./storage/psd");
var _shapeTool = require("./image-operations/shape-tool");
var _klCanvas = require("./canvas/kl-canvas");
var _filters = require("./filters/filters");
var _brushes = require("./brushes/brushes");
var _brushesUi = require("./brushes-ui/brushes-ui");
var _showIframeModal = require("./ui/modals/show-iframe-modal");
var _radioList = require("./ui/components/radio-list");
var _browserStorageUi = require("./ui/components/browser-storage-ui");
var _projectStore = require("./storage/project-store");
var _fileUi = require("./ui/tool-tabs/file-ui");
var _editUi = require("./ui/tool-tabs/edit-ui");
var _imgurUpload = require("./ui/modals/imgur-upload");
var _loadAgPsd = require("./storage/load-ag-psd");
var _saveReminder = require("./ui/components/save-reminder");
var _saveToComputer = require("./storage/save-to-computer");
var _brushSettingService = require("./brushes-ui/brush-setting-service");
var _boxToggle = require("./ui/components/box-toggle");
var _settingsUi = require("./ui/tool-tabs/settings-ui");
var _toolspaceScroller = require("./ui/components/toolspace-scroller");
var _gradientUi = require("./ui/tool-tabs/gradient-ui");
var _gradientTool = require("./image-operations/gradient-tool");
const KL = {
    BRUSHES: // --- brushes ---
    (0, _brushes.BRUSHES),
    BRUSHES_UI: (0, _brushesUi.BRUSHES_UI),
    BrushSettingService: (0, _brushSettingService.BrushSettingService),
    KlCanvas: // --- canvas ---
    (0, _klCanvas.KlCanvas),
    KlCanvasPreview: // --- canvas ui ---
    (0, _klCanvasPreview.KlCanvasPreview),
    FILTER_LIB_STATUS: // --- filters ---
    (0, _filters.FILTER_LIB_STATUS),
    FILTER_LIB: (0, _filters.FILTER_LIB),
    ShapeTool: // --- image operations ---
    (0, _shapeTool.ShapeTool),
    drawShape: (0, _shapeTool.drawShape),
    GradientTool: (0, _gradientTool.GradientTool),
    drawGradient: (0, _gradientTool.drawGradient),
    PSD: // --- storage ---
    _psd,
    ProjectStore: (0, _projectStore.ProjectStore),
    loadAgPsd: (0, _loadAgPsd.loadAgPsd),
    SaveToComputer: (0, _saveToComputer.SaveToComputer),
    Checkbox: // --- ui - components ---
    (0, _checkbox.Checkbox),
    input: (0, _input.input),
    Select: (0, _select.Select),
    ImageToggle: (0, _imageToggle.ImageToggle),
    ImageRadioList: (0, _imageRadioList.ImageRadioList),
    RadioList: (0, _radioList.RadioList),
    createPenPressureToggle: (0, _createPenPressureToggle.createPenPressureToggle),
    KlSlider: (0, _klSlider.KlSlider),
    HexColorDialog: (0, _colorSliderHexDialog.HexColorDialog),
    KlColorSlider: (0, _klColorSlider.KlColorSlider),
    KlColorSliderSmall: (0, _klColorSliderSmall.KlColorSliderSmall),
    PointSlider: (0, _pointSlider.PointSlider),
    ColorOptions: (0, _colorOptions.ColorOptions),
    Options: (0, _options.Options),
    BoxToggle: (0, _boxToggle.BoxToggle),
    StatusOverlay: (0, _statusOverlay.StatusOverlay),
    CropCopy: (0, _cropCopy.CropCopy),
    FreeTransform: (0, _freeTransform.FreeTransform),
    FreeTransformCanvas: (0, _freeTransformCanvas.FreeTransformCanvas),
    Cropper: (0, _cropper.Cropper),
    LayerPreview: (0, _layerPreview.LayerPreview),
    KlImageDropper: (0, _klImageDropper.KlImageDropper),
    OverlayToolspace: (0, _overlayToolspace.OverlayToolspace),
    ToolspaceTopRow: (0, _toolspaceTopRow.ToolspaceTopRow),
    ToolDropdown: (0, _toolDropdown.ToolDropdown),
    ToolspaceToolRow: (0, _toolspaceToolRow.ToolspaceToolRow),
    ToolspaceStabilizerRow: (0, _toolspaceStabilizerRow.ToolspaceStabilizerRow),
    TabRow: (0, _tabRow.TabRow),
    ToolspaceCollapser: (0, _toolspaceCollapser.ToolspaceCollapser),
    BrowserStorageUi: (0, _browserStorageUi.BrowserStorageUi),
    SaveReminder: (0, _saveReminder.SaveReminder),
    ToolspaceScroller: (0, _toolspaceScroller.ToolspaceScroller),
    DIALOG_COUNTER: // --- ui - modals ---
    (0, _modalCount.DIALOG_COUNTER),
    popup: (0, _showModal.showModal),
    Popup: (0, _dynamicModal.DynamicModal),
    clipboardDialog: (0, _clipboardDialog.clipboardDialog),
    showImportAsLayerDialog: (0, _showImportAsLayerDialog.showImportAsLayerDialog),
    newImageDialog: (0, _newImageDialog.newImageDialog),
    textToolDialog: (0, _textToolDialog.textToolDialog),
    showImportImageDialog: (0, _showImportImageDialog.showImportImageDialog),
    showIframePopup: (0, _showIframeModal.showIframeModal),
    imgurUpload: (0, _imgurUpload.imgurUpload),
    HandUi: // --- ui - tool tabs ---
    (0, _handUi.HandUi),
    FillUi: (0, _fillUi.FillUi),
    GradientUi: (0, _gradientUi.GradientUi),
    TextUi: (0, _textUi.TextUi),
    ShapeUi: (0, _shapeUi.ShapeUi),
    FileUi: (0, _fileUi.FileUi),
    EditUi: (0, _editUi.EditUi),
    SettingsUi: (0, _settingsUi.SettingsUi),
    LayersUi: (0, _layersUi.LayersUi)
};
Object.keys(KL); // without this, parcel build may break this object

},{"./ui/modals/base/showModal":"gy3iL","./ui/modals/base/dynamic-modal":"3DApo","./ui/modals/modal-count":"60MST","./ui/components/checkbox":"9bXL6","./ui/components/input":"e8FQP","./ui/components/select":"iuUFh","./ui/components/image-toggle":"6pxUz","./ui/components/image-radio-list":"fAfrJ","./ui/components/create-pen-pressure-toggle":"drOTJ","./ui/components/kl-slider":"fQOKQ","./ui/modals/color-slider-hex-dialog":"arnzW","./ui/components/kl-color-slider":"8Lh1B","./ui/components/kl-color-slider-small":"j88oi","./ui/components/point-slider":"1mvjC","./ui/components/color-options":"1nMl0","./ui/components/options":"7kiPU","./ui/components/status-overlay":"a1BHN","./ui/components/crop-copy":"dtoRN","./ui/modals/clipboard-dialog":"3SqSS","./ui/tool-tabs/layers-ui/layers-ui":"7R6ie","./ui/project-viewport/kl-canvas-preview":"2vGJF","./ui/components/free-transform":"2fR2j","./ui/components/free-transform-canvas":"2itGC","./ui/components/cropper":"dNjUU","./ui/components/layer-preview":"aPNnS","./ui/modals/show-import-as-layer-dialog":"gebP9","./ui/components/kl-image-dropper":"dAMCR","./ui/components/overlay-toolspace":"gwFLq","./ui/components/toolspace-top-row":"bRD8T","./ui/components/tool-dropdown":"Yid1i","./ui/components/toolspace-tool-row":"gVM0D","./ui/components/toolspace-stabilizer-row":"iITGN","./ui/components/tab-row":"bJoVm","./ui/tool-tabs/hand-ui":"k62XM","./ui/tool-tabs/fill-ui":"6xOom","./ui/tool-tabs/text-ui":"i2rnK","./ui/tool-tabs/shape-ui":"4Tqq5","./ui/modals/new-image-dialog":"dwpUK","./ui/mobile/toolspace-collapser":"lr9fj","./ui/modals/text-tool-dialog/text-tool-dialog":"7EFYg","./ui/modals/show-import-image-dialog":"hEFCl","./storage/psd":"erBJa","./image-operations/shape-tool":"diljP","./canvas/kl-canvas":"aumh6","./filters/filters":"g0YSX","./brushes/brushes":"11wyk","./brushes-ui/brushes-ui":"6ZP5I","./ui/modals/show-iframe-modal":"e3aiU","./ui/components/radio-list":"1MvSQ","./ui/components/browser-storage-ui":"jEHd9","./storage/project-store":"6Zcnn","./ui/tool-tabs/file-ui":"lkbRA","./ui/tool-tabs/edit-ui":"deEWV","./ui/modals/imgur-upload":"dLyJt","./storage/load-ag-psd":"ZuAcA","./ui/components/save-reminder":"ge4nE","./storage/save-to-computer":"fvvQk","./brushes-ui/brush-setting-service":"c1CDV","./ui/components/box-toggle":"1YB1o","./ui/tool-tabs/settings-ui":"iO0QN","./ui/components/toolspace-scroller":"83fjv","./ui/tool-tabs/gradient-ui":"ic2NK","./image-operations/gradient-tool":"1HqrJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gy3iL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showModal", ()=>showModal);
var _modalCount = require("../modal-count");
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _scrollFix = require("./scroll-fix");
var _cancelSvg = require("url:/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
var _checkSvg = require("url:/src/app/img/ui/check.svg");
var _checkSvgDefault = parcelHelpers.interopDefault(_checkSvg);
var _removeLayerSvg = require("url:/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
function showModal(p) {
    (0, _modalCount.DIALOG_COUNTER).increase();
    let isClosed = false;
    let ignoreBackground = !!p.ignoreBackground;
    // need this extra layer because chrome mobile otherwise scrolls the page and then glitches as the address bar goes away
    const rootRootEl = (0, _bb.BB).el({
        parent: document.body,
        css: {
            position: 'absolute',
            left: '0',
            top: '0',
            right: '0',
            bottom: '0',
            overflow: 'hidden'
        }
    });
    const rootEl = (0, _bb.BB).el({
        parent: rootRootEl,
        className: 'kl-popup'
    });
    const scrollContent = (0, _bb.BB).el({
        parent: rootEl,
        css: {
            width: '100%',
            minHeight: '100%',
            // padding: '10px 0',
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center'
        }
    });
    const bgEl = (0, _bb.BB).el({
        parent: scrollContent,
        onClick: ()=>{
            if (ignoreBackground) return;
            close('Cancel');
        },
        css: {
            position: 'absolute',
            left: '0',
            top: '0',
            zIndex: '0',
            width: '100%',
            height: '100%'
        }
    });
    const titleHeight = 40;
    const xButton = (0, _bb.BB).el({
        tagName: 'button',
        className: 'popup-x',
        content: `<img alt="${(0, _language.LANG)('modal-close')}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
        title: (0, _language.LANG)('modal-close'),
        onClick: ()=>{
            close('Cancel');
        },
        css: {
            width: titleHeight + 'px',
            height: titleHeight + 'px',
            lineHeight: titleHeight + 'px',
            position: 'absolute',
            right: '0',
            top: '0',
            background: 'none',
            boxShadow: 'none'
        }
    });
    let icon = undefined;
    if (p.type) icon = (0, _bb.BB).el({
        className: {
            error: 'kl-popup__icon-error',
            ok: 'kl-popup__icon-ok',
            warning: 'kl-popup__icon-warning',
            upload: 'kl-popup__icon-upload'
        }[p.type]
    });
    const boxClasses = [
        'kl-popup-box'
    ];
    boxClasses.push('kl-popup-box--sm');
    const boxEl = (0, _bb.BB).el({
        content: [
            xButton,
            icon,
            (0, _bb.BB).el({
                content: p.message,
                css: {
                    marginRight: '15px',
                    marginBottom: p.div ? '10px' : undefined
                }
            }),
            p.div
        ],
        className: boxClasses.join(' '),
        css: p.style ? p.style : undefined
    });
    scrollContent.append((0, _bb.BB).el({
        css: {
            flex: '0.5'
        }
    }), boxEl, (0, _bb.BB).el({
        css: {
            flex: '1'
        }
    }));
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if (isClosed) return;
            if (clickOnEnterBtn && comboStr === 'enter' && !(0, _bb.BB).isInputFocused()) {
                e.stopPropagation();
                setTimeout(()=>{
                    clickOnEnterBtn && clickOnEnterBtn.click();
                }, 10);
            }
            if (comboStr === 'esc') {
                e.stopPropagation();
                e.preventDefault(); // stay in fullscreen on Mac
                close('Cancel');
            }
        }
    });
    // prevent ctrl scroll -> zooming page
    const wheelPrevent = (event)=>{
        if (keyListener.isPressed('ctrl')) event.preventDefault();
    };
    rootEl.addEventListener('wheel', wheelPrevent, {
        passive: false
    });
    rootEl.onclick = (0, _bb.BB).handleClick;
    let autoFocus;
    if (p.autoFocus) autoFocus = p.autoFocus;
    else if (p.autoFocus === false) autoFocus = undefined;
    else autoFocus = 'Ok';
    const buttonRowEl = p.buttons && p.buttons.length > 0 ? (0, _bb.BB).el({
        parent: boxEl,
        css: {
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'flex-end',
            marginTop: '12px',
            marginLeft: '-8px'
        }
    }) : undefined;
    let clickOnEnterBtn;
    const btnElArr = [];
    if (p.buttons) p.buttons.forEach((buttonName)=>{
        const btnClasses = [
            'kl-popup__btn'
        ];
        if (buttonName === 'Ok' || p.primaries && p.primaries.includes(buttonName)) btnClasses.push('kl-button-primary');
        if (buttonName === p.deleteButtonName) btnClasses.push('kl-button-delete');
        let iconUrl;
        let label = buttonName;
        if (buttonName === 'Ok') {
            label = (0, _language.LANG)('modal-ok');
            iconUrl = (0, _checkSvgDefault.default);
        }
        if (buttonName === 'Cancel') {
            label = (0, _language.LANG)('modal-cancel');
            iconUrl = (0, _cancelSvgDefault.default);
            btnClasses.push('kl-button-cancel');
        }
        if (buttonName === p.deleteButtonName) iconUrl = (0, _removeLayerSvgDefault.default);
        let iconImg = undefined;
        if (iconUrl) iconImg = (0, _bb.BB).el({
            tagName: 'img',
            custom: {
                src: iconUrl,
                height: '17'
            }
        });
        const btn = (0, _bb.BB).el({
            parent: buttonRowEl,
            tagName: 'button',
            className: btnClasses.join(' '),
            content: [
                iconImg,
                (0, _bb.BB).el({
                    className: 'kl-popup__btn__text',
                    content: label
                })
            ],
            onClick: ()=>{
                close(buttonName);
            }
        });
        btnElArr.push(btn);
        if (autoFocus === buttonName) {
            setTimeout(()=>{
                btn.focus();
                rootEl.scrollTo(0, 0);
            }, 10);
            setTimeout(()=>{
                // safari needs a separate timeout
                rootEl.scrollTo(0, 0);
            }, 20);
        }
        if (buttonName === p.clickOnEnter) clickOnEnterBtn = btn;
    });
    function close(value) {
        if (isClosed) return;
        isClosed = true;
        (0, _bb.BB).clearSelection();
        (0, _bb.BB).unfocusAnyInput();
        rootRootEl.remove();
        (0, _modalCount.DIALOG_COUNTER).decrease();
        (0, _bb.BB).destroyEl(xButton);
        (0, _bb.BB).destroyEl(bgEl);
        keyListener.destroy();
        rootEl.removeEventListener('wheel', wheelPrevent);
        // (disabled) eslint-disable-next-line no-null/no-null
        rootEl.onclick = null;
        btnElArr.forEach((item)=>(0, _bb.BB).destroyEl(item));
        btnElArr.splice(0, btnElArr.length);
        if (p.callback) p.callback(value);
    }
    if (p.closeFunc) p.closeFunc(function() {
        close('Cancel');
    });
    return {
        setIgnoreBackground: (b)=>{
            ignoreBackground = b;
        }
    };
}

},{"../modal-count":"60MST","../../../../bb/bb":"3zOvT","../../../../language/language":"mcywn","./scroll-fix":"l2GAy","url:/src/app/img/ui/cancel.svg":"kcuhT","url:/src/app/img/ui/check.svg":"8cC21","url:/src/app/img/ui/remove-layer.svg":"fV9n3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"60MST":[function(require,module,exports,__globalThis) {
/**
 * track how many modals are opened
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DialogCounter", ()=>DialogCounter);
parcelHelpers.export(exports, "DIALOG_COUNTER", ()=>DIALOG_COUNTER);
class DialogCounter {
    emit() {
        this.listeners.forEach((item)=>{
            item(this.count);
        });
    }
    // ----------------------------------- public -----------------------------------
    increase(v) {
        if (v !== undefined) this.count += v;
        else this.count++;
        this.emit();
    }
    decrease(v) {
        if (v !== undefined) this.count -= v;
        else this.count--;
        this.emit();
    }
    get() {
        return this.count;
    }
    subscribe(listener) {
        this.listeners.push(listener);
    }
    constructor(){
        this.listeners = [];
        this.count = 0;
    }
}
const DIALOG_COUNTER = new DialogCounter();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"3zOvT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BB", ()=>BB);
var _base = require("./base/base");
var _browser = require("./base/browser");
var _keyListener = require("./input/key-listener");
var _pointerListener = require("./input/pointer-listener");
var _canvas = require("./base/canvas");
var _matrix = require("./math/matrix");
var _vec2 = require("./math/vec2");
var _line = require("./math/line");
var _color = require("./color/color");
var _ui = require("./base/ui");
var _math = require("./math/math");
var _createCanvas = require("./base/create-canvas");
var _bbLog = require("./base/bb-log");
var _localStorage = require("./base/local-storage");
var _coalescedExploder = require("./input/event-chain/coalesced-exploder");
var _nFingerTapper = require("./input/event-chain/n-finger-tapper");
var _pinchZoomer = require("./input/event-chain/pinch-zoomer");
var _doubleTapper = require("./input/event-chain/double-tapper");
var _onePointerLimiter = require("./input/event-chain/one-pointer-limiter");
var _eventChain = require("./input/event-chain/event-chain");
const BB = {
    // ---- browser ----
    eventUsesHighResTimeStamp: (0, _browser.EVENT_USES_HIGH_RES_TIMESTAMP),
    hasPointerEvents: (0, _browser.HAS_POINTER_EVENTS),
    isCssMinMaxSupported: (0, _browser.IS_CSS_MIN_MAX_SUPPORTED),
    canShareFiles: (0, _browser.canShareFiles),
    unsetEventHandler: (0, _browser.unsetEventHandler),
    insertAfter: // ---- base ----
    (0, _base.insertAfter),
    loadImage: (0, _base.loadImage),
    css: (0, _base.css),
    setAttributes: (0, _base.setAttributes),
    append: (0, _base.append),
    fitInto: (0, _base.fitInto),
    centerWithin: (0, _base.centerWithin),
    getDate: (0, _base.getDate),
    gcd: (0, _base.gcd),
    reduce: (0, _base.reduce),
    decToFraction: (0, _base.decToFraction),
    imageBlobToUrl: (0, _base.imageBlobToUrl),
    dateDayDifference: (0, _base.dateDayDifference),
    copyObj: (0, _base.copyObj),
    shareCanvas: (0, _base.shareCanvas),
    handleClick: (0, _base.handleClick),
    createSvg: (0, _base.createSvg),
    BbLog: (0, _bbLog.BbLog),
    LocalStorage: (0, _localStorage.LocalStorage),
    throwIfNull: (0, _base.throwIfNull),
    nullToUndefined: (0, _base.nullToUndefined),
    isDark: (0, _base.isDark),
    mix: // ---- math ----
    (0, _math.mix),
    dist: (0, _math.dist),
    distSquared: (0, _math.distSquared),
    lenSquared: (0, _math.lenSquared),
    pointsToAngleRad: (0, _math.pointsToAngleRad),
    pointsToAngleDeg: (0, _math.pointsToAngleDeg),
    isInsideRect: (0, _math.isInsideRect),
    clamp: (0, _math.clamp),
    rotate: (0, _math.rotate),
    rotateAround: (0, _math.rotateAround),
    Matrix: (0, _matrix.Matrix),
    Vec2: (0, _vec2.Vec2),
    intDxy: (0, _math.intDxy),
    roundEven: (0, _math.roundEven),
    roundUneven: (0, _math.roundUneven),
    round: (0, _math.round),
    updateBounds: (0, _math.updateBounds),
    boundsInArea: (0, _math.boundsInArea),
    projectPointOnLine: // ---- line ----
    (0, _line.projectPointOnLine),
    PointLine: (0, _line.PointLine),
    BezierLine: (0, _line.BezierLine),
    SplineInterpolator: (0, _line.SplineInterpolator),
    powerSplineInput: (0, _line.powerSplineInput),
    // ---- canvas ----
    canvas: (0, _createCanvas.createCanvas),
    ctx: (0, _canvas.ctx),
    copyCanvas: (0, _canvas.copyCanvas),
    testShouldPixelate: (0, _canvas.testShouldPixelate),
    drawTransformedImageWithBounds: (0, _canvas.drawTransformedImageWithBounds),
    drawTransformedImageOnCanvas: (0, _canvas.drawTransformedImageOnCanvas),
    createCheckerCanvas: (0, _canvas.createCheckerCanvas),
    createCheckerDataUrl: (0, _canvas.createCheckerDataUrl),
    resizeCanvas: (0, _canvas.resizeCanvas),
    convertToAlphaChannelCanvas: (0, _canvas.convertToAlphaChannelCanvas),
    freeCanvas: (0, _canvas.freeCanvas),
    canvasBounds: (0, _canvas.canvasBounds),
    HSV: // ---- color ----
    (0, _color.HSV),
    RGB: (0, _color.RGB),
    CMYK: (0, _color.CMYK),
    ColorConverter: (0, _color.ColorConverter),
    testIsWhiteBestContrast: (0, _color.testIsWhiteBestContrast),
    appendTextDiv: // ---- UI ----
    (0, _ui.appendTextDiv),
    clearSelection: (0, _ui.clearSelection),
    el: (0, _ui.el),
    destroyEl: (0, _ui.destroyEl),
    isInputFocused: (0, _ui.isInputFocused),
    unfocusAnyInput: (0, _ui.unfocusAnyInput),
    KeyListener: // ---- events / input ----
    (0, _keyListener.KeyListener),
    PointerListener: (0, _pointerListener.PointerListener),
    sameKeys: (0, _keyListener.sameKeys),
    EventChain: (0, _eventChain.EventChain),
    DoubleTapper: (0, _doubleTapper.DoubleTapper),
    NFingerTapper: (0, _nFingerTapper.NFingerTapper),
    PinchZoomer: (0, _pinchZoomer.PinchZoomer),
    CoalescedExploder: (0, _coalescedExploder.CoalescedExploder),
    OnePointerLimiter: (0, _onePointerLimiter.OnePointerLimiter)
};
Object.keys(BB); // without this, parcel build may break this object

},{"./base/base":"it3mQ","./base/browser":"4hCPW","./input/key-listener":"fDHUR","./input/pointer-listener":"kDObC","./base/canvas":"86XNv","./math/matrix":"exP81","./math/vec2":"g4o19","./math/line":"hqKNL","./color/color":"e0D0Q","./base/ui":"5dJJW","./math/math":"7x9Fp","./base/create-canvas":"5vnin","./base/bb-log":"hiYaP","./base/local-storage":"itqB1","./input/event-chain/coalesced-exploder":"gUydo","./input/event-chain/n-finger-tapper":"96h1z","./input/event-chain/pinch-zoomer":"786i1","./input/event-chain/double-tapper":"fPbPb","./input/event-chain/one-pointer-limiter":"fqRll","./input/event-chain/event-chain":"eo2AB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"it3mQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "insertAfter", ()=>insertAfter);
parcelHelpers.export(exports, "loadImage", ()=>loadImage);
parcelHelpers.export(exports, "asyncLoadImage", ()=>asyncLoadImage);
parcelHelpers.export(exports, "css", ()=>css);
parcelHelpers.export(exports, "setAttributes", ()=>setAttributes);
/**
 * append a list to DOM element
 */ parcelHelpers.export(exports, "append", ()=>append);
/**
 * a needs to fit into b
 */ parcelHelpers.export(exports, "fitInto", ()=>fitInto);
/**
 * center b in a
 * @param aw
 * @param ah
 * @param bw
 * @param bh
 */ parcelHelpers.export(exports, "centerWithin", ()=>centerWithin);
parcelHelpers.export(exports, "getDate", ()=>getDate);
parcelHelpers.export(exports, "gcd", ()=>gcd);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "decToFraction", ()=>decToFraction);
parcelHelpers.export(exports, "isBlob", ()=>isBlob);
/**
 * blobObj isn't always a Blob, but rather an object, because Blob doesn't exist.
 * @param blobObj
 * @returns {string}
 */ parcelHelpers.export(exports, "imageBlobToUrl", ()=>imageBlobToUrl);
parcelHelpers.export(exports, "dateDayDifference", ()=>dateDayDifference);
parcelHelpers.export(exports, "copyObj", ()=>copyObj);
/**
 * triggers Web Share API - share feature on mobile devices
 * Only works if they support file sharing - e.g. Safari can't do this yet
 * only call if BB.canShareFiles() -> true
 *
 * p = {
 *     canvas: Canvas,
 *     fileName: string,
 *     title: string
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "shareCanvas", ()=>shareCanvas);
/**
 * Prevent ipad from zooming in when double tapping. iPadOS 13 bug.
 * Give it your click event
 *
 * Can have GLOBAL EFFECT!
 *
 * @param clickEvent
 * @returns {boolean}
 */ parcelHelpers.export(exports, "handleClick", ()=>handleClick);
parcelHelpers.export(exports, "createSvg", ()=>createSvg);
parcelHelpers.export(exports, "throwIfNull", ()=>throwIfNull);
parcelHelpers.export(exports, "throwIfUndefined", ()=>throwIfUndefined);
parcelHelpers.export(exports, "nullToUndefined", ()=>nullToUndefined);
parcelHelpers.export(exports, "isDark", ()=>isDark);
parcelHelpers.export(exports, "addIsDarkListener", ()=>addIsDarkListener);
parcelHelpers.export(exports, "removeIsDarkListener", ()=>removeIsDarkListener);
parcelHelpers.export(exports, "base64ToBlob", ()=>base64ToBlob);
parcelHelpers.export(exports, "createArray", ()=>createArray);
parcelHelpers.export(exports, "randomUuid", ()=>randomUuid);
parcelHelpers.export(exports, "sleep", ()=>sleep);
// if a promise takes too long
parcelHelpers.export(exports, "timeoutWrapper", ()=>timeoutWrapper);
parcelHelpers.export(exports, "loadSvg", ()=>loadSvg);
function insertAfter(referenceNode, newNode) {
    if (referenceNode.parentNode) referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
function loadImage(im, callback) {
    let counter = 0;
    function check() {
        if (counter === 1000) {
            alert("couldn't load");
            return;
        }
        if (im.complete) {
            counter++;
            callback();
        } else setTimeout(check, 1);
    }
    check();
}
function asyncLoadImage(src) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = reject;
        img.src = src;
    });
}
function css(el, styleObj) {
    const elStyle = el.style;
    Object.keys(styleObj).forEach((key)=>{
        const property = key;
        elStyle[property] = styleObj[property];
        if (property === 'userSelect') elStyle.webkitUserSelect = styleObj[property]; // Safari support
    });
}
function setAttributes(el, attrObj) {
    const keyArr = Object.keys(attrObj);
    let keyStr;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        el.setAttribute(keyStr, attrObj[keyStr]);
    }
}
function append(target, els) {
    const fragment = document.createDocumentFragment();
    els.forEach((item)=>item && fragment.append(item));
    target.append(fragment);
}
function fitInto(aw, ah, bw, bh, min) {
    let width = aw * bw, height = ah * bw;
    if (width > bw) {
        height = bw / width * height;
        width = bw;
    }
    if (height > bh) {
        width = bh / height * width;
        height = bh;
    }
    if (min) {
        width = Math.max(min, width);
        height = Math.max(min, height);
    }
    return {
        width,
        height
    };
}
function centerWithin(aw, ah, bw, bh) {
    return {
        x: aw / 2 - bw / 2,
        y: ah / 2 - bh / 2
    };
}
function getDate() {
    const date = new Date();
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const minutes = (date.getHours() * 60 + date.getMinutes()).toString(36).padStart(3, '0');
    return year + '_' + month + '_' + day + '_' + minutes + '_';
}
function gcd(a, b) {
    return b ? gcd(b, a % b) : a;
}
function reduce(numerator, denominator) {
    const g = gcd(numerator, denominator);
    return [
        numerator / g,
        denominator / g
    ];
}
function decToFraction(decimalNumber) {
    const len = decimalNumber.toString().length - 2;
    const denominator = Math.pow(10, len);
    const numerator = decimalNumber * denominator;
    return reduce(numerator, denominator);
}
function isBlob(maybeBlob) {
    return maybeBlob instanceof Blob || Object.prototype.toString.call(maybeBlob) === '[object Blob]';
}
function imageBlobToUrl(blobObj) {
    if (!blobObj) throw new Error('blobObj is undefined or null');
    if (window.Blob && blobObj instanceof Blob) return URL.createObjectURL(blobObj); // object url
    else if (blobObj.constructor.name === 'Object') {
        const fauxBlob = blobObj;
        return 'data:' + fauxBlob.type + ';' + fauxBlob.encoding + ',' + fauxBlob.data; // data url
    } else throw new Error('unknown blob format');
}
function dateDayDifference(dateA, dateB) {
    dateA = new Date(dateA);
    dateB = new Date(dateB);
    dateA.setHours(0, 0, 0, 0);
    dateB.setHours(0, 0, 0, 0);
    return (dateB.getTime() - dateA.getTime()) / 86400000;
}
function copyObj(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function shareCanvas(p) {
    const mimetype = 'image/png';
    const err = ()=>alert('sharing not supported');
    p.canvas.toBlob(function(blob) {
        if (!blob) {
            err();
            p.callback();
            return;
        }
        try {
            const filesArray = [
                new File([
                    blob
                ], p.fileName, {
                    type: mimetype
                })
            ];
            navigator.share({
                title: p.title,
                files: filesArray
            }).then(()=>{}).catch(()=>{
                err();
            });
        } catch (e) {
            err();
        }
        p.callback();
    }, mimetype);
}
function handleClick(clickEvent) {
    const target = clickEvent.target;
    if (!target) return false;
    let el = target;
    while(el){
        if ([
            'A',
            'LABEL',
            'INPUT',
            'SUMMARY'
        ].includes(el.tagName)) return true;
        el = el.parentElement;
    }
    clickEvent.preventDefault();
    return false;
}
function createSvg(p) {
    const result = document.createElementNS('http://www.w3.org/2000/svg', p.elementType);
    Object.entries(p).forEach(([keyStr, item])=>{
        if (keyStr === 'childrenArr') item.forEach((child)=>{
            result.append(createSvg(child));
        });
        else if (keyStr === 'css') css(result, item);
        else if (keyStr !== 'elementType') result.setAttribute(keyStr, item);
    });
    return result;
}
function throwIfNull(v) {
    // (disabled) eslint-disable-next-line no-null/no-null
    if (v === null) throw new Error('value is null');
    return v;
}
function throwIfUndefined(v, message = 'value is undefined') {
    if (v === undefined) throw new Error(message);
    return v;
}
function nullToUndefined(v) {
    return v === null ? undefined : v;
}
const matchMediaDark = 'matchMedia' in window ? window.matchMedia('(prefers-color-scheme: dark)') : false;
function isDark() {
    return matchMediaDark && matchMediaDark.matches;
}
function addIsDarkListener(func) {
    matchMediaDark && 'addEventListener' in matchMediaDark && matchMediaDark.addEventListener('change', func);
}
function removeIsDarkListener(func) {
    matchMediaDark && 'removeEventListener' in matchMediaDark && matchMediaDark.removeEventListener('change', func);
}
function base64ToBlob(base64Str) {
    const parts = base64Str.match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
    const binStr = atob(parts[3]);
    const buf = new ArrayBuffer(binStr.length);
    const view = new Uint8Array(buf);
    for(let i = 0; i < view.length; i++)view[i] = binStr.charCodeAt(i);
    return new Blob([
        view
    ], {
        type: parts[1]
    });
}
function createArray(length, fillValue) {
    return new Array(length).fill(fillValue);
}
function randomUuid() {
    if ('randumUUID' in crypto) return crypto.randomUUID();
    // fallback just for dev
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
}
function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
async function timeoutWrapper(promise, name, timeoutMs = 5000) {
    return Promise.race([
        promise,
        new Promise((_, reject)=>{
            setTimeout(()=>reject(new Error(`Promise "${name}" timed out.`)), timeoutMs);
        })
    ]);
}
async function loadSvg(url) {
    const response = await fetch(url);
    const svgText = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgText, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if (!svg) throw new Error('No <svg> found in the file');
    // Optional: Clone to prevent reusing the same node
    return svg.cloneNode(true);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4hCPW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IS_FIREFOX", ()=>IS_FIREFOX);
parcelHelpers.export(exports, "EVENT_USES_HIGH_RES_TIMESTAMP", ()=>EVENT_USES_HIGH_RES_TIMESTAMP);
parcelHelpers.export(exports, "HAS_POINTER_EVENTS", ()=>HAS_POINTER_EVENTS);
parcelHelpers.export(exports, "IS_CSS_MIN_MAX_SUPPORTED", ()=>IS_CSS_MIN_MAX_SUPPORTED);
parcelHelpers.export(exports, "canShareFiles", ()=>canShareFiles);
parcelHelpers.export(exports, "unsetEventHandler", ()=>unsetEventHandler);
parcelHelpers.export(exports, "printStorageQuota", ()=>printStorageQuota);
const IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
const EVENT_USES_HIGH_RES_TIMESTAMP = function() {
    const eventUsesHighResTimeStamp = new Event('').timeStamp < 3600000;
    return function() {
        return eventUsesHighResTimeStamp;
    };
}();
const HAS_POINTER_EVENTS = !!window.PointerEvent;
const IS_CSS_MIN_MAX_SUPPORTED = function() {
    let result;
    function test() {
        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = '0';
        div.style.left = 'max(0px, 25px)';
        document.body.append(div);
        setTimeout(function() {
            result = div.offsetLeft === 25;
            div.remove();
        }, 25);
    }
    if (document.body) test();
    else window.addEventListener('DOMContentLoaded', function() {
        test();
    });
    return function() {
        if (result === undefined) throw new Error('isCssMinMaxSupported not initialized');
        return result;
    };
}();
const canShareFiles = function() {
    return 'share' in navigator && 'canShare' in navigator;
};
function unsetEventHandler(obj, ...handlers) {
    handlers.forEach((handler)=>{
        // (disabled) eslint-disable-next-line no-null/no-null
        obj[handler] = null;
    });
}
function printStorageQuota() {
    navigator.storage.estimate().then((estimate)=>{
        if (estimate.quota === undefined || estimate.usage === undefined) {
            console.log('no quota info');
            return;
        }
        console.log(`using ${(estimate.usage / estimate.quota * 100).toFixed(2)}% of total quota`);
        console.log('usage (GB)', (estimate.usage / 1024 / 1024 / 1024).toFixed(2));
        console.log('quota (GB)', (estimate.quota / 1024 / 1024 / 1024).toFixed(2));
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fDHUR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Listens to key events in window. Makes combos easier - e.g. ctrl + z
 *
 * keyStr - see in implementation - my representation of a key. e.g. 'r' can be 'r' and 'R'
 * comboStr - string joins currently pressed keyStr with a +
 *              e.g. 'ctrl+z'
 *
 */ parcelHelpers.export(exports, "KeyListener", ()=>KeyListener);
/**
 * Test, are the same keys pressed. Order does not matter.
 */ parcelHelpers.export(exports, "sameKeys", ()=>sameKeys);
const globalKey = (()=>{
    // keyStr - our key naming system
    // key - KeyboardEvent.key
    // code - KeyboardEvent.code
    const keyStrToKeyObj = {
        // keyStr not to contain a '+', because that's used for the comboStr
        space: [
            ' ',
            'Spacebar'
        ],
        alt: [
            'Alt',
            'AltGraph'
        ],
        shift: 'Shift',
        ctrl: 'Control',
        cmd: [
            'Meta',
            'MetaLeft',
            'MetaRight'
        ],
        enter: 'Enter',
        esc: 'Escape',
        backspace: 'Backspace',
        delete: 'Delete',
        sqbr_open: '[',
        sqbr_close: ']',
        a: [
            'a',
            'A'
        ],
        b: [
            'b',
            'B'
        ],
        c: [
            'c',
            'C'
        ],
        e: [
            'e',
            'E'
        ],
        f: [
            'f',
            'F'
        ],
        g: [
            'g',
            'G'
        ],
        l: [
            'l',
            'L'
        ],
        r: [
            'r',
            'R'
        ],
        s: [
            's',
            'S'
        ],
        t: [
            't',
            'T'
        ],
        u: [
            'u',
            'U'
        ],
        x: [
            'x',
            'X'
        ],
        y: [
            'y',
            'Y'
        ],
        z: [
            'z',
            'Z'
        ],
        plus: '+',
        minus: '-',
        left: 'ArrowLeft',
        right: 'ArrowRight',
        up: 'ArrowUp',
        down: 'ArrowDown',
        home: 'Home',
        end: 'End'
    };
    // ['space', 'alt', ... ]
    const keyStrArr = Object.keys(keyStrToKeyObj);
    // { space: false, ... }
    const isDownObj = Object.entries(keyStrToKeyObj).reduce((acc, [key])=>{
        acc[key] = false;
        return acc;
    }, {});
    // event.key to keyStr
    // { ArrowLeft: 'left', ... }
    const keyToKeyStrObj = Object.entries(keyStrToKeyObj).reduce((acc, [key, code])=>{
        if (typeof code === 'string') acc[code] = key;
        else code.forEach((item)=>{
            acc[item] = key;
        });
        return acc;
    }, {});
    let comboArr = [];
    // a physical key's "key" can change as other keys get pressed. to keep track, need to also track the code
    // { KeyE: 'e', KeyF: undefined } - undefined - not down, string - the associated keyStr
    let codeIsDownObj = {};
    const listenerArr = [];
    /**
     * Windows bug in all browsers: Pressing the Windows key leads to keyboard events not firing.
     * It breaks key state tracking.
     * Workaround: If after a timeout, only the meta key is pressed, fire a keyup for the meta key.
     */ let metaClearTimeout;
    const setupMetaClear = (keyStr, code)=>{
        metaClearTimeout = setTimeout(()=>{
            if (comboArr.length !== 1 || comboArr[0] === 'cmd') return;
            const oldComboStr = comboArr.join('+');
            isDownObj[keyStr] = false;
            codeIsDownObj[code] = undefined;
            // remove from combo
            for(let i = 0; i < comboArr.length; i++)if (comboArr[i] == keyStr) {
                comboArr.splice(i, 1);
                i--;
            }
            emitUp(keyStr, {
                preventDefault: function() {},
                stopPropagation: function() {}
            }, oldComboStr);
            metaClearTimeout = undefined;
        }, 1000);
    };
    const emitDown = function(a, b, c, d) {
        listenerArr.forEach((item)=>{
            if (!item[0]) return;
            item[0](a, b, c, d);
        });
    };
    const emitUp = function(a, b, c) {
        listenerArr.forEach((item)=>{
            if (!item[1]) return;
            item[1](a, b, c);
        });
    };
    const emitBlur = function() {
        listenerArr.forEach((item)=>{
            if (!item[2]) return;
            item[2]();
        });
    };
    function keyDown(e) {
        const key = e.key;
        const code = e.code;
        if (key in keyToKeyStrObj) {
            const keyStr = keyToKeyStrObj[key];
            if (isDownObj[keyStr]) {
                emitDown(keyStr, e, comboArr.join('+'), true);
                return;
            } else {
                if (keyStr === 'cmd') setupMetaClear(keyStr, code);
                else clearTimeout(metaClearTimeout);
                if (keyStr === 'esc') // Workaround for a macOS behavior
                // When in fullscreen, pressing escape exits the fullscreen mode.
                // When that happens, no keyup for escape is fired.
                setTimeout(()=>blur());
            }
            isDownObj[keyStr] = true;
            codeIsDownObj[code] = keyStr;
            //add to combo
            comboArr.push(keyStr);
            emitDown(keyStr, e, comboArr.join('+'));
        }
    }
    function keyUp(e) {
        const code = e.code;
        const oldComboStr = comboArr.join('+');
        // because of a macOS bug: when meta key is down, keyup of other keys does not fire.
        // https://stackoverflow.com/questions/25438608/javascript-keyup-isnt-called-when-command-and-another-is-pressed
        if ([
            'Meta',
            'MetaLeft',
            'MetaRight',
            'OSLeft',
            'OSRight'
        ].includes(code)) {
            blur();
            return;
        } else if (isDownObj['cmd']) {
            // Workaround for Windows bug. Windows doesn't fire keyup for Meta key when pressing Windows Key + Space,
            // neither does it fire blur
            blur();
            return;
        }
        const keyStr = codeIsDownObj[code];
        if (keyStr !== undefined) {
            isDownObj[keyStr] = false;
            codeIsDownObj[code] = undefined;
            // remove from combo
            for(let i = 0; i < comboArr.length; i++)if (comboArr[i] == keyStr) {
                comboArr.splice(i, 1);
                i--;
            }
            emitUp(keyStr, e, oldComboStr);
        }
    }
    function blur() {
        const oldComboStr = comboArr.join('+');
        comboArr = [];
        codeIsDownObj = {};
        const eventArr = [];
        keyStrArr.forEach((keyStr)=>{
            if (isDownObj[keyStr]) {
                isDownObj[keyStr] = false;
                eventArr.push(keyStr);
            }
        });
        for(let i = 0; i < eventArr.length; i++)emitUp(eventArr[i], {
            preventDefault: function() {},
            stopPropagation: function() {}
        }, oldComboStr);
        emitBlur();
    }
    return {
        add: (keyListenerRef)=>{
            if (listenerArr.includes(keyListenerRef)) return;
            const first = listenerArr.length === 0;
            listenerArr.push(keyListenerRef);
            if (first) {
                document.addEventListener('keydown', keyDown);
                document.addEventListener('keyup', keyUp);
                window.addEventListener('blur', blur);
            }
        },
        remove: (keyListenerRef)=>{
            if (!listenerArr.includes(keyListenerRef)) return;
            const last = listenerArr.length === 1;
            for(let i = 0; i < listenerArr.length; i++)if (listenerArr[i] === keyListenerRef) {
                listenerArr.splice(i, 1);
                break;
            }
            if (last) {
                document.removeEventListener('keydown', keyDown);
                document.removeEventListener('keyup', keyUp);
                window.removeEventListener('blur', blur);
            }
        },
        getIsDown: ()=>isDownObj,
        getCombo: ()=>comboArr,
        blur
    };
})();
class KeyListener {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.onDown = p.onDown;
        this.onUp = p.onUp;
        this.onBlur = p.onBlur;
        this.ref = [
            this.onDown,
            this.onUp,
            this.onBlur
        ];
        globalKey.add(this.ref);
    }
    isPressed(keyStr) {
        if (!(keyStr in globalKey.getIsDown())) throw 'key "' + keyStr + '" not found';
        return globalKey.getIsDown()[keyStr];
    }
    getComboStr() {
        return globalKey.getCombo().join('+');
    }
    comboOnlyContains(keyStrArr) {
        for(let i = 0; i < globalKey.getCombo().length; i++){
            if (!keyStrArr.includes(globalKey.getCombo()[i])) return false;
        }
        return true;
    }
    destroy() {
        globalKey.remove(this.ref);
        globalKey.blur();
    }
}
function sameKeys(comboAStr, comboBStr) {
    return comboAStr.split('+').sort().join('+') === comboBStr.split('+').sort().join('+');
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kDObC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * PointerListener - for pointer events, wheel events. uses fallbacks. ideally consistent behavior across browsers.
 * Has some workarounds for browser specific bugs. As browsers evolve this constructor should get smaller.
 */ parcelHelpers.export(exports, "PointerListener", ()=>PointerListener);
var _browser = require("../base/browser");
var _wheelCleaner = require("./wheel-cleaner");
var _pressureNormalizer = require("./pressure-normalizer");
// keeping track of pointers for movement fallback
const pointerArr = [];
function addPointer(event) {
    const pointerObj = {
        pointerId: event.pointerId,
        lastPageX: null,
        lastPageY: null
    };
    pointerArr.push(pointerObj);
    if (pointerArr.length > 15) pointerArr.shift();
    return pointerObj;
}
function getPointer(event) {
    for(let i = pointerArr.length - 1; i >= 0; i--){
        if (event.pointerId === pointerArr[i].pointerId) return pointerArr[i];
    }
    return null;
}
function getButtonStr(buttons) {
    switch(buttons){
        case 1:
            return 'left';
        case 2:
            return 'right';
        case 4:
            return 'middle';
        default:
            return undefined;
    }
}
const pressureNormalizer = new (0, _pressureNormalizer.PressureNormalizer)();
const timeStampOffset = (0, _browser.EVENT_USES_HIGH_RES_TIMESTAMP)() ? 0 : -performance.timing.navigationStart;
const pointerDownEvt = (0, _browser.HAS_POINTER_EVENTS) ? 'pointerdown' : 'mousedown';
const pointerMoveEvt = (0, _browser.HAS_POINTER_EVENTS) ? 'pointermove' : 'mousemove';
const pointerUpEvt = (0, _browser.HAS_POINTER_EVENTS) ? 'pointerup' : 'mouseup';
const pointerCancelEvt = (0, _browser.HAS_POINTER_EVENTS) ? 'pointercancel' : 'mousecancel';
const pointerLeaveEvt = (0, _browser.HAS_POINTER_EVENTS) ? 'pointerleave' : 'mouseleave';
const pointerEnterEvt = (0, _browser.HAS_POINTER_EVENTS) ? 'pointerenter' : 'mouseenter';
/**
 * More trustworthy pointer attributes. that behave the same across browsers.
 * returns a new object. Also attaches itself to the orig event. -> event.corrected
 */ function correctPointerEvent(event) {
    if ('corrected' in event) return event.corrected;
    function determineButtons() {
        if (event.buttons !== undefined) return event.buttons;
        /*
                button -> buttons
        none:	undefined -> 0
        left:	0 -> 1
        middle:	1 -> 4
        right:	2 -> 2
        fourth:	3 -> 8
        fifth:	4 -> 16
         */ if (event.button !== undefined) // old safari on mac has no buttons. remove eventually.
        return [
            1,
            4,
            2,
            8,
            16
        ][event.button];
        return 0;
    }
    const correctedObj = {
        pointerId: event.pointerId,
        pointerType: event.pointerType,
        pageX: event.pageX,
        pageY: event.pageY,
        clientX: event.clientX,
        clientY: event.clientY,
        movementX: event.movementX,
        movementY: event.movementY,
        timeStamp: event.timeStamp + timeStampOffset,
        pressure: pressureNormalizer.normalize(event.pressure, event.type, event.pointerType),
        buttons: determineButtons(),
        button: event.button,
        coalescedArr: [],
        eventPreventDefault: ()=>event.preventDefault(),
        eventStopPropagation: ()=>event.stopPropagation()
    };
    event.corrected = correctedObj;
    let customPressure = null;
    if ('pointerId' in event) {
        if ('pressure' in event && event.buttons !== 0) {
            if (event.pointerType === 'touch' && event.pressure === 0) {
                correctedObj.pressure = 1;
                customPressure = 1;
            }
            // Spec: If there's no pressure support, pressure is 0.5.
            // https://w3c.github.io/pointerevents/#dom-pointerevent-pressure
            // & in older Safari (<=16) it seems to be "mouse" and 0.
            if (event.pointerType === 'mouse' && (event.pressure === 0.5 || event.pressure === 0)) {
                correctedObj.pressure = 1;
                customPressure = 1;
            }
        }
    } else {
        correctedObj.pointerId = 0;
        correctedObj.pointerType = 'mouse';
        correctedObj.pressure = event.buttons !== 0 ? 1 : 0;
        customPressure = correctedObj.pressure;
    }
    if ((0, _browser.IS_FIREFOX) && event.pointerType != 'mouse' && event.type === 'pointermove' && event.buttons === 0) // once again firefox
    correctedObj.buttons = 1; // todo wrong if no buttons actually pressed
    let coalescedEventArr = [];
    if ('getCoalescedEvents' in event) coalescedEventArr = event.getCoalescedEvents();
    // chrome somehow movementX not same scale as pageX. todo: only chrome?
    // so make my own
    const pointerObj = getPointer(correctedObj) || addPointer(correctedObj);
    const totalLastX = pointerObj.lastPageX;
    const totalLastY = pointerObj.lastPageY;
    for(let i = 0; i < coalescedEventArr.length; i++){
        const eventItem = coalescedEventArr[i];
        correctedObj.coalescedArr.push({
            pageX: eventItem.pageX,
            pageY: eventItem.pageY,
            clientX: eventItem.clientX,
            clientY: eventItem.clientY,
            movementX: pointerObj.lastPageX === null ? 0 : eventItem.pageX - pointerObj.lastPageX,
            movementY: pointerObj.lastPageY === null ? 0 : eventItem.pageY - pointerObj.lastPageY,
            timeStamp: eventItem.timeStamp === 0 ? correctedObj.timeStamp : eventItem.timeStamp + timeStampOffset,
            pressure: customPressure === null ? pressureNormalizer.normalize(eventItem.pressure) : customPressure
        });
        pointerObj.lastPageX = eventItem.pageX;
        pointerObj.lastPageY = eventItem.pageY;
    }
    pointerObj.lastPageX = correctedObj.pageX;
    pointerObj.lastPageY = correctedObj.pageY;
    correctedObj.movementX = totalLastX === null ? 0 : pointerObj.lastPageX - totalLastX;
    correctedObj.movementY = totalLastY === null ? 0 : pointerObj.lastPageY - totalLastY;
    return correctedObj;
}
const OPTIONS_PASSIVE = {
    passive: false
};
class PointerListener {
    getDragObj(pointerId) {
        for(let i = 0; i < this.dragObjArr.length; i++){
            if (pointerId === this.dragObjArr[i].pointerId) return this.dragObjArr[i];
        }
        return null;
    }
    removeDragObj(pointerId) {
        let removedDragObj = null;
        for(let i = 0; i < this.dragPointerIdArr.length; i++)if (this.dragPointerIdArr[i] === pointerId) {
            removedDragObj = this.dragObjArr[i];
            this.dragObjArr.splice(i, 1);
            this.dragPointerIdArr.splice(i, 1);
            i--;
        }
        return removedDragObj;
    }
    /**
     * Creates a value for onPointer, from a pointer event handler.
     */ createPointerOutEvent(typeStr, correctedEvent, custom) {
        const bounds = this.targetElement.getBoundingClientRect();
        const result = {
            type: typeStr,
            pointerId: correctedEvent.pointerId,
            pointerType: correctedEvent.pointerType,
            pageX: correctedEvent.pageX,
            pageY: correctedEvent.pageY,
            clientX: correctedEvent.clientX,
            clientY: correctedEvent.clientY,
            relX: correctedEvent.clientX - bounds.left + this.targetElement.scrollLeft,
            relY: correctedEvent.clientY - bounds.top + this.targetElement.scrollTop,
            dX: correctedEvent.movementX,
            dY: correctedEvent.movementY,
            time: correctedEvent.timeStamp,
            eventPreventDefault: correctedEvent.eventPreventDefault,
            eventStopPropagation: correctedEvent.eventStopPropagation,
            ...custom
        };
        if (typeStr === 'pointermove') {
            result.coalescedArr = [];
            if (correctedEvent.coalescedArr.length > 1) {
                let coalescedItem;
                for(let i = 0; i < correctedEvent.coalescedArr.length; i++){
                    coalescedItem = correctedEvent.coalescedArr[i];
                    result.coalescedArr.push({
                        pageX: coalescedItem.pageX,
                        pageY: coalescedItem.pageY,
                        clientX: coalescedItem.clientX,
                        clientY: coalescedItem.clientY,
                        relX: coalescedItem.clientX - bounds.left + this.targetElement.scrollLeft,
                        relY: coalescedItem.clientY - bounds.top + this.targetElement.scrollTop,
                        dX: coalescedItem.movementX,
                        dY: coalescedItem.movementY,
                        time: coalescedItem.timeStamp
                    });
                }
            }
        }
        return result;
    }
    setupDocumentListeners() {
        this.windowOnPointerMove && document.addEventListener(pointerMoveEvt, this.windowOnPointerMove, OPTIONS_PASSIVE);
        this.windowOnPointerUp && document.addEventListener(pointerUpEvt, this.windowOnPointerUp, OPTIONS_PASSIVE);
        this.windowOnPointerLeave && document.addEventListener(pointerCancelEvt, this.windowOnPointerLeave, OPTIONS_PASSIVE);
        this.windowOnPointerLeave && document.addEventListener(pointerLeaveEvt, this.windowOnPointerLeave, OPTIONS_PASSIVE);
    }
    destroyDocumentListeners() {
        this.windowOnPointerMove && document.removeEventListener(pointerMoveEvt, this.windowOnPointerMove);
        this.windowOnPointerUp && document.removeEventListener(pointerUpEvt, this.windowOnPointerUp);
        this.windowOnPointerLeave && document.removeEventListener(pointerCancelEvt, this.windowOnPointerLeave);
        this.windowOnPointerLeave && document.removeEventListener(pointerLeaveEvt, this.windowOnPointerLeave);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isDestroyed = false;
        this.isOverCounter = 0;
        // pointers that are pressing a button
        this.dragObjArr = [];
        this.dragPointerIdArr = [];
        // chrome input glitch workaround
        this.lastPointerType = null;
        this.didSkip = false;
        this.targetElement = p.target;
        this.onPointerCallback = p.onPointer;
        this.onWheelCallback = p.onWheel;
        this.onEnterLeaveCallback = p.onEnterLeave;
        this.maxPointers = Math.max(1, p.maxPointers ?? 1);
        const finalizeWheelEvent = (e)=>{
            if (this.isDestroyed || !this.onWheelCallback) return;
            const bounds = this.targetElement.getBoundingClientRect();
            const whlEvent = {
                ...e instanceof WheelEvent ? {
                    deltaY: e.deltaY / 120,
                    pageX: e.pageX,
                    pageY: e.pageY
                } : e,
                relX: e.clientX - bounds.left + this.targetElement.scrollLeft,
                relY: e.clientY - bounds.top + this.targetElement.scrollTop,
                ...e instanceof WheelEvent ? {
                    event: e
                } : {}
            };
            this.onWheelCallback(whlEvent);
        };
        this.wheelCleaner = p.useDirtyWheel ? undefined : new (0, _wheelCleaner.WheelCleaner)(finalizeWheelEvent);
        if (this.onPointerCallback) {
            this.onPointerMove = (event)=>{
                const correctedEvent = correctPointerEvent(event);
                const tempLastPointerType = this.lastPointerType;
                this.lastPointerType = correctedEvent.pointerType;
                if (this.dragPointerIdArr.includes(correctedEvent.pointerId) || this.dragPointerIdArr.length === this.maxPointers || correctedEvent.pointerType === 'touch') {
                    this.didSkip = false;
                    return;
                }
                // chrome input glitch workaround - throws in a random mouse event with the wrong position when using a stylus
                if (!this.didSkip && correctedEvent.pointerType === 'mouse' && tempLastPointerType === 'pen') {
                    this.didSkip = true;
                    return;
                }
                this.didSkip = false;
                const outEvent = this.createPointerOutEvent('pointermove', correctedEvent);
                this.onPointerCallback?.(outEvent);
            };
            this.onPointerDown = (event, onSkipGlobal)=>{
                //BB.throwOut('pointerdown ' + event.pointerId + ' | ' + dragPointerIdArr.length);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' pointerdown');
                if (this.dragPointerIdArr.includes(correctedEvent.pointerId) || this.dragPointerIdArr.length === this.maxPointers || ![
                    1,
                    2,
                    4
                ].includes(correctedEvent.buttons)) //BB.throwOut('pointerdown ignored');
                return;
                //set up global listeners
                if (this.dragObjArr.length === 0 && !onSkipGlobal) this.setupDocumentListeners();
                const dragObj = {
                    pointerId: correctedEvent.pointerId,
                    pointerType: correctedEvent.pointerType,
                    downPageX: correctedEvent.pageX,
                    downPageY: correctedEvent.pageY,
                    buttons: correctedEvent.buttons,
                    lastPageX: correctedEvent.pageX,
                    lastPageY: correctedEvent.pageY,
                    lastTimeStamp: correctedEvent.timeStamp
                };
                this.dragObjArr.push(dragObj);
                this.dragPointerIdArr.push(correctedEvent.pointerId);
                const outEvent = this.createPointerOutEvent('pointerdown', correctedEvent, {
                    downPageX: correctedEvent.pageX,
                    downPageY: correctedEvent.pageY,
                    button: getButtonStr(correctedEvent.buttons),
                    pressure: correctedEvent.pressure
                });
                this.onPointerCallback?.(outEvent);
            };
            this.windowOnPointerMove = (event)=>{
                //BB.throwOut('pointermove ' + event.pointerId);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' GLOBALpointermove');
                if (!this.dragPointerIdArr.includes(correctedEvent.pointerId)) return;
                const dragObj = this.getDragObj(correctedEvent.pointerId);
                if (!dragObj) // todo need to handle this!
                return;
                //if pointer changes button its pressing -> turn into pointerup
                if (correctedEvent.buttons !== dragObj.buttons) {
                    //pointer up
                    //remove listener
                    if (this.dragObjArr.length === 1) this.destroyDocumentListeners();
                    this.removeDragObj(correctedEvent.pointerId);
                    const outEvent = this.createPointerOutEvent('pointerup', correctedEvent, {
                        downPageX: dragObj.downPageX,
                        downPageY: dragObj.downPageY
                    });
                    this.onPointerCallback?.(outEvent);
                    return;
                }
                // ipad likes to do this
                if (correctedEvent.pointerType === 'pen' && correctedEvent.pageX === dragObj.lastPageX && correctedEvent.pageY === dragObj.lastPageY && correctedEvent.timeStamp === dragObj.lastTimeStamp) //ignore
                return;
                const outEvent = this.createPointerOutEvent('pointermove', correctedEvent, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY,
                    button: getButtonStr(correctedEvent.buttons),
                    pressure: correctedEvent.pressure
                });
                dragObj.lastPageX = correctedEvent.pageX;
                dragObj.lastPageY = correctedEvent.pageY;
                dragObj.lastTimeStamp = correctedEvent.timeStamp;
                this.onPointerCallback?.(outEvent);
            };
            this.windowOnPointerUp = (event)=>{
                //BB.throwOut('pointerup ' + event.pointerId);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' GLOBALpointerup');
                if (!this.dragPointerIdArr.includes(correctedEvent.pointerId)) return;
                //remove listener
                if (this.dragObjArr.length === 1) this.destroyDocumentListeners();
                const dragObj = this.removeDragObj(correctedEvent.pointerId);
                if (!dragObj) // todo need to handle this!
                return;
                const outEvent = this.createPointerOutEvent('pointerup', correctedEvent, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY
                });
                this.onPointerCallback?.(outEvent);
            };
            this.windowOnPointerLeave = (event)=>{
                //BB.throwOut('pointerleave ' + event.pointerId);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' onGlobalPointerLeave', event);
                if (!this.dragPointerIdArr.includes(correctedEvent.pointerId)) //} || event.target !== document) {
                return;
                //remove listener
                if (this.dragObjArr.length === 1) this.destroyDocumentListeners();
                const dragObj = this.removeDragObj(correctedEvent.pointerId);
                if (!dragObj) // todo need to handle this!
                return;
                const outEvent = this.createPointerOutEvent('pointerup', correctedEvent, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY
                });
                this.onPointerCallback?.(outEvent);
            };
            this.targetElement.addEventListener(pointerMoveEvt, this.onPointerMove, OPTIONS_PASSIVE);
            this.targetElement.addEventListener(pointerDownEvt, this.onPointerDown, OPTIONS_PASSIVE);
            if (!(0, _browser.HAS_POINTER_EVENTS)) {
                const touchToFakePointer = (touch, touchEvent, isDown)=>{
                    return {
                        pointerId: touch.identifier,
                        pointerType: 'touch',
                        pageX: touch.pageX,
                        pageY: touch.pageY,
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: isDown ? 0 : undefined,
                        buttons: isDown ? 1 : 0,
                        timeStamp: touchEvent.timeStamp,
                        target: touchEvent.target,
                        pressure: isDown ? 1 : 0,
                        preventDefault: ()=>touchEvent.preventDefault(),
                        stopPropagation: ()=>touchEvent.stopPropagation()
                    };
                };
                const handleTouch = (e, type)=>{
                    for(let i = 0; i < e.changedTouches.length; i++){
                        const touch = e.changedTouches[i];
                        const fakePointer = touchToFakePointer(touch, e, [
                            'start',
                            'move'
                        ].includes(type));
                        if (type === 'start') this.onPointerDown(fakePointer, false);
                        else if (type === 'move') this.windowOnPointerMove(fakePointer);
                        else if (type === 'end') this.windowOnPointerUp(fakePointer);
                        else this.windowOnPointerLeave(fakePointer);
                    }
                };
                this.onTouchStart = (e)=>{
                    e.preventDefault();
                    handleTouch(e, 'start');
                };
                this.onTouchMove = (e)=>{
                    handleTouch(e, 'move');
                };
                this.onTouchEnd = (e)=>{
                    handleTouch(e, 'end');
                };
                this.onTouchCancel = (e)=>{
                    handleTouch(e, 'cancel');
                };
                this.targetElement.addEventListener('touchstart', this.onTouchStart, OPTIONS_PASSIVE);
                this.targetElement.addEventListener('touchmove', this.onTouchMove, OPTIONS_PASSIVE);
                this.targetElement.addEventListener('touchend', this.onTouchEnd, OPTIONS_PASSIVE);
                this.targetElement.addEventListener('touchcancel', this.onTouchCancel, OPTIONS_PASSIVE);
            }
        }
        if (this.onWheelCallback) {
            this.onWheel = (e)=>{
                if (this.wheelCleaner) this.wheelCleaner.process(e);
                else finalizeWheelEvent(e);
            };
            this.targetElement.addEventListener('wheel', this.onWheel, {
                passive: !!p.isWheelPassive
            });
        }
        if (this.onEnterLeaveCallback) {
            this.onPointerEnter = ()=>{
                this.isOverCounter++;
                this.onEnterLeaveCallback?.(true);
            };
            this.onPointerLeave = ()=>{
                this.isOverCounter--;
                this.onEnterLeaveCallback?.(false);
            };
            this.targetElement.addEventListener(pointerEnterEvt, this.onPointerEnter, OPTIONS_PASSIVE);
            this.targetElement.addEventListener(pointerLeaveEvt, this.onPointerLeave, OPTIONS_PASSIVE);
        }
        if (p.fixScribble) {
            //ipad scribble workaround https://developer.apple.com/forums/thread/662874
            this.onTouchMoveScribbleFix = (e)=>e.preventDefault();
            this.targetElement.addEventListener('touchmove', this.onTouchMoveScribbleFix, OPTIONS_PASSIVE);
        }
    }
    destroy() {
        if (this.isDestroyed) return;
        this.isDestroyed = true;
        this.onPointerEnter && this.targetElement.removeEventListener(pointerEnterEvt, this.onPointerEnter);
        this.onPointerLeave && this.targetElement.removeEventListener(pointerLeaveEvt, this.onPointerLeave);
        this.onPointerMove && this.targetElement.removeEventListener(pointerMoveEvt, this.onPointerMove);
        this.onPointerDown && this.targetElement.removeEventListener(pointerDownEvt, this.onPointerDown);
        this.onWheel && this.targetElement.removeEventListener('wheel', this.onWheel);
        this.destroyDocumentListeners();
        this.onTouchMoveScribbleFix && document.removeEventListener('touchmove', this.onTouchMoveScribbleFix);
        this.onTouchStart && this.targetElement.removeEventListener('touchstart', this.onTouchStart);
        this.onTouchMove && this.targetElement.removeEventListener('touchmove', this.onTouchMove);
        this.onTouchEnd && this.targetElement.removeEventListener('touchend', this.onTouchEnd);
        this.onTouchCancel && this.targetElement.removeEventListener('touchcancel', this.onTouchCancel);
    }
}

},{"../base/browser":"4hCPW","./wheel-cleaner":"8mZW2","./pressure-normalizer":"4tEht","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8mZW2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Filters wheel events. removes swipe scrolling and pinch scrolling that trackpads do. (as best as it can)
 * Normalizes regular scrolls.
 *
 * Why:
 * - trackpad scrolling is different from old school mouse scrolling
 * - but there is no way to learn from the browser if it's trackpad scrolling
 * - browsers don't even give access to the raw swiping or pinching movement, but some abstraction on top, making the scrolling
 *      continue an arbitrary amount, at an arbitrary scale
 * - each browser does this differently. So you can't offer a consistent/controlled experience
 *
 * - also trackpads are painful to draw with. So supporting a trackpad-based workflow makes not much sense.
 */ parcelHelpers.export(exports, "WheelCleaner", ()=>WheelCleaner);
const SEQUENCE_TIMEOUT_MS = 200;
class WheelCleaner {
    emit(delta) {
        if (this.position === null || this.sequenceUnit === null) return;
        this.callback({
            deltaY: Math.round(delta / this.sequenceUnit),
            pageX: this.position.pageX,
            pageY: this.position.pageY,
            clientX: this.position.clientX,
            clientY: this.position.clientY
        });
    }
    endSequence() {
        if (this.toEmitDelta !== null) {
            this.emit(this.toEmitDelta);
            this.toEmitDelta = null;
        }
        if (this.sequenceUnit !== null && !this.knownUnitArr.includes(this.sequenceUnit)) this.knownUnitArr.push(this.sequenceUnit);
        this.sequenceLength = 0;
        this.sequenceUnit = null;
    }
    // ----------------------------------- public -----------------------------------
    constructor(callback){
        this.callback = callback;
        this.knownUnitArr = [
            100
        ];
        this.sequenceLength = 0;
        this.sequenceUnit = null;
        this.toEmitDelta = null;
        this.position = null;
    }
    process(event) {
        this.position = {
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY
        };
        if (this.endSequenceTimeout) clearTimeout(this.endSequenceTimeout);
        this.endSequenceTimeout = setTimeout(()=>this.endSequence(), SEQUENCE_TIMEOUT_MS);
        //prep delta
        let delta = event.deltaY;
        if ('deltaMode' in event && event.deltaMode === 1) delta *= 100 / 3;
        const absDelta = Math.abs(delta);
        //sequence begins
        if (this.sequenceLength === 0) {
            this.sequenceLength++;
            if (absDelta < 50) //dirty - probably a swipe scroll or pinch scroll on trackpad
            return;
            this.sequenceUnit = absDelta;
            if (this.knownUnitArr.includes(this.sequenceUnit)) //we know this unit - emit right away
            this.emit(delta);
            else //unknown unit - wait until next event or sequence end, to have more certainty that it's clean
            this.toEmitDelta = delta;
            return;
        }
        if (this.sequenceUnit === null) {
            //previously determined dirty sequence
            this.toEmitDelta = null;
            return;
        }
        //sequence continues
        if (absDelta === 0) //ignore zero scroll
        return;
        if (absDelta === this.sequenceUnit || absDelta / this.sequenceUnit % 1 < 0.0001 // a multiple
        ) ;
        else if (this.sequenceUnit / absDelta % 1 < 0.0001) //unit was actually a multiple - update it
        this.sequenceUnit = absDelta;
        else if (absDelta !== this.sequenceUnit) {
            //not clean - delta is varying - probably a swipe scroll or pinch scroll on trackpad
            this.sequenceUnit = null;
            this.toEmitDelta = null;
            return;
        }
        if (this.toEmitDelta !== null) {
            this.emit(this.toEmitDelta);
            this.toEmitDelta = null;
        }
        this.emit(delta);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4tEht":[function(require,module,exports,__globalThis) {
/**
 * Apple Pencil on iPad in Safari has two problems:
 * - You need to press the stylus very strong to reach 1.0 pressure, to the point where the screen starts discoloring
 * - Always fires the same pressure value on pointerdown
 *
 * This normalizer tries to fix that with a workaround.
 *
 * pressure range [0, 1]
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PressureNormalizer", ()=>PressureNormalizer);
class PressureNormalizer {
    // ----------------------------------- public -----------------------------------
    normalize(pressure, eventType, pointerType) {
        if (pointerType === 'pen') {
            if (!this.detectionComplete) {
                if (eventType === 'pointerdown') {
                    if (this.initialPointerDownPressure === -1) this.initialPointerDownPressure = pressure;
                    else if (this.initialPointerDownPressure === pressure) {
                        this.pointerDownPressureRepeatCount++;
                        if (this.pointerDownPressureRepeatCount > 1 && this.pointerMoveHasDifferentPressure) {
                            this.detectionComplete = true;
                            this.isApplePencil = true;
                        }
                    } else {
                        this.detectionComplete = true;
                        this.isApplePencil = false;
                    }
                } else if (eventType === 'pointermove') {
                    if (this.initialPointerDownPressure !== pressure) this.pointerMoveHasDifferentPressure = true;
                }
            }
            if (this.detectionComplete && this.isApplePencil) {
                if (this.initialPointerDownPressure === pressure) return 0;
                pressure = Math.min(2, pressure * 2);
            }
            return pressure;
        } else return pressure;
    }
    constructor(){
        this.detectionComplete = false;
        this.isApplePencil = false;
        // detection
        this.initialPointerDownPressure = -1;
        this.pointerDownPressureRepeatCount = 0;
        this.pointerMoveHasDifferentPressure = false;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"86XNv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copyCanvas", ()=>copyCanvas);
parcelHelpers.export(exports, "ctx", ()=>ctx);
parcelHelpers.export(exports, "loadToCanvas", ()=>loadToCanvas);
/**
 * Determine if we should disable imageSmoothing for transformation.
 * ImageSmoothing can make images blurry even when they're in the original scale and aligned with the pixelgrid.
 */ parcelHelpers.export(exports, "testShouldPixelate", ()=>testShouldPixelate);
/**
 * @param destCtx - the canvas that will be drawn on
 * @param transformImage - image that will be drawn on canvas
 * @param transform - {x, y, width, height, angle} - x and y are center of transformImage
 * @param bounds object - optional {x, y, width, height} - crop of transformImage in transformImage image space
 * @param pixelated
 */ parcelHelpers.export(exports, "drawTransformedImageWithBounds", ()=>drawTransformedImageWithBounds);
/**
 * all transformations are optional
 * center is the point around which will be scaled and rotated
 *
 * @param baseCanvas canvas - the canvas that will be drawn on
 * @param transformImage image|canvas - image that will be drawn on canvas
 * @param transformObj {center: {x, y}, scale: {x, y}, translate: {x, y}, angleDegree}
 */ parcelHelpers.export(exports, "drawTransformedImageOnCanvas", ()=>drawTransformedImageOnCanvas);
parcelHelpers.export(exports, "createCheckerCanvas", ()=>createCheckerCanvas);
parcelHelpers.export(exports, "createCheckerDataUrl", ()=>createCheckerDataUrl);
/**
 * smooth resize image
 * @param canvas canvas - will be resized (modified)
 * @param w
 * @param h
 * @param tmp1 canvas - optional, provide to save resources
 * @param tmp2 canvas - optional, provide to save resources
 */ parcelHelpers.export(exports, "resizeCanvas", ()=>resizeCanvas);
/**
 * puts naive greyscale version of image into alpha channel.
 * only writes a, doesn't write rgb
 * @param canvas
 */ parcelHelpers.export(exports, "convertToAlphaChannelCanvas", ()=>convertToAlphaChannelCanvas);
/**
 * Sometimes garbage collection is too slow, and canvases use up too much memory,
 * or in the worst case there is a hard to fix memory leak.
 * This function manually makes the canvas use as little memory as possible.
 */ parcelHelpers.export(exports, "freeCanvas", ()=>freeCanvas);
/**
 * Determine bounding box that describes all pixels which are not fully transparent.
 * Returns undefined if empty.
 *
 * @param context
 * @param integerBounds optional - restricts the search to this area. bounds have to be integers
 */ parcelHelpers.export(exports, "canvasBounds", ()=>canvasBounds);
parcelHelpers.export(exports, "htmlCanvasToBlobAsync", ()=>htmlCanvasToBlobAsync);
parcelHelpers.export(exports, "canvasToBlob", ()=>canvasToBlob);
parcelHelpers.export(exports, "drawSelectionMask", ()=>drawSelectionMask);
var _createCanvas = require("./create-canvas");
var _base = require("./base");
var _getSelectionPath2D = require("../multi-polygon/get-selection-path-2d");
function copyCanvas(canvas) {
    const resultCanvas = (0, _createCanvas.createCanvas)(canvas.width, canvas.height);
    const ctx = resultCanvas.getContext('2d');
    if (!ctx) throw new Error('2d context not supported or canvas already initialized');
    ctx.drawImage(canvas, 0, 0);
    return resultCanvas;
}
function ctx(canvas, options) {
    const ctx = canvas.getContext('2d', options);
    if (!ctx) throw new Error("couldn't get 2d context");
    return ctx;
}
async function loadToCanvas(path) {
    const im = await (0, _base.asyncLoadImage)(path);
    const canvas = (0, _createCanvas.createCanvas)(im.width, im.height);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(im, 0, 0);
    return canvas;
}
function testShouldPixelate(transform, scaleX, scaleY) {
    if (![
        1,
        -1
    ].includes(scaleX) || ![
        1,
        -1
    ].includes(scaleY) || transform.width % 1 !== 0 || transform.height % 1 !== 0 || Math.abs(transform.angleDeg) % 90 !== 0) return false;
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    const width = whSwapped ? transform.height : transform.width;
    const height = whSwapped ? transform.width : transform.height;
    return (Math.abs(width) % 2 === 0 && transform.x % 1 === 0 || Math.abs(width) % 2 === 1 && transform.x % 1 === 0.5) && (Math.abs(height) % 2 === 0 && transform.y % 1 === 0 || Math.abs(height) % 2 === 1 && transform.y % 1 === 0.5);
}
function drawTransformedImageWithBounds(destCtx, transformImage, transform, bounds, pixelated) {
    if (!bounds) bounds = {
        x: 0,
        y: 0,
        width: transformImage.width,
        height: transformImage.height
    };
    destCtx.save();
    if (pixelated) destCtx.imageSmoothingEnabled = false;
    else {
        destCtx.imageSmoothingEnabled = true;
        destCtx.imageSmoothingQuality = 'high';
    }
    destCtx.translate(transform.x, transform.y);
    destCtx.rotate(transform.angleDeg / 180 * Math.PI);
    destCtx.scale(transform.width > 0 ? 1 : -1, transform.height > 0 ? 1 : -1);
    destCtx.drawImage(transformImage, bounds.x, bounds.y, bounds.width, bounds.height, -Math.abs(transform.width) / 2, -Math.abs(transform.height) / 2, Math.abs(transform.width), Math.abs(transform.height));
    destCtx.restore();
}
function drawTransformedImageOnCanvas(baseCanvas, transformImage, transformObj) {
    transformObj = (0, _base.copyObj)(transformObj);
    if (!transformObj.center) transformObj.center = {
        x: transformImage.width / 2,
        y: transformImage.height / 2
    };
    if (!transformObj.scale) transformObj.scale = {
        x: 1,
        y: 1
    };
    if (!transformObj.angleDegree) transformObj.angleDegree = 0;
    if (!transformObj.translate) transformObj.translate = {
        x: 0,
        y: 0
    };
    const ctx = baseCanvas.getContext('2d');
    if (!ctx) throw new Error('2d context not supported or canvas already initialized');
    ctx.save();
    if (Math.abs(transformObj.scale.x - 1) > 0.000001 || Math.abs(transformObj.scale.y - 1) > 0.000001 || Math.abs(transformObj.angleDegree % 90) > 0.000001) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
    } else ctx.imageSmoothingEnabled = false;
    ctx.translate(transformObj.translate.x, transformObj.translate.y);
    ctx.translate(transformObj.center.x, transformObj.center.y);
    ctx.rotate(transformObj.angleDegree / 180 * Math.PI);
    ctx.scale(transformObj.scale.x, transformObj.scale.y);
    ctx.translate(-transformObj.center.x, -transformObj.center.y);
    ctx.drawImage(transformImage, 0, 0, transformImage.width, transformImage.height);
    ctx.restore();
}
const createCheckerCanvas = function(size, isDark) {
    const canvas = (0, _createCanvas.createCanvas)();
    let ctx;
    if (size < 1) {
        canvas.width = 1;
        canvas.height = 1;
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('2d context not supported or canvas already initialized');
        ctx.fillStyle = 'rgb(128, 128, 128)';
        ctx.fillRect(0, 0, 1, 1);
    } else {
        canvas.width = size * 2;
        canvas.height = size * 2;
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('2d context not supported or canvas already initialized');
        ctx.fillStyle = isDark ? 'rgb(90, 90, 90)' : 'rgb(255, 255, 255)';
        ctx.fillRect(0, 0, size * 2, size * 2);
        ctx.fillStyle = isDark ? 'rgb(63, 63, 63)' : 'rgb(200, 200, 200)';
        ctx.fillRect(0, 0, size, size);
        ctx.fillRect(size, size, size * 2, size * 2);
    }
    return canvas;
};
const createCheckerDataUrl = function() {
    // previously created dataUrls
    const cache = {};
    return function(size, callback, isDark) {
        const modeStr = isDark ? 'd' : 'l';
        function create(size) {
            size = parseInt('' + size);
            if (cache['' + size + modeStr]) return cache['' + size + modeStr];
            const canvas = createCheckerCanvas(size, isDark);
            const result = canvas.toDataURL('image/png');
            cache['' + size + modeStr] = result;
            return result;
        }
        if (callback) //async
        setTimeout(function() {
            callback(create(size));
        }, 1);
        else //sync
        return create(size);
    };
}();
function resizeCanvas(canvas, w, h, tmp1, tmp2) {
    //determine base 2 exponents of old and new size
    function getBase2Obj(oldW, oldH, newW, newH) {
        const result = {
            oldWidthEx: Math.round(Math.log2(oldW)),
            oldHeightEx: Math.round(Math.log2(oldH)),
            newWidthEx: Math.ceil(Math.log2(newW)),
            newHeightEx: Math.ceil(Math.log2(newH))
        };
        result.oldWidthEx = Math.max(result.oldWidthEx, result.newWidthEx);
        result.oldHeightEx = Math.max(result.oldHeightEx, result.newHeightEx);
        return result;
    }
    if (!w || !h || w === canvas.width && h === canvas.height) return;
    w = Math.max(w, 1);
    h = Math.max(h, 1);
    if (w <= canvas.width && h <= canvas.height) {
        tmp1 = !tmp1 ? (0, _createCanvas.createCanvas)() : tmp1;
        tmp2 = !tmp2 ? (0, _createCanvas.createCanvas)() : tmp2;
        const base2 = getBase2Obj(canvas.width, canvas.height, w, h);
        //initially scale to a base of 2. unless new size is too close to old. e.g. sizing from 900 to 600
        tmp2.width = base2.oldWidthEx > base2.newWidthEx ? Math.pow(2, base2.oldWidthEx) : w;
        tmp2.height = base2.oldHeightEx > base2.newHeightEx ? Math.pow(2, base2.oldHeightEx) : h;
        tmp1.getContext('2d').save();
        tmp2.getContext('2d').save();
        let ew, eh;
        let buffer1 = tmp1, buffer2 = tmp2;
        ew = base2.oldWidthEx;
        eh = base2.oldHeightEx;
        let bufferCtx = buffer2.getContext('2d');
        bufferCtx.imageSmoothingEnabled = true;
        bufferCtx.imageSmoothingQuality = 'high';
        bufferCtx.globalCompositeOperation = 'copy';
        bufferCtx.drawImage(canvas, 0, 0, buffer2.width, buffer2.height);
        let currentWidth = buffer2.width;
        let currentHeight = buffer2.height;
        //stepwise half the size
        for(; ew > base2.newWidthEx || eh > base2.newHeightEx; ew--, eh--){
            bufferCtx = buffer1.getContext('2d');
            bufferCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingQuality = 'high';
            bufferCtx.globalCompositeOperation = 'copy';
            const newWidth = ew > base2.newWidthEx ? currentWidth / 2 : currentWidth;
            const newHeight = eh > base2.newHeightEx ? currentHeight / 2 : currentHeight;
            //buffer also needs to be properly sized, unfortunately
            buffer1.width = newWidth;
            buffer1.height = newHeight;
            bufferCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, newWidth, newHeight);
            currentWidth = newWidth;
            currentHeight = newHeight;
            //swap
            const tmp = buffer1;
            buffer1 = buffer2;
            buffer2 = tmp;
        }
        //when no longer can be halved, bring to target size
        canvas.width = w;
        canvas.height = h;
        const canvasCtx = canvas.getContext('2d');
        canvasCtx.save();
        canvasCtx.imageSmoothingEnabled = true;
        canvasCtx.imageSmoothingQuality = 'high';
        canvasCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, w, h);
        canvasCtx.restore();
        tmp1.getContext('2d').restore();
        tmp2.getContext('2d').restore();
    } else if (w >= canvas.width && h >= canvas.height) {
        tmp1 = !tmp1 ? (0, _createCanvas.createCanvas)() : tmp1;
        tmp1.width = w;
        tmp1.height = h;
        const tmp1Ctx = tmp1.getContext('2d');
        tmp1Ctx.save();
        tmp1Ctx.imageSmoothingEnabled = true;
        tmp1Ctx.imageSmoothingQuality = 'high';
        tmp1Ctx.drawImage(canvas, 0, 0, w, h);
        tmp1Ctx.restore();
        canvas.width = w;
        canvas.height = h;
        canvas.getContext('2d').drawImage(tmp1, 0, 0);
    } else {
        resizeCanvas(canvas, w, canvas.height, tmp1, tmp2);
        resizeCanvas(canvas, w, h, tmp1, tmp2);
    }
}
function convertToAlphaChannelCanvas(canvas) {
    const imdat = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
    for(let i = 0; i < imdat.data.length; i += 4){
        if (imdat.data[i + 3] === 0) continue;
        imdat.data[i + 3] = (imdat.data[i] + imdat.data[i + 1] + imdat.data[i + 2]) / 3 * (imdat.data[i + 3] / 255);
    }
    canvas.getContext('2d').putImageData(imdat, 0, 0);
}
function freeCanvas(canvas) {
    canvas.width = 1;
    canvas.height = 1;
    canvas.remove();
}
function canvasBounds(context, integerBounds) {
    const searchBounds = integerBounds ?? {
        x1: 0,
        y1: 0,
        x2: context.canvas.width - 1,
        y2: context.canvas.height - 1
    };
    const searchWidth = searchBounds.x2 - searchBounds.x1 + 1;
    const searchHeight = searchBounds.y2 - searchBounds.y1 + 1;
    const imdat = context.getImageData(searchBounds.x1, searchBounds.y1, searchWidth, searchHeight);
    if (imdat.data[3] > 0 && imdat.data[imdat.data.length - 1] > 0) return {
        x: searchBounds.x1,
        y: searchBounds.y1,
        width: searchBounds.x2 - searchBounds.x1 + 1,
        height: searchBounds.y2 - searchBounds.y1 + 1
    };
    const tempBounds = {
        x1: undefined,
        y1: undefined,
        x2: undefined,
        y2: undefined
    };
    for(let i = 3; i < imdat.data.length; i += 4)if (imdat.data[i] > 0) {
        const x = (i - 3) / 4 % searchWidth;
        const y = Math.floor((i - 3) / 4 / searchWidth);
        if (tempBounds.x1 === undefined || tempBounds.x1 > x) tempBounds.x1 = x;
        if (tempBounds.y1 === undefined) tempBounds.y1 = y;
        if (tempBounds.x2 === undefined || tempBounds.x2 < x) tempBounds.x2 = x;
        if (tempBounds.y2 === undefined || tempBounds.y2 < y) tempBounds.y2 = y;
    }
    if (tempBounds.x1 === undefined || tempBounds.y1 === undefined || tempBounds.x2 === undefined || tempBounds.y2 === undefined) return undefined;
    return {
        x: tempBounds.x1 + searchBounds.x1,
        y: tempBounds.y1 + searchBounds.y1,
        width: tempBounds.x2 - tempBounds.x1 + 1,
        height: tempBounds.y2 - tempBounds.y1 + 1
    };
}
function htmlCanvasToBlobAsync(canvas, mimeType) {
    return new Promise((resolve, reject)=>{
        canvas.toBlob((blob)=>{
            if (blob) resolve(blob);
            else reject(new Error('Failed to create blob from canvas.'));
        }, mimeType);
    });
}
async function canvasToBlob(canvas, mimeType) {
    if ('toBlob' in HTMLCanvasElement.prototype) return await htmlCanvasToBlobAsync(canvas, mimeType);
    else // assume base64
    return (0, _base.base64ToBlob)(canvas.toDataURL(mimeType));
}
function drawSelectionMask(selection, context) {
    const canvas = context.canvas;
    context.save();
    context.fillRect(0, 0, canvas.width, canvas.height);
    const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(selection);
    context.clip(selectionPath);
    context.fillStyle = 'white';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.restore();
}

},{"./create-canvas":"5vnin","./base":"it3mQ","../multi-polygon/get-selection-path-2d":"hDCCZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5vnin":[function(require,module,exports,__globalThis) {
/*window['canvases'] = [];

window['printCanvases'] = () => {
    let total = 0;

    console.log(window['canvases'].map(item => {
        total += item.width * item.height;
        return {w: item.width, h: item.height};
    }));

    console.log('total: ' + (total * 4 / 1000 / 1000) + 'mb');
};*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCanvas", ()=>createCanvas);
function createCanvas(w, h) {
    const result = document.createElement('canvas');
    if (w && h) {
        result.width = w;
        result.height = h;
    }
    // window['canvases'].push(result);
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hDCCZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSelectionPath2d", ()=>getSelectionPath2d);
parcelHelpers.export(exports, "getSvgPathD", ()=>getSvgPathD);
function getSelectionPath2d(selection) {
    const path = new Path2D();
    selection.forEach((poly)=>{
        poly.forEach((ring)=>{
            ring.forEach((point, index)=>{
                if (index === 0) path.moveTo(...point);
                else path.lineTo(...point);
            });
        });
        path.closePath();
    });
    return path;
}
function getSvgPathD(poly) {
    let result = '';
    poly.forEach((poly)=>{
        poly.forEach((ring)=>{
            result += 'M';
            ring.forEach((point)=>{
                result += point.join(',') + ' ';
            });
        });
    });
    return result.trim();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"exP81":[function(require,module,exports,__globalThis) {
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
// not optimized
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Matrix", ()=>Matrix);
function getIdentity() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
// point  matrix
function multiplyMatrixAndPoint(matrix, point) {
    return [
        point[0] * matrix[0] + point[1] * matrix[4] + point[2] * matrix[8] + point[3] * matrix[12],
        point[0] * matrix[1] + point[1] * matrix[5] + point[2] * matrix[9] + point[3] * matrix[13],
        point[0] * matrix[2] + point[1] * matrix[6] + point[2] * matrix[10] + point[3] * matrix[14],
        point[0] * matrix[3] + point[1] * matrix[7] + point[2] * matrix[11] + point[3] * matrix[15]
    ];
}
//matrixB  matrixA
function multiplyMatrices(matrixA, matrixB) {
    // Slice the second matrix up into rows
    const row0 = [
        matrixB[0],
        matrixB[1],
        matrixB[2],
        matrixB[3]
    ];
    const row1 = [
        matrixB[4],
        matrixB[5],
        matrixB[6],
        matrixB[7]
    ];
    const row2 = [
        matrixB[8],
        matrixB[9],
        matrixB[10],
        matrixB[11]
    ];
    const row3 = [
        matrixB[12],
        matrixB[13],
        matrixB[14],
        matrixB[15]
    ];
    // Multiply each row by matrixA
    const result0 = multiplyMatrixAndPoint(matrixA, row0);
    const result1 = multiplyMatrixAndPoint(matrixA, row1);
    const result2 = multiplyMatrixAndPoint(matrixA, row2);
    const result3 = multiplyMatrixAndPoint(matrixA, row3);
    // Turn the result rows back into a single matrix
    return [
        result0[0],
        result0[1],
        result0[2],
        result0[3],
        result1[0],
        result1[1],
        result1[2],
        result1[3],
        result2[0],
        result2[1],
        result2[2],
        result2[3],
        result3[0],
        result3[1],
        result3[2],
        result3[3]
    ];
}
function createTranslationMatrix(x, y) {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        x,
        y,
        0,
        1
    ];
}
function createRotationMatrix(angleRad) {
    //let angleRad = angleDeg / 360 * 2 * Math.PI;
    return [
        Math.cos(-angleRad),
        -Math.sin(-angleRad),
        0,
        0,
        Math.sin(-angleRad),
        Math.cos(-angleRad),
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function createScaleMatrix(f) {
    return [
        f,
        0,
        0,
        0,
        0,
        f,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
const Matrix = Object.freeze({
    getIdentity,
    multiplyMatrixAndPoint,
    multiplyMatrices,
    createTranslationMatrix,
    createRotationMatrix,
    createScaleMatrix
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g4o19":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec2", ()=>Vec2);
const Vec2 = {
    add: function(p1, p2) {
        return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
        };
    },
    sub: function(p1, p2) {
        return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
        };
    },
    nor: function(p) {
        const len = Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
        return {
            x: p.x / len,
            y: p.y / len
        };
    },
    len: function(p) {
        return Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
    },
    dist: function(p1, p2) {
        return Vec2.len(Vec2.sub(p1, p2));
    },
    mul: function(p, s) {
        return {
            x: p.x * s,
            y: p.y * s
        };
    },
    angle: function(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    },
    dot: function(a, b) {
        const aArr = [
            a.x,
            a.y
        ];
        const bArr = [
            b.x,
            b.y
        ];
        return aArr.map((x, i)=>aArr[i] * bArr[i]).reduce((m, n)=>m + n);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hqKNL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "projectPointOnLine", ()=>projectPointOnLine);
/**
 * Operations on a line made up of points
 */ parcelHelpers.export(exports, "PointLine", ()=>PointLine);
/**
 * Each instance is one line made up of bezier interpolated segments.
 * You feed it points. It calculates control points on its own, and the resulting curve.
 */ parcelHelpers.export(exports, "BezierLine", ()=>BezierLine);
/**
 * from SplineInterpolator.cs in the Paint.NET source code
 */ parcelHelpers.export(exports, "SplineInterpolator", ()=>SplineInterpolator);
/**
 * input for a spline, following curve of a power function x^n [0 - 1]
 * returns [[0, startVal], ..., [1, endVal]]
 */ parcelHelpers.export(exports, "powerSplineInput", ()=>powerSplineInput);
var _vec2 = require("./vec2");
var _math = require("./math");
var _base = require("../base/base");
const projectPointOnLine = function(lineStart, lineEnd, p) {
    let x, y;
    if (lineStart.x === lineEnd.x) {
        x = lineStart.x;
        y = p.y;
        return {
            x: x,
            y: y
        };
    }
    const m = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x);
    const b = lineStart.y - m * lineStart.x;
    x = (m * p.y + p.x - m * b) / (m * m + 1);
    y = (m * m * p.y + m * p.x + b) / (m * m + 1);
    return {
        x: x,
        y: y
    };
};
class PointLine {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.segmentArr = [];
        for(let i = 0; i < p.points.length; i++)((i)=>{
            let length = 0;
            if (i < p.points.length - 1) length = (0, _math.dist)(p.points[i].x, p.points[i].y, p.points[i + 1].x, p.points[i + 1].y);
            this.segmentArr[i] = {
                x: p.points[i].x,
                y: p.points[i].y,
                length: length
            };
        })(i);
    }
    // ---- interface ----
    /**
     * returns point when traveling *dist* along the line, > 0
     * @param dist
     */ getAtDist(dist) {
        let remainder = Math.min(this.getLength(), dist);
        let i = 0;
        for(; remainder > this.segmentArr[i].length && i < this.segmentArr.length - 2; i++)remainder -= this.segmentArr[i].length;
        const fac = Math.min(1, Math.max(0, remainder / this.segmentArr[i].length));
        return {
            x: this.segmentArr[i].x * (1 - fac) + this.segmentArr[i + 1].x * fac,
            y: this.segmentArr[i].y * (1 - fac) + this.segmentArr[i + 1].y * fac
        };
    }
    /**
     * total length of line
     */ getLength() {
        let result = 0;
        for(let i = 0; i < this.segmentArr.length - 1; i++)result += this.segmentArr[i].length;
        return result;
    }
}
class BezierLine {
    /**
     * creates bezier curve from control points
     * @param p1 - control point 1 {x: float, y: float}
     * @param p2 - control point 2 {x: float, y: float}
     * @param p3 - control point 3 {x: float, y: float}
     * @param p4 - control point 4 {x: float, y: float}
     * @param resolution - int
     * @returns bezier curve made up of points {x: float, y: float}
     */ getBezierPoints(p1, p2, p3, p4, resolution) {
        const curvePoints = [];
        let t;
        for(let i = 0; i <= resolution; i++){
            t = i / resolution;
            curvePoints[curvePoints.length] = {
                x: Math.pow(1 - t, 3) * p1.x + 3 * Math.pow(1 - t, 2) * t * p2.x + 3 * (1 - t) * Math.pow(t, 2) * p3.x + Math.pow(t, 3) * p4.x,
                y: Math.pow(1 - t, 3) * p1.y + 3 * Math.pow(1 - t, 2) * t * p2.y + 3 * (1 - t) * Math.pow(t, 2) * p3.y + Math.pow(t, 3) * p4.y
            };
        }
        return curvePoints;
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.lastDot = 0;
        this.pointArr = [];
    }
    // ---- interface ----
    /**
     * Add new point to line. "Drawn" line will go until the previous point.
     *
     * @param x - coord of new point
     * @param y
     * @param spacing - space between each step
     * @param callback - calls for each step
     * @param controlsCallback - calls that callback with the bezier control points
     */ add(x, y, spacing, callback, controlsCallback) {
        if (this.lastPoint && x === this.lastPoint.x && y === this.lastPoint.y) return;
        this.lastPoint = {
            x,
            y
        };
        this.pointArr[this.pointArr.length] = {
            x,
            y,
            spacing
        };
        //calculate directions
        if (this.pointArr.length === 1) {
            this.lastSpacing = spacing;
            return;
        } else if (this.pointArr.length === 2) {
            this.pointArr[0].dir = (0, _vec2.Vec2).nor((0, _vec2.Vec2).sub(this.pointArr[1], this.pointArr[0]));
            this.lastDot = spacing;
            this.lastSpacing = spacing;
            return;
        } else {
            const pointM1 = this.pointArr[this.pointArr.length - 1];
            const pointM2 = this.pointArr[this.pointArr.length - 2];
            const pointM3 = this.pointArr[this.pointArr.length - 3];
            pointM2.dir = (0, _vec2.Vec2).nor((0, _vec2.Vec2).sub(pointM1, pointM3));
            if (isNaN(pointM2.dir.x) || isNaN(pointM2.dir.y)) //when xy -3 == -1
            pointM2.dir = (0, _base.copyObj)(pointM3.dir);
        }
        //get bezier curve
        const a = this.pointArr[this.pointArr.length - 3];
        const b = this.pointArr[this.pointArr.length - 2];
        const p1 = a;
        const p2 = (0, _vec2.Vec2).add(a, (0, _vec2.Vec2).mul(a.dir, (0, _vec2.Vec2).dist(a, b) / 4));
        const p3 = (0, _vec2.Vec2).sub(b, (0, _vec2.Vec2).mul(b.dir, (0, _vec2.Vec2).dist(a, b) / 4));
        const p4 = b;
        let pointLine;
        if (callback) {
            const curvePoints = this.getBezierPoints(p1, p2, p3, p4, 20);
            pointLine = new PointLine({
                points: curvePoints
            });
        } else pointLine = new PointLine({
            points: [
                p1,
                p4
            ]
        });
        //iterate over curve with spacing and callback
        const len = pointLine.getLength();
        let tempSpacing = (0, _math.mix)(this.lastSpacing, spacing, (0, _math.clamp)(this.lastDot / len, 0, 1));
        let d = this.lastDot;
        for(; d <= len; d += tempSpacing){
            tempSpacing = (0, _math.mix)(this.lastSpacing, spacing, (0, _math.clamp)(d / len, 0, 1));
            const point = pointLine.getAtDist(d);
            const angle = this.lastCallbackPoint ? (0, _math.pointsToAngleDeg)(this.lastCallbackPoint, point) : undefined;
            if (callback) callback({
                x: point.x,
                y: point.y,
                t: d / len,
                angle: angle,
                dAngle: this.lastCallbackPoint ? angle - this.lastAngle : 0
            });
            this.lastCallbackPoint = point;
            this.lastAngle = angle;
        }
        if (callback) this.lastDot = d - len;
        else {
            this.lastDot = 0;
            controlsCallback?.({
                p1: p1,
                p2: p2,
                p3: p3,
                p4: p4
            });
        }
        this.lastSpacing = spacing;
    }
    addFinal(spacing, callback, controlsCallback) {
        if (this.pointArr.length < 2) return;
        const p1 = this.pointArr[this.pointArr.length - 2];
        const p2 = this.pointArr[this.pointArr.length - 1];
        const newP = (0, _vec2.Vec2).add(p2, (0, _vec2.Vec2).sub(p2, p1));
        this.add(newP.x, newP.y, spacing, callback, controlsCallback);
    }
}
class SplineInterpolator {
    // ----------------------------------- public -----------------------------------
    constructor(points){
        const n = points.length;
        this.xa = [];
        this.ya = [];
        this.u = [];
        this.y2 = [];
        let i;
        this.first = points[0][0];
        this.last = points[points.length - 1][0];
        points.sort(function(a, b) {
            return a[0] - b[0];
        });
        for(i = 0; i < n; i++){
            this.xa.push(points[i][0]);
            this.ya.push(points[i][1]);
        }
        this.u[0] = 0;
        this.y2[0] = 0;
        for(i = 1; i < n - 1; ++i){
            // This is the decomposition loop of the tridiagonal algorithm.
            // y2 and u are used for temporary storage of the decomposed factors.
            const wx = this.xa[i + 1] - this.xa[i - 1];
            const sig = (this.xa[i] - this.xa[i - 1]) / wx;
            const p = sig * this.y2[i - 1] + 2.0;
            this.y2[i] = (sig - 1.0) / p;
            const ddydx = (this.ya[i + 1] - this.ya[i]) / (this.xa[i + 1] - this.xa[i]) - (this.ya[i] - this.ya[i - 1]) / (this.xa[i] - this.xa[i - 1]);
            this.u[i] = (6.0 * ddydx / wx - sig * this.u[i - 1]) / p;
        }
        this.y2[n - 1] = 0;
        // This is the backsubstitution loop of the tridiagonal algorithm
        for(i = n - 2; i >= 0; --i)this.y2[i] = this.y2[i] * this.y2[i + 1] + this.u[i];
    }
    // ---- interface ----
    getFirstX() {
        return this.first;
    }
    getLastX() {
        return this.last;
    }
    interpolate(x) {
        const n = this.ya.length;
        let klo = 0;
        let khi = n - 1;
        // We will find the right place in the table by means of
        // bisection. This is optimal if sequential calls to this
        // routine are at random values of x. If sequential calls
        // are in order, and closely spaced, one would do better
        // to store previous values of klo and khi.
        while(khi - klo > 1){
            const k = khi + klo >> 1;
            if (this.xa[k] > x) khi = k;
            else klo = k;
        }
        const h = this.xa[khi] - this.xa[klo];
        const a = (this.xa[khi] - x) / h;
        const b = (x - this.xa[klo]) / h;
        // Cubic spline polynomial is now evaluated.
        return a * this.ya[klo] + b * this.ya[khi] + ((a * a * a - a) * this.y2[klo] + (b * b * b - b) * this.y2[khi]) * (h * h) / 6.0;
    }
    /**
     * find x to y. simply by stepping through. suboptimal, so don't call often.
     * searches in x 0-1 range
     */ findX(y, resolution) {
        let x;
        let dist;
        for(let i = 0; i <= resolution; i++){
            const tempX = i / resolution;
            const tempY = this.interpolate(tempX);
            if (x === undefined) {
                x = tempX;
                dist = Math.abs(tempY - y);
                continue;
            }
            const tempDist = Math.abs(tempY - y);
            if (tempDist < dist) {
                x = tempX;
                dist = tempDist;
            } else break;
        }
        return x;
    }
}
function powerSplineInput(startVal, endVal, stepSize, exponent = 2) {
    function round(v, dec) {
        return Math.round(v * Math.pow(10, dec)) / Math.pow(10, dec);
    }
    const resultArr = [];
    for(let i = 0; i <= 1; i += stepSize)resultArr.push([
        round(i, 4),
        round(startVal + Math.pow(i, exponent) * (endVal - startVal), 4)
    ]);
    return resultArr;
}

},{"./vec2":"g4o19","./math":"7x9Fp","../base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7x9Fp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix);
parcelHelpers.export(exports, "dist", ()=>dist);
parcelHelpers.export(exports, "distSquared", ()=>distSquared);
parcelHelpers.export(exports, "lenSquared", ()=>lenSquared);
parcelHelpers.export(exports, "pointsToAngleRad", ()=>pointsToAngleRad);
parcelHelpers.export(exports, "pointsToAngleDeg", ()=>pointsToAngleDeg);
parcelHelpers.export(exports, "isInsideRect", ()=>isInsideRect);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "rotate", ()=>rotate);
parcelHelpers.export(exports, "rotateAround", ()=>rotateAround);
parcelHelpers.export(exports, "snapAngleDeg", ()=>snapAngleDeg);
/**
 * angle always in range [-180, 180]
 */ parcelHelpers.export(exports, "minimizeAngleDeg", ()=>minimizeAngleDeg);
parcelHelpers.export(exports, "intDxy", ()=>intDxy);
/**
 * return closest even number
 * @param f
 */ parcelHelpers.export(exports, "roundEven", ()=>roundEven);
/**
 * return closest uneven number
 * @param f
 */ parcelHelpers.export(exports, "roundUneven", ()=>roundUneven);
/**
 * round number to certain precision.
 * round(1.2345, 2) = 1.23
 * round(1.2345, 0) = 0
 * round(123, -1) = 120
 *
 * @param f
 * @param digits
 */ parcelHelpers.export(exports, "round", ()=>round);
/**
 * update target so it includes bounds
 * @param target
 * @param bounds
 */ parcelHelpers.export(exports, "updateBounds", ()=>updateBounds);
parcelHelpers.export(exports, "boundsOverlap", ()=>boundsOverlap);
/**
 * determine overlap of bounds with width&height
 */ parcelHelpers.export(exports, "boundsInArea", ()=>boundsInArea);
parcelHelpers.export(exports, "intBoundsWithinArea", ()=>intBoundsWithinArea);
parcelHelpers.export(exports, "boundsToRect", ()=>boundsToRect);
parcelHelpers.export(exports, "integerBounds", ()=>integerBounds);
function mix(a, b, f) {
    return a * (1 - f) + b * f;
}
function dist(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));
}
function distSquared(ax, ay, bx, by) {
    // faster because no square-root
    return Math.pow(ax - bx, 2) + Math.pow(ay - by, 2);
}
function lenSquared(x, y) {
    // faster because no square-root
    return x * x + y * y;
}
function pointsToAngleRad(p1, p2) {
    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
}
function pointsToAngleDeg(p1, p2) {
    return pointsToAngleRad(p1, p2) * 180 / Math.PI;
}
function isInsideRect(p, rect) {
    return rect.x <= p.x && p.x <= rect.x + rect.width && rect.y <= p.y && p.y <= rect.y + rect.height;
}
function clamp(num, min, max) {
    return num < min ? min : num > max ? max : num;
}
function rotate(x, y, deg) {
    const theta = deg * (Math.PI / 180);
    const cs = Math.cos(theta);
    const sn = Math.sin(theta);
    return {
        x: x * cs - y * sn,
        y: x * sn + y * cs
    };
}
function rotateAround(center, point, deg) {
    const rot = rotate(point.x - center.x, point.y - center.y, deg);
    rot.x += center.x;
    rot.y += center.y;
    return rot;
}
function snapAngleDeg(angleDeg, snapDegIncrement, maxDistDeg) {
    const modDeg = Math.abs(angleDeg % snapDegIncrement);
    const dist = Math.min(modDeg, snapDegIncrement - modDeg);
    if (dist <= maxDistDeg) angleDeg = Math.round(angleDeg / snapDegIncrement) * snapDegIncrement;
    return angleDeg;
}
function minimizeAngleDeg(angleDeg) {
    angleDeg = angleDeg % 360;
    if (angleDeg > 180) angleDeg -= 360;
    else if (angleDeg < -180) angleDeg += 360;
    return angleDeg;
}
function intDxy(remainder, fDx, fDy) {
    remainder.x += fDx;
    remainder.y += fDy;
    const dX = Math.round(remainder.x);
    const dY = Math.round(remainder.y);
    remainder.x -= dX;
    remainder.y -= dY;
    return {
        dX,
        dY
    };
}
function roundEven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f;
        return f + 1;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 0) return above;
    else return below;
}
function roundUneven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f + 1;
        return f;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 1) return above;
    else return below;
}
function round(f, digits) {
    const digitMult = Math.pow(10, digits);
    return Math.round(f /* + Number.EPSILON*/  * digitMult) / digitMult;
}
function updateBounds(target, bounds) {
    if (!bounds && !target) throw new Error('at least one param needs to be defined');
    if (!bounds) return target;
    if (!target) target = {
        x1: bounds.x1,
        y1: bounds.y1,
        x2: bounds.x2,
        y2: bounds.y2
    };
    else {
        target.x1 = Math.min(target.x1, bounds.x1);
        target.y1 = Math.min(target.y1, bounds.y1);
        target.x2 = Math.max(target.x2, bounds.x2);
        target.y2 = Math.max(target.y2, bounds.y2);
    }
    return target;
}
function boundsOverlap(bounds, limit) {
    if (!bounds) return undefined;
    if (!limit) return bounds;
    const x1 = Math.max(limit.x1, bounds.x1);
    const y1 = Math.max(limit.y1, bounds.y1);
    const x2 = Math.min(limit.x2, bounds.x2);
    const y2 = Math.min(limit.y2, bounds.y2);
    if (x1 > x2 || y1 > y2) return undefined;
    return {
        x1,
        y1,
        x2,
        y2
    };
}
function boundsInArea(bounds, width, height) {
    if (!bounds) return undefined;
    return boundsOverlap(bounds, {
        x1: 0,
        y1: 0,
        x2: width - 1,
        y2: height - 1
    });
}
function intBoundsWithinArea(bounds, width, height, areIndices) {
    const x1 = Math.max(0, Math.floor(bounds.x1));
    const y1 = Math.max(0, Math.floor(bounds.y1));
    const x2 = Math.min(width - (areIndices ? 1 : 0), Math.ceil(bounds.x2));
    const y2 = Math.min(height - (areIndices ? 1 : 0), Math.ceil(bounds.y2));
    if (x1 > x2 || y1 > y2) return undefined;
    return {
        x1,
        y1,
        x2,
        y2
    };
}
function boundsToRect(bounds, areIndices) {
    return {
        x: bounds.x1,
        y: bounds.y1,
        width: bounds.x2 - bounds.x1 + (areIndices ? 1 : 0),
        height: bounds.y2 - bounds.y1 + (areIndices ? 1 : 0)
    };
}
function integerBounds(bounds) {
    return {
        x1: Math.floor(bounds.x1),
        y1: Math.floor(bounds.y1),
        x2: Math.ceil(bounds.x2),
        y2: Math.ceil(bounds.y2)
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e0D0Q":[function(require,module,exports,__globalThis) {
// based on js color conversion http://www.webtoolkit.info/
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HSV", ()=>HSV);
parcelHelpers.export(exports, "RGB", ()=>RGB);
parcelHelpers.export(exports, "CMYK", ()=>CMYK);
parcelHelpers.export(exports, "ColorConverter", ()=>ColorConverter);
parcelHelpers.export(exports, "testIsWhiteBestContrast", ()=>testIsWhiteBestContrast);
class HSV {
    constructor(h, s, v){
        this.h = Math.max(0, Math.min(360, h));
        this.s = Math.max(0.001, Math.min(100, s)); //bug when 0
        this.v = Math.max(0, Math.min(100, v));
    }
}
class RGB {
    constructor(r, g, b){
        this.r = Math.max(0, Math.min(255, r));
        this.g = Math.max(0, Math.min(255, g));
        this.b = Math.max(0, Math.min(255, b));
    }
}
class CMYK {
    constructor(c, m, y, k){
        this.c = Math.max(0, Math.min(100, c));
        this.m = Math.max(0, Math.min(100, m));
        this.y = Math.max(0, Math.min(100, y));
        this.k = Math.max(0, Math.min(100, k));
    }
}
const ColorConverter = {
    _RGBtoHSV: function(RGB) {
        const result = new HSV(0, 0, 0);
        const r = RGB.r / 255;
        const g = RGB.g / 255;
        const b = RGB.b / 255;
        const minVal = Math.min(r, g, b);
        const maxVal = Math.max(r, g, b);
        const delta = maxVal - minVal;
        result.v = maxVal;
        if (delta == 0) {
            result.h = 0;
            result.s = 0;
        } else {
            result.s = delta / maxVal;
            const del_R = ((maxVal - r) / 6 + delta / 2) / delta;
            const del_G = ((maxVal - g) / 6 + delta / 2) / delta;
            const del_B = ((maxVal - b) / 6 + delta / 2) / delta;
            if (r == maxVal) result.h = del_B - del_G;
            else if (g == maxVal) result.h = 1 / 3 + del_R - del_B;
            else if (b == maxVal) result.h = 2 / 3 + del_G - del_R;
            if (result.h < 0) result.h += 1;
            if (result.h > 1) result.h -= 1;
        }
        result.h = Math.round(result.h * 360);
        result.s = Math.round(result.s * 100);
        result.v = Math.round(result.v * 100);
        return result;
    },
    _HSVtoRGB: function(HSV) {
        const result = new RGB(0, 0, 0);
        let var_h, var_i, var_1, var_2, var_3, var_r, var_g, var_b;
        const h = HSV.h / 360 % 1;
        const s = HSV.s / 100;
        const v = HSV.v / 100;
        if (s == 0) {
            result.r = v * 255;
            result.g = v * 255;
            result.b = v * 255;
        } else {
            var_h = h * 6;
            var_i = Math.floor(var_h);
            var_1 = v * (1 - s);
            var_2 = v * (1 - s * (var_h - var_i));
            var_3 = v * (1 - s * (1 - (var_h - var_i)));
            if (var_i == 0) {
                var_r = v;
                var_g = var_3;
                var_b = var_1;
            } else if (var_i == 1) {
                var_r = var_2;
                var_g = v;
                var_b = var_1;
            } else if (var_i == 2) {
                var_r = var_1;
                var_g = v;
                var_b = var_3;
            } else if (var_i == 3) {
                var_r = var_1;
                var_g = var_2;
                var_b = v;
            } else if (var_i == 4) {
                var_r = var_3;
                var_g = var_1;
                var_b = v;
            } else {
                var_r = v;
                var_g = var_1;
                var_b = var_2;
            }
            result.r = var_r * 255;
            result.g = var_g * 255;
            result.b = var_b * 255;
            result.r = Math.round(result.r);
            result.g = Math.round(result.g);
            result.b = Math.round(result.b);
        }
        return result;
    },
    _CMYKtoRGB: function(CMYK) {
        const result = new RGB(0, 0, 0);
        const c = CMYK.c / 100;
        const m = CMYK.m / 100;
        const y = CMYK.y / 100;
        const k = CMYK.k / 100;
        result.r = 1 - Math.min(1, c * (1 - k) + k);
        result.g = 1 - Math.min(1, m * (1 - k) + k);
        result.b = 1 - Math.min(1, y * (1 - k) + k);
        result.r = Math.round(result.r * 255);
        result.g = Math.round(result.g * 255);
        result.b = Math.round(result.b * 255);
        return result;
    },
    _RGBtoCMYK: function(RGB) {
        const result = new CMYK(0, 0, 0, 0);
        const r = RGB.r / 255;
        const g = RGB.g / 255;
        const b = RGB.b / 255;
        result.k = Math.min(1 - r, 1 - g, 1 - b);
        result.c = (1 - r - result.k) / (1 - result.k);
        result.m = (1 - g - result.k) / (1 - result.k);
        result.y = (1 - b - result.k) / (1 - result.k);
        result.c = Math.round(result.c * 100);
        result.m = Math.round(result.m * 100);
        result.y = Math.round(result.y * 100);
        result.k = Math.round(result.k * 100);
        return result;
    },
    toRGB: function(o) {
        if (o instanceof RGB) return o;
        if (o instanceof HSV) return this._HSVtoRGB(o);
        if (o instanceof CMYK) return this._CMYKtoRGB(o);
        throw new Error('unknown type');
    },
    toHSV: function(o) {
        if (o instanceof HSV) return o;
        if (o instanceof RGB) return this._RGBtoHSV(o);
        if (o instanceof CMYK) return this._RGBtoHSV(this._CMYKtoRGB(o));
        throw new Error('unknown type');
    },
    toCMYK: function(o) {
        if (o instanceof CMYK) return o;
        if (o instanceof RGB) return this._RGBtoCMYK(o);
        if (o instanceof HSV) return this._RGBtoCMYK(this._HSVtoRGB(o));
        throw new Error('unknown type');
    },
    toHexString: function(o) {
        if (o instanceof RGB || 'r' in o && 'g' in o && 'b' in o) {
            let ha = parseInt('' + o.r).toString(16);
            let hb = parseInt('' + o.g).toString(16);
            let hc = parseInt('' + o.b).toString(16);
            if (ha.length == 1) ha = '0' + ha;
            if (hb.length == 1) hb = '0' + hb;
            if (hc.length == 1) hc = '0' + hc;
            return ha + hb + hc;
        }
        return '#000';
    },
    toRgbStr: function(rgbObj) {
        return 'rgb(' + Math.round(rgbObj.r) + ', ' + Math.round(rgbObj.g) + ', ' + Math.round(rgbObj.b) + ')';
    },
    toRgbaStr: function(rgbaObj) {
        return 'rgba(' + Math.round(rgbaObj.r) + ', ' + Math.round(rgbaObj.g) + ', ' + Math.round(rgbaObj.b) + ', ' + rgbaObj.a + ')';
    },
    hexToRGB: function(hexStr) {
        hexStr = hexStr.trim();
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexStr = hexStr.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexStr);
        return result ? new RGB(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : undefined;
    }
};
function testIsWhiteBestContrast(rgbObj) {
    return rgbObj.r * 0.299 + rgbObj.g * 0.587 + rgbObj.b * 0.114 < 125;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5dJJW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "appendTextDiv", ()=>appendTextDiv);
/**
 * Is an input element focused.
 * Set attribute "data-ignore-focus" to "true" if its focus should be ignored.
 *
 * @param getAll - check all, even those with "data-ignore-focus" = "true"
 */ parcelHelpers.export(exports, "isInputFocused", ()=>isInputFocused);
parcelHelpers.export(exports, "unfocusAnyInput", ()=>unfocusAnyInput);
/**
 * clears text selection in window
 */ parcelHelpers.export(exports, "clearSelection", ()=>clearSelection);
parcelHelpers.export(exports, "makeUnfocusable", ()=>makeUnfocusable);
// window['els'] = els;
/**
 *
 * Create DOM element - div by default
 * params = {
 * 	    parent: someOtherDiv,
 * 	    css: {
 * 		    width: "500px",
 * 		    backgroundColor: "#fff"
 * 	    },
 * 	    content: "test", //or  content: [divA, divB, divC]   or content: someDiv
 * 	    className: "bla",
 *      id: "bla"
 * }
 *
 *  If onClick or onChange is used, then BB.destroyEl MUST be called
 *  to prevent a memory leak.
 *
 * @param params
 */ parcelHelpers.export(exports, "el", ()=>el);
/**
 * removes event listeners for Elements created via el()
 * @param el
 */ parcelHelpers.export(exports, "destroyEl", ()=>destroyEl);
parcelHelpers.export(exports, "createImage", ()=>createImage);
var _base = require("./base");
var _bb = require("../bb");
function appendTextDiv(target, text) {
    const div = document.createElement('div');
    div.innerHTML = text;
    target.append(div);
    return div;
}
function isInputFocused(getAll = false) {
    const result = !!document.activeElement && [
        'INPUT',
        'TEXTAREA',
        'SELECT'
    ].includes(document.activeElement.tagName);
    if (getAll) return result;
    else return result && !document.activeElement?.getAttribute('data-ignore-focus');
}
function unfocusAnyInput() {
    if (isInputFocused(true)) {
        /*
            Unfocus anything that is focused.

            If an Input is focused in Firefox, and it gets detached from the DOM via a Node
            that isn't its direct parent, then Firefox will keep anything attached to this
            Input in memory. It will not be garbage collected until a new Input is focused.

            Workaround: Temporarily create an input, focus it, detach it.
             */ const focusEl = (0, _bb.BB).el({
            parent: document.body,
            tagName: 'input',
            css: {
                opacity: '0',
                width: '0',
                height: '0'
            }
        });
        setTimeout(()=>{
            focusEl.select();
            focusEl.focus();
            focusEl.remove();
        }, 10);
    }
}
function clearSelection() {
    if (window.getSelection) {
        const sel = window.getSelection();
        if (sel) {
            if (sel.empty) sel.empty();
            else if (sel.removeAllRanges) sel.removeAllRanges();
        }
    }
}
const makeUnfocusable = function() {
    function preventFocus(event) {
        event.preventDefault();
        let didFocusRelated = false;
        if (event.relatedTarget) try {
            event.relatedTarget.focus();
            didFocusRelated = true;
        } catch (e) {
            console.error('failed to focus');
        }
        if (!didFocusRelated) event.currentTarget.blur();
    }
    return function(el) {
        el.setAttribute('tabindex', '-1');
        el.addEventListener('focus', preventFocus);
    };
}();
const els = [];
function el(params) {
    if (!params) return document.createElement('div');
    const result = document.createElement(params.tagName ? params.tagName : 'div');
    params.css && (0, _base.css)(result, params.css);
    if (params.content) {
        if (typeof params.content === "string") result.innerHTML = params.content;
        else if (Array.isArray(params.content)) (0, _bb.BB).append(result, params.content);
        else result.append(params.content);
    }
    if (params.textContent) result.textContent = params.textContent;
    if (params.className) result.className = params.className;
    if (params.id) result.id = params.id;
    if (params.parent) params.parent.append(result);
    if ('title' in params && params.title !== undefined) result.title = params.title;
    const listeners = [];
    if (params.onClick !== undefined) {
        result.addEventListener('click', params.onClick);
        !params.noRef && listeners.push([
            'click',
            params.onClick
        ]);
    }
    if (params.onChange !== undefined) {
        result.addEventListener('change', params.onChange);
        !params.noRef && listeners.push([
            'change',
            params.onChange
        ]);
    }
    if (listeners.length > 0) els.push({
        el: result,
        listeners
    });
    if ('custom' in params && params.custom) {
        const customKeyArr = Object.keys(params.custom);
        for(let i = 0; i < customKeyArr.length; i++)result.setAttribute(customKeyArr[i], params.custom[customKeyArr[i]]);
    }
    return result;
}
function destroyEl(el) {
    if (!el) return;
    for(let i = 0; i < els.length; i++){
        const item = els[i];
        if (item.el === el) {
            item.listeners.forEach((item)=>{
                el.removeEventListener(item[0], item[1]);
            });
            els.splice(i, 1);
            return;
        }
    }
    // not found
    return;
}
function createImage(p) {
    const result = new Image();
    if (p.src !== undefined) result.src = p.src;
    if (p.alt !== undefined) result.alt = p.alt;
    if (p.width !== undefined) result.width = p.width;
    if (p.height !== undefined) result.height = p.height;
    if (p.className !== undefined) result.className = p.className;
    p.css && (0, _base.css)(result, p.css);
    return result;
}

},{"./base":"it3mQ","../bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hiYaP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BbLog", ()=>BbLog);
class BbLog {
    static{
        this.listeners = [];
    }
    // ----------------------------------- public -----------------------------------
    constructor(){}
    static subscribe(listener) {
        if (BbLog.listeners.includes(listener)) return;
        BbLog.listeners.push(listener);
    }
    static unsubscribe(listener) {
        for(let i = 0; i < BbLog.listeners.length; i++)if (listener === BbLog.listeners[i]) {
            BbLog.listeners.splice(i, 1);
            return;
        }
    }
    static emit(msg) {
        BbLog.listeners.forEach((item)=>{
            item(msg);
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"itqB1":[function(require,module,exports,__globalThis) {
/**
 * LocalStorage wrapper that does not throw exceptions.
 * If cookies disabled in Safari localStorage interactions throw exception "insecure operation"
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalStorage", ()=>LocalStorage);
class LocalStorage {
    static getItem(key) {
        // (disabled) eslint-disable-next-line no-null/no-null
        let result = null;
        try {
            result = localStorage.getItem(key);
        } catch (e) {
            this.error = e;
        }
        return result;
    }
    static setItem(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            this.error = e;
        }
    }
    static removeItem(key) {
        try {
            localStorage.removeItem(key);
        } catch (e) {
            this.error = e;
        }
    }
    static getError() {
        return this.error;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gUydo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Splits up coalesced events into their own pointermove events. Otherwise regular pass through.
 *
 * in: IPointerEvent
 * out: IPointerEvent with property isCoalesced: boolean
 *
 * todo: eventPreventDefault and eventStopPropagation are broken events w coalesced events. (because of json parse json stringify)
 * but how could that even work?
 */ parcelHelpers.export(exports, "CoalescedExploder", ()=>CoalescedExploder);
var _base = require("../../base/base");
class CoalescedExploder {
    // ----------------------------------- public -----------------------------------
    setChainOut(func) {
        this.chainOut = func;
    }
    chainIn(event) {
        if (event.type === 'pointermove') {
            if (event.coalescedArr && event.coalescedArr.length > 0) for(let i = 0; i < event.coalescedArr.length; i++){
                const eventCopy = (0, _base.copyObj)(event);
                if (i === 0) eventCopy.coalescedArr = [];
                const coalescedItem = event.coalescedArr[i];
                eventCopy.pageX = coalescedItem.pageX;
                eventCopy.pageY = coalescedItem.pageY;
                eventCopy.relX = coalescedItem.relX;
                eventCopy.relY = coalescedItem.relY;
                eventCopy.dX = coalescedItem.dX;
                eventCopy.dY = coalescedItem.dY;
                eventCopy.time = coalescedItem.time;
                eventCopy.isCoalesced = i < event.coalescedArr.length - 1;
                this.chainOut && this.chainOut(eventCopy);
            }
            else return event;
        } else return event;
        return null;
    }
}

},{"../../base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"96h1z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Detects a single tap with N 'touch' pointers
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "NFingerTapper", ()=>NFingerTapper);
var _math = require("../../math/math");
class NFingerTapper {
    failGesture() {
        if (this.eventQueueArr.length === 0) return;
        this.timeoutObj.firstLastDownTimeout && clearTimeout(this.timeoutObj.firstLastDownTimeout);
        this.timeoutObj.tapTimeout && clearTimeout(this.timeoutObj.tapTimeout);
        for(let i = 0; i < this.eventQueueArr.length; i++)this.chainOut && this.chainOut(this.eventQueueArr[i]);
        this.eventQueueArr = [];
        this.fingerArr = [];
    }
    success() {
        this.timeoutObj.firstLastDownTimeout && clearTimeout(this.timeoutObj.firstLastDownTimeout);
        this.timeoutObj.tapTimeout && clearTimeout(this.timeoutObj.tapTimeout);
        this.eventQueueArr = []; // events get swallowed
        this.fingerArr = [];
        this.onTap();
    }
    setupTimeout(timeoutStr, timeMS) {
        const diff = timeMS - this.nowTime;
        //console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0) // time already up
        return false;
        this.timeoutObj[timeoutStr] = setTimeout(()=>this.failGesture(), diff);
        return true;
    }
    processEvent(event) {
        const tempLastEventTime = this.lastEventTime;
        this.lastEventTime = event.time;
        if (event.type === 'pointerdown') this.pointersDownIdArr.push(event.pointerId);
        else if (event.type === 'pointerup') {
            for(let i = 0; i < this.pointersDownIdArr.length; i++)if (this.pointersDownIdArr[i] === event.pointerId) {
                this.pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (event.pointerType !== 'touch') {
            if (this.fingerArr.length > 0) // already in gesture -> fail
            this.failGesture();
            return;
        }
        this.nowTime = performance.now();
        if (event.type === 'pointerdown') {
            //console.log('down');
            if (this.fingerArr.length + 1 !== this.pointersDownIdArr.length) {
                // failed before, and some fingers are still down -> fail
                this.failGesture();
                return;
            }
            if (this.fingerArr.length === this.fingers) {
                // too many fingers down -> fail
                //console.log(fingers + ': too many fingers down -> fail');
                this.failGesture();
                return;
            }
            if (this.fingerArr.length > 0 && event.time - this.maxFirstLastFingerDownMs > this.fingerArr[0].downTimeMs) {
                // took too long to touch with all fingers -> fail
                //console.log(fingers + ': took too long to touch with all fingers -> fail');
                this.failGesture();
                return;
            }
            if (this.fingerArr.length === 0 && event.time - this.minSilenceBeforeDurationMs < tempLastEventTime) {
                // not enough silence before -> fail
                //console.log(fingers + ': not enough silence before -> fail');
                this.failGesture();
                return;
            }
            if (this.fingerArr.length === 0) {
                this.firstDownTime = event.time;
                if (!this.setupTimeout('firstLastDownTimeout', event.time + this.maxFirstLastFingerDownMs) || !this.setupTimeout('tapTimeout', event.time + this.maxTapMs)) {
                    // timeouts already up -> fail
                    this.failGesture();
                    return;
                }
            }
            this.fingerArr.push({
                pointerId: event.pointerId,
                downTimeMs: event.time,
                downPageX: event.pageX,
                downPageY: event.pageY
            });
            return;
        }
        if (event.type === 'pointermove') {
            if (this.fingerArr.length === 0) //not in a gesture -> ignore
            return;
            let fingerObj = null;
            for(let i = 0; i < this.fingerArr.length; i++)if (this.fingerArr[i].pointerId === event.pointerId) {
                fingerObj = this.fingerArr[i];
                break;
            }
            if (fingerObj === null) {
                // finger not part of the tap is on screen -> fail
                this.failGesture();
                return;
            }
            if (event.time - this.maxTapMs > this.firstDownTime) {
                // tap took too long -> fail
                //console.log(fingers + ': tap took too long -> fail');
                this.failGesture();
                return;
            }
            const distance = (0, _math.dist)(event.pageX, event.pageY, fingerObj.downPageX, fingerObj.downPageY);
            if (distance > this.maxPressedDistancePx) {
                // finger moved too much -> fail
                //console.log(fingers + ': a finger moved too much -> fail', distance);
                this.failGesture();
                return;
            }
        }
        if (event.type === 'pointerup') {
            if (this.fingerArr.length === 0) //not in a gesture -> ignore
            return;
            //console.log('up', event.pageX, event.pageY);
            if (this.fingerArr.length !== this.fingers) {
                // not enough fingers -> fail
                //console.log(fingers + ': not enough fingers -> fail');
                this.failGesture();
                return;
            }
            let fingerObj = null;
            let i = 0;
            for(; i < this.fingerArr.length; i++)if (this.fingerArr[i].pointerId === event.pointerId) {
                fingerObj = this.fingerArr[i];
                break;
            }
            if (fingerObj === null) //do nothing
            return;
            if (event.time - this.maxTapMs > this.firstDownTime) {
                // tap took too long -> fail
                //console.log(fingers + ': tap took too long -> fail');
                this.failGesture();
                return;
            }
            const distance = (0, _math.dist)(event.pageX, event.pageY, fingerObj.downPageX, fingerObj.downPageY);
            if (distance > this.maxPressedDistancePx) {
                // finger moved too much -> fail
                //console.log(fingers + ': b finger moved too much -> fail', distance, event.pageX, event.pageY);
                //console.log(fingerArr);
                this.failGesture();
                return;
            }
            fingerObj.isUp = true;
            let allAreUp = true;
            for(let i = 0; i < this.fingerArr.length; i++)if (!this.fingerArr[i].isUp) {
                allAreUp = false;
                break;
            }
            //console.log('fingerArr', fingerArr);
            if (allAreUp) {
                // success
                this.success();
                return true;
            }
        }
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.minSilenceBeforeDurationMs = 50;
        this.maxTapMs = 500;
        this.maxFirstLastFingerDownMs = 250;
        this.maxPressedDistancePx = 12 //5 + fingers * 5;
        ;
        this.fingerArr = [];
        this.eventQueueArr = [];
        this.firstDownTime = 0;
        this.lastEventTime = 0;
        this.nowTime = performance.now();
        this.pointersDownIdArr = [];
        this.timeoutObj = {
            firstLastDownTimeout: null,
            tapTimeout: null
        };
        this.fingers = p.fingers;
        this.onTap = p.onTap;
    }
    chainIn(event) {
        const result = this.processEvent(event);
        //console.log(fingerArr.length);
        if (result === true) //tap success -> event gets swallowed
        return null;
        if (this.fingerArr.length === 0) return event;
        else this.eventQueueArr.push(event);
        return null;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
}

},{"../../math/math":"7x9Fp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"786i1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Detects a pinch zooming (2 touch pointers). If one finger lifts, then will use the remaining.
 * Further pointers are ignored, but their events get swallowed during the pinching.
 * pinching ends when ALL pointers are lifted.
 * Events passed through if no pinching.
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "PinchZoomer", ()=>PinchZoomer);
var _math = require("../../math/math");
class PinchZoomer {
    end() {
        this.gestureObj = null;
        this.eventQueueArr = [];
    }
    fail(doSwallow) {
        if (!this.gestureObj) // no gesture happening -> ignore
        return;
        this.timeoutObj.secondFingerTimeout && clearTimeout(this.timeoutObj.secondFingerTimeout);
        if (!doSwallow) for(let i = 0; i < this.eventQueueArr.length; i++)this.chainOut && this.chainOut(this.eventQueueArr[i]);
        this.end();
    }
    setupFailTimeout(timeMS) {
        const diff = timeMS - this.nowTime;
        if (diff <= 0) // time already up
        return false;
        this.timeoutObj.secondFingerTimeout = setTimeout(()=>this.fail(), diff);
        return true;
    }
    processEvent(event) {
        if (event.type === 'pointerdown') this.pointersDownIdArr.push(event.pointerId);
        else if (event.type === 'pointerup') {
            for(let i = 0; i < this.pointersDownIdArr.length; i++)if (this.pointersDownIdArr[i] === event.pointerId) {
                this.pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        //pass through scenarios
        if (!this.gestureObj && (event.pointerType !== 'touch' || // wrong pointer type
        event.type === 'pointermove' && this.pointersDownIdArr.length > 0 || // failed before
        this.pointersDownIdArr.length > 1 || // failed before
        event.type === 'pointerup' // failed before
        )) return;
        this.nowTime = performance.now();
        //pointer down
        if (event.type === 'pointerdown') {
            if (this.gestureObj) {
                if (event.pointerType === 'touch') {
                    // touch finger down - as nth pointer
                    this.gestureObj.touchPointerArr.push({
                        pointerId: event.pointerId,
                        relX: event.relX,
                        relY: event.relY
                    });
                    if (this.gestureObj.isInProgress) this.continuePinch(this.gestureObj, {
                        type: 'down',
                        index: this.gestureObj.touchPointerArr.length - 1
                    });
                    else {
                        this.timeoutObj.secondFingerTimeout && clearTimeout(this.timeoutObj.secondFingerTimeout);
                        this.gestureObj.isInProgress = true;
                        this.beginPinch(this.gestureObj);
                    }
                    return;
                } else {
                    // non-touch finger down - as nth pointer
                    if (this.gestureObj.isInProgress) this.gestureObj.otherPointerIdArr.push(event.pointerId);
                    else // second pointer wrong type -> fail
                    this.fail();
                    return;
                }
            } else {
                // first finger down - can only be touch if no gestureObj
                this.gestureObj = {
                    touchPointerArr: [
                        {
                            pointerId: event.pointerId,
                            relX: event.relX,
                            relY: event.relY,
                            downRelX: event.relX,
                            downRelY: event.relY
                        }
                    ],
                    otherPointerIdArr: [],
                    isInProgress: false
                };
                if (!this.setupFailTimeout(event.time + this.untilSecondFingerDurationMs)) {
                    // time ran out -> fail
                    this.fail();
                    return;
                }
                return;
            }
        }
        // should not happen. something went wrong
        if (!this.gestureObj) {
            // throw? would make it less robust
            this.fail();
            return;
        }
        //pointer move
        if (event.type === 'pointermove' && event.pointerType === 'touch') {
            //gesture object should always exist here
            let touchPointerObj = null;
            let i = 0;
            for(; i < this.gestureObj.touchPointerArr.length; i++)if (event.pointerId === this.gestureObj.touchPointerArr[i].pointerId) {
                touchPointerObj = this.gestureObj.touchPointerArr[i];
                break;
            }
            //null should not be possible. something went wrong
            if (!touchPointerObj) {
                // throw? would make it less robust
                this.fail();
                return;
            }
            touchPointerObj.relX = event.relX;
            touchPointerObj.relY = event.relY;
            if (!this.gestureObj.isInProgress) {
                // only one finger down & pinching hasn't started
                // should not happen. something went wrong
                if (!('downRelX' in touchPointerObj && touchPointerObj.downRelX !== undefined) || !('downRelY' in touchPointerObj && touchPointerObj.downRelY !== undefined)) {
                    this.fail();
                    return;
                }
                const distance = (0, _math.dist)(touchPointerObj.downRelX, touchPointerObj.downRelY, touchPointerObj.relX, touchPointerObj.relY);
                if (distance > this.firstFingerMaxDistancePx) {
                    // moved too much -> fail
                    this.fail();
                    return;
                }
            } else if (i < 2) // only first two touches can affect pinching
            this.continuePinch(this.gestureObj, {
                type: 'move',
                index: i
            });
            return;
        }
        //pointer up
        if (event.type === 'pointerup') {
            //gesture object should always exist here
            if (event.pointerType === 'touch') {
                let i = 0;
                for(; i < this.gestureObj.touchPointerArr.length; i++)if (this.gestureObj.touchPointerArr[i].pointerId === event.pointerId) {
                    this.gestureObj.touchPointerArr.splice(i, 1);
                    break;
                }
                if (this.gestureObj.touchPointerArr.length > 0) this.continuePinch(this.gestureObj, {
                    type: 'up',
                    index: i
                });
            } else {
                // non-touch
                for(let i = 0; i < this.gestureObj.otherPointerIdArr.length; i++)if (this.gestureObj.otherPointerIdArr[i] === event.pointerId) {
                    this.gestureObj.otherPointerIdArr.splice(i, 1);
                    break;
                }
            }
            //all fingers lifted?
            if (this.gestureObj.touchPointerArr.length === 0 && this.gestureObj.otherPointerIdArr.length === 0) {
                if (this.gestureObj.isInProgress) {
                    // lifted last finger -> end of pinching
                    this.end();
                    this.endPinch();
                } else // lifted finger again before pinching started -> fail
                this.fail();
                return;
            }
        }
    }
    beginPinch(gestureObj) {
        for(let i = 0; i < gestureObj.touchPointerArr.length; i++){
            const pointerObj = gestureObj.touchPointerArr[i];
            this.pincherArr.push({
                pointerId: pointerObj.pointerId,
                relX: pointerObj.relX,
                relY: pointerObj.relY,
                downRelX: pointerObj.relX,
                downRelY: pointerObj.relY
            });
        }
        const event = {
            type: 'move',
            // temp
            downRelX: 0,
            downRelY: 0,
            relX: 0,
            relY: 0,
            angleRad: 0,
            scale: 1
        };
        if (this.pincherArr.length === 1) {
            event.relX = this.pincherArr[0].downRelX;
            event.relY = this.pincherArr[0].downRelY;
        } else {
            event.relX = 0.5 * (this.pincherArr[0].downRelX + this.pincherArr[1].downRelX);
            event.relY = 0.5 * (this.pincherArr[0].downRelY + this.pincherArr[1].downRelY);
        }
        event.downRelX = event.relX;
        event.downRelY = event.relY;
        this.onPinch(event);
    }
    //actionObj = {type: 'down'|'move'|'up', index: number}
    continuePinch(gestureObj, actionObj) {
        if (actionObj.index > 1) // only first two pointers matter
        return;
        if (actionObj.type === 'move') {
            let event;
            this.pincherArr[actionObj.index].relX = gestureObj.touchPointerArr[actionObj.index].relX;
            this.pincherArr[actionObj.index].relY = gestureObj.touchPointerArr[actionObj.index].relY;
            if (this.pincherArr.length === 1) event = {
                type: 'move',
                downRelX: this.pincherArr[0].downRelX,
                downRelY: this.pincherArr[0].downRelY,
                relX: this.pincherArr[0].relX,
                relY: this.pincherArr[0].relY,
                angleRad: 0,
                scale: 1
            };
            else {
                const startDist = (0, _math.dist)(this.pincherArr[0].downRelX, this.pincherArr[0].downRelY, this.pincherArr[1].downRelX, this.pincherArr[1].downRelY);
                const distance = (0, _math.dist)(this.pincherArr[0].relX, this.pincherArr[0].relY, this.pincherArr[1].relX, this.pincherArr[1].relY);
                const startAngle = (0, _math.pointsToAngleRad)({
                    x: this.pincherArr[0].downRelX,
                    y: this.pincherArr[0].downRelY
                }, {
                    x: this.pincherArr[1].downRelX,
                    y: this.pincherArr[1].downRelY
                });
                const angle = (0, _math.pointsToAngleRad)({
                    x: this.pincherArr[0].relX,
                    y: this.pincherArr[0].relY
                }, {
                    x: this.pincherArr[1].relX,
                    y: this.pincherArr[1].relY
                });
                event = {
                    type: 'move',
                    downRelX: 0.5 * (this.pincherArr[0].downRelX + this.pincherArr[1].downRelX),
                    downRelY: 0.5 * (this.pincherArr[0].downRelY + this.pincherArr[1].downRelY),
                    relX: 0.5 * (this.pincherArr[0].relX + this.pincherArr[1].relX),
                    relY: 0.5 * (this.pincherArr[0].relY + this.pincherArr[1].relY),
                    angleRad: angle - startAngle,
                    scale: distance / startDist
                };
            }
            this.onPinch(event);
        } else if (actionObj.type === 'down' || actionObj.type === 'up') {
            this.endPinch();
            this.beginPinch(gestureObj);
        }
    }
    endPinch() {
        this.pincherArr = [];
        this.onPinch({
            type: 'end'
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.firstFingerMaxDistancePx = 10;
        this.untilSecondFingerDurationMs = 250;
        this.pointersDownIdArr = [];
        this.gestureObj = null;
        this.eventQueueArr = [];
        this.nowTime = performance.now();
        this.timeoutObj = {
            secondFingerTimeout: null
        };
        this.pincherArr = [];
        this.onPinch = p.onPinch;
    }
    chainIn(event) {
        this.processEvent(event);
        if (this.gestureObj) {
            if (!this.gestureObj.isInProgress) // might still fail -> into queue
            this.eventQueueArr.push(event);
        } else return event;
        return null;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
}

},{"../../math/math":"7x9Fp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fPbPb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Detects double taps.
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "DoubleTapper", ()=>DoubleTapper);
var _math = require("../../math/math");
class DoubleTapper {
    // double tap achieved
    success() {
        this.timeoutObj.fail = null;
        this.timeoutObj.success = null;
        this.eventQueueArr = []; // events get swallowed
        const lastSequenceItem = this.sequenceArr[this.sequenceArr.length - 1];
        this.sequenceArr = [];
        if ('pageX' in lastSequenceItem) this.onDoubleTap({
            pageX: lastSequenceItem.pageX,
            pageY: lastSequenceItem.pageY,
            relX: lastSequenceItem.relX,
            relY: lastSequenceItem.relY
        });
    }
    // returns false if time already up. otherwise sets up timeout
    setupTimeout(timeoutStr, targetFunc, timeMS, noComparison) {
        const diff = timeMS - this.nowTime;
        // console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0 && !noComparison) // time already up
        return false;
        this.timeoutObj[timeoutStr] = setTimeout(targetFunc, Math.max(0, diff));
        return true;
    }
    /**
     * @param event object - a pointer event from BB.PointerListener
     */ processEvent(event) {
        if (event.type === 'pointerdown') this.pointersDownIdArr.push(event.pointerId);
        else if (event.type === 'pointerup') {
            for(let i = 0; i < this.pointersDownIdArr.length; i++)if (this.pointersDownIdArr[i] === event.pointerId) {
                this.pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (!this.allowedPointerTypeArr.includes(event.pointerType)) {
            //wrong input type -> fail
            //console.log('wrong input type -> fail');
            this.gestureFailed();
            return;
        }
        this.nowTime = performance.now();
        const lastSequenceItem = this.sequenceArr.length > 0 ? this.sequenceArr[this.sequenceArr.length - 1] : null;
        if (event.type === 'pointerup') this.lastUpTime = event.time;
        if (event.type === 'pointerdown') {
            if (this.pointersDownIdArr.length > 1) {
                // more than one pointer down -> fail
                //console.log('more than one pointer down -> fail');
                this.gestureFailed();
                return;
            }
            if (this.timeoutObj.success !== null) {
                // silence-after not achieved -> fail
                //console.log('silence-after not achieved -> fail');
                this.gestureFailed();
                return;
            }
            if (this.sequenceArr.length === 0 && this.nowTime - this.lastUpTime < this.minSilenceBeforeDurationMs) {
                // silence before not achieved -> fail
                //console.log('silence before not achieved -> fail');
                this.gestureFailed();
                return;
            }
            if (event.button && !this.allowedButtonArr.includes(event.button)) {
                // wrong button -> fail
                //console.log('wrong button -> fail', event.button, allowedButtonArr);
                this.gestureFailed();
                return;
            }
            if (lastSequenceItem && 'isDown' in lastSequenceItem && lastSequenceItem.isDown || this.sequenceArr.length > 2) {
                // jumbled -> fail
                //console.log('jumbled -> fail');
                this.gestureFailed();
                return;
            }
            if (lastSequenceItem && 'position' in lastSequenceItem) {
                const distance = (0, _math.dist)(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
                if (distance > this.maxInbetweenDistancePx) {
                    //moved too much -> reset
                    //console.log('maxInbetweenDistancePx -> reset');
                    this.gestureFailed();
                    if ('time' in lastSequenceItem && this.nowTime - lastSequenceItem.time < this.minSilenceBeforeDurationMs) //silence before not achieved -> fail
                    return;
                }
            }
            this.sequenceArr.push({
                isDown: true,
                time: this.nowTime,
                position: [
                    event.pageX,
                    event.pageY
                ],
                pointerId: event.pointerId
            });
            //maxUntilSecondDown
            if (this.sequenceArr.length > 1) this.timeoutObj.maxUntilSecondDown && clearTimeout(this.timeoutObj.maxUntilSecondDown);
            else if (!this.setupTimeout('maxUntilSecondDown', ()=>this.gestureFailed(), event.time + this.maxUntilSecondDownDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                this.gestureFailed();
                return;
            }
            this.timeoutObj.fail && clearTimeout(this.timeoutObj.fail);
            if (!this.setupTimeout('fail', ()=>this.gestureFailed(), event.time + this.maxPressedDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                this.gestureFailed();
                return;
            }
        }
        if (lastSequenceItem && event.type === 'pointermove' && 'pointerId' in lastSequenceItem && lastSequenceItem.pointerId === event.pointerId) {
            /*if (lastSequenceItem.pointerId !== event.pointerId) { //another pointer mixing in -> fail
                console.log('another pointer mixing in -> fail');
                this.fail();
                return;
            }*/ const distance = (0, _math.dist)(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
            if (distance > this.maxPressedDistancePx) {
                //moved too much -> fail
                //console.log('maxPressedDistancePx -> fail');
                this.gestureFailed();
                return;
            }
        }
        if (lastSequenceItem && event.type === 'pointerup') {
            if ('pointerId' in lastSequenceItem && lastSequenceItem.pointerId !== event.pointerId) {
                //another pointer mixing in -> fail
                this.gestureFailed();
                return;
            }
            if ('time' in lastSequenceItem && this.nowTime >= lastSequenceItem.time + this.maxPressedDurationMs) {
                //pressed too long -> fail
                this.gestureFailed();
                return;
            }
            this.timeoutObj.fail && clearTimeout(this.timeoutObj.fail);
            if (this.sequenceArr.length < 3) {
                if (!this.setupTimeout('fail', ()=>this.gestureFailed(), event.time + this.maxUpToUpDurationMs)) {
                    this.gestureFailed();
                    return;
                }
                this.sequenceArr = [
                    lastSequenceItem,
                    {
                        isUp: true,
                        time: this.nowTime,
                        position: [
                            event.pageX,
                            event.pageY
                        ]
                    }
                ];
                return;
            }
            if ('time' in this.sequenceArr[1] && this.nowTime < this.sequenceArr[1].time + this.maxUpToUpDurationMs) {
                // double tap almost success
                // only needs silence
                this.sequenceArr.push({
                    pageX: event.pageX,
                    pageY: event.pageY,
                    relX: event.relX,
                    relY: event.relY
                });
                if (!this.setupTimeout('success', ()=>this.success(), event.time + this.minSilenceAfterMs, true)) this.gestureFailed();
            } else // time up -> fail
            this.gestureFailed();
        }
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.allowedPointerTypeArr = [
            'touch',
            'mouse',
            'pen'
        ];
        this.allowedButtonArr = [
            'left'
        ];
        this.minSilenceBeforeDurationMs = 400;
        this.maxPressedDurationMs = 300;
        this.maxPressedDistancePx = 10;
        this.maxInbetweenDistancePx = 19;
        this.maxUpToUpDurationMs = 500;
        this.maxUntilSecondDownDurationMs = 300;
        this.minSilenceAfterMs = 250;
        this.sequenceArr = [];
        this.pointersDownIdArr = [];
        this.lastUpTime = 0;
        this.nowTime = 0;
        this.eventQueueArr = [];
        this.timeoutObj = {
            fail: null,
            maxUntilSecondDown: null,
            success: null
        };
        this.onDoubleTap = p.onDoubleTap;
        if (p.isInstant) {
            this.minSilenceBeforeDurationMs = 0;
            this.minSilenceAfterMs = 0;
        }
        this.gestureFailed = ()=>{
            if (this.sequenceArr.length === 0) // no gesture started -> can be ignored
            return;
            this.timeoutObj.fail && clearTimeout(this.timeoutObj.fail);
            this.timeoutObj.maxUntilSecondDown && clearTimeout(this.timeoutObj.maxUntilSecondDown);
            this.timeoutObj.success && clearTimeout(this.timeoutObj.success);
            this.timeoutObj.fail = null;
            this.timeoutObj.maxUntilSecondDown = null;
            this.timeoutObj.success = null;
            if (this.chainOut) for(let i = 0; i < this.eventQueueArr.length; i++)this.chainOut(this.eventQueueArr[i]);
            this.eventQueueArr = [];
            this.sequenceArr = [];
        };
    }
    chainIn(event) {
        this.processEvent(event);
        if (this.sequenceArr.length === 0) {
            //existing events can not become a double tap
            this.gestureFailed();
            return event;
        }
        // events might become a double tap -> queue
        this.eventQueueArr.push(event);
        return null;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    setAllowedPointerTypeArr(arr) {
        this.allowedPointerTypeArr = [
            ...arr
        ];
    }
    setAllowedButtonArr(arr) {
        this.allowedButtonArr = [
            ...arr
        ];
    }
}

},{"../../math/math":"7x9Fp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqRll":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * only lets through events from one pointer at a time.
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "OnePointerLimiter", ()=>OnePointerLimiter);
class OnePointerLimiter {
    // ----------------------------------- public -----------------------------------
    chainIn(event) {
        if (this.ignorePointerIdArr.includes(event.pointerId)) {
            if (event.type === 'pointerup') {
                for(let i = 0; i < this.ignorePointerIdArr.length; i++)if (this.ignorePointerIdArr[i] === event.pointerId) {
                    this.ignorePointerIdArr.splice(i, 1);
                    break;
                }
            }
            return null;
        }
        if (this.downPointerId === null) {
            if (event.type === 'pointerdown') this.downPointerId = event.pointerId;
            return event;
        } else {
            if (event.pointerId !== this.downPointerId) {
                if (event.type === 'pointerdown') this.ignorePointerIdArr.push(event.pointerId);
                return null;
            }
            if (event.type === 'pointerup') this.downPointerId = null;
            return event;
        }
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    constructor(){
        this.downPointerId = null;
        this.ignorePointerIdArr = [];
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eo2AB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * for chaining event processing. useful for gestures (double tap, pinch zoom, max pointer filter).
 * each element in the chain might hold back the events, swallow them, transform them, or create new ones
 */ parcelHelpers.export(exports, "EventChain", ()=>EventChain);
class EventChain {
    continueChain(i, event) {
        for(; i < this.chainArr.length; i++){
            event = this.chainArr[i].chainIn(event);
            if (event === null) return null;
        }
        this.chainOut && this.chainOut(event);
        return null;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.chainArr = p.chainArr;
        for(let i = 0; i < this.chainArr.length; i++)((i)=>{
            this.chainArr[i].setChainOut((event)=>{
                this.continueChain(i + 1, event);
            });
        })(i);
    }
    /**
     * feed an event into the chain
     */ chainIn(event) {
        return this.continueChain(0, event);
    }
    /**
     * func will be called when event has passed through the chain
     */ setChainOut(func) {
        this.chainOut = func;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"mcywn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LS_LANGUAGE_KEY", ()=>LS_LANGUAGE_KEY);
parcelHelpers.export(exports, "getLanguage", ()=>getLanguage);
parcelHelpers.export(exports, "LANGUAGE_STRINGS", ()=>LANGUAGE_STRINGS);
parcelHelpers.export(exports, "LANG", ()=>LANG);
parcelHelpers.export(exports, "initLANG", ()=>initLANG);
var _languages = require("../../languages/languages");
var _localStorage = require("../bb/base/local-storage");
const LS_LANGUAGE_KEY = 'klecks-language';
class LanguageStrings {
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.listeners = [];
        // need to use setLanguage for a different language
        this.data = {
            ...(0, _languages.english)
        };
        this.code = 'en';
    }
    async setLanguage(langCode) {
        if (langCode === 'en') this.data = {
            ...(0, _languages.english)
        };
        else this.data = {
            ...(0, _languages.english),
            ...await (0, _languages.loadLanguage)(langCode)
        };
        this.code = langCode;
        document.documentElement.setAttribute('lang', langCode);
        this.listeners.forEach((item)=>{
            item();
        });
    }
    get(code) {
        if (!(code in this.data)) throw new Error("translation code doesn't exist: " + code);
        return this.data[code];
    }
    getLanguage() {
        return (0, _languages.languages).find((item)=>{
            return item.code === this.code;
        });
    }
    getAutoLanguage() {
        const autoCode = getLanguage(false);
        return (0, _languages.languages).find((item)=>{
            return item.code === autoCode;
        });
    }
    getCode() {
        return this.code;
    }
    // get notified on language change
    subscribe(subscriber) {
        if (this.listeners.includes(subscriber)) return;
        this.listeners.push(subscriber);
    }
    unsubscribe(subscriber) {
        for(let i = 0; i < this.listeners.length; i++)if (subscriber === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
}
function getLanguage(useLocalStorage) {
    let result = 'en';
    const langs = []; // from highest to lowest priority
    const navLangs = navigator.languages ? navigator.languages : [
        navigator.language
    ];
    navLangs.forEach((item)=>{
        const split = item.split('-');
        langs.push(item);
        if (split.length === 2) langs.push(split[0]);
    });
    if (useLocalStorage) try {
        const item = (0, _localStorage.LocalStorage).getItem(LS_LANGUAGE_KEY);
        if (item) langs.unshift(item);
    } catch (e) {
    // likely cookies disabled in Safari
    }
    for(let i = 0; i < langs.length; i++){
        const lang = langs[i];
        const found = (0, _languages.languages).find((item)=>{
            return item.code.toLowerCase() === lang.toLowerCase();
        });
        if (found) {
            result = found.code;
            break;
        }
    }
    return result;
}
const activeLanguageCode = getLanguage(true);
const LANGUAGE_STRINGS = new LanguageStrings();
const LANG = (code, replace)=>{
    if (replace) {
        let result = LANGUAGE_STRINGS.get(code);
        const keyArr = Object.keys(replace);
        keyArr.forEach((key)=>{
            result = result.replace(`{${key}}`, replace[key]);
        });
        return result;
    } else return LANGUAGE_STRINGS.get(code);
};
const initLANG = ()=>LANGUAGE_STRINGS.setLanguage(activeLanguageCode);

},{"../../languages/languages":"e8OBh","../bb/base/local-storage":"itqB1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e8OBh":[function(require,module,exports,__globalThis) {
// generated from src/languages. "npm run lang:build" to update
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "english", ()=>english);
parcelHelpers.export(exports, "languages", ()=>languages);
parcelHelpers.export(exports, "loadLanguage", ()=>loadLanguage);
var _enJson = require("./en.json");
var _enJsonDefault = parcelHelpers.interopDefault(_enJson);
const english = (0, _enJsonDefault.default);
const languages = [
    {
        code: 'en',
        name: 'English'
    },
    {
        code: 'de',
        name: 'Deutsch'
    },
    {
        code: 'es',
        name: "Espa\xf1ol"
    },
    {
        code: 'fi',
        name: 'suomi'
    },
    {
        code: 'fr',
        name: "Fran\xe7ais"
    },
    {
        code: 'hu',
        name: 'Magyar'
    },
    {
        code: 'id',
        name: 'Bahasa Indonesia'
    },
    {
        code: 'ja',
        name: "\u65E5\u672C\u8A9E"
    },
    {
        code: 'jv',
        name: 'Basa Jawa'
    },
    {
        code: 'ko',
        name: "\uD55C\uAD6D\uC5B4"
    },
    {
        code: 'lv',
        name: "Latvie\u0161u Valoda"
    },
    {
        code: 'nl',
        name: 'Nederlands'
    },
    {
        code: 'pt-BR',
        name: "Portugu\xeas Brasil"
    },
    {
        code: 'ru',
        name: "\u0440\u0443\u0441\u0441\u043A\u0438\u0439"
    },
    {
        code: 'su',
        name: 'Basa Sunda'
    },
    {
        code: 'sv',
        name: 'Svenska'
    },
    {
        code: 'zh-CN',
        name: "\u7B80\u4F53\u4E2D\u6587"
    },
    {
        code: 'zh-TW',
        name: "\u7E41\u9AD4\u4E2D\u6587"
    }
];
const loadLanguage = async (code)=>{
    if (code === 'en') return english;
    else if (code === 'de') return await require("f059653332475fd3");
    else if (code === 'es') return await require("2bb15fbb86ba5946");
    else if (code === 'fi') return await require("5ca602a917777bab");
    else if (code === 'fr') return await require("cfa52edf344ca1ef");
    else if (code === 'hu') return await require("29b829fbbd2611bc");
    else if (code === 'id') return await require("e486e82cf1c9af8c");
    else if (code === 'ja') return await require("814394c8adce581b");
    else if (code === 'jv') return await require("69758c200539f0b3");
    else if (code === 'ko') return await require("315931c731a980dc");
    else if (code === 'lv') return await require("e0d161da89293a11");
    else if (code === 'nl') return await require("f37f094ed804e7c6");
    else if (code === 'pt-BR') return await require("4daa4c0c53082f3b");
    else if (code === 'ru') return await require("a8720c333f72a760");
    else if (code === 'su') return await require("4b86e5ca1d6e77da");
    else if (code === 'sv') return await require("af9d035aa73a4453");
    else if (code === 'zh-CN') return await require("8d2d53e9ba060849");
    else if (code === 'zh-TW') return await require("ca68ac3f0df3555b");
    throw new Error('unknown language code');
};
 // Dismiss

},{"./en.json":"flRay","f059653332475fd3":"9NT8r","2bb15fbb86ba5946":"eLv87","5ca602a917777bab":"aw946","cfa52edf344ca1ef":"hbLhO","29b829fbbd2611bc":"1PCSS","e486e82cf1c9af8c":"86wmw","814394c8adce581b":"hdHH8","69758c200539f0b3":"cunkz","315931c731a980dc":"al2lS","e0d161da89293a11":"dbhmD","f37f094ed804e7c6":"kYXl1","4daa4c0c53082f3b":"gS0kP","a8720c333f72a760":"i2DHf","4b86e5ca1d6e77da":"f0o1s","af9d035aa73a4453":"6QUlt","8d2d53e9ba060849":"3nc47","ca68ac3f0df3555b":"cLj9j","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"flRay":[function(require,module,exports,__globalThis) {
module.exports = JSON.parse('{"switch-ui-left-right":"Switch left/right UI","toggle-show-tools":"Show/Hide Tools","scroll":"Scroll","donate":"Donate","home":"Home","modal-new-tab":"Open in new tab","tab-edit":"Edit","tab-file":"File","tool-brush":"Brush","tool-paint-bucket":"Paint Bucket","tool-gradient":"Gradient","tool-shape":"Shape","tool-text":"Text","tool-hand":"Hand Tool","tool-select":"Select Tool","tool-zoom":"Zoom","tool-more-tools":"More Tools","tool-more-tools-click-again":"Click again for more tools","undo":"Undo","redo":"Redo","brush-pen":"Pen","brush-blend":"Blend","brush-sketchy":"Sketchy","brush-pixel":"Pixel","brush-chemy":"Chemy","brush-smudge":"Smudge","brush-size":"Size","brush-blending":"Blending","brush-toggle-pressure":"Toggle Pressure Sensitivity","brush-pen-circle":"Circle","brush-pen-chalk":"Chalk","brush-pen-calligraphy":"Calligraphy","brush-pen-square":"Square","brush-sketchy-scale":"Scale","brush-pixel-dither":"Dither","brush-chemy-fill":"Fill","brush-chemy-stroke":"Stroke","brush-chemy-mirror-x":"Horizontal Symmetry","brush-chemy-mirror-y":"Vertical Symmetry","brush-chemy-gradient":"Gradient","brush-eraser-transparent-bg":"Transparent Background","stabilizer":"Stabilizer","stabilizer-title":"Stroke Stabilizer","eyedropper":"Eyedropper","secondary-color":"Secondary Color","manual-color-input":"Manual Color Input","mci-hex":"Hex","mci-copy":"Copy","modal-ok":"Ok","modal-cancel":"Cancel","modal-close":"Close","layers-active-layer":"Active Layer","layers-layer":"Layer","layers-copy":"copy","layers-blending":"Blending","layers-new":"New Layer","layers-remove":"Remove Layer","layers-duplicate":"Duplicate Layer","layers-merge":"Merge with layer below","layers-clear":"Clear layer","layers-merge-all":"Merge all","layers-rename":"Rename","layers-active-layer-visible":"Active layer is visible","layers-active-layer-hidden":"Active layer is hidden","layers-visibility-toggle":"Layer Visibility","layers-blend-normal":"normal","layers-blend-darken":"darken","layers-blend-multiply":"multiply","layers-blend-color-burn":"color burn","layers-blend-lighten":"lighten","layers-blend-screen":"screen","layers-blend-color-dodge":"color dodge","layers-blend-overlay":"overlay","layers-blend-soft-light":"soft light","layers-blend-hard-light":"hard light","layers-blend-difference":"difference","layers-blend-exclusion":"exclusion","layers-blend-hue":"hue","layers-blend-saturation":"saturation","layers-blend-color":"color","layers-blend-luminosity":"luminosity","layers-rename-title":"Rename Layer","layers-rename-name":"Name","layers-rename-clear":"Clear Name","layers-rename-sketch":"Sketch","layers-rename-colors":"Colors","layers-rename-shading":"Shading","layers-rename-lines":"Lines","layers-rename-effects":"Effects","layers-rename-foreground":"Foreground","layers-merge-modal-title":"Merge/Mix Layers","layers-merge-description":"Merges the selected layer with the one underneath. Select the mix mode:","file-no-autosave":"No autosave, no cloud storage","file-new":"New","file-import":"Import","file-save":"Save","file-format":"File Format","file-show-save-dialog":"Show save dialog","file-copy":"Copy","file-copy-title":"Copy To Clipboard","file-paste":"Paste","file-share":"Share","file-storage":"Browser Storage","file-storage-about":"About Browser Storage","file-storage-cant-access":"Can\'t access storage.","file-storage-empty":"Empty","file-storage-store":"Store","file-storage-open":"Open","file-storage-open-confirmation":"This image is already open in another tab. Open it here too?","file-storage-open-failed":"Failed to load.","file-storage-clear":"Clear","file-storage-clear-prompt":"Clear Browser Storage? Clearing can not be undone.","file-storage-storing":"Storing","file-storage-overwrite":"Overwrite","file-storage-overwrite-confirm":"Overwrite Browser Storage? Overwritten data will be permanently deleted.","file-storage-min-ago":"{x}min ago","file-storage-hours-ago":"{x}h ago","file-storage-days-ago":"{x}d ago","file-storage-month-ago":"> 1month ago","file-storage-restored":"Restored from Browser Storage","file-storage-stored":"Stored to Browser Storage","file-storage-failed":"Failed to store to Browser Storage","file-storage-failed-1":"Failed to store. Possible causes:","file-storage-failed-2":"Out of disk space","file-storage-failed-3":"Storage disabled in incognito tab","file-storage-failed-4":"Browser doesn\'t support storage","file-storage-failed-clear":"Failed to clear.","file-upload":"Upload","tab-recovery-recover-tabs":"Recover closed tabs","tab-recovery-explanation":"Recovery data is only kept for a little while. Save to ensure your work is not lost.","tab-recovery-total-quota-label":"Total:","tab-recovery-empty":"Nothing to recover.","tab-recovery-recover":"Recover","tab-recovery-delete":"Delete","tab-recovery-delete-confirmation":"Delete this recovery? Deletion can not be undone.","tab-recovery-failed-to-recover":"Failed to recover tab.","tab-recovery-recovered":"Tab recovered.","cleared-layer":"Cleared layer","cleared-selected-area":"Cleared selected area","filled":"Filled","filled-selected-area":"Filled selection","new-title":"New Image","new-current":"Current","new-fit":"Fit","new-oversize":"Oversize","new-square":"Square","new-landscape":"Landscape","new-portrait":"Portrait","new-screen":"Screen","new-video":"Video","new-din-paper":"DIN Paper","new-px":"px","new-ratio":"Ratio","upload-title":"Upload to Imgur","upload-link-notice":"Anyone with the link to your uploaded image will be able to view it.","upload-name":"Title","upload-title-untitled":"Untitled","upload-caption":"Caption","upload-submit":"Upload","upload-uploading":"Uploading...","upload-success":"Upload Successful","upload-failed":"Upload failed.","upload-delete":"To delete your image from Imgur visit:","cropcopy-title-copy":"Copy To Clipboard","cropcopy-title-crop":"Crop","cropcopy-mask":"Mask unselected","cropcopy-click-hold":"Right-click or press hold to copy.","cropcopy-btn-copy":"To Clipboard","cropcopy-copied":"Copied.","cropcopy-btn-crop":"Apply Crop","crop-drag-to-crop":"Drag to crop","filter-crop-extend":"Crop/Extend","filter-flip":"Flip","filter-perspective":"Perspective","filter-resize":"Resize","filter-rotate":"Rotate","filter-transform":"Transform","filter-bright-contrast":"Bright/Contrast","filter-curves":"Curves","filter-hue-sat":"Hue/Saturation","filter-invert":"Invert","filter-tilt-shift":"Tilt Shift","filter-to-alpha":"To Alpha","filter-triangle-blur":"Triangle Blur","filter-unsharp-mask":"Unsharp Mask","filter-crop-title":"Crop / Extend","filter-crop-description":"Crop or extend the image.","filter-crop-left":"Left","filter-crop-right":"Right","filter-crop-top":"Top","filter-crop-bottom":"Bottom","filter-crop-rule-thirds":"Rule of Thirds","filter-crop-fill":"Fill","filter-flip-title":"Flip","filter-flip-description":"Flips layer or whole image.","filter-flip-horizontal":"Horizontal","filter-flip-vertical":"Vertical","filter-flip-image":"Flip Image","filter-flip-layer":"Flip Layer","filter-perspective-title":"Perspective","filter-perspective-description":"Transforms the selected layer.","filter-resize-title":"Resize","filter-resize-description":"Resizes the image.","filter-rotate-title":"Rotate","filter-rotate-description":"Rotates the image.","filter-transform-empty":"Layer is empty.","filter-transform-empty-selection":"Layer is empty in selected area.","filter-transform-title":"Transform","filter-transform-description":"Transforms selected layer. Hold Shift for additional behavior.","filter-transform-rotation":"Rotation","filter-transform-flip":"Flip","filter-transform-center":"Center","filter-transform-constrain":"Constrain","filter-transform-snap":"Snap","filter-transform-snap-title":"Snap Rotation And Position","filter-bright-contrast-title":"Brightness / Contrast","filter-bright-contrast-description":"Change brightness and contrast for the selected layer.","filter-bright-contrast-brightness":"Brightness","filter-bright-contrast-contrast":"Contrast","filter-curves-title":"Curves","filter-curves-description":"Apply curves on the selected layer.","filter-curves-all":"All","filter-hue-sat-title":"Hue / Saturation","filter-hue-sat-description":"Change hue and saturation for the selected layer.","filter-hue-sat-hue":"Hue","filter-hue-sat-saturation":"Saturation","filter-applied":"applied","filter-tilt-shift-title":"Tilt Shift","filter-tilt-shift-description":"Applies tilt shift on the selected layer.","filter-tilt-shift-blur":"Blur Radius","filter-tilt-shift-gradient":"Gradient Radius","filter-to-alpha-title":"To Alpha","filter-to-alpha-description":"Generates alpha channel for selected layer from:","filter-to-alpha-inverted-lum":"Inverted Luminance","filter-to-alpha-lum":"Luminance","filter-to-alpha-replace":"Replace RGB","filter-triangle-blur-title":"Triangle Blur","filter-triangle-blur-description":"Applies triangle blur on the selected layer.","filter-unsharp-mask-title":"Unsharp Mask","filter-unsharp-mask-description":"Sharpens the selected layer by scaling pixels away from the average of their neighbors.","filter-unsharp-mask-strength":"Strength","filter-grid":"Grid","filter-grid-description":"Draws grid on selected layer.","filter-noise":"Noise","filter-noise-description":"Adds noise to selected layer.","filter-noise-scale":"Scale","filter-noise-alpha":"Alpha","filter-pattern":"Pattern","filter-pattern-description":"Generates pattern on selected layer. Drag the preview for further controls.","filter-distort":"Distort","filter-distort-description":"Distorts the selected layer.","filter-distort-phase":"Phase","filter-distort-stepsize":"Step Size","filter-distort-sync-xy":"Sync XY","filter-vanish-point":"Vanish Point","filter-vanish-point-title":"Vanishing Point","filter-vanish-point-description":"Adds vanishing point to selected layer. Drag preview to move.","filter-vanish-point-lines":"Lines","dropper-drop":"Drop to import","dropper-as-image":"As New Image","dropper-as-layer":"As Layer","import-opening":"Opening file...","import-title":"Import Image","import-too-large":"Image too large, will be downscaled.","import-btn-as-layer":"As Layer","import-btn-as-image":"As Image","import-as-layer-title":"Import Image as New Layer","import-as-layer-description":"Adjust the position of the imported image.","import-as-layer-limit-reached":"Layer limit reached. Image will be placed on existing layer.","import-as-layer-fit":"Fit","import-flatten":"Flatten image","import-unsupported-file":"Unsupported file type. See Help for supported types.","import-broken-file":"Couldn\'t load image. File might be corrupted.","import-psd-unsupported":"Unsupported features. PSD had to be flattened.","import-psd-limited-support":"PSD support is limited. Flattened will more likely look correct.","import-psd-too-large":"Image exceeds maximum dimensions of {x} x {x} pixels. Unable to import.","import-psd-size":"Image size","clipboard-read-fail":"Failed to read from clipboard.","clipboard-no-image":"No image found in clipboard.","hand-reset":"Reset","hand-fit":"Fit","hand-inertia-scrolling":"Inertia Scrolling","bucket-tolerance":"Tolerance","bucket-sample":"Sample","bucket-sample-title":"Which layers to sample color from","bucket-sample-all":"All","bucket-sample-active":"Active","bucket-sample-above":"Above","bucket-grow":"Grow","bucket-grow-title":"Grow filled area (in pixels)","bucket-contiguous":"Contiguous","bucket-contiguous-title":"Only fill connected areas","gradient-linear":"Linear","gradient-linear-mirror":"Linear-Mirror","gradient-radial":"Radial","shape-stroke":"Stroke","shape-fill":"Fill","shape-rect":"Rectangle","shape-ellipse":"Ellipse","shape-line":"Line","shape-line-width":"Line Width","shape-outwards":"Outwards","shape-fixed":"Fixed 1:1","shape-auto-pan":"Auto-pan","shape-auto-pan-title":"Automatically moves as you draw","text-instruction":"Click canvas to place text","text-title":"Add Text","text-text":"Text","text-font":"Font","text-placeholder":"Your text","text-color":"Color","text-size":"Size","text-line-height":"Line Height","text-letter-spacing":"Letter Spacing","text-left":"Left","text-center":"Center","text-right":"Right","text-italic":"Italic","text-bold":"Bold","text-failed-import":"Failed to import the following files:","text-supported-formats":"Supported formats:","select-select":"Select","select-transform":"Transform","select-lasso":"Lasso","select-polygon":"Polygon","select-boolean-replace":"Replace","select-boolean-add":"Add","select-boolean-subtract":"Subtract","select-all":"All","select-invert":"Invert","select-reset":"Reset","select-fill":"Fill","select-erase":"Erase","select-transform-clone":"Clone","select-transform-clone-applied":"Cloned","select-transform-move-to-layer":"Move to layer:","select-transform-applied":"Transformation applied","select-transform-empty":"Selected area on active layer is empty.","save-reminder-title":"Unsaved Work","save-reminder-text":"Image was not saved in {a} minutes{b}. Save now to prevent eventual loss.","save-reminder-save-psd":"Save As PSD","save-reminder-psd-layers":"PSD will remember all layers.","backup-drawing":"You can backup your drawing.","submit":"Submit","submit-title":"Submit Drawing","submit-prompt":"Submit drawing?","submit-submitting":"Submitting","embed-init-loading":"Loading app","embed-init-waiting":"Waiting for image","help":"Help","tab-settings":"Settings","settings-language":"Language","settings-language-reload":"Will update after reloading.","settings-theme":"Theme","settings-save-reminder-label":"Save Reminder","settings-save-reminder-disabled":"disabled","settings-save-reminder-confirm-title":"Turn off Save Reminder?","settings-save-reminder-confirm-a":"There is no autosave and browser tabs don\'t last forever. If you don\'t periodically save you will likely lose work.","settings-save-reminder-confirm-b":"Disable at your own risk?","settings-save-reminder-confirm-disable":"Disable","theme-dark":"Dark","theme-light":"Light","terms-of-service":"Terms of Service","licenses":"Licenses","source-code":"Source Code","auto":"auto","zoom-in":"Zoom In","zoom-out":"Zoom Out","radius":"Radius","constrain-proportions":"Constrain Proportions","width":"Width","height":"Height","opacity":"Opacity","scatter":"Scatter","red":"Red","green":"Green","blue":"Blue","eraser":"Eraser","center":"Center","layers":"Layers","background":"Background","scaling-algorithm":"Scaling Algorithm","algorithm-smooth":"Smooth","algorithm-pixelated":"Pixelated","preview":"Preview","angle-snap":"Snap","angle-snap-title":"45\xb0 Angle Snapping","lock-alpha":"Lock Alpha","lock-alpha-title":"Locks layer\'s alpha channel","reverse":"Reverse","compare-before":"Before","compare-after":"After","loading":"Loading","more":"More","x-minutes":"{x}min","wip":"Work in progress","browser-zoom-help":"Double-tap or pinch-out to reset browser zoom.","dismiss":"Dismiss"}');

},{}],"9NT8r":[function(require,module,exports,__globalThis) {
module.exports = import("./de.c4354d88.js").then(()=>module.bundle.root('eG4RV'));

},{"eG4RV":"eG4RV"}],"eLv87":[function(require,module,exports,__globalThis) {
module.exports = import("./es.c803f839.js").then(()=>module.bundle.root('KK4Io'));

},{"KK4Io":"KK4Io"}],"aw946":[function(require,module,exports,__globalThis) {
module.exports = import("./fi.377694cc.js").then(()=>module.bundle.root('9cTLq'));

},{"9cTLq":"9cTLq"}],"hbLhO":[function(require,module,exports,__globalThis) {
module.exports = import("./fr.9e239a10.js").then(()=>module.bundle.root('88TCU'));

},{"88TCU":"88TCU"}],"1PCSS":[function(require,module,exports,__globalThis) {
module.exports = import("./hu.6ab39b53.js").then(()=>module.bundle.root('dpvNl'));

},{"dpvNl":"dpvNl"}],"86wmw":[function(require,module,exports,__globalThis) {
module.exports = import("./id.b62850c5.js").then(()=>module.bundle.root('kjQyW'));

},{"kjQyW":"kjQyW"}],"hdHH8":[function(require,module,exports,__globalThis) {
module.exports = import("./ja.a58ebabd.js").then(()=>module.bundle.root('bsob2'));

},{"bsob2":"bsob2"}],"cunkz":[function(require,module,exports,__globalThis) {
module.exports = import("./jv.1bf872f3.js").then(()=>module.bundle.root('8pbYd'));

},{"8pbYd":"8pbYd"}],"al2lS":[function(require,module,exports,__globalThis) {
module.exports = import("./ko.08bd2b9e.js").then(()=>module.bundle.root('dpdrV'));

},{"dpdrV":"dpdrV"}],"dbhmD":[function(require,module,exports,__globalThis) {
module.exports = import("./lv.e257a609.js").then(()=>module.bundle.root('k2wtJ'));

},{"k2wtJ":"k2wtJ"}],"kYXl1":[function(require,module,exports,__globalThis) {
module.exports = import("./nl.f9f11996.js").then(()=>module.bundle.root('cYOZ3'));

},{"cYOZ3":"cYOZ3"}],"gS0kP":[function(require,module,exports,__globalThis) {
module.exports = import("./pt-BR.7b5f66cd.js").then(()=>module.bundle.root('7yyvT'));

},{"7yyvT":"7yyvT"}],"i2DHf":[function(require,module,exports,__globalThis) {
module.exports = import("./ru.7a39819d.js").then(()=>module.bundle.root('9eB8i'));

},{"9eB8i":"9eB8i"}],"f0o1s":[function(require,module,exports,__globalThis) {
module.exports = import("./su.374d6d8b.js").then(()=>module.bundle.root('fqM0J'));

},{"fqM0J":"fqM0J"}],"6QUlt":[function(require,module,exports,__globalThis) {
module.exports = import("./sv.9319fcd1.js").then(()=>module.bundle.root('gk47B'));

},{"gk47B":"gk47B"}],"3nc47":[function(require,module,exports,__globalThis) {
module.exports = import("./zh-CN.00e00499.js").then(()=>module.bundle.root('78jb2'));

},{"78jb2":"78jb2"}],"cLj9j":[function(require,module,exports,__globalThis) {
module.exports = import("./zh-TW.11f2bb48.js").then(()=>module.bundle.root('ih0DG'));

},{"ih0DG":"ih0DG"}],"l2GAy":[function(require,module,exports,__globalThis) {
window.onscroll = (e)=>{
    e.preventDefault();
};

},{}],"kcuhT":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("cancel.b4ce6a28.svg") + "?" + Date.now();

},{}],"8cC21":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("check.46a6ec75.svg") + "?" + Date.now();

},{}],"fV9n3":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("remove-layer.fe38f9b0.svg") + "?" + Date.now();

},{}],"3DApo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * popup that fill whole height, with some padding.
 * currently only used for iframe popups.
 */ parcelHelpers.export(exports, "DynamicModal", ()=>DynamicModal);
var _modalCount = require("../modal-count");
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _scrollFix = require("./scroll-fix");
var _cancelSvg = require("url:/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
var _base = require("../../../../bb/base/base");
class DynamicModal {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        (0, _modalCount.DIALOG_COUNTER).increase();
        this.onClose = p.onClose;
        this.parent = document.body;
        this.rootEl = (0, _bb.BB).el({
            parent: this.parent,
            className: 'g-root kl-d-modal-root',
            css: {
                position: 'fixed',
                left: '0',
                top: '0',
                bottom: '0',
                right: '0',
                overflow: 'auto',
                animationName: 'consoleIn',
                animationDuration: '0.3s',
                animationTimingFunction: 'ease-out'
            },
            onClick: (0, _bb.BB).handleClick
        });
        //background element registering clicks
        this.bgEl = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                position: 'absolute',
                left: '0',
                top: '0',
                bottom: '0',
                right: '0'
            },
            onClick: ()=>this.close()
        });
        //the actual popup box
        const popupEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'kl-d-modal',
            css: {
                position: 'absolute',
                width: (0, _bb.BB).isCssMinMaxSupported() ? 'min(calc(100% - 40px), ' + (p.width ? p.width : 400) + 'px)' : (p.width ? p.width : 400) + 'px',
                height: 'calc(100% - 40px)',
                borderRadius: '10px',
                overflow: 'hidden'
            }
        });
        //x and y position via script. flex not powerful enough imo
        this.updatePos = ()=>{
            const elW = popupEl.offsetWidth;
            const elH = popupEl.offsetHeight;
            (0, _base.css)(popupEl, {
                left: Math.max(0, (window.innerWidth - elW) / 2) + 'px',
                top: Math.max(20, (window.innerHeight - elH) / 2 - elH * 0.2) + 'px'
            });
        };
        this.updatePos();
        window.addEventListener('resize', this.updatePos);
        //title row in popup
        const titleHeight = 40;
        const titleEl = (0, _bb.BB).el({
            parent: popupEl,
            css: {
                height: titleHeight + 'px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                paddingLeft: titleHeight / 2 + 'px'
            }
        });
        if (p.title) titleEl.append(p.title);
        this.xButton = (0, _bb.BB).el({
            parent: titleEl,
            tagName: 'button',
            className: 'popup-x',
            content: `<img alt="${(0, _language.LANG)('modal-close')}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
            title: (0, _language.LANG)('modal-close'),
            onClick: ()=>this.close(),
            css: {
                width: titleHeight + 'px',
                height: titleHeight + 'px',
                lineHeight: titleHeight + 'px',
                background: 'none',
                boxShadow: 'none'
            },
            custom: {
                tabindex: '0'
            }
        });
        const contentEl = (0, _bb.BB).el({
            parent: popupEl,
            css: {
                height: 'calc(100% - ' + titleHeight + 'px)'
            }
        });
        if (p.content) contentEl.append(p.content);
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, e)=>{
                if (keyStr === 'esc') {
                    e.stopPropagation();
                    e.preventDefault(); // stay in fullscreen on Mac
                    this.close();
                }
            }
        });
    }
    // ---- interface ----
    close() {
        (0, _modalCount.DIALOG_COUNTER).decrease();
        (0, _bb.BB).destroyEl(this.rootEl);
        this.rootEl.remove();
        window.removeEventListener('resize', this.updatePos);
        this.keyListener.destroy();
        (0, _bb.BB).destroyEl(this.xButton);
        (0, _bb.BB).destroyEl(this.bgEl);
        this.onClose && this.onClose();
    }
}

},{"../modal-count":"60MST","../../../../bb/bb":"3zOvT","../../../../language/language":"mcywn","./scroll-fix":"l2GAy","url:/src/app/img/ui/cancel.svg":"kcuhT","../../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9bXL6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checkbox - with label
 */ parcelHelpers.export(exports, "Checkbox", ()=>Checkbox);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class Checkbox {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.doHighlight = !!p.doHighlight;
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-checkbox'
        });
        const innerEl = (0, _bb.BB).el({
            parent: this.rootEl,
            tagName: 'label',
            className: 'kl-checkbox__inner',
            css: {
                display: 'flex'
            }
        });
        this.check = (0, _bb.BB).el({
            parent: innerEl,
            tagName: 'input',
            css: {
                margin: '0 5px 0 0'
            },
            custom: {
                type: 'checkbox',
                name: p.name
            }
        });
        this.check.checked = !!p.init;
        if (this.doHighlight && this.check.checked) this.rootEl.classList.add('kl-checkbox--highlight');
        if (!p.allowTab) this.check.tabIndex = -1;
        if (p.title) innerEl.title = p.title;
        const label = (0, _bb.BB).el({
            parent: innerEl,
            content: p.label,
            css: {}
        });
        this.check.onchange = ()=>{
            if (this.doHighlight) this.rootEl.classList.toggle('kl-checkbox--highlight', this.check.checked);
            p.callback && p.callback(this.check.checked);
            setTimeout(()=>{
                this.check.blur();
            }, 0);
        };
        if (p.css) (0, _base.css)(this.rootEl, p.css);
    }
    getValue() {
        return this.check.checked;
    }
    setValue(b) {
        this.check.checked = b;
        if (this.doHighlight) this.rootEl.classList.toggle('kl-checkbox--highlight', this.check.checked);
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.check.onchange = null;
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e8FQP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Input", ()=>Input);
parcelHelpers.export(exports, "input", ()=>input);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class Input {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.keyListener = {
            destroy: ()=>{}
        };
        this.rootEl = (0, _bb.BB).el({
            tagName: 'label',
            content: p.label,
            css: {
                display: 'flex',
                alignItems: 'center',
                gap: '5px'
            }
        });
        this.input = (0, _bb.BB).el({
            tagName: 'input',
            parent: this.rootEl,
            title: p.title,
            custom: {
                name: p.name
            }
        });
        this.type = p.type ?? 'text';
        try {
            this.input.type = this.type;
        } catch (e) {
        // ie can't deal with number
        }
        const stepSize = p.step ?? 1;
        if (this.type === 'number') {
            if (p.min !== undefined) this.input.min = '' + p.min;
            if (p.max !== undefined) this.input.max = '' + p.max;
            if (p.step !== undefined) this.input.step = '' + stepSize;
        }
        this.input.value = '' + p.init;
        let lastValidValue = this.input.value;
        /**
         * return true if not changed
         */ const handleChange = ()=>{
            const oldVal = lastValidValue;
            let newValue = this.input.value;
            if (p.doResetIfInvalid) {
                let didChange = false;
                if (newValue === '') {
                    newValue = lastValidValue;
                    didChange = true;
                }
                if (p.min !== undefined && parseFloat(newValue) < p.min) {
                    newValue = '' + p.min;
                    didChange = true;
                }
                if (p.max !== undefined && parseFloat(newValue) > p.max) {
                    newValue = '' + p.max;
                    didChange = true;
                }
                if (didChange) this.input.value = '' + newValue;
            }
            lastValidValue = newValue;
            return oldVal !== newValue;
        };
        if (p.onChange) {
            const onChange = p.onChange;
            this.input.onchange = ()=>{
                handleChange() && onChange(this.input.value);
            };
        }
        if (p.css) (0, _base.css)(this.input, p.css);
        if (p.doScrollWithoutFocus && p.type === 'number' && p.onChange) {
            const onChange = p.onChange;
            this.keyListener = new (0, _bb.BB).KeyListener({});
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.input,
                onWheel: (e)=>{
                    /*if (document.hasFocus()) { // what was the point of this?
                        return;
                    }*/ const fac = this.keyListener.isPressed('shift') ? 4 : 1;
                    this.input.value = '' + (parseFloat(this.input.value) - e.deltaY * stepSize * fac);
                    handleChange() && onChange(this.input.value);
                }
            });
        }
    }
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.input.value;
    }
    setValue(v) {
        this.input.value = '' + v;
    }
    destroy() {
        this.pointerListener && this.pointerListener.destroy();
        this.keyListener.destroy();
    }
}
const input = function(params) {
    const result = document.createElement('input');
    if (params.type) try {
        result.type = params.type;
    } catch (e) {
    /* empty */ // ie can't deal with number
    }
    else result.type = 'text';
    if (params.min !== undefined) result.min = '' + params.min;
    if (params.max !== undefined) result.max = '' + params.max;
    result.value = '' + params.init;
    if (params.callback) result.onchange = function() {
        params.callback(result.value);
    };
    if (params.css) (0, _base.css)(result, params.css);
    return result;
};

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iuUFh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A select dropdown
 */ parcelHelpers.export(exports, "Select", ()=>Select);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class Select {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.optionArr = [];
        this.selectEl = (0, _bb.BB).el({
            tagName: 'select',
            title: p.title,
            className: 'kl-select',
            css: {
                cursor: 'pointer',
                fontSize: '15px',
                padding: '3px'
            },
            custom: {
                name: p.name
            }
        });
        if (p.css) (0, _base.css)(this.selectEl, p.css);
        const isFocusable = p.isFocusable;
        if (!isFocusable) this.selectEl.tabIndex = -1;
        this.setOptionArr(p.optionArr);
        if (p.onChange) this.onChange = p.onChange;
        this.changeListener = ()=>{
            if (!isFocusable) this.selectEl.blur();
            this.onChange && this.onChange(this.getValue());
        };
        this.selectEl.addEventListener('change', this.changeListener);
        this.selectEl.value = p.initValue !== undefined ? p.initValue : '';
    }
    setValue(val) {
        this.selectEl.value = val === undefined ? '' : val;
    }
    getValue() {
        return this.selectEl.value;
    }
    setDeltaValue(delta) {
        let index = 0;
        for(let i = 0; i < this.optionArr.length; i++){
            const option = this.optionArr[i];
            if (option.item && '' + option.item[0] === this.selectEl.value) {
                index = i;
                break;
            }
        }
        index = Math.max(0, Math.min(this.optionArr.length - 1, index + delta));
        const option = this.optionArr[index];
        this.selectEl.value = option.item ? option.item[0] : '';
        this.onChange && this.onChange(this.getValue());
    }
    getElement() {
        return this.selectEl;
    }
    updateLabel(id, label) {
        this.optionArr.forEach((option)=>{
            if (option.item && option.item[0] === id && option.el) {
                option.item[1] = label;
                option.el.textContent = option.item[1];
            }
        });
    }
    setOptionArr(optionArr) {
        const oldVal = this.selectEl.value;
        this.optionArr = [];
        this.selectEl.innerHTML = '';
        for(let i = 0; i < optionArr.length; i++){
            const item = optionArr[i];
            if (!item) {
                this.optionArr.push({
                    item
                });
                continue;
            }
            const el = document.createElement('option');
            el.value = item[0];
            el.textContent = item[1];
            if (item[2]) (0, _base.css)(el, item[2].css);
            this.optionArr.push({
                item,
                el
            });
            this.selectEl.append(el);
        }
        // restore old value
        if (oldVal === '' || optionArr.findIndex((item)=>item && item[0] === oldVal) > -1) this.setValue(oldVal);
    }
    destroy() {
        this.selectEl.removeEventListener('change', this.changeListener);
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6pxUz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Toggle button with an image
 */ parcelHelpers.export(exports, "ImageToggle", ()=>ImageToggle);
var _bb = require("../../../bb/bb");
class ImageToggle {
    update() {
        this.rootEl.classList.toggle('image-toggle-active', this.isActive);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isActive = p.initValue;
        this.rootEl = (0, _bb.BB).el({
            className: 'image-toggle',
            title: p.title,
            content: (0, _bb.BB).el({
                className: 'image-toggle__im' + (p.darkInvert ? ' dark-invert' : ''),
                css: {
                    backgroundImage: "url('" + p.image + "')"
                }
            }),
            onClick: (e)=>{
                e.preventDefault();
                if (p.isRadio && this.isActive) return;
                this.isActive = !this.isActive;
                this.update();
                p.onChange(this.isActive);
            }
        });
        this.update();
    }
    // --- interface ---
    setValue(b) {
        this.isActive = b;
        this.update();
    }
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.isActive;
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.rootEl);
    }
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fAfrJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Radio input group. each one has an image
 */ parcelHelpers.export(exports, "ImageRadioList", ()=>ImageRadioList);
var _bb = require("../../../bb/bb");
var _imageToggle = require("./image-toggle");
class ImageRadioList {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: 'image-radio-wrapper',
            css: {
                display: 'flex'
            }
        });
        this.optionArr = [];
        const select = (index, id)=>{
            this.activeIndex = index;
            for(let i = 0; i < this.optionArr.length; i++)this.optionArr[i].radioEl.setValue(i === this.activeIndex);
            p.onChange(id);
        };
        let initialIndex;
        const createOption = (index, o)=>{
            if (o.id === p.initId) initialIndex = index;
            const radioEl = new (0, _imageToggle.ImageToggle)({
                image: o.image,
                title: o.title,
                initValue: o.id === p.initId,
                isRadio: true,
                onChange: ()=>{
                    select(index, o.id);
                },
                darkInvert: o.darkInvert
            });
            this.rootEl.append(radioEl.getElement());
            return {
                id: o.id,
                radioEl
            };
        };
        for(let i = 0; i < p.optionArr.length; i++)this.optionArr.push(createOption(i, p.optionArr[i]));
        if (initialIndex === undefined) throw new Error('initId not in optionArr');
        this.activeIndex = initialIndex;
    }
    // --- interface ---
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.optionArr[this.activeIndex].id;
    }
    destroy() {
        this.optionArr.forEach((item)=>{
            item.radioEl.destroy();
        });
    }
}

},{"../../../bb/bb":"3zOvT","./image-toggle":"6pxUz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"drOTJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPenPressureToggle", ()=>createPenPressureToggle);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _brushPressureSvg = require("url:/src/app/img/ui/brush-pressure.svg");
var _brushPressureSvgDefault = parcelHelpers.interopDefault(_brushPressureSvg);
var _boxToggle = require("./box-toggle");
const createPenPressureToggle = function(isChecked, changeCallback) {
    const toggleEl = new (0, _boxToggle.BoxToggle)({
        label: (0, _bb.BB).el({
            className: 'dark-invert',
            css: {
                width: '17px',
                height: '17px',
                backgroundImage: 'url("' + (0, _brushPressureSvgDefault.default) + '")',
                backgroundSize: 'contain',
                backgroundRepeat: 'no-repeat',
                margin: '1px',
                borderRadius: '3px'
            }
        }),
        title: (0, _language.LANG)('brush-toggle-pressure'),
        init: isChecked,
        onChange: (b)=>{
            changeCallback(b);
        }
    });
    return toggleEl.getElement();
};

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","url:/src/app/img/ui/brush-pressure.svg":"kcvYS","./box-toggle":"1YB1o","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kcvYS":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-pressure.0966db85.svg") + "?" + Date.now();

},{}],"1YB1o":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BoxToggle", ()=>BoxToggle);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class BoxToggle {
    update() {
        this.el.classList.toggle('kl-box-toggle--active', this.value);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.value = !!p.init;
        this.el = (0, _bb.BB).el({
            content: p.label,
            title: p.title,
            className: typeof p.label === 'string' ? 'kl-box-toggle' : 'kl-box-toggle kl-box-toggle--custom-el',
            onClick: ()=>{
                this.value = !this.value;
                this.update();
                p.onChange(this.value);
            },
            css: {
                cursor: 'pointer'
            }
        });
        if (typeof p.label !== 'string') (0, _base.css)(p.label, {
            display: 'block',
            pointerEvents: 'none'
        });
        this.update();
    }
    getValue() {
        return this.value;
    }
    setValue(b) {
        this.value = b;
        this.update();
    }
    getElement() {
        return this.el;
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.el);
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fQOKQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Horizontal slider, can be changed by dragging anywhere on it. Has a label & value.
 * e.g. used for brush size
 *
 * left mouse button - set absolute value
 * right mouse button - change relative value
 * drag mouse vertically away - precision mode
 * double-click/tap slider - manual input mode
 *
 * Values can be spline interpolated
 * On change callback can be debounced
 *
 */ parcelHelpers.export(exports, "KlSlider", ()=>KlSlider);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
var _language = require("../../../language/language");
var _klSliderManualInput = require("./kl-slider-manual-input");
var _base = require("../../../bb/base/base");
class KlSlider {
    valueToSliderValue(value) {
        if (this.useSpline && this.splineInterpolator) return this.splineInterpolator.findX(value, Math.floor(this.resolution)) || 0;
        return (value - this.min) / (this.max - this.min);
    }
    sliderValueToValue(sliderValue) {
        let result = this.min + sliderValue * (this.max - this.min);
        if (this.useSpline && this.splineInterpolator) result = this.splineInterpolator.interpolate(sliderValue) || 0;
        return result;
    }
    updateLabel() {
        let displayValue = this.valueToDisplayValue(this.value);
        displayValue = this.formatFunc ? this.formatFunc(displayValue) : Math.round(displayValue);
        displayValue = displayValue.toLocaleString((0, _language.LANGUAGE_STRINGS).getCode());
        const unit = this.unit !== undefined ? this.unit : '';
        this.labelValueEl.textContent = displayValue + unit;
        const sliderValue = this.valueToSliderValue(this.value);
        this.control.style.width = sliderValue * this.elementWidth + 'px';
    }
    emit(isFinal) {
        if (!isFinal && this.isChangeOnFinal) return;
        if (isFinal || !this.eventResMs) {
            this.onChange(this.value);
            if (this.emitInterval) {
                clearInterval(this.emitInterval);
                this.emitInterval = undefined;
            }
            return;
        }
        if (this.emitInterval) this.emitValue = this.value;
        else {
            this.onChange(this.value);
            this.emitInterval = setInterval(()=>{
                if (this.emitValue === undefined) {
                    clearInterval(this.emitInterval);
                    this.emitInterval = undefined;
                } else {
                    this.onChange(this.emitValue);
                    this.emitValue = undefined;
                }
            }, this.eventResMs);
        }
    }
    updateEnable() {
        this.sliderWrapperEl.classList.toggle('slider-wrapper--disabled', !this.isEnabled);
        (0, _base.css)(this.sliderWrapperEl, {
            opacity: this.isEnabled ? '' : '0.5',
            pointerEvents: this.isEnabled ? '' : 'none'
        });
        if (this.manualInput) this.manualInput.setIsEnabled(this.isEnabled);
    }
    showManualInput() {
        this.manualInput = new (0, _klSliderManualInput.KlSliderManualInput)(this.valueToDisplayValue(this.value), this.valueToDisplayValue(this.min), this.valueToDisplayValue(this.max), this.sliderWrapperEl.getBoundingClientRect(), (val)=>{
            val = this.displayValueToValue(val);
            this.setValue((0, _bb.BB).clamp(val, this.min, this.max));
            this.onChange(this.value);
        }, ()=>{
            (0, _base.css)(this.sliderWrapperEl, {
                display: ''
            });
            if (this.manualInput) {
                this.manualInput.getElement().remove();
                this.manualInput.destroy();
            }
            this.manualInput = undefined;
        }, this.manualInputRoundDigits && this.manualInputRoundDigits > 0 ? this.manualInputRoundDigits : 0);
        this.manualInput.setIsEnabled(this.isEnabled);
        this.rootEl.append(this.manualInput.getElement());
        setTimeout(()=>{
            this.manualInput && this.manualInput.focus();
        });
        (0, _base.css)(this.sliderWrapperEl, {
            display: 'none'
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isEnabled = p.isEnabled !== false;
        this.manualInputRoundDigits = p.manualInputRoundDigits;
        this.useSpline = !!p.curve;
        if (!p.label) throw new Error('KlSlider missing params');
        if (p.min != 0 && p.max != 0 && p.value != 0) {
            if (!p.min || !p.max || !p.value) throw new Error('KlSlider broken params');
        }
        if (p.min >= p.max) throw new Error('KlSlider broken params');
        this.min = p.min;
        this.max = p.max;
        this.value = (0, _bb.BB).clamp(p.value, this.min, this.max);
        this.elementWidth = p.width;
        this.elementHeight = p.height;
        this.resolution = p.resolution ? p.resolution : this.elementWidth * 2;
        this.onChange = p.onChange ? p.onChange : ()=>{};
        if (!p.toValue !== !p.toDisplayValue) throw new Error('both or neither have to be set, toValue and toDisplayValue');
        this.displayValueToValue = p.toValue ? p.toValue : (displayValue)=>displayValue;
        this.valueToDisplayValue = p.toDisplayValue ? p.toDisplayValue : (value)=>value;
        this.isChangeOnFinal = !!p.isChangeOnFinal;
        this.formatFunc = p.formatFunc;
        this.eventResMs = p.eventResMs;
        this.unit = p.unit;
        if (this.useSpline) {
            if (!p.curve) throw new Error('curve needs to be set if useSpline true');
            const curveArr = p.curve === 'quadratic' ? (0, _bb.BB).powerSplineInput(this.min, this.max, 0.1) : p.curve;
            this.splineInterpolator = new (0, _bb.BB).SplineInterpolator(curveArr);
        }
        this.rootEl = (0, _bb.BB).el({
            css: {
                display: 'flex'
            }
        });
        this.sliderWrapperEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'slider-wrapper',
            css: {
                overflow: 'hidden',
                position: 'relative',
                width: this.elementWidth + 'px',
                height: this.elementHeight + 'px',
                userSelect: 'none'
            }
        });
        this.rootEl.oncontextmenu = function() {
            return false;
        };
        this.label = p.label;
        const labelFontSize = this.elementHeight - 14;
        this.labelValueEl = (0, _bb.BB).el({
            css: {
                fontWeight: 'bold'
            }
        });
        this.textEl = (0, _bb.BB).el({
            content: [
                (0, _bb.BB).el({
                    content: this.label,
                    css: {
                        overflow: 'hidden',
                        textOverflow: 'ellipsis'
                    }
                }),
                this.labelValueEl
            ],
            css: {
                position: 'absolute',
                display: 'flex',
                alignItems: 'center',
                padding: '0 7px',
                height: '100%',
                width: '100%',
                fontSize: labelFontSize + 'px',
                pointerEvents: 'none',
                gap: '8px'
            }
        });
        this.control = (0, _bb.BB).el({
            className: 'slider-inner',
            css: {
                position: 'absolute',
                left: '0',
                top: '0',
                width: this.valueToSliderValue(this.value) * this.elementWidth + 'px',
                height: this.elementHeight + 'px'
            }
        });
        const controlInner = document.createElement('div');
        this.sliderWrapperEl.append(this.control, this.textEl);
        this.control.append(controlInner);
        this.updateEnable();
        const doubleTapper = new (0, _bb.BB).DoubleTapper({
            onDoubleTap: ()=>{
                this.showManualInput();
            }
        });
        doubleTapper.setAllowedButtonArr([
            'left',
            'right'
        ]);
        const eventChain = new (0, _bb.BB).EventChain({
            chainArr: [
                doubleTapper
            ]
        });
        let virtualVal;
        const onPointer = (event)=>{
            event.eventPreventDefault();
            if (!this.isEnabled) return;
            if (event.type === 'pointerdown') {
                // unfocus manual slider input
                (0, _bb.BB).unfocusAnyInput();
                this.sliderWrapperEl.className = 'slider-wrapper slider-wrapper--active';
                if (event.button === 'left') {
                    let sliderValue = event.relX / this.elementWidth;
                    sliderValue = Math.max(0, Math.min(1, sliderValue));
                    this.value = this.sliderValueToValue(sliderValue);
                    this.updateLabel();
                    this.emit(false);
                }
                virtualVal = this.valueToSliderValue(this.value);
            }
            if (event.type === 'pointermove' && [
                'left',
                'right'
            ].includes(event.button || '')) {
                let deltaX = event.dX;
                const deltaY = Math.abs(event.pageY - (event.downPageY || 0));
                const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === 'right');
                deltaX *= factor;
                deltaX /= this.elementWidth;
                virtualVal += deltaX;
                const sliderValue = Math.max(0, Math.min(1, virtualVal));
                this.value = this.sliderValueToValue(sliderValue);
                this.updateLabel();
                this.emit(false);
            }
            if (event.type === 'pointerup') {
                this.sliderWrapperEl.className = 'slider-wrapper';
                this.emit(true);
            }
        };
        this.pointerListenerTimeout = setTimeout(()=>{
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.sliderWrapperEl,
                fixScribble: true,
                onPointer: (e)=>{
                    onPointer(e);
                    eventChain.chainIn(e);
                },
                onWheel: (event)=>{
                    let sliderValue = this.valueToSliderValue(this.value);
                    sliderValue = (0, _bb.BB).clamp(sliderValue - event.deltaY / 40, 0, 1);
                    this.value = this.sliderValueToValue(sliderValue);
                    this.updateLabel();
                    this.onChange(this.value);
                }
            });
            this.updateLabel();
        }, 1);
    }
    changeSliderValue(f) {
        if (!this.isEnabled) return;
        let sliderValue = this.valueToSliderValue(this.value);
        sliderValue = (0, _bb.BB).clamp(sliderValue + f, 0, 1);
        this.value = this.sliderValueToValue(sliderValue);
        this.updateLabel();
        this.onChange(this.value);
    }
    setValue(v) {
        this.value = (0, _bb.BB).clamp(v, this.min, this.max);
        this.updateLabel();
    }
    getValue() {
        return this.value;
    }
    getDisplayValue() {
        return this.valueToDisplayValue(this.value);
    }
    update(config) {
        this.min = config.min;
        this.max = config.max;
        this.useSpline = !!config.curve;
        if (this.useSpline) {
            if (!config.curve) throw new Error('curve needs to be set if useSpline true');
            const curveArr = config.curve === 'quadratic' ? (0, _bb.BB).powerSplineInput(this.min, this.max, 0.1) : config.curve;
            this.splineInterpolator = new (0, _bb.BB).SplineInterpolator(curveArr);
        } else this.splineInterpolator = undefined;
        this.setIsEnabled(!config.isDisabled);
    }
    setIsEnabled(e) {
        this.isEnabled = e;
        this.updateEnable();
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        clearTimeout(this.pointerListenerTimeout);
        this.pointerListener && this.pointerListener.destroy();
        if (this.manualInput) this.manualInput.destroy();
        if (this.emitInterval) clearInterval(this.emitInterval);
    }
}

},{"../../../bb/bb":"3zOvT","./slider-falloff":"e8ZzL","../../../language/language":"mcywn","./kl-slider-manual-input":"fqPQ8","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e8ZzL":[function(require,module,exports,__globalThis) {
/**
 * To make sliders more fine-grained. The falloff when moving cursor away from cursor.
 * Returns the factor [0,1]
 *  0 -> infinite movement required for change of 1
 *  1 -> 1px movement for change of 1
 *
 * @param deltaY vertical distance from pointerdown
 * @param isRightButton
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calcSliderFalloffFactor", ()=>calcSliderFalloffFactor);
function calcSliderFalloffFactor(deltaY, isRightButton) {
    let result = Math.min(10, 1 + Math.pow(Math.floor(deltaY / 50), 2));
    if (isRightButton) result *= 2;
    return 1 / result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqPQ8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Used by KlSlider. Allows user to type in value in input (type=number) field, instead of dragging with mouse.
 * Input goes away when losing focus, or when pressing Enter/Escape.
 */ parcelHelpers.export(exports, "KlSliderManualInput", ()=>KlSliderManualInput);
var _bb = require("../../../bb/bb");
var _input = require("./input");
var _base = require("../../../bb/base/base");
class KlSliderManualInput {
    emit() {
        if (this.lastValue !== Number(this.input.value)) {
            this.onChange(Number(this.input.value));
            this.lastValue = Number(this.input.value);
        }
    }
    privateOnClose() {
        if (this.isClosed) return;
        this.isClosed = true;
        this.emit();
        this.onClose();
        setTimeout(()=>{
            // because iPad keyboard changes the scroll position
            this.scrollBefore && window.scrollTo(this.scrollBefore.x, this.scrollBefore.y);
            this.scrollBefore = undefined;
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(value, min, max, rect, onChange, onClose, roundDigits){
        this.onChange = onChange;
        this.onClose = onClose;
        this.isEnabled = true;
        this.isClosed = false;
        this.input = (0, _input.input)({
            type: 'number',
            init: value,
            min,
            max,
            callback: (val)=>{
                this.emit();
            }
        });
        if (roundDigits !== 0) this.input.setAttribute('step', 'any');
        this.input.onblur = ()=>{
            this.privateOnClose();
        };
        this.input.addEventListener('keyup', (e)=>{
            if ([
                'Enter',
                'Escape'
            ].includes(e.key)) this.privateOnClose();
            else this.emit();
        }, {
            passive: false
        });
        this.input.addEventListener('wheel', ()=>this.emit(), {
            passive: false
        });
        this.scrollBefore = {
            x: window.scrollX,
            y: window.scrollY
        };
        let currentValue;
        if (roundDigits || roundDigits === 0) currentValue = (0, _bb.BB).round(value, roundDigits);
        else currentValue = value;
        this.lastValue = currentValue;
        this.input.value = '' + currentValue;
        (0, _base.css)(this.input, {
            width: rect.width + 'px',
            height: rect.height + 'px'
        });
    }
    getElement() {
        return this.input;
    }
    setIsEnabled(b) {
        this.isEnabled = b;
    }
    focus() {
        this.input.focus();
        this.input.select();
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.input);
    }
}

},{"../../../bb/bb":"3zOvT","./input":"e8FQP","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"arnzW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * dialog for manually inputting the color
 */ parcelHelpers.export(exports, "HexColorDialog", ()=>HexColorDialog);
var _bb = require("../../../bb/bb");
var _input = require("../components/input");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
var _copySvg = require("url:/src/app/img/ui/copy.svg");
var _copySvgDefault = parcelHelpers.interopDefault(_copySvg);
var _c = require("../../../bb/base/c");
var _colorSliderHexDialogModuleScss = require("./color-slider-hex-dialog.module.scss");
class HexColorDialog {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        let lastValidRgb = new (0, _bb.BB).RGB(p.color.r, p.color.g, p.color.b);
        const previewEl = (0, _bb.BB).el({
            css: {
                width: '20px',
                height: '20px',
                marginBottom: '10px',
                boxShadow: 'inset 0 0 0 1px #fff, 0 0 0 1px #000',
                background: '#' + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb)
            }
        });
        // --- Hex ---
        const hexLabel = (0, _bb.BB).el({
            content: (0, _language.LANG)('mci-hex')
        });
        const hexInput = (0, _input.input)({
            init: '#' + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb),
            css: {
                width: '80px'
            },
            callback: function() {
                let rgbObj = (0, _bb.BB).ColorConverter.hexToRGB(hexInput.value);
                if (!rgbObj) {
                    rgbObj = lastValidRgb;
                    hexInput.value = '#' + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
                } else lastValidRgb = rgbObj;
                previewEl.style.background = '#' + (0, _bb.BB).ColorConverter.toHexString(rgbObj);
                for(let i = 0; i < rgbArr.length; i++)rgbArr[i].update();
            }
        });
        const copyButton = (0, _bb.BB).el({
            tagName: 'button',
            content: '<img src="' + (0, _copySvgDefault.default) + '" height="20" alt=""/>',
            title: (0, _language.LANG)('mci-copy'),
            onClick: function() {
                hexInput.select();
                navigator.clipboard.writeText(hexInput.value).then().catch();
            }
        });
        const hexRowEl = (0, _c.c)({
            css: {
                display: 'flex',
                alignItems: 'center',
                marginBottom: '15px',
                flexWrap: 'wrap',
                gap: '5px 10px',
                maxWidth: '250px'
            }
        }, [
            hexLabel,
            (0, _c.c)(',flex,items-center,gap-10', [
                hexInput,
                copyButton
            ])
        ]);
        setTimeout(function() {
            hexInput.focus();
            hexInput.select();
        }, 0);
        // --- R G B ---
        function createRgbInputRow(labelStr, attributeStr) {
            const inputEl = (0, _input.input)({
                init: lastValidRgb[attributeStr],
                min: 0,
                max: 255,
                type: 'number',
                css: {
                    width: '80px'
                },
                callback: function() {
                    if (inputEl.value === '' || parseFloat(inputEl.value) < 0 || parseFloat(inputEl.value) > 255) {
                        result.update();
                        return;
                    }
                    inputEl.value = '' + Math.round(parseFloat(inputEl.value));
                    lastValidRgb[attributeStr] = Number(inputEl.value);
                    previewEl.style.background = '#' + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
                    hexInput.value = '#' + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
                }
            });
            const rowEl = (0, _c.c)('tr', [
                (0, _c.c)('td,pr-10', labelStr),
                (0, _c.c)('td', [
                    inputEl
                ])
            ]);
            const result = {
                update: ()=>{
                    inputEl.value = '' + lastValidRgb[attributeStr];
                },
                destroy: ()=>{
                    (0, _bb.BB).unsetEventHandler(inputEl, 'onchange');
                },
                element: rowEl
            };
            return result;
        }
        const rgbArr = [
            createRgbInputRow((0, _language.LANG)('red'), 'r'),
            createRgbInputRow((0, _language.LANG)('green'), 'g'),
            createRgbInputRow((0, _language.LANG)('blue'), 'b')
        ];
        const rootEl = (0, _c.c)('', [
            previewEl,
            hexRowEl,
            (0, _c.c)('table.' + _colorSliderHexDialogModuleScss.table, [
                (0, _c.c)('tbody', rgbArr.map((item)=>item.element))
            ])
        ]);
        (0, _showModal.showModal)({
            target: document.body,
            message: `<b>${(0, _language.LANG)('manual-color-input')}</b>`,
            div: rootEl,
            autoFocus: false,
            clickOnEnter: 'Ok',
            buttons: [
                'Ok',
                'Cancel'
            ],
            callback: function(resultStr) {
                (0, _bb.BB).destroyEl(copyButton);
                rgbArr.forEach((item)=>item.destroy());
                rgbArr.splice(0, rgbArr.length);
                p.onClose(resultStr === 'Ok' ? (0, _bb.BB).ColorConverter.hexToRGB(hexInput.value) : undefined);
            }
        });
    }
}

},{"../../../bb/bb":"3zOvT","../components/input":"e8FQP","./base/showModal":"gy3iL","../../../language/language":"mcywn","url:/src/app/img/ui/copy.svg":"9BQWG","../../../bb/base/c":"3KmDH","./color-slider-hex-dialog.module.scss":"b2O6k","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9BQWG":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("copy.9e5cae90.svg") + "?" + Date.now();

},{}],"3KmDH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * composes HTML
 */ parcelHelpers.export(exports, "c", ()=>c);
var _ui = require("./ui");
var _base = require("./base");
function decomposeElString(el) {
    if (el === '') return {};
    let split;
    let tagName;
    const classes = [];
    split = el.split('.');
    if (split.length === 1) {
        split = split[0].split(',');
        tagName = split.shift();
    } else {
        tagName = split.shift();
        split.forEach((item, index)=>{
            const isLast = index === split.length - 1;
            if (isLast) {
                split = item.split(',');
                const last = split.shift();
                if (last !== undefined) classes.push(last);
            } else classes.push(item);
        });
    }
    const result = {};
    if (tagName !== '') result.tagName = tagName;
    if (classes.length > 0) result.classes = classes;
    if (split.length > 0) result.styles = split;
    return result;
}
function applyStyleNames(el, styleNames) {
    const style = {};
    const operations = {
        c: (params)=>{
            style.color = params[0];
        },
        bg: (params)=>{
            style.background = params[0];
        },
        p: (params)=>{
            style.padding = params[0] + 'px';
        },
        py: (params)=>{
            style.paddingTop = params[0] + 'px';
            style.paddingBottom = params[0] + 'px';
        },
        pt: (params)=>{
            style.paddingTop = params[0] + 'px';
        },
        pr: (params)=>{
            style.paddingRight = params[0] + 'px';
        },
        pb: (params)=>{
            style.paddingBottom = params[0] + 'px';
        },
        pl: (params)=>{
            style.paddingLeft = params[0] + 'px';
        },
        mt: (params)=>{
            style.marginTop = params[0] + 'px';
        },
        mr: (params)=>{
            style.marginRight = params[0] + 'px';
        },
        mb: (params)=>{
            style.marginBottom = params[0] + 'px';
        },
        ml: (params)=>{
            style.marginLeft = params[0] + 'px';
        },
        // flex
        flex: ()=>{
            style.display = 'flex';
        },
        flexCol: ()=>{
            style.flexDirection = 'column';
        },
        flexWrap: ()=>{
            style.flexWrap = 'wrap';
        },
        gap: (params)=>{
            style.gap = params.map((item)=>item + 'px').join(' ');
        },
        grow: ()=>{
            style.flexGrow = '1';
        },
        justify: (params)=>{
            style.justifyContent = params[0];
        },
        items: (params)=>{
            style.alignItems = params[0];
        },
        hidden: ()=>{
            style.display = 'none';
        },
        nowrap: ()=>{
            style.whiteSpace = 'nowrap';
        },
        abs: (params)=>{
            style.position = 'absolute';
            style.left = params[0] + 'px';
            style.top = params[1] + 'px';
        },
        w: (params)=>{
            style.width = params[0] === 'full' ? '100%' : params[0] + 'px';
        },
        h: (params)=>{
            style.height = params[0] === 'full' ? '100%' : params[0] + 'px';
        },
        minh: (params)=>{
            style.minHeight = params[0] + 'px';
        },
        z: (params)=>{
            style.zIndex = params[0];
        },
        overflow: (params)=>{
            style.overflow = params[0];
        },
        pos: (params)=>{
            style.position = params[0];
        },
        left: (params)=>{
            style.left = params[0] === 'full' ? '100%' : params[0] + 'px';
        },
        top: (params)=>{
            style.top = params[0] === 'full' ? '100%' : params[0] + 'px';
        },
        right: (params)=>{
            style.right = params[0] === 'full' ? '100%' : params[0] + 'px';
        },
        bottom: (params)=>{
            style.bottom = params[0] === 'full' ? '100%' : params[0] + 'px';
        },
        size: (params)=>{
            style.fontSize = params[0] + 'px';
        },
        pointer: (params)=>{
            style.pointerEvents = params[0];
        }
    };
    styleNames.forEach((item)=>{
        const params = item.split('-');
        const operation = params.shift();
        operations[operation](params);
    });
    (0, _base.css)(el, style);
}
function c(element, inner) {
    if (element === undefined) return document.createElement('div');
    if (typeof element !== 'string') {
        if (!(element instanceof HTMLElement)) element = (0, _ui.el)(element);
        if (inner) {
            if (typeof inner === 'string') element.innerHTML = inner;
            else element.append(...inner);
        }
        return element;
    }
    const decomp = decomposeElString(element);
    const result = document.createElement(decomp.tagName ?? 'div');
    decomp.classes && result.classList.add(...decomp.classes);
    decomp.styles && applyStyleNames(result, decomp.styles);
    if (inner) {
        if (typeof inner === 'string') result.innerHTML = inner;
        else result.append(...inner);
    }
    return result;
}

},{"./ui":"5dJJW","./base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b2O6k":[function(require,module,exports,__globalThis) {
module.exports["table"] = `_7-bVqq_table`;

},{}],"8Lh1B":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * big main HS+V color slider
 * 2 elements: slider, and colorpreview(output) + eyedropper
 */ parcelHelpers.export(exports, "KlColorSlider", ()=>KlColorSlider);
var _bb = require("../../../bb/bb");
var _colorSliderHexDialog = require("../modals/color-slider-hex-dialog");
var _sliderFalloff = require("./slider-falloff");
var _toolPickerSvg = require("url:/src/app/img/ui/tool-picker.svg");
var _toolPickerSvgDefault = parcelHelpers.interopDefault(_toolPickerSvg);
var _language = require("../../../language/language");
var _eraseColor = require("../../brushes/erase-color");
var _base = require("../../../bb/base/base");
class KlColorSlider {
    updatePrimaryHSV(hsv) {
        if (hsv.s === 0) this.primaryColorHsv = new (0, _bb.BB).HSV(this.primaryColorHsv.h, hsv.s, hsv.v);
        else this.primaryColorHsv = new (0, _bb.BB).HSV(hsv.h, hsv.s, hsv.v);
    }
    updateSVCanvas() {
        const rgb = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(this.primaryColorHsv.h, 100, 100));
        this.svGradient.style.setProperty('--kl-color-picker--hue', '#' + (0, _bb.BB).ColorConverter.toHexString(rgb));
    }
    updateSVPointer() {
        const left = this.primaryColorHsv.s / 100 * this.width - 7;
        const top = (1 - this.primaryColorHsv.v / 100) * this.svHeight - 6;
        (0, _base.css)(this.pointerSV, {
            left: left + 'px',
            top: top + 'px'
        });
    }
    setColPreview() {
        this.divPreview.style.backgroundColor = 'rgb(' + this.primaryColorRgb.r + ',' + this.primaryColorRgb.g + ',' + this.primaryColorRgb.b + ')';
        if ((0, _bb.BB).testIsWhiteBestContrast(this.primaryColorRgb)) {
            (0, _base.css)(this.pickerButton, {
                filter: 'invert(1)'
            });
            (0, _base.css)(this.hexButton, {
                filter: 'invert(1)'
            });
        } else {
            (0, _base.css)(this.pickerButton, {
                filter: ''
            });
            (0, _base.css)(this.hexButton, {
                filter: ''
            });
        }
    }
    updateSecondaryColor() {
        this.secondaryColorBtn.style.backgroundColor = (0, _bb.BB).ColorConverter.toRgbStr(this.secondaryColorRgb);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-color-picker',
            css: {
                position: 'relative'
            }
        });
        this.outputDiv = (0, _bb.BB).el({
            css: {
                display: 'flex',
                alignItems: 'center'
            }
        });
        this.width = p.width;
        this.svHeight = p.svHeight;
        this.height = p.height;
        this.emitColor = p.onPick;
        this.onEyedropper = p.onEyedropper;
        this.primaryColorRgb = {
            r: parseInt('' + p.startValue.r),
            g: parseInt('' + p.startValue.g),
            b: parseInt('' + p.startValue.b)
        };
        this.primaryColorHsv = (0, _bb.BB).ColorConverter.toHSV(p.startValue); // BB.HSV
        this.secondaryColorRgb = {
            r: (0, _eraseColor.ERASE_COLOR),
            g: (0, _eraseColor.ERASE_COLOR),
            b: (0, _eraseColor.ERASE_COLOR)
        };
        this.secondaryColorHsv = (0, _bb.BB).ColorConverter._RGBtoHSV(this.secondaryColorRgb); // BB.HSV
        const svWrapper = (0, _bb.BB).el();
        this.svGradient = (0, _bb.BB).el({
            css: {
                background: 'linear-gradient(0deg, #000 0%, rgba(255, 0, 0, 0) 100%), linear-gradient(-90deg, var(--kl-color-picker--hue) 0%, #fff 100%)',
                width: this.width + 'px',
                height: this.svHeight + 'px'
            }
        });
        svWrapper.append(this.svGradient);
        const divH = (0, _bb.BB).el({
            className: 'kl-color-picker__h',
            css: {
                overflow: 'hidden',
                position: 'relative',
                width: this.width + 'px',
                height: this.height + 'px',
                cursor: 'ew-resize',
                marginTop: '1px',
                marginBottom: '1px'
            }
        });
        this.divPreview = (0, _bb.BB).el({
            className: 'kl-color-picker__preview',
            css: {
                display: 'flex',
                justifyContent: 'space-between',
                width: this.height * 2.5 + 'px',
                height: this.height + 'px'
            }
        });
        this.controlH = (0, _bb.BB).el();
        const createHueBg = (targetEl)=>{
            const im = new Image();
            (0, _base.css)(im, {
                position: 'absolute',
                left: '0',
                top: '0',
                display: 'none',
                pointerEvents: 'none'
            });
            const cv = (0, _bb.BB).canvas(this.width, this.height);
            const ctx = (0, _bb.BB).ctx(cv);
            const gradH = ctx.createLinearGradient(0, 0, this.width, 0);
            for(let i = 0; i < 1; i += 0.01){
                const col = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(i * 360, 100, 100));
                let ha = parseInt('' + col.r).toString(16);
                let hb = parseInt('' + col.g).toString(16);
                let hc = parseInt('' + col.b).toString(16);
                if (ha.length === 1) ha = '0' + ha;
                if (hb.length === 1) hb = '0' + hb;
                if (hc.length === 1) hc = '0' + hc;
                gradH.addColorStop(i, '#' + ha + hb + hc);
            }
            ctx.fillStyle = gradH;
            ctx.fillRect(0, 0, this.width, this.height);
            targetEl.append(im);
            im.alt = 'hue';
            im.src = cv.toDataURL('image/png');
            im.style.display = 'block';
        };
        this.updateSVCanvas();
        this.rootEl.style.width = this.width + 'px';
        this.rootEl.oncontextmenu = ()=>{
            return false;
        };
        this.SVContainer = (0, _bb.BB).el({
            className: 'kl-color-picker__sv',
            css: {
                width: this.width + 'px',
                height: this.svHeight + 'px',
                overflow: 'hidden',
                display: 'block',
                position: 'relative',
                cursor: 'crosshair'
            }
        });
        this.pointerSV = (0, _bb.BB).el({
            css: {
                width: '12px',
                height: '12px',
                borderRadius: '6px',
                position: 'absolute',
                pointerEvents: 'none',
                boxShadow: '0px 0px 0 1px #000, inset 0px 0px 0 1px #fff'
            }
        });
        this.SVContainer.append(svWrapper, this.pointerSV);
        this.updateSVPointer();
        this.rootEl.append(this.SVContainer, divH);
        this.outputDiv.append(this.divPreview);
        //divH.className = "svSlider";
        (0, _base.css)(this.controlH, {
            width: '2px',
            height: this.height + 'px',
            background: '#000',
            borderLeft: '1px solid #fff',
            position: 'absolute',
            top: '0',
            left: parseInt('' + (this.primaryColorHsv.h / 360 * this.width - 1)) + 'px'
        });
        const virtualHSV = {
            h: 0,
            s: 0,
            v: 0
        };
        this.pickerButton = (0, _bb.BB).el({
            title: (0, _language.LANG)('eyedropper') + ' [Alt]',
            className: 'color-picker-preview-button',
            css: {
                width: '30px',
                height: '30px',
                backgroundImage: 'url(' + (0, _toolPickerSvgDefault.default) + ')',
                backgroundRepeat: 'no-repeat',
                backgroundSize: '70%',
                backgroundPosition: 'center'
            },
            onClick: ()=>{
                if (this.isPicking) this.setIsEyedropping(false);
                else {
                    this.pickerButton.classList.remove('color-picker-preview-button-hover');
                    this.pickerButton.classList.add('color-picker-preview-button-active');
                    this.isPicking = true;
                    this.onEyedropper(true);
                }
            }
        });
        this.isPicking = false;
        const pickerButtonPointerListener = new (0, _bb.BB).PointerListener({
            target: this.pickerButton,
            onEnterLeave: (isOver)=>{
                if (this.isPicking) return;
                this.pickerButton.classList.toggle('color-picker-preview-button-hover', isOver);
            }
        });
        this.divPreview.append(this.pickerButton);
        this.hexButton = (0, _bb.BB).el({
            content: '#',
            className: 'color-picker-preview-button',
            title: (0, _language.LANG)('manual-color-input'),
            css: {
                height: '100%',
                width: this.height + 'px',
                lineHeight: this.height + 'px',
                fontSize: this.height * 0.65 + 'px'
            },
            onClick: ()=>{
                new (0, _colorSliderHexDialog.HexColorDialog)({
                    color: new (0, _bb.BB).RGB(this.primaryColorRgb.r, this.primaryColorRgb.g, this.primaryColorRgb.b),
                    onClose: (rgbObj)=>{
                        if (!rgbObj) return;
                        this.setColor(rgbObj);
                        this.emitColor(new (0, _bb.BB).RGB(this.primaryColorRgb.r, this.primaryColorRgb.g, this.primaryColorRgb.b));
                    }
                });
            }
        });
        const hexButtonPointerListener = new (0, _bb.BB).PointerListener({
            target: this.hexButton,
            onEnterLeave: (isOver)=>{
                this.hexButton.classList.toggle('color-picker-preview-button-hover', isOver);
            }
        });
        this.divPreview.append(this.hexButton);
        this.setColPreview();
        setTimeout(()=>{
            createHueBg(divH);
            divH.append(this.controlH);
            const svPointerListener = new (0, _bb.BB).PointerListener({
                target: svWrapper,
                fixScribble: true,
                onPointer: (event)=>{
                    if (event.type === 'pointerdown') {
                        // prevent manual slider input keeping focus on iPad
                        (0, _bb.BB).unfocusAnyInput();
                        this.SVContainer.classList.toggle('kl-color-picker--active', true);
                        if (event.button === 'left') {
                            virtualHSV.s = event.relX / this.width * 100;
                            virtualHSV.v = 100 - event.relY / this.svHeight * 100;
                            this.primaryColorHsv = new (0, _bb.BB).HSV(this.primaryColorHsv.h, virtualHSV.s, virtualHSV.v);
                            this.primaryColorRgb = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv);
                            this.updateSVPointer();
                            this.setColPreview();
                            this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv));
                        } else {
                            virtualHSV.s = this.primaryColorHsv.s;
                            virtualHSV.v = this.primaryColorHsv.v;
                        }
                    }
                    if (event.type === 'pointermove' && [
                        'left',
                        'right'
                    ].includes(event.button || '')) {
                        let factor = 1;
                        if (event.button === 'right') factor = 0.5;
                        virtualHSV.s += event.dX / this.width * 100 * factor;
                        virtualHSV.v -= event.dY / this.svHeight * 100 * factor;
                        this.primaryColorHsv = new (0, _bb.BB).HSV(this.primaryColorHsv.h, virtualHSV.s, virtualHSV.v);
                        this.primaryColorRgb = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv);
                        this.updateSVPointer();
                        this.setColPreview();
                        this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv));
                    }
                    if (event.type === 'pointerup') this.SVContainer.classList.toggle('kl-color-picker--active', false);
                }
            });
            const hPointerListener = new (0, _bb.BB).PointerListener({
                target: divH,
                fixScribble: true,
                onPointer: (event)=>{
                    if (event.type === 'pointerdown') {
                        // prevent manual slider input keeping focus on iPad
                        (0, _bb.BB).unfocusAnyInput();
                        divH.classList.toggle('kl-color-picker--active', true);
                        if (event.button === 'left') {
                            virtualHSV.h = event.relX / this.width * 359.99;
                            this.primaryColorHsv = new (0, _bb.BB).HSV(virtualHSV.h, this.primaryColorHsv.s, this.primaryColorHsv.v);
                            this.primaryColorRgb = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv);
                            this.controlH.style.left = Math.round(this.primaryColorHsv.h / 359.99 * this.width) - 1 + 'px';
                            this.updateSVCanvas();
                            this.setColPreview();
                            this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv));
                        } else virtualHSV.h = this.primaryColorHsv.h;
                    }
                    if (event.type === 'pointermove' && [
                        'left',
                        'right'
                    ].includes(event.button || '')) {
                        const deltaY = Math.abs(event.pageY - event.downPageY);
                        const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === 'right');
                        virtualHSV.h += event.dX / this.width * 359.99 * factor;
                        if (event.button === 'right') {
                            virtualHSV.h = virtualHSV.h % 359.99;
                            if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                        }
                        virtualHSV.h = Math.min(359.99, virtualHSV.h);
                        this.primaryColorHsv = new (0, _bb.BB).HSV(virtualHSV.h, this.primaryColorHsv.s, this.primaryColorHsv.v);
                        this.primaryColorRgb = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv);
                        this.controlH.style.left = Math.round(this.primaryColorHsv.h / 359.99 * this.width) - 1 + 'px';
                        this.updateSVCanvas();
                        this.setColPreview();
                        this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHsv));
                    }
                    if (event.type === 'pointerup') divH.classList.toggle('kl-color-picker--active', false);
                }
            });
        }, 1);
        // --- secondary color ---
        this.secondaryColorBtn = (0, _bb.BB).el({
            parent: this.outputDiv,
            title: (0, _language.LANG)('secondary-color') + ' [X]',
            className: 'kl-color-picker__secondary',
            css: {
                cursor: 'pointer',
                marginLeft: '5px',
                width: '22px',
                height: '22px'
            },
            onClick: (e)=>{
                e.preventDefault();
                this.swapColors();
            }
        });
        this.updateSecondaryColor();
    }
    setColor(c) {
        this.primaryColorRgb = {
            r: parseInt('' + c.r),
            g: parseInt('' + c.g),
            b: parseInt('' + c.b)
        };
        this.updatePrimaryHSV((0, _bb.BB).ColorConverter.toHSV(c));
        this.controlH.style.left = parseInt('' + (this.primaryColorHsv.h / 359 * this.width - 1)) + 'px';
        this.updateSVCanvas();
        this.updateSVPointer();
        this.setColPreview();
    }
    getColor() {
        return new (0, _bb.BB).RGB(this.primaryColorRgb.r, this.primaryColorRgb.g, this.primaryColorRgb.b);
    }
    getSecondaryRGB() {
        return new (0, _bb.BB).RGB(this.secondaryColorRgb.r, this.secondaryColorRgb.g, this.secondaryColorRgb.b);
    }
    getIsEyedropping() {
        return this.isPicking;
    }
    setIsEyedropping(b) {
        if (b) {
            this.isPicking = true;
            this.onEyedropper(true);
            this.pickerButton.classList.add('color-picker-preview-button-active');
        } else {
            this.isPicking = false;
            this.onEyedropper(false);
            this.pickerButton.classList.remove('color-picker-preview-button-active');
        }
    }
    enable(e) {
        const style = {
            pointerEvents: e ? '' : 'none',
            opacity: e ? '1' : '0.5'
        };
        (0, _base.css)(this.rootEl, style);
        (0, _base.css)(this.outputDiv, style);
    }
    setHeight(h) {
        h = parseInt('' + (h - this.height * 2 - 3), 10);
        if (h === this.svHeight) return;
        this.svHeight = h;
        (0, _base.css)(this.svGradient, {
            width: this.width + 'px',
            height: this.svHeight + 'px'
        });
        this.SVContainer.style.height = this.svHeight + 'px';
        this.updateSVPointer();
    }
    swapColors() {
        // swap hsv
        let tmp = this.secondaryColorHsv;
        this.secondaryColorHsv = this.primaryColorHsv;
        this.updatePrimaryHSV(tmp);
        // swap rgb
        tmp = this.secondaryColorRgb;
        this.secondaryColorRgb = this.primaryColorRgb;
        this.primaryColorRgb = tmp;
        this.controlH.style.left = parseInt('' + (this.primaryColorHsv.h / 359 * this.width - 1)) + 'px';
        this.updateSVCanvas();
        this.updateSVPointer();
        this.setColPreview();
        this.updateSecondaryColor();
        this.emitColor(new (0, _bb.BB).RGB(this.primaryColorRgb.r, this.primaryColorRgb.g, this.primaryColorRgb.b));
    }
    getElement() {
        return this.rootEl;
    }
    getOutputElement() {
        return this.outputDiv;
    }
}

},{"../../../bb/bb":"3zOvT","../modals/color-slider-hex-dialog":"arnzW","./slider-falloff":"e8ZzL","url:/src/app/img/ui/tool-picker.svg":"hq1oG","../../../language/language":"mcywn","../../brushes/erase-color":"4wlOt","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hq1oG":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-picker.dcb78a56.svg") + "?" + Date.now();

},{}],"4wlOt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ERASE_COLOR", ()=>ERASE_COLOR);
parcelHelpers.export(exports, "getEraseColor", ()=>getEraseColor);
var _theme = require("../../theme/theme");
const ERASE_COLOR = (0, _theme.THEME).isDark() ? 255 : 255;
function getEraseColor() {
    return {
        r: ERASE_COLOR,
        g: ERASE_COLOR,
        b: ERASE_COLOR
    };
}

},{"../../theme/theme":"cVh0j","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cVh0j":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "THEME", ()=>THEME);
var _base = require("../bb/base/base");
var _localStorage = require("../bb/base/local-storage");
const LS_THEME_KEY = 'klecks-theme';
class Theme {
    updateTheme() {
        const oldTheme = this.theme;
        this.theme = this.storedTheme || this.mediaQueryTheme;
        if (this.theme === oldTheme) return;
        document.body.classList.toggle('kl-theme-dark', this.theme === 'dark');
        this.listeners.forEach((item)=>item());
    }
    readLocalStorage() {
        let result = (0, _localStorage.LocalStorage).getItem(LS_THEME_KEY);
        if (!result || typeof result === 'string' && ![
            'dark',
            'light'
        ].includes(result)) {
            result = undefined;
            (0, _localStorage.LocalStorage).removeItem(LS_THEME_KEY); // reset because invalid
        }
        return result;
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        // initialization will be overwritten.
        this.mediaQueryTheme = 'light' // prefers-color-scheme
        ;
        this.theme = 'light';
        this.listeners = [];
        // init media query
        this.mediaQueryTheme = (0, _base.isDark)() ? 'dark' : 'light';
        (0, _base.addIsDarkListener)(()=>{
            this.mediaQueryTheme = (0, _base.isDark)() ? 'dark' : 'light';
            this.updateTheme();
        });
        // init local storage
        this.storedTheme = this.readLocalStorage();
        addEventListener('storage', (e)=>{
            if (e.key === LS_THEME_KEY) {
                this.storedTheme = this.readLocalStorage();
                this.updateTheme();
            }
        });
        this.updateTheme();
    }
    isDark() {
        return this.theme === 'dark';
    }
    addIsDarkListener(func) {
        if (this.listeners.includes(func)) return;
        this.listeners.push(func);
    }
    removeIsDarkListener(func) {
        for(let i = 0; i < this.listeners.length; i++)if (this.listeners[i] === func) {
            this.listeners.splice(i, 1);
            return;
        }
    }
    getMediaQueryTheme() {
        return this.mediaQueryTheme;
    }
    getStoredTheme() {
        return this.storedTheme;
    }
    setStoredTheme(theme) {
        if (theme) (0, _localStorage.LocalStorage).setItem(LS_THEME_KEY, theme);
        else (0, _localStorage.LocalStorage).removeItem(LS_THEME_KEY);
        this.storedTheme = theme;
        this.updateTheme();
    }
}
const THEME = new Theme();

},{"../bb/base/base":"it3mQ","../bb/base/local-storage":"itqB1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j88oi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * a small color slider
 */ parcelHelpers.export(exports, "KlColorSliderSmall", ()=>KlColorSliderSmall);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
var _base = require("../../../bb/base/base");
class KlColorSliderSmall {
    updateSV() {
        const ctx = (0, _bb.BB).ctx(this.canvasSV);
        if (!ctx) throw new Error("couldn't create canvas");
        for(let i = 0; i < this.canvasSV.height; i += 1){
            const gradient1 = ctx.createLinearGradient(0, 0, this.canvasSV.width, 0);
            const colleft = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(this.color.h, 1, 100 - i / this.canvasSV.height * 100.0));
            const colright = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(this.color.h, 100, 100 - i / this.canvasSV.height * 100.0));
            gradient1.addColorStop(0, '#' + (0, _bb.BB).ColorConverter.toHexString(colleft));
            gradient1.addColorStop(1, '#' + (0, _bb.BB).ColorConverter.toHexString(colright));
            ctx.fillStyle = '#ff0000'; //needed for chrome...otherwise alpha problem
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, i, this.canvasSV.width, 1);
        }
    }
    updateSVPointer() {
        const left = this.color.s / 100 * this.width - 4;
        const top = (1 - this.color.v / 100) * this.heightSV - 4;
        (0, _base.css)(this.pointerSV, {
            left: left + 'px',
            top: top + 'px'
        });
    }
    updateHPointer() {
        this.pointerH.style.left = this.color.h / 359.999 * this.width - 1 + 'px';
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                width: p.width + 'px',
                position: 'relative',
                overflow: 'hidden',
                userSelect: 'none'
            }
        });
        this.rootEl.oncontextmenu = (e)=>{
            e.preventDefault();
        };
        this.color = (0, _bb.BB).ColorConverter.toHSV(new (0, _bb.BB).RGB(p.color.r, p.color.g, p.color.b));
        this.width = p.width;
        this.heightSV = p.heightSV;
        this.canvasSV = (0, _bb.BB).canvas(10, 10);
        (0, _base.css)(this.canvasSV, {
            width: this.width + 'px',
            height: this.heightSV + 'px',
            cursor: 'crosshair'
        });
        this.updateSV();
        const canvasH = (0, _bb.BB).canvas(p.width, p.heightH);
        canvasH.style.cursor = 'ew-resize';
        (()=>{
            const ctx = (0, _bb.BB).ctx(canvasH);
            const gradH = ctx.createLinearGradient(0, 0, p.width, 0);
            for(let i = 0; i < 1; i += 0.01){
                const col = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(i * 360, 100, 100));
                gradH.addColorStop(i, 'rgba(' + parseInt('' + col.r) + ', ' + parseInt('' + col.g) + ', ' + parseInt('' + col.b) + ', 1)');
            }
            ctx.fillStyle = gradH;
            ctx.fillRect(0, 0, p.width, p.heightH);
        })();
        (0, _base.css)(this.canvasSV, {
            width: p.width + 'px',
            height: p.heightSV + 'px',
            overflow: 'hidden',
            position: 'relative'
        });
        this.canvasSV.style.cssFloat = 'left';
        canvasH.style.cssFloat = 'left';
        this.rootEl.append(this.canvasSV, canvasH);
        this.pointerSV = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                width: '8px',
                height: '8px',
                borderRadius: '8px',
                position: 'absolute',
                pointerEvents: 'none',
                boxShadow: '0 0 0 1px #000, inset 0 0 0 1px #fff'
            }
        });
        this.pointerH = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                width: '0',
                height: p.heightH + 'px',
                borderLeft: '1px solid #fff',
                borderRight: '1px solid #000',
                position: 'absolute',
                top: p.heightSV + 'px',
                pointerEvents: 'none'
            }
        });
        this.updateSVPointer();
        this.updateHPointer();
        const virtualHSV = {
            h: 0,
            s: 0,
            v: 0
        };
        this.svPointerId = null;
        this.svPointerListener = new (0, _bb.BB).PointerListener({
            target: this.canvasSV,
            fixScribble: true,
            onPointer: (event)=>{
                if (event.type === 'pointerdown') {
                    // prevent manual slider input keeping focus on iPad
                    (0, _bb.BB).unfocusAnyInput();
                    this.svPointerId = event.pointerId;
                    if (event.button === 'left') {
                        virtualHSV.s = event.relX / p.width * 100;
                        virtualHSV.v = 100 - event.relY / p.heightSV * 100;
                        this.color = new (0, _bb.BB).HSV(this.color.h, virtualHSV.s, virtualHSV.v);
                        this.updateSVPointer();
                        p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                    } else {
                        virtualHSV.s = this.color.s;
                        virtualHSV.v = this.color.v;
                    }
                }
                if (event.type === 'pointermove' && [
                    'left',
                    'right'
                ].includes('' + event.button) && this.svPointerId === event.pointerId) {
                    let factor = 1;
                    if (event.button === 'right') factor = 0.5;
                    virtualHSV.s += event.dX / p.width * 100 * factor;
                    virtualHSV.v -= event.dY / p.heightSV * 100 * factor;
                    this.color = new (0, _bb.BB).HSV(this.color.h, virtualHSV.s, virtualHSV.v);
                    this.updateSVPointer();
                    p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                }
                if (event.type === 'pointerup') this.svPointerId = null;
            }
        });
        this.hPointerId = null;
        this.hPointerListener = new (0, _bb.BB).PointerListener({
            target: canvasH,
            fixScribble: true,
            onPointer: (event)=>{
                if (event.type === 'pointerdown') {
                    this.hPointerId = event.pointerId;
                    if (event.button === 'left') {
                        virtualHSV.h = event.relX / p.width * 359.99;
                        this.color = new (0, _bb.BB).HSV(virtualHSV.h, this.color.s, this.color.v);
                        this.updateSV();
                        this.updateHPointer();
                        p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                    } else virtualHSV.h = this.color.h;
                }
                if (event.type === 'pointermove' && [
                    'left',
                    'right'
                ].includes('' + event.button) && this.hPointerId === event.pointerId) {
                    const deltaY = Math.abs(event.pageY - event.downPageY);
                    const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === 'right');
                    virtualHSV.h += event.dX / p.width * 359.99 * factor;
                    if (event.button === 'right') {
                        virtualHSV.h = virtualHSV.h % 359.99;
                        if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                    }
                    virtualHSV.h = Math.min(359.99, virtualHSV.h);
                    this.color = new (0, _bb.BB).HSV(virtualHSV.h, this.color.s, this.color.v);
                    this.updateSV();
                    this.updateHPointer();
                    p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                }
                if (event.type === 'pointerup') this.hPointerId = null;
            }
        });
        const cleardiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                clear: 'both'
            }
        });
    }
    // ---- interface ----
    setColor(c) {
        if (this.hPointerId !== null || this.svPointerId !== null) return;
        this.color = (0, _bb.BB).ColorConverter.toHSV(new (0, _bb.BB).RGB(c.r, c.g, c.b));
        this.updateSV();
        this.updateSVPointer();
        this.updateHPointer();
    }
    getColor() {
        return (0, _bb.BB).ColorConverter.toRGB(this.color);
    }
    getElement() {
        return this.rootEl;
    }
    end() {
        this.svPointerId = null;
        this.hPointerId = null;
    }
    destroy() {
        this.svPointerListener.destroy();
        this.hPointerListener.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","./slider-falloff":"e8ZzL","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1mvjC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A slider that looks like this
 * ------O----
 */ parcelHelpers.export(exports, "PointSlider", ()=>PointSlider);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class PointSlider {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: 'relative'
            }
        });
        const sliderLine = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'kl-point-slider__line',
            css: {
                marginTop: parseInt('' + (p.pointSize / 2 - 1)) + 'px',
                width: p.width + 'px'
            }
        });
        this.sliderPoint = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'kl-point-slider__point'
        });
        let sliderPos;
        let isDragging = false;
        //sliderPoint
        const touchAreaEl = (0, _bb.BB).el({
            // expand clickable area
            parent: this.sliderPoint,
            css: {
                // background: 'rgba(255,0,0,0.4)',
                margin: '-7px 0 0 -7px',
                width: 'calc(100% + 14px)',
                height: 'calc(100% + 7px)'
            }
        });
        const redrawPoint = ()=>{
            (0, _base.css)(this.sliderPoint, {
                left: sliderPos + 'px'
            });
        };
        const getValue = ()=>{
            return sliderPos / (p.width - p.pointSize);
        };
        {
            let isFirst;
            sliderPos = (0, _bb.BB).clamp(p.init * (p.width - p.pointSize), 0, p.width - p.pointSize);
            (0, _base.css)(this.sliderPoint, {
                width: p.pointSize + 'px',
                height: p.pointSize + 'px',
                borderRadius: p.pointSize + 'px'
            });
            redrawPoint();
            let imaginaryPos;
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.sliderPoint,
                fixScribble: true,
                onPointer: (event)=>{
                    if (event.type === 'pointerdown' && event.button === 'left') {
                        isFirst = true;
                        isDragging = true;
                        imaginaryPos = sliderPos;
                        redrawPoint();
                        event.eventStopPropagation();
                    } else if (event.type === 'pointermove' && event.button === 'left') {
                        event.eventStopPropagation();
                        imaginaryPos = imaginaryPos + event.dX;
                        sliderPos = parseInt('' + (0, _bb.BB).clamp(imaginaryPos, 0, p.width - p.pointSize));
                        redrawPoint();
                        p.callback(getValue(), isFirst, false);
                        isFirst = false;
                    }
                    if (event.type === 'pointerup') {
                        event.eventStopPropagation();
                        isDragging = false;
                        redrawPoint();
                        p.callback(getValue(), false, true);
                    }
                }
            });
        }
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    setActive(isActive) {
        this.sliderPoint.style.backgroundColor = isActive ? '#fff' : '#eaeaea';
    }
    destroy() {
        this.pointerListener.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1nMl0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * UI to pick between colors in colorArr. can display full transparent (checkerboard).
 * Can't deal with 0.5 alpha.
 * Rectangular buttons.
 */ parcelHelpers.export(exports, "ColorOptions", ()=>ColorOptions);
var _bb = require("../../../bb/bb");
var _color = require("../../../bb/color/color");
var _c = require("../../../bb/base/c");
class ColorOptions {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.colorArr = [];
        this.selectedIndex = 0;
        this.rootEl = (0, _bb.BB).el({
            content: p.label ? p.label : '',
            title: p.title ?? undefined,
            css: {
                display: 'flex',
                alignItems: 'center',
                gap: '7px',
                position: 'relative',
                ...p.css
            }
        });
        this.buttonArr = [];
        const buttonSize = 22;
        this.onColorInputChange = ()=>{
            const i = this.selectedIndex;
            const color = this.colorArr[i];
            if (!color || color.a < 1) // ignore
            return;
            const newRawColor = this.colorInput.value;
            this.buttonArr[this.selectedIndex].el.style.backgroundColor = newRawColor;
            this.colorArr[i] = {
                ...(0, _color.ColorConverter).hexToRGB(newRawColor),
                a: 1
            };
            p.onChange(this.colorArr[i]);
        };
        this.colorInput = (0, _bb.BB).el({
            tagName: 'input',
            custom: {
                type: 'color',
                tabIndex: '-1'
            }
        });
        this.colorInput.onchange = this.onColorInputChange;
        this.colorInput.oninput = this.onColorInputChange;
        // build colorArr while removing duplicates
        for(let i = 0; i < p.colorArr.length; i++){
            const item = p.colorArr[i];
            let found = false;
            for(let e = 0; e < this.colorArr.length; e++){
                const sItem = this.colorArr[e];
                if (sItem === item) {
                    found = true;
                    break;
                }
                if (sItem === null || item === null) continue;
                if (sItem.r === item.r && sItem.g === item.g && sItem.b === item.b && sItem.a === item.a) {
                    found = true;
                    break;
                }
            }
            if (found) continue;
            this.colorArr.push(item);
            if ('initialIndex' in p && p.initialIndex === i) this.selectedIndex = this.colorArr.length - 1;
        }
        for(let i = 0; i < this.colorArr.length; i++)((i)=>{
            const color = this.colorArr[i];
            const colorButton = (0, _bb.BB).el({
                parent: this.rootEl,
                content: color ? '' : 'X',
                className: 'kl-color-option',
                css: {
                    width: buttonSize + 'px',
                    height: buttonSize + 'px',
                    backgroundColor: color ? (0, _bb.BB).ColorConverter.toRgbaStr(color) : 'transparent',
                    lineHeight: buttonSize + 1 + 'px'
                },
                onClick: (e)=>{
                    if (this.selectedIndex === i) {
                        if (color && color.a === 1) this.colorInput.showPicker ? this.colorInput.showPicker() : this.colorInput.click();
                        return;
                    }
                    e.preventDefault();
                    this.selectedIndex = i;
                    update();
                    p.onChange(this.colorArr[i]); // color may change
                }
            });
            if (color && color.a === 0) colorButton.style.background = 'var(--kl-checkerboard-background)';
            const setIsSelected = (b)=>{
                colorButton.classList.toggle('kl-color-option--active', b);
            };
            this.buttonArr.push({
                el: colorButton,
                setIsSelected
            });
        })(i);
        this.rootEl.append((0, _c.c)(',w-0,h-0,overflow-hidden,abs-0-0', [
            this.colorInput
        ]));
        const update = ()=>{
            for(let i = 0; i < this.buttonArr.length; i++)this.buttonArr[i].setIsSelected(i === this.selectedIndex);
        };
        update();
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.colorArr[this.selectedIndex];
    }
    destroy() {
        this.rootEl.remove();
        this.buttonArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item.el);
        });
        this.buttonArr.splice(0, this.buttonArr.length);
        this.colorInput.onchange = null;
        this.colorInput.oninput = null;
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/color/color":"e0D0Q","../../../bb/base/c":"3KmDH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7kiPU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * selectable options
 */ parcelHelpers.export(exports, "Options", ()=>Options);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class Options {
    getIndex() {
        for(let i = 0; i < this.optionArr.length; i++){
            if (this.optionArr[i].id === this.selectedId) return i;
        }
        return -1;
    }
    update() {
        for(let i = 0; i < this.optionArr.length; i++)this.optionArr[i].el.classList.toggle('kl-option-selected', this.optionArr[i].id === this.selectedId);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: p.css
        });
        const wrapperEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'kl-option-wrapper',
            css: {
                display: 'flex',
                flexDirection: p.isColumn ? 'column' : 'row'
            }
        });
        if (p.onChange) this.onChange = p.onChange;
        this.optionArr = [];
        this.selectedId = 'initialId' in p && p.initId !== undefined ? p.initId : p.optionArr[0].id;
        const createOption = (o)=>{
            const classArr = [
                'kl-option'
            ];
            if (p.isSmall) classArr.push('kl-option--small');
            if (typeof o.label !== 'string') {
                classArr.push('kl-option--custom-el');
                (0, _base.css)(o.label, {
                    display: 'block',
                    pointerEvents: 'none'
                });
            }
            const optionObj = {
                id: o.id,
                el: (0, _bb.BB).el({
                    parent: wrapperEl,
                    content: o.label,
                    className: classArr.join(' '),
                    onClick: ()=>{
                        if (this.selectedId !== optionObj.id) {
                            if (p.onBeforeChange && !p.onBeforeChange(optionObj.id)) return;
                            this.selectedId = optionObj.id;
                            this.update();
                            this.onChange && this.onChange(this.selectedId);
                        }
                    },
                    css: p.optionCss
                })
            };
            if (o.title) optionObj.el.title = o.title;
            this.optionArr.push(optionObj);
        };
        for(let i = 0; i < p.optionArr.length; i++)createOption(p.optionArr[i]);
        this.update();
        if (p.changeOnInit) setTimeout(()=>{
            this.onChange && this.onChange(this.selectedId);
        }, 0);
    }
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.selectedId;
    }
    next() {
        this.selectedId = this.optionArr[(this.getIndex() + 1) % this.optionArr.length].id;
        this.update();
        this.onChange && this.onChange(this.selectedId);
    }
    setValue(val, skipEmit) {
        if (this.selectedId === val) return;
        this.selectedId = val;
        this.update();
        !skipEmit && this.onChange && this.onChange(this.selectedId);
    }
    previous() {
        this.selectedId = this.optionArr[(this.optionArr.length + this.getIndex() - 1) % this.optionArr.length].id;
        this.update();
        this.onChange && this.onChange(this.selectedId);
    }
    destroy() {
        this.rootEl.remove();
        this.optionArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item.el);
        });
        this.optionArr.splice(0, this.optionArr.length);
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a1BHN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * display little messages at the top of KlWorkspace
 */ parcelHelpers.export(exports, "StatusOverlay", ()=>StatusOverlay);
var _bb = require("../../../bb/bb");
var _angleSvg = require("url:/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
var _base = require("../../../bb/base/base");
class StatusOverlay {
    updateUiState() {
        if (this.uiState === 'left') this.el.style.left = '271px';
        else this.el.style.removeProperty('left');
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.isWide = false // tool space hidden
        ;
        this.uiState = 'right';
        this.el = (0, _bb.BB).el({
            className: 'top-overlay g-root',
            onClick: (0, _bb.BB).handleClick
        });
        this.updateUiState();
        this.innerEl = (0, _bb.BB).el({
            className: 'top-overlay--inner'
        });
        this.angleIm = new Image();
        this.angleIm.src = (0, _angleSvgDefault.default);
        (0, _base.css)(this.angleIm, {
            verticalAlign: 'bottom',
            width: '20px',
            height: '20px',
            marginLeft: '5px',
            borderRadius: '10px'
        });
        this.innerInnerEl = document.createElement('div');
        this.innerInnerEl.style.display = 'inline-block';
        this.innerEl.append(this.innerInnerEl, this.angleIm);
        this.el.append(this.innerEl);
        document.body.append(this.el);
        this.el.style.display = 'none';
    }
    setWide(b) {
        this.isWide = b;
        if (!this.el) return;
        if (this.isWide) {
            this.el.style.width = '100%';
            this.el.style.left = '';
        } else {
            this.el.style.removeProperty('width');
            this.el.style.left = this.uiState === 'left' ? '271px' : '';
        }
    }
    setUiState(state) {
        this.uiState = state;
        this.updateUiState();
    }
    out(msg, doPulse) {
        if (typeof msg === 'string') {
            this.angleIm.style.display = 'none';
            this.innerInnerEl.style.removeProperty('font-family');
            this.innerInnerEl.innerHTML = msg;
        } else if (msg.type === 'transform') {
            this.angleIm.style.display = 'inline-block';
            this.angleIm.style.transform = 'rotate(' + msg.angleDeg + 'deg)';
            if (msg.angleDeg % 90 === 0) this.angleIm.style.boxShadow = 'inset 0 0 0 1px rgba(255, 255, 255, 0.7)';
            else this.angleIm.style.boxShadow = '';
            this.innerInnerEl.style.fontFamily = 'monospace';
            this.innerInnerEl.innerHTML = Math.round(msg.scale * 100) + '%';
        } else this.angleIm.style.display = 'none';
        if (doPulse) {
            this.innerEl.style.animation = '';
            setTimeout(()=>this.innerEl.style.animation = 'topOverlayPulse 0.5s ease-out', 20);
            clearTimeout(this.timeout3);
            this.timeout3 = setTimeout(()=>this.innerEl.style.animation = '', 520);
        }
        clearTimeout(this.timeout);
        clearTimeout(this.timeout2);
        this.el.style.animationName = doPulse ? 'consoleInFast' : 'consoleIn';
        this.el.style.opacity = '1';
        this.timeout = setTimeout(()=>{
            this.el.style.opacity = '0';
            this.el.style.animationName = 'consoleOut';
            this.timeout2 = setTimeout(()=>{
                this.el.style.display = 'none';
            }, 450);
        }, 1200);
        this.el.style.display = 'flex';
    }
}

},{"../../../bb/bb":"3zOvT","url:/src/app/img/ui/angle.svg":"lzYt5","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lzYt5":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("angle.dbd82c6a.svg") + "?" + Date.now();

},{}],"dtoRN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * element that lets you crop an image and copy it via right click
 */ parcelHelpers.export(exports, "CropCopy", ()=>CropCopy);
var _bb = require("../../../bb/bb");
var _preview = require("../project-viewport/preview");
var _transformationMatrix = require("transformation-matrix");
var _createMatrixFromTransform = require("../../../bb/transform/create-matrix-from-transform");
var _math = require("../../../bb/math/math");
var _language = require("../../../language/language");
var _editCropSvg = require("url:/src/app/img/ui/edit-crop.svg");
var _editCropSvgDefault = parcelHelpers.interopDefault(_editCropSvg);
var _eventChain = require("../../../bb/input/event-chain/event-chain");
var _onePointerLimiter = require("../../../bb/input/event-chain/one-pointer-limiter");
var _canvas = require("../../../bb/base/canvas");
var _base = require("../../../bb/base/base");
class CropCopy {
    resetCrop() {
        this.cropRect = {
            x: 0,
            y: 0,
            width: this.canvas.width,
            height: this.canvas.height
        };
    }
    getViewportSelectionRect() {
        const transform = this.preview.getTransform();
        const mat = (0, _createMatrixFromTransform.createMatrixFromTransform)(transform);
        const p = (0, _transformationMatrix.applyToPoint)(mat, this.cropRect);
        return {
            x: p.x,
            y: p.y,
            width: this.cropRect.width * transform.scale,
            height: this.cropRect.height * transform.scale
        };
    }
    async updateCroppedCanvas() {
        this.croppedCanvas.width = Math.round(this.cropRect.width);
        this.croppedCanvas.height = Math.round(this.cropRect.height);
        const ctx = (0, _bb.BB).ctx(this.croppedCanvas);
        ctx.drawImage(this.canvas, Math.round(-this.cropRect.x), Math.round(-this.cropRect.y));
        const blob = await (0, _canvas.canvasToBlob)(this.croppedCanvas, 'image/png');
        this.croppedBlob = blob;
        if (this.croppedObjectUrl !== '') URL.revokeObjectURL(this.croppedObjectUrl);
        this.croppedObjectUrl = URL.createObjectURL(blob);
        if (this.croppedImageElement) this.croppedImageElement.src = this.croppedObjectUrl;
        this.onChange?.(this.croppedCanvas.width, this.croppedCanvas.height);
    }
    updateSelectionRect() {
        const rect = this.getViewportSelectionRect();
        (0, _base.css)(this.selectionRectEl, {
            left: rect.x + 'px',
            top: rect.y + 'px',
            width: rect.width + 'px',
            height: rect.height + 'px',
            display: this.isReset() ? 'none' : ''
        });
        this.onChange?.(Math.round(this.cropRect.width), Math.round(this.cropRect.height));
    }
    isReset() {
        return this.cropRect.x === 0 && this.cropRect.y === 0 && this.cropRect.width === this.canvas.width && this.cropRect.height === this.canvas.height;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.cropRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        } // canvas coordinates
        ;
        this.mode = 'edit';
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-edit-crop-preview',
            css: {
                position: 'relative',
                height: p.height + 'px',
                width: p.width + 'px',
                overflow: 'hidden'
            }
        });
        if (p.onChange) this.onChange = p.onChange;
        this.canvas = p.canvas;
        if (p.init) this.cropRect = p.init;
        else this.resetCrop();
        const isInsideSelectionRect = (p)=>{
            return (0, _bb.BB).isInsideRect(p, this.getViewportSelectionRect());
        };
        this.croppedCanvas = (0, _bb.BB).canvas();
        this.croppedBlob = {};
        this.croppedObjectUrl = '';
        this.eventTarget = this.croppedCanvas;
        if (p.enableRightClickCopy) {
            this.croppedImageElement = new Image();
            this.eventTarget = this.croppedImageElement;
        }
        (0, _base.css)(this.eventTarget, {
            height: p.height + 'px',
            width: p.width + 'px'
        });
        this.rootEl.append(this.eventTarget);
        this.updateCroppedCanvas();
        this.previewLayer = {
            image: p.canvas,
            opacity: 1,
            isVisible: true,
            mixModeStr: 'source-over',
            hasClipping: false
        };
        this.preview = new (0, _preview.Preview)({
            width: p.width,
            height: p.height - 2,
            project: {
                width: p.canvas.width,
                height: p.canvas.height,
                layers: [
                    this.previewLayer
                ]
            },
            hasEditMode: true,
            onModeChange: (mode)=>{
                this.mode = mode;
                this.preview.getElement().style.pointerEvents = mode === 'edit' ? 'none' : '';
                this.rootEl.title = mode === 'edit' ? (0, _language.LANG)('crop-drag-to-crop') : '';
            },
            onTransformChange: ()=>this.updateSelectionRect(),
            padding: 20,
            hasBorder: false,
            editIcon: (0, _editCropSvgDefault.default)
        });
        (0, _base.css)(this.preview.getElement(), {
            position: 'absolute',
            left: '0',
            top: '0',
            overflow: 'hidden',
            pointerEvents: 'none'
        });
        this.preview.render();
        this.rootEl.append(this.preview.getElement());
        this.selectionRectEl = (0, _bb.BB).el({
            parent: this.preview.getElement(),
            className: 'kl-edit-crop-preview__sel'
        });
        this.updateSelectionRect();
        //gen crop from viewport points
        const genCrop = (p1, p2)=>{
            const mat = (0, _createMatrixFromTransform.createMatrixFromTransform)(this.preview.getTransform());
            const inverseMat = (0, _transformationMatrix.inverse)(mat);
            const topLeftP = {
                x: Math.min(p1.x, p2.x),
                y: Math.min(p1.y, p2.y)
            };
            const bottomRightP = {
                x: Math.max(p1.x, p2.x),
                y: Math.max(p1.y, p2.y)
            };
            const origTopLeftP = (0, _transformationMatrix.applyToPoint)(inverseMat, topLeftP);
            const origBottomRightP = (0, _transformationMatrix.applyToPoint)(inverseMat, bottomRightP);
            origTopLeftP.x = (0, _math.clamp)(Math.floor(origTopLeftP.x), 0, this.canvas.width);
            origTopLeftP.y = (0, _math.clamp)(Math.floor(origTopLeftP.y), 0, this.canvas.height);
            origBottomRightP.x = (0, _math.clamp)(Math.ceil(origBottomRightP.x), 0, this.canvas.width);
            origBottomRightP.y = (0, _math.clamp)(Math.ceil(origBottomRightP.y), 0, this.canvas.height);
            return {
                x: origTopLeftP.x,
                y: origTopLeftP.y,
                width: origBottomRightP.x - origTopLeftP.x,
                height: origBottomRightP.y - origTopLeftP.y
            };
        };
        let startP;
        let startCrop = null;
        let isDragging = false;
        let didMove = false;
        let updateCropTimeout;
        const pointerChain = new (0, _eventChain.EventChain)({
            chainArr: [
                new (0, _onePointerLimiter.OnePointerLimiter)()
            ]
        });
        pointerChain.setChainOut((event)=>{
            if (event.type === 'pointerdown' && event.button === 'left') {
                event.eventPreventDefault();
                isDragging = true;
                startP = {
                    x: event.relX,
                    y: event.relY
                };
                if (!this.isReset() && isInsideSelectionRect(startP)) startCrop = {
                    x: this.cropRect.x,
                    y: this.cropRect.y,
                    width: this.cropRect.width,
                    height: this.cropRect.height
                };
                else this.cropRect = genCrop(startP, startP);
            } else if (event.type === 'pointermove' && event.button === 'left') {
                event.eventPreventDefault();
                didMove = true;
                if (startCrop) {
                    const transform = this.preview.getTransform();
                    this.cropRect.x = startCrop.x + Math.round((event.relX - startP.x) / transform.scale);
                    this.cropRect.y = startCrop.y + Math.round((event.relY - startP.y) / transform.scale);
                    this.cropRect.x = (0, _bb.BB).clamp(this.cropRect.x, 0, this.canvas.width - this.cropRect.width);
                    this.cropRect.y = (0, _bb.BB).clamp(this.cropRect.y, 0, this.canvas.height - this.cropRect.height);
                } else this.cropRect = genCrop(startP, {
                    x: event.relX,
                    y: event.relY
                });
                this.updateSelectionRect();
            } else if (event.type === 'pointerup' && startP) {
                event.eventPreventDefault();
                isDragging = false;
                startCrop = null;
                startP = null;
                if (this.cropRect.width === 0 || this.cropRect.height === 0 || !didMove) {
                    this.resetCrop();
                    this.updateSelectionRect();
                }
                didMove = false;
                updateCropTimeout = setTimeout(()=>this.updateCroppedCanvas(), 1);
            }
        });
        this.pointerListener = new (0, _bb.BB).PointerListener({
            target: this.eventTarget,
            fixScribble: true,
            onWheel: (event)=>{
                this.preview.onWheel(event);
            },
            onPointer: (event)=>{
                if (this.mode === 'hand') {
                    event.eventPreventDefault();
                    this.preview.onPointer(event);
                    return;
                }
                pointerChain.chainIn(event);
            },
            maxPointers: 2
        });
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, e)=>{
                if (isDragging) return;
                let doUpdate = false;
                const transform = this.preview.getTransform();
                const stepSize = Math.max(1, 1 / transform.scale);
                const shiftIsPressed = this.keyListener.isPressed('shift');
                if (keyStr === 'left') {
                    if (shiftIsPressed) this.cropRect.width = (0, _bb.BB).clamp(this.cropRect.width - stepSize, 1, this.canvas.width - this.cropRect.x);
                    else this.cropRect.x = (0, _bb.BB).clamp(this.cropRect.x - stepSize, 0, this.canvas.width - this.cropRect.width);
                    doUpdate = true;
                }
                if (keyStr === 'right') {
                    if (shiftIsPressed) this.cropRect.width = (0, _bb.BB).clamp(this.cropRect.width + stepSize, 1, this.canvas.width - this.cropRect.x);
                    else this.cropRect.x = (0, _bb.BB).clamp(this.cropRect.x + stepSize, 0, this.canvas.width - this.cropRect.width);
                    doUpdate = true;
                }
                if (keyStr === 'up') {
                    if (shiftIsPressed) this.cropRect.height = (0, _bb.BB).clamp(this.cropRect.height - stepSize, 1, this.canvas.height - this.cropRect.y);
                    else this.cropRect.y = (0, _bb.BB).clamp(this.cropRect.y - stepSize, 0, this.canvas.height - this.cropRect.height);
                    doUpdate = true;
                }
                if (keyStr === 'down') {
                    if (shiftIsPressed) this.cropRect.height = (0, _bb.BB).clamp(this.cropRect.height + stepSize, 1, this.canvas.height - this.cropRect.y);
                    else this.cropRect.y = (0, _bb.BB).clamp(this.cropRect.y + stepSize, 0, this.canvas.height - this.cropRect.height);
                    doUpdate = true;
                }
                if (doUpdate) {
                    e.preventDefault();
                    this.updateSelectionRect();
                    clearTimeout(updateCropTimeout);
                    updateCropTimeout = setTimeout(()=>this.updateCroppedCanvas(), 100);
                }
            }
        });
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    // in input canvas coordinates
    getCropRect() {
        return (0, _bb.BB).copyObj(this.cropRect);
    }
    getCroppedCanvas() {
        return this.croppedCanvas;
    }
    // image/png blob
    getCroppedBlob() {
        return this.croppedBlob;
    }
    setCanvas(canvas) {
        this.canvas = canvas;
        this.previewLayer.image = canvas;
        this.updateCroppedCanvas();
        this.preview.render();
    }
    destroy() {
        if (this.croppedImageElement) this.croppedImageElement.src = '';
        URL.revokeObjectURL(this.croppedObjectUrl);
        this.rootEl.remove();
        this.eventTarget.style.removeProperty('width');
        this.eventTarget.style.removeProperty('height');
        this.keyListener.destroy();
        this.pointerListener.destroy();
        this.preview.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","../project-viewport/preview":"j8zOr","transformation-matrix":"70QDB","../../../bb/transform/create-matrix-from-transform":"6kvhU","../../../bb/math/math":"7x9Fp","../../../language/language":"mcywn","url:/src/app/img/ui/edit-crop.svg":"7YZBQ","../../../bb/input/event-chain/event-chain":"eo2AB","../../../bb/input/event-chain/one-pointer-limiter":"fqRll","../../../bb/base/canvas":"86XNv","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j8zOr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Preview", ()=>Preview);
var _c = require("../../../bb/base/c");
var _projectViewport = require("./project-viewport");
var _bb = require("../../../bb/bb");
var _pointerListener = require("../../../bb/input/pointer-listener");
var _toolZoomInSvg = require("url:/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
var _toolZoomOutSvg = require("url:/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _viewportResetSvg = require("url:/src/app/img/ui/viewport-reset.svg");
var _viewportResetSvgDefault = parcelHelpers.interopDefault(_viewportResetSvg);
var _toolHandSvg = require("url:/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
var _editPencilSvg = require("url:/src/app/img/ui/edit-pencil.svg");
var _editPencilSvgDefault = parcelHelpers.interopDefault(_editPencilSvg);
var _eventChain = require("../../../bb/input/event-chain/event-chain");
var _doubleTapper = require("../../../bb/input/event-chain/double-tapper");
var _previewModuleScss = require("./preview.module.scss");
var _zoomByStep = require("./utils/zoom-by-step");
var _pinchZoomer = require("../../../bb/input/event-chain/pinch-zoomer");
var _language = require("../../../language/language");
var _transformationMatrix = require("transformation-matrix");
var _createTransform = require("../../../bb/transform/create-transform");
var _toMetaTransform = require("../../../bb/transform/to-meta-transform");
var _options = require("../components/options");
var _createMatrixFromTransform = require("../../../bb/transform/create-matrix-from-transform");
var _selectionRenderer = require("../easel/selection-renderer");
var _base = require("../../../bb/base/base");
const DEFAULT_PADDING = 10;
class Preview {
    requestRerender() {
        this.doRender = true;
    }
    resetOrZoom(x, y) {
        if (this.isReset) {
            this.isReset = false;
            const canvasP = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)((0, _createMatrixFromTransform.createMatrixFromTransform)(this.viewport.getTransform())), {
                x,
                y
            });
            this.viewport.setTransform((0, _createTransform.createTransform)({
                x: this.width / 2,
                y: this.height / 2
            }, canvasP, 1, 0));
            this.requestRerender();
        } else this.reset();
    }
    reset() {
        const fit = (0, _bb.BB).fitInto(this.project.width, this.project.height, this.width - this.padding * 2, this.height - this.padding * 2);
        const scale = fit.width / this.project.width;
        this.viewport.setTransform((0, _createTransform.createTransform)({
            x: this.width / 2,
            y: this.height / 2
        }, {
            x: this.project.width / 2,
            y: this.project.height / 2
        }, scale, 0));
        this.isReset = true;
        this.requestRerender();
    }
    transformCanvas(t) {
        if (t.type === 'translate') {
            const old = this.viewport.getTransform();
            if (t.x === 0 && t.y === 0) return;
            this.viewport.setTransform({
                ...old,
                x: old.x + t.x,
                y: old.y + t.y
            });
        } else if (t.type === 'zoom') {
            const old = this.viewport.getTransform();
            const viewportRect = this.viewport.getElement().getBoundingClientRect();
            t.vX = t.vX ?? viewportRect.width / 2;
            t.vY = t.vY ?? viewportRect.height / 2;
            const metaTransform = (0, _toMetaTransform.toMetaTransform)(old, {
                x: t.vX,
                y: t.vY
            });
            metaTransform.scale *= t.fac;
            this.viewport.setTransform((0, _createTransform.createTransform)(metaTransform.viewportP, metaTransform.canvasP, metaTransform.scale, metaTransform.angleDeg));
        }
        this.isReset = false;
        this.requestRerender();
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isReset = true;
        this.doRender = false;
        this.lastEmittedTransform = {
            x: 0,
            y: 0,
            scale: 0,
            angleDeg: 0
        };
        this.renderLoop = ()=>{
            this.animationFrameId = requestAnimationFrame(this.renderLoop);
            if (this.doRender) {
                this.doRender = false;
                this.viewport.render();
                const viewportTransform = this.viewport.getTransform();
                this.selectionRenderer?.setTransform(viewportTransform);
                if (this.onTransformChange && JSON.stringify(this.lastEmittedTransform) !== JSON.stringify(viewportTransform)) {
                    this.onTransformChange(viewportTransform);
                    this.lastEmittedTransform = viewportTransform;
                }
            }
        };
        this.onWheel = (e)=>{
            const viewportRect = this.viewport.getElement().getBoundingClientRect();
            const vX = e.pageX - viewportRect.x;
            const vY = e.pageY - viewportRect.y;
            const oldScale = this.viewport.getTransform().scale;
            const newScale = (0, _zoomByStep.zoomByStep)(oldScale, -e.deltaY / 2);
            this.transformCanvas({
                type: 'zoom',
                vX,
                vY,
                fac: newScale / oldScale
            });
        };
        this.width = p.width;
        this.height = p.height;
        this.project = p.project;
        this.onTransformChange = p.onTransformChange;
        this.padding = p.padding ?? DEFAULT_PADDING;
        const fit = (0, _bb.BB).fitInto(this.project.width, this.project.height, this.width - this.padding * 2, this.height - this.padding * 2);
        const scale = fit.width / this.project.width;
        this.viewport = new (0, _projectViewport.ProjectViewport)({
            width: this.width,
            height: this.height,
            transform: (0, _createTransform.createTransform)({
                x: this.width / 2,
                y: this.height / 2
            }, {
                x: this.project.width / 2,
                y: this.project.height / 2
            }, scale, 0),
            project: this.project,
            useNativeResolution: false,
            drawBackground: true
        });
        const doubleTapper = new (0, _doubleTapper.DoubleTapper)({
            onDoubleTap: (e)=>{
                const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(this.viewport.getTransform());
                const tl = (0, _transformationMatrix.applyToPoint)(m, {
                    x: 0,
                    y: 0
                });
                const br = (0, _transformationMatrix.applyToPoint)(m, {
                    x: this.project.width,
                    y: this.project.height
                });
                const isInside = (0, _bb.BB).isInsideRect({
                    x: e.relX,
                    y: e.relY
                }, {
                    x: tl.x,
                    y: tl.y,
                    width: br.x - tl.x,
                    height: br.y - tl.y
                });
                if (!this.isReset || isInside) this.resetOrZoom(e.relX, e.relY);
            },
            isInstant: true
        });
        let oldTransform = undefined;
        const pinchZoomer = new (0, _pinchZoomer.PinchZoomer)({
            onPinch: (e)=>{
                if (e.type === 'move') {
                    if (!oldTransform) oldTransform = this.viewport.getTransform();
                    const metaTransform = (0, _toMetaTransform.toMetaTransform)(oldTransform, {
                        x: e.downRelX,
                        y: e.downRelY
                    });
                    metaTransform.scale *= e.scale;
                    metaTransform.viewportP.x += e.relX - e.downRelX;
                    metaTransform.viewportP.y += e.relY - e.downRelY;
                    this.viewport.setTransform((0, _createTransform.createTransform)(metaTransform.viewportP, metaTransform.canvasP, metaTransform.scale, metaTransform.angleDeg));
                    this.requestRerender();
                    this.isReset = false;
                } else if (e.type === 'end') oldTransform = undefined;
            }
        });
        this.pointerChain = new (0, _eventChain.EventChain)({
            chainArr: [
                pinchZoomer,
                doubleTapper
            ]
        });
        this.pointerChain.setChainOut((e)=>{
            if (e.button && [
                'left',
                'middle'
            ].includes(e.button)) // debugOut(JSON.stringify(e));
            this.transformCanvas({
                type: 'translate',
                x: e.dX,
                y: e.dY
            });
        });
        this.viewport.getElement().classList.add(_previewModuleScss.viewport);
        (0, _base.css)(this.viewport.getElement(), {
            userSelect: 'none',
            touchAction: 'none'
        });
        this.viewport.getElement().addEventListener('touchend', (e)=>{
            e.preventDefault();
            return false;
        });
        this.viewport.getElement().addEventListener('contextmenu', (e)=>{
            e.preventDefault();
            return false;
        });
        this.viewport.getElement().addEventListener('dragstart', (e)=>{
            e.preventDefault();
            return false;
        });
        this.viewportPointerListener = new (0, _pointerListener.PointerListener)({
            target: this.viewport.getElement(),
            onPointer: (e)=>{
                this.pointerChain.chainIn(e);
            },
            onWheel: this.onWheel,
            maxPointers: 2
        });
        this.viewport.getElement().addEventListener('wheel', (e)=>{
            e.preventDefault();
        });
        const svgRoot = (0, _bb.BB).createSvg({
            elementType: 'svg'
        });
        (0, _base.css)(svgRoot, {
            position: 'absolute',
            left: '0',
            top: '0',
            width: '100%',
            height: '100%',
            pointerEvents: 'none'
        });
        if (p.selection) {
            this.selectionRenderer = new (0, _selectionRenderer.SelectionRenderer)({
                transform: this.lastEmittedTransform,
                selection: p.selection,
                width: this.width,
                height: this.height
            });
            svgRoot.append(this.selectionRenderer.getElement());
        }
        if (p.hasEditMode) this.modeToggle = new (0, _options.Options)({
            optionArr: [
                'edit',
                'hand'
            ].map((id)=>{
                const el = (0, _bb.BB).el({
                    className: 'dark-invert',
                    css: {
                        width: '28px',
                        height: '28px',
                        backgroundSize: 'contain',
                        margin: '5px',
                        backgroundImage: `url(${id === 'edit' ? p.editIcon ?? (0, _editPencilSvgDefault.default) : (0, _toolHandSvgDefault.default)})`,
                        backgroundPosition: 'center',
                        backgroundRepeat: 'no-repeat'
                    }
                });
                return {
                    id,
                    label: el,
                    title: id === 'edit' ? (0, _language.LANG)('tab-edit') : (0, _language.LANG)('tool-hand')
                };
            }),
            initId: 'edit',
            onChange: (val)=>{
                p.onModeChange && p.onModeChange(val);
            }
        });
        // pointer-events: auto - So the canvas can be ignored, while the buttons still work.
        this.rootEl = (0, _c.c)({
            className: p.hasBorder === false ? undefined : _previewModuleScss.preview,
            css: {
                position: 'relative',
                zIndex: '0'
            }
        }, [
            this.viewport.getElement(),
            svgRoot,
            ...this.modeToggle ? [
                (0, _c.c)(',pos-absolute,left-5,top-5,z-1,pointer-auto', [
                    this.modeToggle.getElement()
                ])
            ] : [],
            (0, _c.c)(',pos-absolute,right-5,bottom-5,flex,flexCol,gap-5,z-1,pointer-auto', [
                (0, _c.c)({
                    tagName: 'button',
                    title: (0, _language.LANG)('hand-reset'),
                    onClick: ()=>{
                        this.reset();
                    },
                    content: `<img alt="reset" height="20" src="${(0, _viewportResetSvgDefault.default)}">`,
                    noRef: true
                }),
                (0, _c.c)({
                    tagName: 'button',
                    title: (0, _language.LANG)('zoom-in'),
                    onClick: ()=>{
                        const oldScale = this.viewport.getTransform().scale;
                        const newScale = (0, _zoomByStep.zoomByStep)(oldScale, 1);
                        this.transformCanvas({
                            type: 'zoom',
                            fac: newScale / oldScale
                        });
                    },
                    content: `<img alt="zoom-in" height="20" src="${(0, _toolZoomInSvgDefault.default)}">`,
                    noRef: true
                }),
                (0, _c.c)({
                    tagName: 'button',
                    title: (0, _language.LANG)('zoom-out'),
                    onClick: ()=>{
                        const oldScale = this.viewport.getTransform().scale;
                        const newScale = (0, _zoomByStep.zoomByStep)(oldScale, -1);
                        this.transformCanvas({
                            type: 'zoom',
                            fac: newScale / oldScale
                        });
                    },
                    content: `<img alt="zoom-out" height="20" src="${(0, _toolZoomOutSvgDefault.default)}">`,
                    noRef: true
                })
            ])
        ]);
        this.renderLoop();
    }
    render() {
        this.requestRerender();
    }
    setTransform(transform) {
        this.viewport.setTransform(transform);
        this.requestRerender();
        this.isReset = false;
    }
    getTransform() {
        return this.viewport.getTransform();
    }
    onPointer(event) {
        this.pointerChain.chainIn(event);
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.animationFrameId !== undefined && cancelAnimationFrame(this.animationFrameId);
        this.viewport.destroy();
        this.viewportPointerListener.destroy();
        this.rootEl.remove();
        this.modeToggle && this.modeToggle.destroy();
        this.selectionRenderer?.destroy();
    }
}

},{"../../../bb/base/c":"3KmDH","./project-viewport":"cxBEj","../../../bb/bb":"3zOvT","../../../bb/input/pointer-listener":"kDObC","url:/src/app/img/ui/tool-zoom-in.svg":"6SrvZ","url:/src/app/img/ui/tool-zoom-out.svg":"ifF9F","url:/src/app/img/ui/viewport-reset.svg":"5FJkn","url:/src/app/img/ui/tool-hand.svg":"3vXJO","url:/src/app/img/ui/edit-pencil.svg":"iSzAd","../../../bb/input/event-chain/event-chain":"eo2AB","../../../bb/input/event-chain/double-tapper":"fPbPb","./preview.module.scss":"k7NJM","./utils/zoom-by-step":"f7IyB","../../../bb/input/event-chain/pinch-zoomer":"786i1","../../../language/language":"mcywn","transformation-matrix":"70QDB","../../../bb/transform/create-transform":"kdXSP","../../../bb/transform/to-meta-transform":"4mFA3","../components/options":"7kiPU","../../../bb/transform/create-matrix-from-transform":"6kvhU","../easel/selection-renderer":"eUVrm","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cxBEj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *
 * Scale - size of one project-canvas pixel compared to CSS pixel
 *      -> 1 means 1 pixel in the drawing is the size of a CSS pixel
 *      -> independent of device pixel ratio, or what resolution the viewport
 *          canvas may actually have.
 * Translate - translates in CSS pixels
 * Viewport origin is top left (same as canvas)
 *
 * Order of transformations (matrix multiplication is reversed): translate, rotate, scale
 */ parcelHelpers.export(exports, "ProjectViewport", ()=>ProjectViewport);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
var _theme = require("../../../theme/theme");
var _transformationMatrix = require("transformation-matrix");
var _createMatrixFromTransform = require("../../../bb/transform/create-matrix-from-transform");
var _matrixToTuple = require("../../../bb/math/matrix-to-tuple");
var _debugRender = require("./debug-render");
function fixScale(scale, pixels) {
    return Math.round(pixels * scale) / pixels;
}
class ProjectViewport {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.doResize = true;
        this.onIsDark = ()=>{
            this.pattern = (0, _base.throwIfNull)(this.ctx.createPattern((0, _bb.BB).createCheckerCanvas(10, (0, _theme.THEME).isDark()), 'repeat'));
            this.render();
        };
        this.oldDPR = devicePixelRatio;
        this.resizeListener = ()=>{
            if (devicePixelRatio !== this.oldDPR) {
                this.canvas.style.imageRendering = Math.round(devicePixelRatio) !== devicePixelRatio ? '' : 'pixelated';
                this.oldDPR = devicePixelRatio;
            }
        };
        this.width = p.width;
        this.height = p.height;
        this.project = p.project;
        this.useNativeResolution = !!p.useNativeResolution;
        this.drawBackground = p.drawBackground ?? true;
        this.doFillParent = !!p.fillParent;
        this.renderAfter = p.renderAfter;
        this.transform = {
            ...p.transform
        };
        this.resFactor = this.useNativeResolution ? devicePixelRatio : 1;
        this.canvas = (0, _bb.BB).canvas(this.width * this.resFactor, this.height * this.resFactor);
        this.ctx = (0, _bb.BB).ctx(this.canvas);
        (0, _base.css)(this.canvas, {
            width: this.doFillParent ? '100%' : this.width + 'px',
            height: this.doFillParent ? '100%' : this.height + 'px',
            imageRendering: Math.round(devicePixelRatio) !== devicePixelRatio ? undefined : 'pixelated',
            display: 'block'
        });
        window.addEventListener('resize', this.resizeListener);
        this.pattern = (0, _base.throwIfNull)(this.ctx.createPattern((0, _bb.BB).createCheckerCanvas(10, (0, _theme.THEME).isDark()), 'repeat'));
        (0, _theme.THEME).addIsDarkListener(this.onIsDark);
    // this.render();
    }
    render(optimizeForAnimation) {
        const isDark = (0, _theme.THEME).isDark();
        const transform = {
            ...this.transform,
            x: this.transform.x,
            y: this.transform.y,
            scale: this.transform.scale
        };
        if (this.doResize) {
            this.doResize = false;
            this.resFactor = this.useNativeResolution ? devicePixelRatio : 1;
            this.canvas.width = Math.round(this.width * this.resFactor);
            this.canvas.height = Math.round(this.height * this.resFactor);
        }
        const renderedTransform = optimizeForAnimation ? {
            x: transform.x,
            y: transform.y,
            angleDeg: transform.angleDeg,
            scaleX: transform.scale,
            scaleY: transform.scale
        } : {
            x: Math.round(transform.x),
            y: Math.round(transform.y),
            scaleX: fixScale(transform.scale, this.project.width),
            scaleY: fixScale(transform.scale, this.project.height),
            angleDeg: transform.angleDeg
        };
        const renderedMat = (0, _createMatrixFromTransform.createMatrixFromTransform)(renderedTransform);
        this.ctx.save();
        if (renderedTransform.scaleX >= 4 || renderedTransform.scaleX === 1 && renderedTransform.angleDeg === 0) this.ctx.imageSmoothingEnabled = false;
        else {
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'low'; // art.scale >= 1 ? 'low' : 'medium';
        }
        // this.ctx.imageSmoothingEnabled = false;
        if (this.drawBackground) {
            this.ctx.fillStyle = isDark ? 'rgb(33, 33, 33)' : 'rgb(158,158,158)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
            this.ctx.fillStyle = this.pattern;
            this.ctx.fillRect(0, 0, this.width, this.height);
        }
        // this.ctx.scale(this.resFactor, this.resFactor);
        this.ctx.translate(renderedTransform.x, renderedTransform.y);
        this.ctx.scale(renderedTransform.scaleX, renderedTransform.scaleY);
        this.ctx.rotate(renderedTransform.angleDeg / 180 * Math.PI);
        if (this.drawBackground) {
            this.ctx.save();
            this.ctx.fillStyle = (0, _theme.THEME).isDark() ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.2)';
            const scaledPixelX = 1 / renderedTransform.scaleX;
            const scaledPixelY = 1 / renderedTransform.scaleY;
            this.ctx.fillRect(-scaledPixelX, -scaledPixelY, this.project.width + scaledPixelX * 2, this.project.height + scaledPixelY * 2);
            this.ctx.fillStyle = this.pattern;
            try {
                // setTransform got browser support since 2018-2020. catch if fails.
                this.pattern.setTransform((0, _transformationMatrix.inverse)(renderedMat));
            } catch (e) {
            /* */ }
            this.ctx.fillRect(0, 0, this.project.width, this.project.height);
            this.ctx.restore();
        }
        this.project.layers.forEach((layer)=>{
            if (!layer.isVisible || !layer.opacity) return;
            this.ctx.save();
            this.ctx.globalCompositeOperation = layer.mixModeStr;
            this.ctx.globalAlpha = layer.opacity;
            let image;
            if (typeof layer.image === 'function') {
                const res = layer.image(renderedTransform, this.canvas.width, this.canvas.height);
                if ('image' in res && 'transform' in res) {
                    image = res.image;
                    this.ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)((0, _transformationMatrix.compose)(renderedMat, res.transform)));
                } else image = res;
            } else image = layer.image;
            this.ctx.drawImage(image, 0, 0); // , this.project.width, this.project.height);
            this.ctx.restore();
        });
        this.renderAfter?.(this.ctx, renderedTransform);
        (0, _debugRender.DEBUG_RENDERER_ENABLED) && (0, _debugRender.DEBUG_RENDER).render(this.ctx, this.project.width, this.project.height, renderedTransform.scaleX);
        this.ctx.restore();
    }
    setSize(width, height) {
        this.doResize = true;
        this.width = width;
        this.height = height;
        (0, _base.css)(this.canvas, {
            width: this.doFillParent ? '100%' : this.width + 'px',
            height: this.doFillParent ? '100%' : this.height + 'px'
        });
    }
    setTransform(transform) {
        this.transform = {
            ...transform
        };
    }
    setProject(project) {
        this.project = project;
    }
    getTransform() {
        return {
            ...this.transform
        };
    }
    setUseNativeResolution(b) {
        this.useNativeResolution = b;
        this.doResize = true;
    }
    getUseNativeResolution() {
        return this.useNativeResolution;
    }
    getElement() {
        return this.canvas;
    }
    destroy() {
        (0, _bb.BB).freeCanvas(this.canvas);
        (0, _theme.THEME).removeIsDarkListener(this.onIsDark);
        window.removeEventListener('resize', this.resizeListener);
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","../../../theme/theme":"cVh0j","transformation-matrix":"70QDB","../../../bb/transform/create-matrix-from-transform":"6kvhU","../../../bb/math/matrix-to-tuple":"8BP1P","./debug-render":"g3qLw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"70QDB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _applyToPoint = require("./applyToPoint");
parcelHelpers.exportAll(_applyToPoint, exports);
var _fromObject = require("./fromObject");
parcelHelpers.exportAll(_fromObject, exports);
var _fromString = require("./fromString");
parcelHelpers.exportAll(_fromString, exports);
var _identity = require("./identity");
parcelHelpers.exportAll(_identity, exports);
var _inverse = require("./inverse");
parcelHelpers.exportAll(_inverse, exports);
var _isAffineMatrix = require("./isAffineMatrix");
parcelHelpers.exportAll(_isAffineMatrix, exports);
var _rotate = require("./rotate");
parcelHelpers.exportAll(_rotate, exports);
var _scale = require("./scale");
parcelHelpers.exportAll(_scale, exports);
var _shear = require("./shear");
parcelHelpers.exportAll(_shear, exports);
var _skew = require("./skew");
parcelHelpers.exportAll(_skew, exports);
var _toString = require("./toString");
parcelHelpers.exportAll(_toString, exports);
var _transform = require("./transform");
parcelHelpers.exportAll(_transform, exports);
var _translate = require("./translate");
parcelHelpers.exportAll(_translate, exports);
var _fromTriangles = require("./fromTriangles");
parcelHelpers.exportAll(_fromTriangles, exports);
var _smoothMatrix = require("./smoothMatrix");
parcelHelpers.exportAll(_smoothMatrix, exports);
var _fromDefinition = require("./fromDefinition");
parcelHelpers.exportAll(_fromDefinition, exports);
var _fromTransformAttribute = require("./fromTransformAttribute");
parcelHelpers.exportAll(_fromTransformAttribute, exports);
var _decompose = require("./decompose");
parcelHelpers.exportAll(_decompose, exports);
var _flip = require("./flip");
parcelHelpers.exportAll(_flip, exports);
var _fromMovingPoints = require("./fromMovingPoints");
parcelHelpers.exportAll(_fromMovingPoints, exports);

},{"./applyToPoint":"kLlwC","./fromObject":"tCfy4","./fromString":"hkzT5","./identity":"6IkVZ","./inverse":"1eutl","./isAffineMatrix":"cXQTk","./rotate":"4yoNg","./scale":"eHhrD","./shear":"9f8Ul","./skew":"fI6Px","./toString":"bXrhr","./transform":"cHSP6","./translate":"9xEOu","./fromTriangles":"32MPd","./smoothMatrix":"5sWr0","./fromDefinition":"7O2E1","./fromTransformAttribute":"dbDuX","./decompose":"ahj0T","./flip":"fqjav","./fromMovingPoints":"aK3ix","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kLlwC":[function(require,module,exports,__globalThis) {
/**
 * Calculate a point transformed with an affine matrix
 * @param matrix {Matrix} Affine Matrix
 * @param  point {Point} Point
 * @returns {Point} Point
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyToPoint", ()=>applyToPoint);
/**
 * Calculate an array of points transformed with an affine matrix
 * @param matrix {Matrix} Affine Matrix
 * @param points {Point[]} Array of point
 * @returns {Point[]} Array of point
 */ parcelHelpers.export(exports, "applyToPoints", ()=>applyToPoints);
function applyToPoint(matrix, point) {
    return Array.isArray(point) ? [
        matrix.a * point[0] + matrix.c * point[1] + matrix.e,
        matrix.b * point[0] + matrix.d * point[1] + matrix.f
    ] : {
        x: matrix.a * point.x + matrix.c * point.y + matrix.e,
        y: matrix.b * point.x + matrix.d * point.y + matrix.f
    };
}
function applyToPoints(matrix, points) {
    return points.map((point)=>applyToPoint(matrix, point));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"tCfy4":[function(require,module,exports,__globalThis) {
/**
 * Extract an affine matrix from an object that contains a,b,c,d,e,f keys
 * Any value could be a float or a string that contains a float
 * @param object {Object} Object that contains a,b,c,d,e,f keys
 * @return {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromObject", ()=>fromObject);
function fromObject(object) {
    return {
        a: parseFloat(object.a),
        b: parseFloat(object.b),
        c: parseFloat(object.c),
        d: parseFloat(object.d),
        e: parseFloat(object.e),
        f: parseFloat(object.f)
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hkzT5":[function(require,module,exports,__globalThis) {
/**
 * @ignore
 * @type {RegExp}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parse a string formatted as matrix(a,b,c,d,e,f)
 * @param string {string} String with an affine matrix
 * @returns {Matrix} Affine Matrix
 *
 * @example
 * > fromString('matrix(1,2,3,4,5,6)')
 * {a: 1, b: 2, c: 3, d: 4, c: 5, e: 6}
 */ parcelHelpers.export(exports, "fromString", ()=>fromString);
/**
 * Parse a string formatted as matrix(a,b,c,d,e,f) - Legacy implementation of `fromString(matrix)`;
 * Read this PR for details {@link https://github.com/chrvadala/transformation-matrix/pull/107}
 * @param string {string} String with an affine matrix
 * @deprecated
 * @returns {Matrix} Affine Matrix
 *
 * @example
 * > fromStringLegacy('matrix(1,2,3,4,5,6)')
 * {a: 1, b: 2, c: 3, d: 4, c: 5, e: 6}
 */ parcelHelpers.export(exports, "fromStringLegacy", ()=>fromStringLegacy);
const matrixRegex = /^matrix\(\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*\)$/i;
function fromString(string) {
    const parseFloatOrThrow = (number)=>{
        const n = parseFloat(number);
        if (Number.isFinite(n)) return n // excludes NaN, +Infinite, -Infinite
        ;
        throw new Error(`'${string}' is not a matrix`);
    };
    const prefix = string.substring(0, 7).toLowerCase();
    const suffix = string.substring(string.length - 1);
    const body = string.substring(7, string.length - 1);
    const elements = body.split(',');
    if (prefix === 'matrix(' && suffix === ')' && elements.length === 6) return {
        a: parseFloatOrThrow(elements[0]),
        b: parseFloatOrThrow(elements[1]),
        c: parseFloatOrThrow(elements[2]),
        d: parseFloatOrThrow(elements[3]),
        e: parseFloatOrThrow(elements[4]),
        f: parseFloatOrThrow(elements[5])
    };
    throw new Error(`'${string}' is not a matrix`);
}
function fromStringLegacy(string) {
    const parsed = string.match(matrixRegex);
    if (parsed === null || parsed.length < 7) throw new Error(`'${string}' is not a matrix`);
    return {
        a: parseFloat(parsed[1]),
        b: parseFloat(parsed[2]),
        c: parseFloat(parsed[3]),
        d: parseFloat(parsed[4]),
        e: parseFloat(parsed[5]),
        f: parseFloat(parsed[6])
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6IkVZ":[function(require,module,exports,__globalThis) {
/**
 * Identity matrix
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
function identity() {
    return {
        a: 1,
        c: 0,
        e: 0,
        b: 0,
        d: 1,
        f: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1eutl":[function(require,module,exports,__globalThis) {
/**
 * Calculate a matrix that is the inverse of the provided matrix
 * @param matrix {Matrix} Affine Matrix
 * @returns {Matrix} Inverted Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inverse", ()=>inverse);
function inverse(matrix) {
    // http://www.wolframalpha.com/input/?i=Inverse+%5B%7B%7Ba,c,e%7D,%7Bb,d,f%7D,%7B0,0,1%7D%7D%5D
    const { a, b, c, d, e, f } = matrix;
    const denom = a * d - b * c;
    return {
        a: d / denom,
        b: b / -denom,
        c: c / -denom,
        d: a / denom,
        e: (d * e - c * f) / -denom,
        f: (b * e - a * f) / denom
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cXQTk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Check if the object contain an affine matrix
 * @param object {Object} Generic Plain Object
 * @return {boolean} True if is an object and contains an affine matrix
 */ parcelHelpers.export(exports, "isAffineMatrix", ()=>isAffineMatrix);
var _utils = require("./utils");
function isAffineMatrix(object) {
    return (0, _utils.isObject)(object) && 'a' in object && (0, _utils.isNumeric)(object.a) && 'b' in object && (0, _utils.isNumeric)(object.b) && 'c' in object && (0, _utils.isNumeric)(object.c) && 'd' in object && (0, _utils.isNumeric)(object.d) && 'e' in object && (0, _utils.isNumeric)(object.e) && 'f' in object && (0, _utils.isNumeric)(object.f);
}

},{"./utils":"3XrbL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3XrbL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isUndefined", ()=>isUndefined);
parcelHelpers.export(exports, "isNumeric", ()=>isNumeric);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "matchesShape", ()=>matchesShape);
function isUndefined(val) {
    return typeof val === 'undefined';
}
function isNumeric(n) {
    return typeof n === 'number' && !Number.isNaN(n) && Number.isFinite(n);
}
function isObject(obj) {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
}
function matchesShape(obj, keys) {
    return keys.every((key)=>key in obj);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4yoNg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculate a rotation matrix
 * @param angle {number} Angle in radians
 * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point
 * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Calculate a rotation matrix with a DEG angle
 * @param angle {number} Angle in degree
 * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point
 * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "rotateDEG", ()=>rotateDEG);
var _utils = require("./utils");
var _translate = require("./translate");
var _transform = require("./transform");
const { cos, sin, PI } = Math;
function rotate(angle, cx, cy) {
    const cosAngle = cos(angle);
    const sinAngle = sin(angle);
    const rotationMatrix = {
        a: cosAngle,
        c: -sinAngle,
        e: 0,
        b: sinAngle,
        d: cosAngle,
        f: 0
    };
    if ((0, _utils.isUndefined)(cx) || (0, _utils.isUndefined)(cy)) return rotationMatrix;
    return (0, _transform.transform)([
        (0, _translate.translate)(cx, cy),
        rotationMatrix,
        (0, _translate.translate)(-cx, -cy)
    ]);
}
function rotateDEG(angle, cx, cy) {
    return rotate(angle * PI / 180, cx, cy);
}

},{"./utils":"3XrbL","./translate":"9xEOu","./transform":"cHSP6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9xEOu":[function(require,module,exports,__globalThis) {
/**
 * Calculate a translate matrix
 * @param tx {number} Translation on axis x
 * @param [ty = 0] {number} Translation on axis y
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translate", ()=>translate);
function translate(tx, ty = 0) {
    return {
        a: 1,
        c: 0,
        e: tx,
        b: 0,
        d: 1,
        f: ty
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cHSP6":[function(require,module,exports,__globalThis) {
/**
 * Merge multiple matrices into one
 * @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transform", ()=>transform);
/**
 * Merge multiple matrices into one
 * @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "compose", ()=>compose);
function transform(...matrices) {
    matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices;
    const multiply = (m1, m2)=>{
        return {
            a: m1.a * m2.a + m1.c * m2.b,
            c: m1.a * m2.c + m1.c * m2.d,
            e: m1.a * m2.e + m1.c * m2.f + m1.e,
            b: m1.b * m2.a + m1.d * m2.b,
            d: m1.b * m2.c + m1.d * m2.d,
            f: m1.b * m2.e + m1.d * m2.f + m1.f
        };
    };
    switch(matrices.length){
        case 0:
            throw new Error('no matrices provided');
        case 1:
            return matrices[0];
        case 2:
            return multiply(matrices[0], matrices[1]);
        default:
            {
                const [m1, m2, ...rest] = matrices;
                const m = multiply(m1, m2);
                return transform(m, ...rest);
            }
    }
}
function compose(...matrices) {
    return transform(...matrices);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eHhrD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculate a scaling matrix
 * @param sx {number} Scaling on axis x
 * @param [sy = sx] {number} Scaling on axis y (default sx)
 * @param [cx] {number} If (cx,cy) are supplied the scaling is about this point
 * @param [cy] {number} If (cx,cy) are supplied the scaling is about this point
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "scale", ()=>scale);
var _utils = require("./utils");
var _translate = require("./translate");
var _transform = require("./transform");
function scale(sx, sy, cx, cy) {
    if ((0, _utils.isUndefined)(sy)) sy = sx;
    const scaleMatrix = {
        a: sx,
        c: 0,
        e: 0,
        b: 0,
        d: sy,
        f: 0
    };
    if ((0, _utils.isUndefined)(cx) || (0, _utils.isUndefined)(cy)) return scaleMatrix;
    return (0, _transform.transform)([
        (0, _translate.translate)(cx, cy),
        scaleMatrix,
        (0, _translate.translate)(-cx, -cy)
    ]);
}

},{"./utils":"3XrbL","./translate":"9xEOu","./transform":"cHSP6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9f8Ul":[function(require,module,exports,__globalThis) {
/**
 * Calculate a shear matrix
 * @param shx {number} Shear on axis x
 * @param shy {number} Shear on axis y
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shear", ()=>shear);
function shear(shx, shy) {
    return {
        a: 1,
        c: shx,
        e: 0,
        b: shy,
        d: 1,
        f: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fI6Px":[function(require,module,exports,__globalThis) {
// https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculate a skew matrix
 * @param ax {number} Skew on axis x
 * @param ay {number} Skew on axis y
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "skew", ()=>skew);
/**
 * Calculate a skew matrix using DEG angles
 * @param ax {number} Skew on axis x
 * @param ay {number} Skew on axis y
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "skewDEG", ()=>skewDEG);
const { tan } = Math;
function skew(ax, ay) {
    return {
        a: 1,
        c: tan(ax),
        e: 0,
        b: tan(ay),
        d: 1,
        f: 0
    };
}
function skewDEG(ax, ay) {
    return skew(ax * Math.PI / 180, ay * Math.PI / 180);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bXrhr":[function(require,module,exports,__globalThis) {
/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toCSS", ()=>toCSS);
/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */ parcelHelpers.export(exports, "toSVG", ()=>toSVG);
/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */ parcelHelpers.export(exports, "toString", ()=>toString);
function toCSS(matrix) {
    return toString(matrix);
}
function toSVG(matrix) {
    return toString(matrix);
}
function toString(matrix) {
    return `matrix(${matrix.a},${matrix.b},${matrix.c},${matrix.d},${matrix.e},${matrix.f})`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"32MPd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a matrix that transforms a triangle t1 into another triangle t2, or throws an exception if it is impossible.
 * @param t1 {Point[]} Array of points containing the three points for the first triangle
 * @param t2 {Point[]} Array of points containing the three points for the second triangle
 * @returns {Matrix} Matrix which transforms t1 to t2
 * @throws Exception if the matrix becomes not invertible
 */ parcelHelpers.export(exports, "fromTriangles", ()=>fromTriangles);
var _inverse = require("./inverse");
var _transform = require("./transform");
var _smoothMatrix = require("./smoothMatrix");
function fromTriangles(t1, t2) {
    // point p = first point of the triangle
    const px1 = t1[0].x != null ? t1[0].x : t1[0][0];
    const py1 = t1[0].y != null ? t1[0].y : t1[0][1];
    const px2 = t2[0].x != null ? t2[0].x : t2[0][0];
    const py2 = t2[0].y != null ? t2[0].y : t2[0][1];
    // point q = second point of the triangle
    const qx1 = t1[1].x != null ? t1[1].x : t1[1][0];
    const qy1 = t1[1].y != null ? t1[1].y : t1[1][1];
    const qx2 = t2[1].x != null ? t2[1].x : t2[1][0];
    const qy2 = t2[1].y != null ? t2[1].y : t2[1][1];
    // point r = third point of the triangle
    const rx1 = t1[2].x != null ? t1[2].x : t1[2][0];
    const ry1 = t1[2].y != null ? t1[2].y : t1[2][1];
    const rx2 = t2[2].x != null ? t2[2].x : t2[2][0];
    const ry2 = t2[2].y != null ? t2[2].y : t2[2][1];
    const r1 = {
        a: px1 - rx1,
        b: py1 - ry1,
        c: qx1 - rx1,
        d: qy1 - ry1,
        e: rx1,
        f: ry1
    };
    const r2 = {
        a: px2 - rx2,
        b: py2 - ry2,
        c: qx2 - rx2,
        d: qy2 - ry2,
        e: rx2,
        f: ry2
    };
    const inverseR1 = (0, _inverse.inverse)(r1);
    const affineMatrix = (0, _transform.transform)([
        r2,
        inverseR1
    ]);
    // round the matrix elements to smooth the finite inversion
    return (0, _smoothMatrix.smoothMatrix)(affineMatrix);
}

},{"./inverse":"1eutl","./transform":"cHSP6","./smoothMatrix":"5sWr0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5sWr0":[function(require,module,exports,__globalThis) {
/**
 * Rounds all elements of the given matrix using the given precision
 * @param matrix {Matrix} An affine matrix to round
 * @param [precision] {number} A precision to use for Math.round. Defaults to 10000000000 (meaning which rounds to the 10th digit after the comma).
 * @returns {Matrix} The rounded Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smoothMatrix", ()=>smoothMatrix);
function smoothMatrix(matrix, precision = 10000000000) {
    return {
        a: Math.round(matrix.a * precision) / precision,
        b: Math.round(matrix.b * precision) / precision,
        c: Math.round(matrix.c * precision) / precision,
        d: Math.round(matrix.d * precision) / precision,
        e: Math.round(matrix.e * precision) / precision,
        f: Math.round(matrix.f * precision) / precision
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7O2E1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts array of matrix descriptor to array of matrix
 * @param definitionOrArrayOfDefinition {Object[]} Array of object describing the matrix
 * @returns {Matrix[]} Array of matrix
 *
 * @example
 * > fromDefinition([
 *  { type: 'matrix', a:1, b:2, c:3, d:4, e:5, f:6 },
 *  { type: 'translate', tx: 10, ty: 20 },
 *  { type: 'scale', sx: 2, sy: 4 },
 *  { type: 'rotate', angle: 90, cx: 50, cy: 25 },
 *  { type: 'skewX', angle: 45 },
 *  { type: 'skewY',  angle: 45 },
 *  { type: 'shear', shx: 10, shy: 20}
 * ])
 *
 * [
 *  { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 },
 *  { a: 1, c: 0, e: 10, b: 0, d: 1, f: 20 },
 *  { a: 2, c: 0, e: 0, b: 0, d: 4, f: 0 },
 *  { a: 6.123, c: -1, e: 0, b: 1, d: 6.123, f: 0 },
 *  { a: 1, c: 0.99.., e: 0, b: 0, d: 1, f: 0 },
 *  { a: 1, c: 0, e: 0, b: 0.99, d: 1, f: 0 },
 *  { a: 1, c: 10, e: 0, b: 20, d: 1, f: 0 }
 * ]
 **/ parcelHelpers.export(exports, "fromDefinition", ()=>fromDefinition);
var _fromObject = require("./fromObject");
var _translate = require("./translate");
var _scale = require("./scale");
var _rotate = require("./rotate");
var _skew = require("./skew");
var _shear = require("./shear");
function fromDefinition(definitionOrArrayOfDefinition) {
    return Array.isArray(definitionOrArrayOfDefinition) ? definitionOrArrayOfDefinition.map(mapper) : mapper(definitionOrArrayOfDefinition);
    function mapper(descriptor) {
        switch(descriptor.type){
            case 'matrix':
                if ('a' in descriptor && 'b' in descriptor && 'c' in descriptor && 'd' in descriptor && 'e' in descriptor && 'f' in descriptor) return (0, _fromObject.fromObject)(descriptor);
                else throw new Error('MISSING_MANDATORY_PARAM');
            case 'translate':
                if (!('tx' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM');
                if ('ty' in descriptor) return (0, _translate.translate)(descriptor.tx, descriptor.ty);
                return (0, _translate.translate)(descriptor.tx);
            case 'scale':
                if (!('sx' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM');
                if ('sy' in descriptor) return (0, _scale.scale)(descriptor.sx, descriptor.sy);
                return (0, _scale.scale)(descriptor.sx);
            case 'rotate':
                if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM');
                if ('cx' in descriptor && 'cy' in descriptor) return (0, _rotate.rotateDEG)(descriptor.angle, descriptor.cx, descriptor.cy);
                return (0, _rotate.rotateDEG)(descriptor.angle);
            case 'skewX':
                if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM');
                return (0, _skew.skewDEG)(descriptor.angle, 0);
            case 'skewY':
                if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM');
                return (0, _skew.skewDEG)(0, descriptor.angle);
            case 'shear':
                if (!('shx' in descriptor && 'shy' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM');
                return (0, _shear.shear)(descriptor.shx, descriptor.shy);
            default:
                throw new Error('UNSUPPORTED_DESCRIPTOR');
        }
    }
}

},{"./fromObject":"tCfy4","./translate":"9xEOu","./scale":"eHhrD","./rotate":"4yoNg","./skew":"fI6Px","./shear":"9f8Ul","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dbDuX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parser for SVG Trasform Attribute http://www.w3.org/TR/SVG/coords.html#TransformAttribute
 * @param transformString {string} Transform string as defined by w3 Consortium
 * @returns {MatrixDescriptor[]} Array of MatrixDescriptor
 *
 * @example
 * > fromTransformAttribute('translate(-10,-10) scale(2,2) translate(10,10)')
 * [
 *  { type: 'translate', tx: -10, ty: -10},
 *  { type: 'scale', sx: 2, sy: 2 },
 *  { type: 'translate', tx: 10, ty: 10}
 * ]
 *
 * > compose(fromDefinition(fromTransformAttribute('translate(-10, -10) scale(10, 10)')))
 * { a: 10, c: 0, e: -10, b: 0, d: 10, f: -10 }
 */ parcelHelpers.export(exports, "fromTransformAttribute", ()=>fromTransformAttribute);
var _fromTransformAttributeAutogenerated = require("./fromTransformAttribute.autogenerated");
function fromTransformAttribute(transformString) {
    return (0, _fromTransformAttributeAutogenerated.parse)(transformString);
}

},{"./fromTransformAttribute.autogenerated":"klMRQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"klMRQ":[function(require,module,exports,__globalThis) {
// @generated by Peggy 5.0.6.
//
// https://peggyjs.org/
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StartRules", ()=>peg$allowedStartRules);
parcelHelpers.export(exports, "SyntaxError", ()=>peg$SyntaxError);
parcelHelpers.export(exports, "parse", ()=>peg$parse);
class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location){
        super(message);
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
    }
    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            const st = sources.find((s)=>s.source === this.location.source);
            if (st) src = st.text.split(/\r\n|\n|\r/g);
            const s = this.location.start;
            const offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
                const e = this.location.end;
                const filler = "".padEnd(offset_s.line.toString().length, " ");
                const line = src[s.line - 1];
                const last = s.line === e.line ? e.column : line.length + 1;
                const hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + "".padEnd(s.column - 1, " ") + "".padEnd(hatLen, "^");
            } else str += "\n at " + loc;
        }
        return str;
    }
    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase();
        }
        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode") ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu") : null;
        function unicodeEscape(s) {
            if (nonPrintable) return s.replace(nonPrintable, (ch)=>"\\u{" + hex(ch) + "}");
            return s;
        }
        function literalEscape(s) {
            return unicodeEscape(s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch)));
        }
        function classEscape(s) {
            return unicodeEscape(s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch)));
        }
        const DESCRIBE_EXPECTATION_FNS = {
            literal (expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
            },
            class (expectation) {
                const escapedParts = expectation.parts.map((part)=>Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part));
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
            },
            any () {
                return "any character";
            },
            end () {
                return "end of input";
            },
            other (expectation) {
                return expectation.description;
            }
        };
        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation);
            descriptions.sort();
            if (descriptions.length > 0) {
                let j = 1;
                for(let i = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                }
                descriptions.length = j;
            }
            switch(descriptions.length){
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found) {
            return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
}
function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    const peg$FAILED = {};
    const peg$source = options.grammarSource;
    const peg$startRuleFunctions = {
        transformList: peg$parsetransformList
    };
    let peg$startRuleFunction = peg$parsetransformList;
    const peg$c0 = "matrix";
    const peg$c1 = "(";
    const peg$c2 = ")";
    const peg$c3 = "translate";
    const peg$c4 = "scale";
    const peg$c5 = "rotate";
    const peg$c6 = "skewX";
    const peg$c7 = "skewY";
    const peg$c8 = ",";
    const peg$c9 = ".";
    const peg$r0 = /^[eE]/;
    const peg$r1 = /^[+\-]/;
    const peg$r2 = /^[0-9]/;
    const peg$r3 = /^[ \t\r\n]/;
    const peg$e0 = peg$literalExpectation("matrix", false);
    const peg$e1 = peg$literalExpectation("(", false);
    const peg$e2 = peg$literalExpectation(")", false);
    const peg$e3 = peg$literalExpectation("translate", false);
    const peg$e4 = peg$literalExpectation("scale", false);
    const peg$e5 = peg$literalExpectation("rotate", false);
    const peg$e6 = peg$literalExpectation("skewX", false);
    const peg$e7 = peg$literalExpectation("skewY", false);
    const peg$e8 = peg$literalExpectation(",", false);
    const peg$e9 = peg$otherExpectation("fractionalConstant");
    const peg$e10 = peg$literalExpectation(".", false);
    const peg$e11 = peg$classExpectation([
        "e",
        "E"
    ], false, false, false);
    const peg$e12 = peg$classExpectation([
        "+",
        "-"
    ], false, false, false);
    const peg$e13 = peg$classExpectation([
        [
            "0",
            "9"
        ]
    ], false, false, false);
    const peg$e14 = peg$classExpectation([
        " ",
        "\t",
        "\r",
        "\n"
    ], false, false, false);
    function peg$f0(ts) {
        return ts;
    }
    function peg$f1(t, ts) {
        return t.concat(ts);
    }
    function peg$f2(a, b, c, d, e, f) {
        return [
            {
                type: 'matrix',
                a: a,
                b: b,
                c: c,
                d: d,
                e: e,
                f: f
            }
        ];
    }
    function peg$f3(tx, ty) {
        var t = {
            type: 'translate',
            tx: tx
        };
        if (ty) t.ty = ty;
        return [
            t
        ];
    }
    function peg$f4(sx, sy) {
        var s = {
            type: 'scale',
            sx: sx
        };
        if (sy) s.sy = sy;
        return [
            s
        ];
    }
    function peg$f5(angle, c) {
        var r = {
            type: 'rotate',
            angle: angle
        };
        if (c) {
            r.cx = c[0];
            r.cy = c[1];
        }
        return [
            r
        ];
    }
    function peg$f6(angle) {
        return [
            {
                type: 'skewX',
                angle: angle
            }
        ];
    }
    function peg$f7(angle) {
        return [
            {
                type: 'skewY',
                angle: angle
            }
        ];
    }
    function peg$f8(f) {
        return parseFloat(f.join(""));
    }
    function peg$f9(i) {
        return parseInt(i.join(""));
    }
    function peg$f10(n) {
        return n;
    }
    function peg$f11(n1, n2) {
        return [
            n1,
            n2
        ];
    }
    function peg$f12(ds) {
        return ds.join("");
    }
    function peg$f13(f, e) {
        return [
            f,
            e || null
        ].join("");
    }
    function peg$f14(d, e) {
        return [
            d,
            e
        ].join("");
    }
    function peg$f15(d1, d2) {
        return [
            d1 ? d1.join("") : null,
            ".",
            d2.join("")
        ].join("");
    }
    function peg$f16(d) {
        return d.join("");
    }
    function peg$f17(s, d) {
        return [
            'e',
            s,
            d.join("")
        ].join("");
    }
    let peg$currPos = options.peg$currPos | 0;
    let peg$savedPos = peg$currPos;
    const peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    let peg$maxFailPos = peg$currPos;
    let peg$maxFailExpected = options.peg$maxFailExpected || [];
    let peg$silentFails = options.peg$silentFails | 0;
    let peg$result;
    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function offset() {
        return peg$savedPos;
    }
    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos
        };
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location);
    }
    function error(message, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
    }
    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos);
        if (cp === undefined) return "";
        return String.fromCodePoint(cp);
    }
    function peg$literalExpectation(text, ignoreCase) {
        return {
            type: "literal",
            text,
            ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return {
            type: "class",
            parts,
            inverted,
            ignoreCase,
            unicode
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description
        };
    }
    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;
        if (details) return details;
        else {
            if (pos >= peg$posDetailsCache.length) p = peg$posDetailsCache.length - 1;
            else {
                p = pos;
                while(!peg$posDetailsCache[--p]);
            }
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);
        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
        if (offset && peg$source && typeof peg$source.offset === "function") {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }
    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
    }
    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parsetransformList() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsewsp();
        }
        s2 = peg$parsetransforms();
        if (s2 === peg$FAILED) s2 = null;
        s3 = [];
        s4 = peg$parsewsp();
        while(s4 !== peg$FAILED){
            s3.push(s4);
            s4 = peg$parsewsp();
        }
        peg$savedPos = s0;
        s0 = peg$f0(s2);
        return s0;
    }
    function peg$parsetransforms() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsetransform();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsecommaWsp();
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsecommaWsp();
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                s3 = peg$parsetransforms();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f1(s1, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsetransform();
        return s0;
    }
    function peg$parsetransform() {
        let s0;
        s0 = peg$parsematrix();
        if (s0 === peg$FAILED) {
            s0 = peg$parsetranslate();
            if (s0 === peg$FAILED) {
                s0 = peg$parsescale();
                if (s0 === peg$FAILED) {
                    s0 = peg$parserotate();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseskewX();
                        if (s0 === peg$FAILED) s0 = peg$parseskewY();
                    }
                }
            }
        }
        return s0;
    }
    function peg$parsematrix() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c0) {
            s1 = peg$c0;
            peg$currPos += 6;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e0);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWsp();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsenumber();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsecommaWsp();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parsenumber();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsecommaWsp();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parsenumber();
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parsecommaWsp();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parsenumber();
                                                if (s13 !== peg$FAILED) {
                                                    s14 = peg$parsecommaWsp();
                                                    if (s14 !== peg$FAILED) {
                                                        s15 = peg$parsenumber();
                                                        if (s15 !== peg$FAILED) {
                                                            s16 = [];
                                                            s17 = peg$parsewsp();
                                                            while(s17 !== peg$FAILED){
                                                                s16.push(s17);
                                                                s17 = peg$parsewsp();
                                                            }
                                                            if (input.charCodeAt(peg$currPos) === 41) {
                                                                s17 = peg$c2;
                                                                peg$currPos++;
                                                            } else {
                                                                s17 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$e2);
                                                            }
                                                            if (s17 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s0 = peg$f2(s5, s7, s9, s11, s13, s15);
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsetranslate() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c3) {
            s1 = peg$c3;
            peg$currPos += 9;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e3);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWspNumber();
                    if (s6 === peg$FAILED) s6 = null;
                    s7 = [];
                    s8 = peg$parsewsp();
                    while(s8 !== peg$FAILED){
                        s7.push(s8);
                        s8 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s8 = peg$c2;
                        peg$currPos++;
                    } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f3(s5, s6);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsescale() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c4) {
            s1 = peg$c4;
            peg$currPos += 5;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e4);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWspNumber();
                    if (s6 === peg$FAILED) s6 = null;
                    s7 = [];
                    s8 = peg$parsewsp();
                    while(s8 !== peg$FAILED){
                        s7.push(s8);
                        s8 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s8 = peg$c2;
                        peg$currPos++;
                    } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f4(s5, s6);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parserotate() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c5) {
            s1 = peg$c5;
            peg$currPos += 6;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e5);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWspTwoNumbers();
                    if (s6 === peg$FAILED) s6 = null;
                    s7 = [];
                    s8 = peg$parsewsp();
                    while(s8 !== peg$FAILED){
                        s7.push(s8);
                        s8 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s8 = peg$c2;
                        peg$currPos++;
                    } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f5(s5, s6);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseskewX() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c6) {
            s1 = peg$c6;
            peg$currPos += 5;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e6);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parsewsp();
                    while(s7 !== peg$FAILED){
                        s6.push(s7);
                        s7 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s7 = peg$c2;
                        peg$currPos++;
                    } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f6(s5);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseskewY() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c7) {
            s1 = peg$c7;
            peg$currPos += 5;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e7);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parsewsp();
                    while(s7 !== peg$FAILED){
                        s6.push(s7);
                        s7 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s7 = peg$c2;
                        peg$currPos++;
                    } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f7(s5);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsenumber() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesign();
        if (s2 === peg$FAILED) s2 = null;
        s3 = peg$parsefloatingPointConstant();
        if (s3 !== peg$FAILED) {
            s2 = [
                s2,
                s3
            ];
            s1 = s2;
        } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parsesign();
            if (s2 === peg$FAILED) s2 = null;
            s3 = peg$parseintegerConstant();
            if (s3 !== peg$FAILED) {
                s2 = [
                    s2,
                    s3
                ];
                s1 = s2;
            } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f9(s1);
            }
            s0 = s1;
        }
        return s0;
    }
    function peg$parsecommaWspNumber() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsecommaWsp();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f10(s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsecommaWspTwoNumbers() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parsecommaWsp();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsecommaWsp();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsenumber();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f11(s2, s4);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsecommaWsp() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsewsp();
        }
        else s1 = peg$FAILED;
        if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma();
            if (s2 === peg$FAILED) s2 = null;
            s3 = [];
            s4 = peg$parsewsp();
            while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parsewsp();
            }
            s1 = [
                s1,
                s2,
                s3
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecomma();
            if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsewsp();
                while(s3 !== peg$FAILED){
                    s2.push(s3);
                    s3 = peg$parsewsp();
                }
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parsecomma() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 44) {
            s0 = peg$c8;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e8);
        }
        return s0;
    }
    function peg$parseintegerConstant() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsedigitSequence();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f12(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parsefloatingPointConstant() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsefractionalConstant();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseexponent();
            if (s2 === peg$FAILED) s2 = null;
            peg$savedPos = s0;
            s0 = peg$f13(s1, s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedigitSequence();
            if (s1 !== peg$FAILED) {
                s2 = peg$parseexponent();
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f14(s1, s2);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parsefractionalConstant() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsedigitSequence();
        if (s1 === peg$FAILED) s1 = null;
        if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c9;
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e10);
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parsedigitSequence();
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f15(s1, s3);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedigitSequence();
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                    s2 = peg$c9;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e10);
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f16(s1);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e9);
        }
        return s0;
    }
    function peg$parseexponent() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = input.charAt(peg$currPos);
        if (peg$r0.test(s1)) peg$currPos++;
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e11);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsesign();
            if (s2 === peg$FAILED) s2 = null;
            s3 = peg$parsedigitSequence();
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f17(s2, s3);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsesign() {
        let s0;
        s0 = input.charAt(peg$currPos);
        if (peg$r1.test(s0)) peg$currPos++;
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e12);
        }
        return s0;
    }
    function peg$parsedigitSequence() {
        let s0, s1;
        s0 = [];
        s1 = peg$parsedigit();
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            s1 = peg$parsedigit();
        }
        else s0 = peg$FAILED;
        return s0;
    }
    function peg$parsedigit() {
        let s0;
        s0 = input.charAt(peg$currPos);
        if (peg$r2.test(s0)) peg$currPos++;
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e13);
        }
        return s0;
    }
    function peg$parsewsp() {
        let s0;
        s0 = input.charAt(peg$currPos);
        if (peg$r3.test(s0)) peg$currPos++;
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e14);
        }
        return s0;
    }
    peg$result = peg$startRuleFunction();
    const peg$success = peg$result !== peg$FAILED && peg$currPos === input.length;
    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
    if (options.peg$library) return /** @type {any} */ {
        peg$result,
        peg$currPos,
        peg$FAILED,
        peg$maxFailExpected,
        peg$maxFailPos,
        peg$success,
        peg$throw: peg$success ? undefined : peg$throw
    };
    if (peg$success) return peg$result;
    else peg$throw();
}
const peg$allowedStartRules = [
    "transformList"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ahj0T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Decompose a matrix into translation, scaling and rotation components, optionally
 * take horizontal and vertical flip in to consideration.
 * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for
 * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:
 *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }
 * composing in a different order may yield a different decomposition result.
 * @param matrix {Matrix} Affine Matrix
 * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis
 * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis
 * @returns {Transform} A transform object consisted by its translation, scaling
 * and rotation components.
 */ parcelHelpers.export(exports, "decomposeTSR", ()=>decomposeTSR);
var _scale = require("./scale");
var _transform = require("./transform");
function decomposeTSR(matrix, flipX = false, flipY = false) {
    // Remove flip from the matrix first - flip could be incorrectly interpreted as
    // rotations (e.g. flipX + flipY = rotate by 180 degrees).
    // Note flipX is a vertical flip, and flipY is a horizontal flip.
    if (flipX) {
        if (flipY) matrix = (0, _transform.compose)(matrix, (0, _scale.scale)(-1, -1));
        else matrix = (0, _transform.compose)(matrix, (0, _scale.scale)(1, -1));
    } else if (flipY) matrix = (0, _transform.compose)(matrix, (0, _scale.scale)(-1, 1));
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    let scaleX, scaleY, rotation;
    if (a !== 0 || c !== 0) {
        const hypotAc = Math.hypot(a, c);
        scaleX = hypotAc;
        scaleY = (a * d - b * c) / hypotAc;
        const acos = Math.acos(a / hypotAc);
        rotation = c > 0 ? -acos : acos;
    } else if (b !== 0 || d !== 0) {
        const hypotBd = Math.hypot(b, d);
        scaleX = (a * d - b * c) / hypotBd;
        scaleY = hypotBd;
        const acos = Math.acos(b / hypotBd);
        rotation = Math.PI / 2 + (d > 0 ? -acos : acos);
    } else {
        scaleX = 0;
        scaleY = 0;
        rotation = 0;
    }
    // put the flip factors back
    if (flipY) scaleX = -scaleX;
    if (flipX) scaleY = -scaleY;
    return {
        translate: {
            tx: matrix.e,
            ty: matrix.f
        },
        scale: {
            sx: scaleX,
            sy: scaleY
        },
        rotation: {
            angle: rotation
        }
    };
}

},{"./scale":"eHhrD","./transform":"cHSP6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqjav":[function(require,module,exports,__globalThis) {
/**
 * Tranformation matrix that mirrors on x-axis
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flipX", ()=>flipX);
/**
 * Tranformation matrix that mirrors on y-axis
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "flipY", ()=>flipY);
/**
 * Tranformation matrix that mirrors on origin
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "flipOrigin", ()=>flipOrigin);
function flipX() {
    return {
        a: 1,
        c: 0,
        e: 0,
        b: 0,
        d: -1,
        f: 0
    };
}
function flipY() {
    return {
        a: -1,
        c: 0,
        e: 0,
        b: 0,
        d: 1,
        f: 0
    };
}
function flipOrigin() {
    return {
        a: -1,
        c: 0,
        e: 0,
        b: 0,
        d: -1,
        f: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aK3ix":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// https://manivannan-ai.medium.com/find-the-angle-between-three-points-from-2d-using-python-348c513e2cd
/**
 * Calculate a transformation matrix from a point that starts from A to A'
 * This approach can be associated to a pointer that moves on a device
 * @param {Point} startingPoint - Starting point (A)
 * @param {Point} endingPoint - Ending point (A')
 */ parcelHelpers.export(exports, "fromOneMovingPoint", ()=>fromOneMovingPoint);
/**
 * Calculate a transformation matrix about two points that move from positions A and B to A' and B'
 * This approach can be associated to a two finger gesture on a touch device
 * @param {Point} startingPoint1 - Starting Point (A)
 * @param {Point} startingPoint2 - Starting Point (B)
 * @param {Point} endingPoint1 - Ending point (A')
 * @param {Point} endingPoint2 - Ending Point (B')
 */ parcelHelpers.export(exports, "fromTwoMovingPoints", ()=>fromTwoMovingPoints);
var _translate = require("./translate");
var _applyToPoint = require("./applyToPoint");
var _rotate = require("./rotate");
var _scale = require("./scale");
var _transform = require("./transform");
function fromOneMovingPoint(startingPoint, endingPoint) {
    const tx = endingPoint.x - startingPoint.x;
    const ty = endingPoint.y - startingPoint.y;
    return (0, _translate.translate)(tx, ty);
}
function fromTwoMovingPoints(startingPoint1, startingPoint2, endingPoint1, endingPoint2) {
    // finds translation
    const translationMatrix = fromOneMovingPoint(startingPoint1, endingPoint1);
    const pointA = (0, _applyToPoint.applyToPoint)(translationMatrix, startingPoint2) // I have to translate this point
    ;
    const center = endingPoint1;
    const pointB = endingPoint2;
    // finds rotation matrix
    const angle = Math.atan2(pointB.y - center.y, pointB.x - center.x) - Math.atan2(pointA.y - center.y, pointA.x - center.x);
    const rotationMatrix = (0, _rotate.rotate)(angle, center.x, center.y);
    // finds scale matrix
    const d1 = Math.sqrt(Math.pow(pointA.x - center.x, 2) + Math.pow(pointA.y - center.y, 2));
    const d2 = Math.sqrt(Math.pow(pointB.x - center.x, 2) + Math.pow(pointB.y - center.y, 2));
    const scalingLevel = d2 / d1;
    const scalingMatrix = (0, _scale.scale)(scalingLevel, scalingLevel, center.x, center.y);
    return (0, _transform.compose)([
        translationMatrix,
        scalingMatrix,
        rotationMatrix
    ]);
}

},{"./translate":"9xEOu","./applyToPoint":"kLlwC","./rotate":"4yoNg","./scale":"eHhrD","./transform":"cHSP6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6kvhU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createMatrixFromTransform", ()=>createMatrixFromTransform);
var _transformationMatrix = require("transformation-matrix");
function createMatrixFromTransform(transform) {
    const scaleX = 'scale' in transform ? transform.scale : transform.scaleX;
    const scaleY = 'scale' in transform ? transform.scale : transform.scaleY;
    return (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(transform.x, transform.y), (0, _transformationMatrix.rotate)(transform.angleDeg / 180 * Math.PI), (0, _transformationMatrix.scale)(scaleX, scaleY));
}

},{"transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8BP1P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "matrixToTuple", ()=>matrixToTuple);
function matrixToTuple(m) {
    return [
        m.a,
        m.b,
        m.c,
        m.d,
        m.e,
        m.f
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g3qLw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEBUG_RENDERER_ENABLED", ()=>DEBUG_RENDERER_ENABLED);
parcelHelpers.export(exports, "DEBUG_RENDER", ()=>DEBUG_RENDER);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
var _klHistory = require("../../history/kl-history");
const DEBUG_RENDERER_ENABLED = false;
/**
 * renders into all ProjectViewports
 */ class DebugRender {
    // --------------- public ---------------------
    constructor(){
        this.internalRenderFuncs = [];
        this.renderFuncs = [];
        if (DEBUG_RENDERER_ENABLED) {
            // draw checkerboard
            const checkerCanvas = (0, _bb.BB).createCheckerCanvas(256, false);
            const pattern = (0, _base.throwIfNull)((0, _bb.BB).ctx((0, _bb.BB).canvas((0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE))).createPattern(checkerCanvas, 'repeat'));
            this.internalRenderFuncs.push((ctx, width, height)=>{
                ctx.fillStyle = pattern;
                ctx.globalAlpha = 0.2;
                ctx.fillRect(0, 0, width, height);
            });
        }
    }
    render(ctx, width, height, scale) {
        this.internalRenderFuncs.forEach((func)=>{
            ctx.save();
            func(ctx, width, height, scale);
            ctx.restore();
        });
        this.renderFuncs.forEach((func)=>{
            ctx.save();
            func(ctx, width, height, scale);
            ctx.restore();
        });
    }
    // add something to be rendered
    add(func) {
        this.renderFuncs.push(func);
    }
    remove(func) {
        for(let i = 0; i < this.renderFuncs.length; i++)if (this.renderFuncs[i] === func) {
            this.renderFuncs.splice(i, 1);
            return;
        }
    }
    clear() {
        this.renderFuncs = [];
    }
}
const DEBUG_RENDER = new DebugRender();

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","../../history/kl-history":"l5YQK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l5YQK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HISTORY_TILE_SIZE", ()=>HISTORY_TILE_SIZE);
parcelHelpers.export(exports, "KlHistory", ()=>KlHistory);
var _composeHistoryStateData = require("./compose-history-state-data");
var _estimateBytes = require("./estimate-bytes");
var _entryCausesChange = require("./entry-causes-change");
const HISTORY_TILE_SIZE = 256;
const HISTORY_DEBUGGING = true;
class KlHistory {
    broadcast() {
        this.changeCount++;
        setTimeout(()=>{
            for(let i = 0; i < this.listeners.length; i++)this.listeners[i]();
        }, 1);
    }
    updateComposed() {
        this.composed = (0, _composeHistoryStateData.composeHistoryStateData)(this.entries.slice(0, this.index + 1).map((item)=>item.data));
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        // total number of non-free undo steps
        this.maxUndoSteps = 20;
        /*
    All entries together can't exceed this limit. Supersedes maxUndoSteps. Intended
    to ensure app stability.

    The worst-case (memory wise) happens when the project at max size with max layers is
    rotated repeatedly, or the user continually imports a large project.

    max image size:      2048 x 2048
    max layers:          16
    max history entries: 20 + 1 (+1 is the current state of KlCanvas)
          1 layer @ 2048 x 2048 = 16,777,216 Bytes    = 16.78 MB    = 0.02 GB
         16 layer @ 2048 x 2048 = 268,435,456 Bytes   = 268.44 MB   = 0.27 GB
    21 x 16 layer @ 2048 x 2048 = 5,637,144,576 Bytes = 5,637.14 MB = 5.64 GB

    (2024-09) Low-end Chromebooks may only have 2GB of RAM. 5.64 GB would be too much.
    Going with 1 GB, which is 3.7 worst-case undo steps.
     */ this.totalThresholdBytes = 1e9;
        // up to a certain threshold an undo step counts as free, and doesn't get you closer to undo
        // step limit. E.g. renaming a layer has virtually no impact on memory or performance.
        this.isFreeThresholdBytes = 2048 // 2MB if there were 1000 steps like that
        ;
        this.index = 0 // current action the user is on.
        ;
        this.indexOffset = 0 // for getting the total number of actions (beyond undo limit)
        ;
        this.changeCount = 0 // number keeps incrementing with each change (push, undo, redo)
        ;
        this.pauseStack = 0 // how often paused without unpause. push does nothing when paused.
        ;
        this.listeners = [] // broadcasts on undo, redo, push
        ;
        this.entries = [
            {
                timestamp: new Date().getTime(),
                memoryEstimateBytes: (0, _estimateBytes.estimateBytes)(p.oldest),
                data: p.oldest
            }
        ];
        this.composed = p.oldest;
        if (HISTORY_DEBUGGING) window.getHistoryEntries = ()=>this.entries;
    }
    /**
     * Needed, because sometimes there are actions that would cause other undo steps.
     * For example a filter that does something with two layers and then merges them.
     * That should be a single undo step, and prevent merging from creating its own undo step.
     * Pause prevents creation of unintended undo steps.
     */ pause(b) {
        if (b) this.pauseStack++;
        else this.pauseStack = Math.max(0, this.pauseStack - 1);
    }
    /**
     * listens to changes - on undo, redo, push
     */ addListener(l) {
        this.listeners.push(l);
    }
    push(entryData, replaceTop) {
        if (this.pauseStack > 0) return;
        const entry = {
            timestamp: new Date().getTime(),
            memoryEstimateBytes: (0, _estimateBytes.estimateBytes)(entryData),
            data: entryData
        };
        if (replaceTop && this.index > 0) {
            this.index--;
            // remove current top
            while(this.index < this.entries.length - 1)this.entries.pop();
            // it's possible that new entry replacing top is same to composed history
            // e.g. toggle layer visibility twice
            const isDifferent = (0, _entryCausesChange.entryCausesChange)(entryData, (0, _composeHistoryStateData.composeHistoryStateData)(this.entries.slice(0, this.index + 1).map((item)=>item.data)));
            // only need to push if it's different
            isDifferent && this.entries.push(entry);
        } else {
            while(this.index < this.entries.length - 1)this.entries.pop();
            this.entries.push(entry);
        }
        // determine oldest - consider maxUndoSteps, isFree, totalThresholdBytes
        let remainingSteps = this.maxUndoSteps;
        let oldestIndex = this.entries.length - 1;
        let remainingBytes = this.totalThresholdBytes - entry.memoryEstimateBytes;
        while(oldestIndex > 0 && remainingSteps >= 0){
            oldestIndex--;
            const currentEntryBytes = this.entries[oldestIndex].memoryEstimateBytes;
            if (currentEntryBytes < this.isFreeThresholdBytes) {
                remainingBytes -= currentEntryBytes;
                continue;
            }
            if (remainingSteps === 0) {
                // already used up all steps
                oldestIndex++;
                break;
            }
            if (remainingBytes - currentEntryBytes < 0) {
                // used up all memory
                oldestIndex++;
                break;
            }
            remainingBytes -= currentEntryBytes;
            remainingSteps--;
        }
        // compose forward to the oldest index
        while(oldestIndex > 0){
            const composedData = (0, _composeHistoryStateData.composeHistoryStateData)(this.entries.slice(0, oldestIndex + 1).map((item)=>item.data), oldestIndex);
            const memoryEstimateBytes = (0, _estimateBytes.estimateBytes)(composedData);
            this.entries = [
                {
                    timestamp: this.entries[oldestIndex].timestamp,
                    memoryEstimateBytes,
                    description: 'oldest',
                    data: composedData
                },
                ...this.entries.slice(oldestIndex + 1)
            ];
            this.indexOffset += oldestIndex;
            oldestIndex = 0;
            // despite the earlier check, it can still exceed the threshold
            if (this.entries.reduce((before, item)=>before + item.memoryEstimateBytes, 0) > this.totalThresholdBytes) oldestIndex = 1;
        }
        this.index = this.entries.length - 1;
        this.updateComposed();
        this.broadcast();
    }
    increaseIndex() {
        if (this.canRedo()) this.index++;
        this.updateComposed();
        this.broadcast();
        return this.entries[this.index];
    }
    decreaseIndex() {
        if (this.canUndo()) this.index--;
        this.updateComposed();
        this.broadcast();
        return this.entries[this.index];
    }
    canUndo() {
        return this.index > 0;
    }
    canRedo() {
        return this.index < this.entries.length - 1;
    }
    getEntries() {
        return this.entries.slice(0, this.index + 1);
    }
    getComposed() {
        return this.composed;
    }
    getChangeCount() {
        return this.changeCount;
    }
    getTotalIndex() {
        return this.indexOffset + this.index;
    }
    isPaused() {
        return this.pauseStack > 0;
    }
}

},{"./compose-history-state-data":"nJEgd","./estimate-bytes":"d7xvR","./entry-causes-change":"bgCRK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"nJEgd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Combines multiple history entries into one. Entries after targetIndex are ignored.
 *
 * Each history entry only contains changes (e.g. name of layer 1 changed, or an area of layer 2 got
 * changed by a brush stroke), so it isn't the complete picture. Combining everything gives the complete picture.
 *
 * When combining it always takes the most recent data (<=targetIndex).
 * [oldest, ..., newest]
 */ parcelHelpers.export(exports, "composeHistoryStateData", ()=>composeHistoryStateData);
// finds the largest index that is defined
function getLatestDefined(array) {
    for(let i = array.length - 1; i >= 0; i--){
        const value = array[i];
        if (value !== undefined) return value;
    }
    throw new Error('no defined entry found');
}
// in an array of maps, finds array[i][prop] for the largest index
// where array[i][prop] is defined
function getLatestDefinedProp(array, prop) {
    for(let i = array.length - 1; i >= 0; i--){
        if (!array[i]) continue;
        const value = array[i][prop];
        if (value !== undefined) return value;
    }
    throw new Error('no defined entry found');
}
// For each tile gets the latest which is defined.
// Each tile[] is from a history entry.
function composeLayerTiles(tilesEntries) {
    const result = [
        ...getLatestDefined(tilesEntries)
    ];
    Object.entries(result).forEach(([id])=>{
        result[+id] = getLatestDefinedProp(tilesEntries, id);
    });
    return result;
}
// combines layers from multiple history entries into the latest representation
function composeLayer(layerEntries) {
    return {
        name: getLatestDefinedProp(layerEntries, 'name'),
        opacity: getLatestDefinedProp(layerEntries, 'opacity'),
        isVisible: getLatestDefinedProp(layerEntries, 'isVisible'),
        mixModeStr: getLatestDefinedProp(layerEntries, 'mixModeStr'),
        index: getLatestDefinedProp(layerEntries, 'index'),
        tiles: composeLayerTiles(layerEntries.map((item)=>item ? item.tiles : undefined))
    };
}
// combines layerMaps from multiple history entries into the latest representation
function composeLayerMap(layerMaps) {
    const result = {
        ...getLatestDefined(layerMaps)
    };
    Object.entries(result).forEach(([id])=>{
        result[id] = composeLayer(layerMaps.map((item)=>item ? item[id] : undefined));
    });
    return result;
}
function composeHistoryStateData(entries, targetIndex) {
    if (targetIndex === undefined) targetIndex = entries.length - 1;
    entries = entries.slice(0, targetIndex + 1);
    return {
        projectId: getLatestDefinedProp(entries, 'projectId'),
        size: getLatestDefinedProp(entries, 'size'),
        activeLayerId: getLatestDefinedProp(entries, 'activeLayerId'),
        selection: getLatestDefinedProp(entries, 'selection'),
        layerMap: composeLayerMap(entries.map((item)=>item.layerMap))
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d7xvR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// estimates how much memory a history entry uses
parcelHelpers.export(exports, "estimateBytes", ()=>estimateBytes);
var _klTypes = require("../kl-types");
function estimateBytes(entry) {
    let result = 0;
    // for complex selection paths
    entry.selection?.value?.forEach((poly)=>{
        poly.forEach((ring)=>{
            result += ring.length * 2 * 8; // each number 8 bytes
        });
    });
    entry.layerMap && Object.entries(entry.layerMap).forEach(([, layer])=>{
        layer.tiles?.forEach((tile)=>{
            if (tile === undefined) return;
            if ((0, _klTypes.isLayerFill)(tile)) result += tile.fill.length * 2; // 2 byte per character
            else result += tile.data.width * tile.data.height * 4; // 4 channels, each 1 byte
        });
    });
    return result;
}

},{"../kl-types":"E0RUG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"E0RUG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isLayerFill", ()=>isLayerFill);
function isLayerFill(obj) {
    return typeof obj === 'object' && obj !== null && 'fill' in obj && typeof obj.fill === 'string';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bgCRK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// checks if `entry` would change `composed`
parcelHelpers.export(exports, "entryCausesChange", ()=>entryCausesChange);
function entryCausesChange(entry, composed) {
    if (entry.size !== undefined) {
        if (entry.size.width !== composed.size.width) return true;
        if (entry.size.height !== composed.size.height) return true;
    }
    if (entry.selection !== undefined) {
        if (entry.selection.value !== composed.selection.value) return true;
    }
    if (entry.activeLayerId !== undefined) {
        if (entry.activeLayerId !== composed.activeLayerId) return true;
    }
    if (entry.layerMap !== undefined) {
        const entryLayerMapIds = Object.keys(entry.layerMap);
        for (const layerId of Object.keys(composed.layerMap)){
            if (!entryLayerMapIds.includes(layerId)) return true;
        }
        for (const layerId of entryLayerMapIds){
            const composedLayer = composed.layerMap[layerId];
            if (!composedLayer) return true;
            const entryLayer = entry.layerMap[layerId];
            if (entryLayer.name !== undefined && entryLayer.name !== composedLayer.name) return true;
            if (entryLayer.opacity !== undefined && entryLayer.opacity !== composedLayer.opacity) return true;
            if (entryLayer.isVisible !== undefined && entryLayer.isVisible !== composedLayer.isVisible) return true;
            if (entryLayer.mixModeStr !== undefined && entryLayer.mixModeStr !== composedLayer.mixModeStr) return true;
            if (entryLayer.index !== undefined && entryLayer.index !== composedLayer.index) return true;
            if (entryLayer.tiles !== undefined) // not needed currently
            return true;
        }
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6SrvZ":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-zoom-in.7d977a87.svg") + "?" + Date.now();

},{}],"ifF9F":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-zoom-out.d8bf23f4.svg") + "?" + Date.now();

},{}],"5FJkn":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("viewport-reset.5ce5c7b0.svg") + "?" + Date.now();

},{}],"3vXJO":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-hand.8dd30f77.svg") + "?" + Date.now();

},{}],"iSzAd":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-pencil.26e6cef2.svg") + "?" + Date.now();

},{}],"k7NJM":[function(require,module,exports,__globalThis) {
module.exports["kl-theme-dark"] = `VFEAZq_kl-theme-dark`;
module.exports["preview"] = `VFEAZq_preview`;
module.exports["viewport"] = `VFEAZq_viewport`;

},{}],"f7IyB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zoomByStep", ()=>zoomByStep);
function zoomByStep(oldScale, stepNum) {
    const step = Math.log2(oldScale);
    let newStep = step / Math.abs(stepNum);
    newStep += stepNum > 0 ? 1 : -1;
    newStep = Math.round(newStep);
    newStep *= Math.abs(stepNum);
    return Math.pow(2, newStep);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kdXSP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTransform", ()=>createTransform);
var _transformationMatrix = require("transformation-matrix");
function createTransform(viewportPoint, canvasPoint, scale, angleDeg) {
    const mat = (0, _transformationMatrix.compose)((0, _transformationMatrix.scale)(-scale, -scale), (0, _transformationMatrix.rotate)(angleDeg / 180 * Math.PI));
    const topLeftP = (0, _transformationMatrix.applyToPoint)(mat, canvasPoint);
    topLeftP.x += viewportPoint.x;
    topLeftP.y += viewportPoint.y;
    return {
        x: topLeftP.x,
        y: topLeftP.y,
        scale,
        angleDeg
    };
}

},{"transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4mFA3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toMetaTransform", ()=>toMetaTransform);
var _createMatrixFromTransform = require("./create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
function toMetaTransform(transform, viewportP) {
    const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(transform);
    const canvasP = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), viewportP);
    return {
        viewportP,
        canvasP,
        scale: transform.scale,
        angleDeg: transform.angleDeg
    };
}

},{"./create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eUVrm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// makes right angle rects look more crisp
parcelHelpers.export(exports, "roundPoly", ()=>roundPoly);
parcelHelpers.export(exports, "SelectionRenderer", ()=>SelectionRenderer);
var _bb = require("../../../bb/bb");
var _selectionRendererModuleScss = require("./selection-renderer.module.scss");
var _createMatrixFromTransform = require("../../../bb/transform/create-matrix-from-transform");
var _getSelectionPath2D = require("../../../bb/multi-polygon/get-selection-path-2d");
var _transformMultiPolygon = require("../../../bb/multi-polygon/transform-multi-polygon");
var _applyPolygonClipping = require("../../../bb/multi-polygon/apply-polygon-clipping");
function roundPoly(multiPolygon) {
    return multiPolygon.map((poly)=>{
        return poly.map((ring)=>{
            return ring.map((point)=>{
                return [
                    Math.round(point[0] + 0.5) - 0.5,
                    Math.round(point[1] + 0.5) - 0.5
                ]; // on .5
            });
        });
    });
}
class SelectionRenderer {
    update() {
        const selection = this.renderedSelection === null ? this.selection : this.renderedSelection;
        if (!selection) {
            this.svgPath1.setAttribute('d', '');
            this.svgPath2.setAttribute('d', '');
            return;
        }
        // firefox has problems with non-scaling-stroke, so we scale manually.
        // ^ it has visual glitches when the transformation changes.
        const transformedSelection = (0, _transformMultiPolygon.transformMultiPolygon)(selection, this.viewportMat);
        // Firefox has bad performance when zoomed in far (guess: it doesn't clip the path)
        // So we clip manually.
        const clipPadding = 10;
        const clippedSelection = (0, _applyPolygonClipping.applyPolygonClipping)('intersection', transformedSelection, [
            [
                [
                    -clipPadding,
                    -clipPadding
                ],
                [
                    this.viewportWidth + clipPadding,
                    -clipPadding
                ],
                [
                    this.viewportWidth + clipPadding,
                    this.viewportHeight + clipPadding
                ],
                [
                    -clipPadding,
                    this.viewportHeight + clipPadding
                ],
                [
                    -clipPadding,
                    -clipPadding
                ]
            ]
        ]);
        const d = (0, _getSelectionPath2D.getSvgPathD)(roundPoly(clippedSelection));
        this.svgPath1.setAttribute('d', d);
        this.svgPath2.setAttribute('d', d);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.renderedSelection = null // overwrites this.selection, unless it's null
        ;
        this.viewportTransform = p.transform;
        this.viewportMat = (0, _createMatrixFromTransform.createMatrixFromTransform)(this.viewportTransform);
        this.selection = p.selection;
        this.viewportWidth = p.width;
        this.viewportHeight = p.height;
        this.svgPath1 = (0, _bb.BB).createSvg({
            elementType: 'path',
            'vector-effect': 'non-scaling-stroke'
        });
        this.svgPath1.classList.add(_selectionRendererModuleScss.whitePath);
        this.svgPath2 = (0, _bb.BB).createSvg({
            elementType: 'path',
            'vector-effect': 'non-scaling-stroke'
        });
        this.svgPath2.classList.add(_selectionRendererModuleScss.blackPath);
        this.rootEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.rootEl.append(this.svgPath1, this.svgPath2);
    }
    setTransform(transform) {
        this.viewportTransform = transform;
        this.viewportMat = (0, _createMatrixFromTransform.createMatrixFromTransform)(this.viewportTransform);
        this.update();
    }
    setSelection(selection) {
        if (this.selection === selection) return;
        this.selection = selection;
        // only need to update when this.selection is used
        if (this.renderedSelection === null) this.update();
    }
    // overwrite project selection
    setRenderedSelection(renderedSelection, isImmediate) {
        if (this.renderedSelection === renderedSelection) return;
        this.renderedSelection = renderedSelection;
        this.update();
    }
    // render project selection again
    clearRenderedSelection(isImmediate) {
        this.renderedSelection = null;
        if (!isImmediate) // good enough to update on next setSelection. (to prevent flickering)
        return;
        this.update();
    }
    setSize(width, height) {
        this.viewportWidth = width;
        this.viewportHeight = height;
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.rootEl.remove();
        this.selection = undefined;
    }
}

},{"../../../bb/bb":"3zOvT","./selection-renderer.module.scss":"4Lfd7","../../../bb/transform/create-matrix-from-transform":"6kvhU","../../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../../bb/multi-polygon/transform-multi-polygon":"54b2I","../../../bb/multi-polygon/apply-polygon-clipping":"iHG5e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Lfd7":[function(require,module,exports,__globalThis) {
module.exports["blackAnim"] = `uIhb5a_blackAnim`;
module.exports["blackAnim"];
module.exports["blackPath"] = `uIhb5a_blackPath`;
module.exports["whiteAnim"] = `uIhb5a_whiteAnim`;
module.exports["whiteAnim"];
module.exports["whitePath"] = `uIhb5a_whitePath`;

},{}],"54b2I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transformMultiPolygon", ()=>transformMultiPolygon);
var _transformationMatrix = require("transformation-matrix");
function transformMultiPolygon(multiPolygon, transform) {
    return multiPolygon.map((poly)=>{
        return poly.map((ring)=>{
            return ring.map((point)=>{
                return Object.values((0, _transformationMatrix.applyToPoint)(transform, {
                    x: point[0],
                    y: point[1]
                }));
            });
        });
    });
}

},{"transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iHG5e":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// wrapper to catch errors, and offer fallback
parcelHelpers.export(exports, "applyPolygonClipping", ()=>applyPolygonClipping);
var _polygonClipping = require("polygon-clipping");
function applyPolygonClipping(operation, geom, ...geoms) {
    let result = []; // initialized with fallback
    try {
        result = _polygonClipping[operation](geom, ...geoms);
    } catch (e) {
    /* */ }
    return result;
}

},{"polygon-clipping":"2SaFc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2SaFc":[function(require,module,exports,__globalThis) {
(function(global, factory) {
    module.exports = factory();
})(this, function() {
    'use strict';
    /**
     * splaytree v3.1.2
     * Fast Splay tree for Node and browser
     *
     * @author Alexander Milevski <info@w8r.name>
     * @license MIT
     * @preserve
     */ /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */ function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
            },
            trys: [],
            ops: []
        }, f, y, t, g;
        return g = {
            next: verb(0),
            "throw": verb(1),
            "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
        }), g;
        function verb(n) {
            return function(v) {
                return step([
                    n,
                    v
                ]);
            };
        }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while(_)try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [
                    op[0] & 2,
                    t.value
                ];
                switch(op[0]){
                    case 0:
                    case 1:
                        t = op;
                        break;
                    case 4:
                        _.label++;
                        return {
                            value: op[1],
                            done: false
                        };
                    case 5:
                        _.label++;
                        y = op[1];
                        op = [
                            0
                        ];
                        continue;
                    case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];
                            break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                }
                op = body.call(thisArg, _);
            } catch (e) {
                op = [
                    6,
                    e
                ];
                y = 0;
            } finally{
                f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return {
                value: op[0] ? op[1] : void 0,
                done: true
            };
        }
    }
    var Node = /** @class */ function() {
        function Node(key, data) {
            this.next = null;
            this.key = key;
            this.data = data;
            this.left = null;
            this.right = null;
        }
        return Node;
    }();
    /* follows "An implementation of top-down splaying"
     * by D. Sleator <sleator@cs.cmu.edu> March 1992
     */ function DEFAULT_COMPARE(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    /**
     * Simple top down splay, not requiring i to be in the tree t.
     */ function splay(i, t, comparator) {
        var N = new Node(null, null);
        var l = N;
        var r = N;
        while(true){
            var cmp = comparator(i, t.key);
            //if (i < t.key) {
            if (cmp < 0) {
                if (t.left === null) break;
                //if (i < t.left.key) {
                if (comparator(i, t.left.key) < 0) {
                    var y = t.left; /* rotate right */ 
                    t.left = y.right;
                    y.right = t;
                    t = y;
                    if (t.left === null) break;
                }
                r.left = t; /* link right */ 
                r = t;
                t = t.left;
            //} else if (i > t.key) {
            } else if (cmp > 0) {
                if (t.right === null) break;
                //if (i > t.right.key) {
                if (comparator(i, t.right.key) > 0) {
                    var y = t.right; /* rotate left */ 
                    t.right = y.left;
                    y.left = t;
                    t = y;
                    if (t.right === null) break;
                }
                l.right = t; /* link left */ 
                l = t;
                t = t.right;
            } else break;
        }
        /* assemble */ l.right = t.left;
        r.left = t.right;
        t.left = N.right;
        t.right = N.left;
        return t;
    }
    function insert(i, data, t, comparator) {
        var node = new Node(i, data);
        if (t === null) {
            node.left = node.right = null;
            return node;
        }
        t = splay(i, t, comparator);
        var cmp = comparator(i, t.key);
        if (cmp < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
        } else if (cmp >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
        }
        return node;
    }
    function split(key, v, comparator) {
        var left = null;
        var right = null;
        if (v) {
            v = splay(key, v, comparator);
            var cmp = comparator(v.key, key);
            if (cmp === 0) {
                left = v.left;
                right = v.right;
            } else if (cmp < 0) {
                right = v.right;
                v.right = null;
                left = v;
            } else {
                left = v.left;
                v.left = null;
                right = v;
            }
        }
        return {
            left: left,
            right: right
        };
    }
    function merge(left, right, comparator) {
        if (right === null) return left;
        if (left === null) return right;
        right = splay(left.key, right, comparator);
        right.left = left;
        return right;
    }
    /**
     * Prints level of the tree
     */ function printRow(root, prefix, isTail, out, printNode) {
        if (root) {
            out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root) + "\n");
            var indent = prefix + (isTail ? '    ' : "\u2502   ");
            if (root.left) printRow(root.left, indent, false, out, printNode);
            if (root.right) printRow(root.right, indent, true, out, printNode);
        }
    }
    var Tree = /** @class */ function() {
        function Tree(comparator) {
            if (comparator === void 0) comparator = DEFAULT_COMPARE;
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
        }
        /**
       * Inserts a key, allows duplicates
       */ Tree.prototype.insert = function(key, data) {
            this._size++;
            return this._root = insert(key, data, this._root, this._comparator);
        };
        /**
       * Adds a key, if it is not present in the tree
       */ Tree.prototype.add = function(key, data) {
            var node = new Node(key, data);
            if (this._root === null) {
                node.left = node.right = null;
                this._size++;
                this._root = node;
            }
            var comparator = this._comparator;
            var t = splay(key, this._root, comparator);
            var cmp = comparator(key, t.key);
            if (cmp === 0) this._root = t;
            else {
                if (cmp < 0) {
                    node.left = t.left;
                    node.right = t;
                    t.left = null;
                } else if (cmp > 0) {
                    node.right = t.right;
                    node.left = t;
                    t.right = null;
                }
                this._size++;
                this._root = node;
            }
            return this._root;
        };
        /**
       * @param  {Key} key
       * @return {Node|null}
       */ Tree.prototype.remove = function(key) {
            this._root = this._remove(key, this._root, this._comparator);
        };
        /**
       * Deletes i from the tree if it's there
       */ Tree.prototype._remove = function(i, t, comparator) {
            var x;
            if (t === null) return null;
            t = splay(i, t, comparator);
            var cmp = comparator(i, t.key);
            if (cmp === 0) {
                /* found it */ if (t.left === null) x = t.right;
                else {
                    x = splay(i, t.left, comparator);
                    x.right = t.right;
                }
                this._size--;
                return x;
            }
            return t; /* It wasn't there */ 
        };
        /**
       * Removes and returns the node with smallest key
       */ Tree.prototype.pop = function() {
            var node = this._root;
            if (node) {
                while(node.left)node = node.left;
                this._root = splay(node.key, this._root, this._comparator);
                this._root = this._remove(node.key, this._root, this._comparator);
                return {
                    key: node.key,
                    data: node.data
                };
            }
            return null;
        };
        /**
       * Find without splaying
       */ Tree.prototype.findStatic = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while(current){
                var cmp = compare(key, current.key);
                if (cmp === 0) return current;
                else if (cmp < 0) current = current.left;
                else current = current.right;
            }
            return null;
        };
        Tree.prototype.find = function(key) {
            if (this._root) {
                this._root = splay(key, this._root, this._comparator);
                if (this._comparator(key, this._root.key) !== 0) return null;
            }
            return this._root;
        };
        Tree.prototype.contains = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while(current){
                var cmp = compare(key, current.key);
                if (cmp === 0) return true;
                else if (cmp < 0) current = current.left;
                else current = current.right;
            }
            return false;
        };
        Tree.prototype.forEach = function(visitor, ctx) {
            var current = this._root;
            var Q = []; /* Initialize stack s */ 
            var done = false;
            while(!done){
                if (current !== null) {
                    Q.push(current);
                    current = current.left;
                } else if (Q.length !== 0) {
                    current = Q.pop();
                    visitor.call(ctx, current);
                    current = current.right;
                } else done = true;
            }
            return this;
        };
        /**
       * Walk key range from `low` to `high`. Stops if `fn` returns a value.
       */ Tree.prototype.range = function(low, high, fn, ctx) {
            var Q = [];
            var compare = this._comparator;
            var node = this._root;
            var cmp;
            while(Q.length !== 0 || node)if (node) {
                Q.push(node);
                node = node.left;
            } else {
                node = Q.pop();
                cmp = compare(node.key, high);
                if (cmp > 0) break;
                else if (compare(node.key, low) >= 0) {
                    if (fn.call(ctx, node)) return this; // stop if smth is returned
                }
                node = node.right;
            }
            return this;
        };
        /**
       * Returns array of keys
       */ Tree.prototype.keys = function() {
            var keys = [];
            this.forEach(function(_a) {
                var key = _a.key;
                return keys.push(key);
            });
            return keys;
        };
        /**
       * Returns array of all the data in the nodes
       */ Tree.prototype.values = function() {
            var values = [];
            this.forEach(function(_a) {
                var data = _a.data;
                return values.push(data);
            });
            return values;
        };
        Tree.prototype.min = function() {
            if (this._root) return this.minNode(this._root).key;
            return null;
        };
        Tree.prototype.max = function() {
            if (this._root) return this.maxNode(this._root).key;
            return null;
        };
        Tree.prototype.minNode = function(t) {
            if (t === void 0) t = this._root;
            if (t) while(t.left)t = t.left;
            return t;
        };
        Tree.prototype.maxNode = function(t) {
            if (t === void 0) t = this._root;
            if (t) while(t.right)t = t.right;
            return t;
        };
        /**
       * Returns node at given index
       */ Tree.prototype.at = function(index) {
            var current = this._root;
            var done = false;
            var i = 0;
            var Q = [];
            while(!done){
                if (current) {
                    Q.push(current);
                    current = current.left;
                } else if (Q.length > 0) {
                    current = Q.pop();
                    if (i === index) return current;
                    i++;
                    current = current.right;
                } else done = true;
            }
            return null;
        };
        Tree.prototype.next = function(d) {
            var root = this._root;
            var successor = null;
            if (d.right) {
                successor = d.right;
                while(successor.left)successor = successor.left;
                return successor;
            }
            var comparator = this._comparator;
            while(root){
                var cmp = comparator(d.key, root.key);
                if (cmp === 0) break;
                else if (cmp < 0) {
                    successor = root;
                    root = root.left;
                } else root = root.right;
            }
            return successor;
        };
        Tree.prototype.prev = function(d) {
            var root = this._root;
            var predecessor = null;
            if (d.left !== null) {
                predecessor = d.left;
                while(predecessor.right)predecessor = predecessor.right;
                return predecessor;
            }
            var comparator = this._comparator;
            while(root){
                var cmp = comparator(d.key, root.key);
                if (cmp === 0) break;
                else if (cmp < 0) root = root.left;
                else {
                    predecessor = root;
                    root = root.right;
                }
            }
            return predecessor;
        };
        Tree.prototype.clear = function() {
            this._root = null;
            this._size = 0;
            return this;
        };
        Tree.prototype.toList = function() {
            return toList(this._root);
        };
        /**
       * Bulk-load items. Both array have to be same size
       */ Tree.prototype.load = function(keys, values, presort) {
            if (values === void 0) values = [];
            if (presort === void 0) presort = false;
            var size = keys.length;
            var comparator = this._comparator;
            // sort if needed
            if (presort) sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) {
                // empty tree
                this._root = loadRecursive(keys, values, 0, size);
                this._size = size;
            } else {
                // that re-builds the whole tree from two in-order traversals
                var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
                size = this._size + size;
                this._root = sortedListToBST({
                    head: mergedList
                }, 0, size);
            }
            return this;
        };
        Tree.prototype.isEmpty = function() {
            return this._root === null;
        };
        Object.defineProperty(Tree.prototype, "size", {
            get: function() {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Tree.prototype, "root", {
            get: function() {
                return this._root;
            },
            enumerable: true,
            configurable: true
        });
        Tree.prototype.toString = function(printNode) {
            if (printNode === void 0) printNode = function(n) {
                return String(n.key);
            };
            var out = [];
            printRow(this._root, '', true, function(v) {
                return out.push(v);
            }, printNode);
            return out.join('');
        };
        Tree.prototype.update = function(key, newKey, newData) {
            var comparator = this._comparator;
            var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
            if (comparator(key, newKey) < 0) right = insert(newKey, newData, right, comparator);
            else left = insert(newKey, newData, left, comparator);
            this._root = merge(left, right, comparator);
        };
        Tree.prototype.split = function(key) {
            return split(key, this._root, this._comparator);
        };
        Tree.prototype[Symbol.iterator] = function() {
            var current, Q, done;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        current = this._root;
                        Q = [];
                        done = false;
                        _a.label = 1;
                    case 1:
                        if (!!done) return [
                            3 /*break*/ ,
                            6
                        ];
                        if (!(current !== null)) return [
                            3 /*break*/ ,
                            2
                        ];
                        Q.push(current);
                        current = current.left;
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 2:
                        if (!(Q.length !== 0)) return [
                            3 /*break*/ ,
                            4
                        ];
                        current = Q.pop();
                        return [
                            4 /*yield*/ ,
                            current
                        ];
                    case 3:
                        _a.sent();
                        current = current.right;
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 4:
                        done = true;
                        _a.label = 5;
                    case 5:
                        return [
                            3 /*break*/ ,
                            1
                        ];
                    case 6:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        };
        return Tree;
    }();
    function loadRecursive(keys, values, start, end) {
        var size = end - start;
        if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var key = keys[middle];
            var data = values[middle];
            var node = new Node(key, data);
            node.left = loadRecursive(keys, values, start, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
        }
        return null;
    }
    function createList(keys, values) {
        var head = new Node(null, null);
        var p = head;
        for(var i = 0; i < keys.length; i++)p = p.next = new Node(keys[i], values[i]);
        p.next = null;
        return head.next;
    }
    function toList(root) {
        var current = root;
        var Q = [];
        var done = false;
        var head = new Node(null, null);
        var p = head;
        while(!done){
            if (current) {
                Q.push(current);
                current = current.left;
            } else if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
            } else done = true;
        }
        p.next = null; // that'll work even if the tree was empty
        return head.next;
    }
    function sortedListToBST(list, start, end) {
        var size = end - start;
        if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var left = sortedListToBST(list, start, middle);
            var root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
        }
        return null;
    }
    function mergeLists(l1, l2, compare) {
        var head = new Node(null, null); // dummy
        var p = head;
        var p1 = l1;
        var p2 = l2;
        while(p1 !== null && p2 !== null){
            if (compare(p1.key, p2.key) < 0) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if (p1 !== null) p.next = p1;
        else if (p2 !== null) p.next = p2;
        return head.next;
    }
    function sort(keys, values, left, right, compare) {
        if (left >= right) return;
        var pivot = keys[left + right >> 1];
        var i = left - 1;
        var j = right + 1;
        while(true){
            do i++;
            while (compare(keys[i], pivot) < 0);
            do j--;
            while (compare(keys[j], pivot) > 0);
            if (i >= j) break;
            var tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        sort(keys, values, left, j, compare);
        sort(keys, values, j + 1, right, compare);
    }
    /**
     * A bounding box has the format:
     *
     *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
     *
     */ const isInBbox = (bbox, point)=>{
        return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
    };
    /* Returns either null, or a bbox (aka an ordered pair of points)
     * If there is only one point of overlap, a bbox with identical points
     * will be returned */ const getBboxOverlap = (b1, b2)=>{
        // check if the bboxes overlap at all
        if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;
        // find the middle two X values
        const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
        const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
        // find the middle two Y values
        const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
        const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
        // put those middle values together to get the overlap
        return {
            ll: {
                x: lowerX,
                y: lowerY
            },
            ur: {
                x: upperX,
                y: upperY
            }
        };
    };
    /* Javascript doesn't do integer math. Everything is
     * floating point with percision Number.EPSILON.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
     */ let epsilon$1 = Number.EPSILON;
    // IE Polyfill
    if (epsilon$1 === undefined) epsilon$1 = Math.pow(2, -52);
    const EPSILON_SQ = epsilon$1 * epsilon$1;
    /* FLP comparator */ const cmp = (a, b)=>{
        // check if they're both 0
        if (-epsilon$1 < a && a < epsilon$1) {
            if (-epsilon$1 < b && b < epsilon$1) return 0;
        }
        // check if they're flp equal
        const ab = a - b;
        if (ab * ab < EPSILON_SQ * a * b) return 0;
        // normal comparison
        return a < b ? -1 : 1;
    };
    /**
     * This class rounds incoming values sufficiently so that
     * floating points problems are, for the most part, avoided.
     *
     * Incoming points are have their x & y values tested against
     * all previously seen x & y values. If either is 'too close'
     * to a previously seen value, it's value is 'snapped' to the
     * previously seen value.
     *
     * All points should be rounded by this class before being
     * stored in any data structures in the rest of this algorithm.
     */ class PtRounder {
        constructor(){
            this.reset();
        }
        reset() {
            this.xRounder = new CoordRounder();
            this.yRounder = new CoordRounder();
        }
        round(x, y) {
            return {
                x: this.xRounder.round(x),
                y: this.yRounder.round(y)
            };
        }
    }
    class CoordRounder {
        constructor(){
            this.tree = new Tree();
            // preseed with 0 so we don't end up with values < Number.EPSILON
            this.round(0);
        }
        // Note: this can rounds input values backwards or forwards.
        //       You might ask, why not restrict this to just rounding
        //       forwards? Wouldn't that allow left endpoints to always
        //       remain left endpoints during splitting (never change to
        //       right). No - it wouldn't, because we snap intersections
        //       to endpoints (to establish independence from the segment
        //       angle for t-intersections).
        round(coord) {
            const node = this.tree.add(coord);
            const prevNode = this.tree.prev(node);
            if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
                this.tree.remove(coord);
                return prevNode.key;
            }
            const nextNode = this.tree.next(node);
            if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
                this.tree.remove(coord);
                return nextNode.key;
            }
            return coord;
        }
    }
    // singleton available by import
    const rounder = new PtRounder();
    const epsilon = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon) * epsilon;
    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if (fnow > enow === fnow > -enow) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if (fnow > enow === fnow > -enow) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) h[hindex++] = hh;
            while(eindex < elen && findex < flen){
                if (fnow > enow === fnow > -enow) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) h[hindex++] = hh;
            }
        }
        while(eindex < elen){
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) h[hindex++] = hh;
        }
        while(findex < flen){
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) h[hindex++] = hh;
        }
        if (Q !== 0 || hindex === 0) h[hindex++] = Q;
        return hindex;
    }
    function estimate(elen, e) {
        let Q = e[0];
        for(let i = 1; i < elen; i++)Q += e[i];
        return Q;
    }
    function vec(n) {
        return new Float64Array(n);
    }
    const ccwerrboundA = (3 + 16 * epsilon) * epsilon;
    const ccwerrboundB = (2 + 12 * epsilon) * epsilon;
    const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);
    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;
        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;
        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) return det;
        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);
        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) return det;
        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;
        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum(4, B, 4, u, C1);
        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum(C1len, C1, 4, u, C2);
        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum(C2len, C2, 4, u, D);
        return D[Dlen - 1];
    }
    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;
        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;
        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }
    /* Cross Product of two vectors with first point at origin */ const crossProduct = (a, b)=>a.x * b.y - a.y * b.x;
    /* Dot Product of two vectors with first point at origin */ const dotProduct = (a, b)=>a.x * b.x + a.y * b.y;
    /* Comparator for two vectors with same starting point */ const compareVectorAngles = (basePt, endPt1, endPt2)=>{
        const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
        if (res > 0) return -1;
        if (res < 0) return 1;
        return 0;
    };
    const length = (v)=>Math.sqrt(dotProduct(v, v));
    /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */ const sineOfAngle = (pShared, pBase, pAngle)=>{
        const vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
        };
        const vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
        };
        return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };
    /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */ const cosineOfAngle = (pShared, pBase, pAngle)=>{
        const vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
        };
        const vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
        };
        return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };
    /* Get the x coordinate where the given line (defined by a point and vector)
     * crosses the horizontal line with the given y coordiante.
     * In the case of parrallel lines (including overlapping ones) returns null. */ const horizontalIntersection = (pt, v, y)=>{
        if (v.y === 0) return null;
        return {
            x: pt.x + v.x / v.y * (y - pt.y),
            y: y
        };
    };
    /* Get the y coordinate where the given line (defined by a point and vector)
     * crosses the vertical line with the given x coordiante.
     * In the case of parrallel lines (including overlapping ones) returns null. */ const verticalIntersection = (pt, v, x)=>{
        if (v.x === 0) return null;
        return {
            x: x,
            y: pt.y + v.y / v.x * (x - pt.x)
        };
    };
    /* Get the intersection of two lines, each defined by a base point and a vector.
     * In the case of parrallel lines (including overlapping ones) returns null. */ const intersection$1 = (pt1, v1, pt2, v2)=>{
        // take some shortcuts for vertical and horizontal lines
        // this also ensures we don't calculate an intersection and then discover
        // it's actually outside the bounding box of the line
        if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
        if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
        if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
        if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);
        // General case for non-overlapping segments.
        // This algorithm is based on Schneider and Eberly.
        // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244
        const kross = crossProduct(v1, v2);
        if (kross == 0) return null;
        const ve = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
        };
        const d1 = crossProduct(ve, v1) / kross;
        const d2 = crossProduct(ve, v2) / kross;
        // take the average of the two calculations to minimize rounding error
        const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
        const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
        const x = (x1 + x2) / 2;
        const y = (y1 + y2) / 2;
        return {
            x: x,
            y: y
        };
    };
    class SweepEvent {
        // for ordering sweep events in the sweep event queue
        static compare(a, b) {
            // favor event with a point that the sweep line hits first
            const ptCmp = SweepEvent.comparePoints(a.point, b.point);
            if (ptCmp !== 0) return ptCmp;
            // the points are the same, so link them if needed
            if (a.point !== b.point) a.link(b);
            // favor right events over left
            if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
            // we have two matching left or right endpoints
            // ordering of this case is the same as for their segments
            return Segment.compare(a.segment, b.segment);
        }
        // for ordering points in sweep line order
        static comparePoints(aPt, bPt) {
            if (aPt.x < bPt.x) return -1;
            if (aPt.x > bPt.x) return 1;
            if (aPt.y < bPt.y) return -1;
            if (aPt.y > bPt.y) return 1;
            return 0;
        }
        // Warning: 'point' input will be modified and re-used (for performance)
        constructor(point, isLeft){
            if (point.events === undefined) point.events = [
                this
            ];
            else point.events.push(this);
            this.point = point;
            this.isLeft = isLeft;
        // this.segment, this.otherSE set by factory
        }
        link(other) {
            if (other.point === this.point) throw new Error("Tried to link already linked events");
            const otherEvents = other.point.events;
            for(let i = 0, iMax = otherEvents.length; i < iMax; i++){
                const evt = otherEvents[i];
                this.point.events.push(evt);
                evt.point = this.point;
            }
            this.checkForConsuming();
        }
        /* Do a pass over our linked events and check to see if any pair
       * of segments match, and should be consumed. */ checkForConsuming() {
            // FIXME: The loops in this method run O(n^2) => no good.
            //        Maintain little ordered sweep event trees?
            //        Can we maintaining an ordering that avoids the need
            //        for the re-sorting with getLeftmostComparator in geom-out?
            // Compare each pair of events to see if other events also match
            const numEvents = this.point.events.length;
            for(let i = 0; i < numEvents; i++){
                const evt1 = this.point.events[i];
                if (evt1.segment.consumedBy !== undefined) continue;
                for(let j = i + 1; j < numEvents; j++){
                    const evt2 = this.point.events[j];
                    if (evt2.consumedBy !== undefined) continue;
                    if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
                    evt1.segment.consume(evt2.segment);
                }
            }
        }
        getAvailableLinkedEvents() {
            // point.events is always of length 2 or greater
            const events = [];
            for(let i = 0, iMax = this.point.events.length; i < iMax; i++){
                const evt = this.point.events[i];
                if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) events.push(evt);
            }
            return events;
        }
        /**
       * Returns a comparator function for sorting linked events that will
       * favor the event that will give us the smallest left-side angle.
       * All ring construction starts as low as possible heading to the right,
       * so by always turning left as sharp as possible we'll get polygons
       * without uncessary loops & holes.
       *
       * The comparator function has a compute cache such that it avoids
       * re-computing already-computed values.
       */ getLeftmostComparator(baseEvent) {
            const cache = new Map();
            const fillCache = (linkedEvent)=>{
                const nextEvent = linkedEvent.otherSE;
                cache.set(linkedEvent, {
                    sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
                    cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
                });
            };
            return (a, b)=>{
                if (!cache.has(a)) fillCache(a);
                if (!cache.has(b)) fillCache(b);
                const { sine: asine, cosine: acosine } = cache.get(a);
                const { sine: bsine, cosine: bcosine } = cache.get(b);
                // both on or above x-axis
                if (asine >= 0 && bsine >= 0) {
                    if (acosine < bcosine) return 1;
                    if (acosine > bcosine) return -1;
                    return 0;
                }
                // both below x-axis
                if (asine < 0 && bsine < 0) {
                    if (acosine < bcosine) return -1;
                    if (acosine > bcosine) return 1;
                    return 0;
                }
                // one above x-axis, one below
                if (bsine < asine) return -1;
                if (bsine > asine) return 1;
                return 0;
            };
        }
    }
    // Give segments unique ID's to get consistent sorting of
    // segments and sweep events when all else is identical
    let segmentId = 0;
    class Segment {
        /* This compare() function is for ordering segments in the sweep
       * line tree, and does so according to the following criteria:
       *
       * Consider the vertical line that lies an infinestimal step to the
       * right of the right-more of the two left endpoints of the input
       * segments. Imagine slowly moving a point up from negative infinity
       * in the increasing y direction. Which of the two segments will that
       * point intersect first? That segment comes 'before' the other one.
       *
       * If neither segment would be intersected by such a line, (if one
       * or more of the segments are vertical) then the line to be considered
       * is directly on the right-more of the two left inputs.
       */ static compare(a, b) {
            const alx = a.leftSE.point.x;
            const blx = b.leftSE.point.x;
            const arx = a.rightSE.point.x;
            const brx = b.rightSE.point.x;
            // check if they're even in the same vertical plane
            if (brx < alx) return 1;
            if (arx < blx) return -1;
            const aly = a.leftSE.point.y;
            const bly = b.leftSE.point.y;
            const ary = a.rightSE.point.y;
            const bry = b.rightSE.point.y;
            // is left endpoint of segment B the right-more?
            if (alx < blx) {
                // are the two segments in the same horizontal plane?
                if (bly < aly && bly < ary) return 1;
                if (bly > aly && bly > ary) return -1;
                // is the B left endpoint colinear to segment A?
                const aCmpBLeft = a.comparePoint(b.leftSE.point);
                if (aCmpBLeft < 0) return 1;
                if (aCmpBLeft > 0) return -1;
                // is the A right endpoint colinear to segment B ?
                const bCmpARight = b.comparePoint(a.rightSE.point);
                if (bCmpARight !== 0) return bCmpARight;
                // colinear segments, consider the one with left-more
                // left endpoint to be first (arbitrary?)
                return -1;
            }
            // is left endpoint of segment A the right-more?
            if (alx > blx) {
                if (aly < bly && aly < bry) return -1;
                if (aly > bly && aly > bry) return 1;
                // is the A left endpoint colinear to segment B?
                const bCmpALeft = b.comparePoint(a.leftSE.point);
                if (bCmpALeft !== 0) return bCmpALeft;
                // is the B right endpoint colinear to segment A?
                const aCmpBRight = a.comparePoint(b.rightSE.point);
                if (aCmpBRight < 0) return 1;
                if (aCmpBRight > 0) return -1;
                // colinear segments, consider the one with left-more
                // left endpoint to be first (arbitrary?)
                return 1;
            }
            // if we get here, the two left endpoints are in the same
            // vertical plane, ie alx === blx
            // consider the lower left-endpoint to come first
            if (aly < bly) return -1;
            if (aly > bly) return 1;
            // left endpoints are identical
            // check for colinearity by using the left-more right endpoint
            // is the A right endpoint more left-more?
            if (arx < brx) {
                const bCmpARight = b.comparePoint(a.rightSE.point);
                if (bCmpARight !== 0) return bCmpARight;
            }
            // is the B right endpoint more left-more?
            if (arx > brx) {
                const aCmpBRight = a.comparePoint(b.rightSE.point);
                if (aCmpBRight < 0) return 1;
                if (aCmpBRight > 0) return -1;
            }
            if (arx !== brx) {
                // are these two [almost] vertical segments with opposite orientation?
                // if so, the one with the lower right endpoint comes first
                const ay = ary - aly;
                const ax = arx - alx;
                const by = bry - bly;
                const bx = brx - blx;
                if (ay > ax && by < bx) return 1;
                if (ay < ax && by > bx) return -1;
            }
            // we have colinear segments with matching orientation
            // consider the one with more left-more right endpoint to be first
            if (arx > brx) return 1;
            if (arx < brx) return -1;
            // if we get here, two two right endpoints are in the same
            // vertical plane, ie arx === brx
            // consider the lower right-endpoint to come first
            if (ary < bry) return -1;
            if (ary > bry) return 1;
            // right endpoints identical as well, so the segments are idential
            // fall back on creation order as consistent tie-breaker
            if (a.id < b.id) return -1;
            if (a.id > b.id) return 1;
            // identical segment, ie a === b
            return 0;
        }
        /* Warning: a reference to ringWindings input will be stored,
       *  and possibly will be later modified */ constructor(leftSE, rightSE, rings, windings){
            this.id = ++segmentId;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
        // left unset for performance, set later in algorithm
        // this.ringOut, this.consumedBy, this.prev
        }
        static fromRing(pt1, pt2, ring) {
            let leftPt, rightPt, winding;
            // ordering the two points according to sweep line ordering
            const cmpPts = SweepEvent.comparePoints(pt1, pt2);
            if (cmpPts < 0) {
                leftPt = pt1;
                rightPt = pt2;
                winding = 1;
            } else if (cmpPts > 0) {
                leftPt = pt2;
                rightPt = pt1;
                winding = -1;
            } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
            const leftSE = new SweepEvent(leftPt, true);
            const rightSE = new SweepEvent(rightPt, false);
            return new Segment(leftSE, rightSE, [
                ring
            ], [
                winding
            ]);
        }
        /* When a segment is split, the rightSE is replaced with a new sweep event */ replaceRightSE(newRightSE) {
            this.rightSE = newRightSE;
            this.rightSE.segment = this;
            this.rightSE.otherSE = this.leftSE;
            this.leftSE.otherSE = this.rightSE;
        }
        bbox() {
            const y1 = this.leftSE.point.y;
            const y2 = this.rightSE.point.y;
            return {
                ll: {
                    x: this.leftSE.point.x,
                    y: y1 < y2 ? y1 : y2
                },
                ur: {
                    x: this.rightSE.point.x,
                    y: y1 > y2 ? y1 : y2
                }
            };
        }
        /* A vector from the left point to the right */ vector() {
            return {
                x: this.rightSE.point.x - this.leftSE.point.x,
                y: this.rightSE.point.y - this.leftSE.point.y
            };
        }
        isAnEndpoint(pt) {
            return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
        }
        /* Compare this segment with a point.
       *
       * A point P is considered to be colinear to a segment if there
       * exists a distance D such that if we travel along the segment
       * from one * endpoint towards the other a distance D, we find
       * ourselves at point P.
       *
       * Return value indicates:
       *
       *   1: point lies above the segment (to the left of vertical)
       *   0: point is colinear to segment
       *  -1: point lies below the segment (to the right of vertical)
       */ comparePoint(point) {
            if (this.isAnEndpoint(point)) return 0;
            const lPt = this.leftSE.point;
            const rPt = this.rightSE.point;
            const v = this.vector();
            // Exactly vertical segments.
            if (lPt.x === rPt.x) {
                if (point.x === lPt.x) return 0;
                return point.x < lPt.x ? 1 : -1;
            }
            // Nearly vertical segments with an intersection.
            // Check to see where a point on the line with matching Y coordinate is.
            const yDist = (point.y - lPt.y) / v.y;
            const xFromYDist = lPt.x + yDist * v.x;
            if (point.x === xFromYDist) return 0;
            // General case.
            // Check to see where a point on the line with matching X coordinate is.
            const xDist = (point.x - lPt.x) / v.x;
            const yFromXDist = lPt.y + xDist * v.y;
            if (point.y === yFromXDist) return 0;
            return point.y < yFromXDist ? -1 : 1;
        }
        /**
       * Given another segment, returns the first non-trivial intersection
       * between the two segments (in terms of sweep line ordering), if it exists.
       *
       * A 'non-trivial' intersection is one that will cause one or both of the
       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
       *
       *   * endpoint of segA with endpoint of segB --> trivial
       *   * endpoint of segA with point along segB --> non-trivial
       *   * endpoint of segB with point along segA --> non-trivial
       *   * point along segA with point along segB --> non-trivial
       *
       * If no non-trivial intersection exists, return null
       * Else, return null.
       */ getIntersection(other) {
            // If bboxes don't overlap, there can't be any intersections
            const tBbox = this.bbox();
            const oBbox = other.bbox();
            const bboxOverlap = getBboxOverlap(tBbox, oBbox);
            if (bboxOverlap === null) return null;
            // We first check to see if the endpoints can be considered intersections.
            // This will 'snap' intersections to endpoints if possible, and will
            // handle cases of colinearity.
            const tlp = this.leftSE.point;
            const trp = this.rightSE.point;
            const olp = other.leftSE.point;
            const orp = other.rightSE.point;
            // does each endpoint touch the other segment?
            // note that we restrict the 'touching' definition to only allow segments
            // to touch endpoints that lie forward from where we are in the sweep line pass
            const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
            const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
            const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
            const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
            // do left endpoints match?
            if (touchesThisLSE && touchesOtherLSE) {
                // these two cases are for colinear segments with matching left
                // endpoints, and one segment being longer than the other
                if (touchesThisRSE && !touchesOtherRSE) return trp;
                if (!touchesThisRSE && touchesOtherRSE) return orp;
                // either the two segments match exactly (two trival intersections)
                // or just on their left endpoint (one trivial intersection
                return null;
            }
            // does this left endpoint matches (other doesn't)
            if (touchesThisLSE) {
                // check for segments that just intersect on opposing endpoints
                if (touchesOtherRSE) {
                    if (tlp.x === orp.x && tlp.y === orp.y) return null;
                }
                // t-intersection on left endpoint
                return tlp;
            }
            // does other left endpoint matches (this doesn't)
            if (touchesOtherLSE) {
                // check for segments that just intersect on opposing endpoints
                if (touchesThisRSE) {
                    if (trp.x === olp.x && trp.y === olp.y) return null;
                }
                // t-intersection on left endpoint
                return olp;
            }
            // trivial intersection on right endpoints
            if (touchesThisRSE && touchesOtherRSE) return null;
            // t-intersections on just one right endpoint
            if (touchesThisRSE) return trp;
            if (touchesOtherRSE) return orp;
            // None of our endpoints intersect. Look for a general intersection between
            // infinite lines laid over the segments
            const pt = intersection$1(tlp, this.vector(), olp, other.vector());
            // are the segments parrallel? Note that if they were colinear with overlap,
            // they would have an endpoint intersection and that case was already handled above
            if (pt === null) return null;
            // is the intersection found between the lines not on the segments?
            if (!isInBbox(bboxOverlap, pt)) return null;
            // round the the computed point if needed
            return rounder.round(pt.x, pt.y);
        }
        /**
       * Split the given segment into multiple segments on the given points.
       *  * Each existing segment will retain its leftSE and a new rightSE will be
       *    generated for it.
       *  * A new segment will be generated which will adopt the original segment's
       *    rightSE, and a new leftSE will be generated for it.
       *  * If there are more than two points given to split on, new segments
       *    in the middle will be generated with new leftSE and rightSE's.
       *  * An array of the newly generated SweepEvents will be returned.
       *
       * Warning: input array of points is modified
       */ split(point) {
            const newEvents = [];
            const alreadyLinked = point.events !== undefined;
            const newLeftSE = new SweepEvent(point, true);
            const newRightSE = new SweepEvent(point, false);
            const oldRightSE = this.rightSE;
            this.replaceRightSE(newRightSE);
            newEvents.push(newRightSE);
            newEvents.push(newLeftSE);
            const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
            // when splitting a nearly vertical downward-facing segment,
            // sometimes one of the resulting new segments is vertical, in which
            // case its left and right events may need to be swapped
            if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) newSeg.swapEvents();
            if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) this.swapEvents();
            // in the point we just used to create new sweep events with was already
            // linked to other events, we need to check if either of the affected
            // segments should be consumed
            if (alreadyLinked) {
                newLeftSE.checkForConsuming();
                newRightSE.checkForConsuming();
            }
            return newEvents;
        }
        /* Swap which event is left and right */ swapEvents() {
            const tmpEvt = this.rightSE;
            this.rightSE = this.leftSE;
            this.leftSE = tmpEvt;
            this.leftSE.isLeft = true;
            this.rightSE.isLeft = false;
            for(let i = 0, iMax = this.windings.length; i < iMax; i++)this.windings[i] *= -1;
        }
        /* Consume another segment. We take their rings under our wing
       * and mark them as consumed. Use for perfectly overlapping segments */ consume(other) {
            let consumer = this;
            let consumee = other;
            while(consumer.consumedBy)consumer = consumer.consumedBy;
            while(consumee.consumedBy)consumee = consumee.consumedBy;
            const cmp = Segment.compare(consumer, consumee);
            if (cmp === 0) return; // already consumed
            // the winner of the consumption is the earlier segment
            // according to sweep line ordering
            if (cmp > 0) {
                const tmp = consumer;
                consumer = consumee;
                consumee = tmp;
            }
            // make sure a segment doesn't consume it's prev
            if (consumer.prev === consumee) {
                const tmp = consumer;
                consumer = consumee;
                consumee = tmp;
            }
            for(let i = 0, iMax = consumee.rings.length; i < iMax; i++){
                const ring = consumee.rings[i];
                const winding = consumee.windings[i];
                const index = consumer.rings.indexOf(ring);
                if (index === -1) {
                    consumer.rings.push(ring);
                    consumer.windings.push(winding);
                } else consumer.windings[index] += winding;
            }
            consumee.rings = null;
            consumee.windings = null;
            consumee.consumedBy = consumer;
            // mark sweep events consumed as to maintain ordering in sweep event queue
            consumee.leftSE.consumedBy = consumer.leftSE;
            consumee.rightSE.consumedBy = consumer.rightSE;
        }
        /* The first segment previous segment chain that is in the result */ prevInResult() {
            if (this._prevInResult !== undefined) return this._prevInResult;
            if (!this.prev) this._prevInResult = null;
            else if (this.prev.isInResult()) this._prevInResult = this.prev;
            else this._prevInResult = this.prev.prevInResult();
            return this._prevInResult;
        }
        beforeState() {
            if (this._beforeState !== undefined) return this._beforeState;
            if (!this.prev) this._beforeState = {
                rings: [],
                windings: [],
                multiPolys: []
            };
            else {
                const seg = this.prev.consumedBy || this.prev;
                this._beforeState = seg.afterState();
            }
            return this._beforeState;
        }
        afterState() {
            if (this._afterState !== undefined) return this._afterState;
            const beforeState = this.beforeState();
            this._afterState = {
                rings: beforeState.rings.slice(0),
                windings: beforeState.windings.slice(0),
                multiPolys: []
            };
            const ringsAfter = this._afterState.rings;
            const windingsAfter = this._afterState.windings;
            const mpsAfter = this._afterState.multiPolys;
            // calculate ringsAfter, windingsAfter
            for(let i = 0, iMax = this.rings.length; i < iMax; i++){
                const ring = this.rings[i];
                const winding = this.windings[i];
                const index = ringsAfter.indexOf(ring);
                if (index === -1) {
                    ringsAfter.push(ring);
                    windingsAfter.push(winding);
                } else windingsAfter[index] += winding;
            }
            // calcualte polysAfter
            const polysAfter = [];
            const polysExclude = [];
            for(let i = 0, iMax = ringsAfter.length; i < iMax; i++){
                if (windingsAfter[i] === 0) continue; // non-zero rule
                const ring = ringsAfter[i];
                const poly = ring.poly;
                if (polysExclude.indexOf(poly) !== -1) continue;
                if (ring.isExterior) polysAfter.push(poly);
                else {
                    if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
                    const index = polysAfter.indexOf(ring.poly);
                    if (index !== -1) polysAfter.splice(index, 1);
                }
            }
            // calculate multiPolysAfter
            for(let i = 0, iMax = polysAfter.length; i < iMax; i++){
                const mp = polysAfter[i].multiPoly;
                if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
            }
            return this._afterState;
        }
        /* Is this segment part of the final result? */ isInResult() {
            // if we've been consumed, we're not in the result
            if (this.consumedBy) return false;
            if (this._isInResult !== undefined) return this._isInResult;
            const mpsBefore = this.beforeState().multiPolys;
            const mpsAfter = this.afterState().multiPolys;
            switch(operation.type){
                case "union":
                    {
                        // UNION - included iff:
                        //  * On one side of us there is 0 poly interiors AND
                        //  * On the other side there is 1 or more.
                        const noBefores = mpsBefore.length === 0;
                        const noAfters = mpsAfter.length === 0;
                        this._isInResult = noBefores !== noAfters;
                        break;
                    }
                case "intersection":
                    {
                        // INTERSECTION - included iff:
                        //  * on one side of us all multipolys are rep. with poly interiors AND
                        //  * on the other side of us, not all multipolys are repsented
                        //    with poly interiors
                        let least;
                        let most;
                        if (mpsBefore.length < mpsAfter.length) {
                            least = mpsBefore.length;
                            most = mpsAfter.length;
                        } else {
                            least = mpsAfter.length;
                            most = mpsBefore.length;
                        }
                        this._isInResult = most === operation.numMultiPolys && least < most;
                        break;
                    }
                case "xor":
                    {
                        // XOR - included iff:
                        //  * the difference between the number of multipolys represented
                        //    with poly interiors on our two sides is an odd number
                        const diff = Math.abs(mpsBefore.length - mpsAfter.length);
                        this._isInResult = diff % 2 === 1;
                        break;
                    }
                case "difference":
                    {
                        // DIFFERENCE included iff:
                        //  * on exactly one side, we have just the subject
                        const isJustSubject = (mps)=>mps.length === 1 && mps[0].isSubject;
                        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                        break;
                    }
                default:
                    throw new Error(`Unrecognized operation type found ${operation.type}`);
            }
            return this._isInResult;
        }
    }
    class RingIn {
        constructor(geomRing, poly, isExterior){
            if (!Array.isArray(geomRing) || geomRing.length === 0) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
                ll: {
                    x: firstPoint.x,
                    y: firstPoint.y
                },
                ur: {
                    x: firstPoint.x,
                    y: firstPoint.y
                }
            };
            let prevPoint = firstPoint;
            for(let i = 1, iMax = geomRing.length; i < iMax; i++){
                if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                let point = rounder.round(geomRing[i][0], geomRing[i][1]);
                // skip repeated points
                if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
                this.segments.push(Segment.fromRing(prevPoint, point, this));
                if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
                if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
                if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
                if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
                prevPoint = point;
            }
            // add segment from last to first if last is not the same as first
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
        }
        getSweepEvents() {
            const sweepEvents = [];
            for(let i = 0, iMax = this.segments.length; i < iMax; i++){
                const segment = this.segments[i];
                sweepEvents.push(segment.leftSE);
                sweepEvents.push(segment.rightSE);
            }
            return sweepEvents;
        }
    }
    class PolyIn {
        constructor(geomPoly, multiPoly){
            if (!Array.isArray(geomPoly)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            this.exteriorRing = new RingIn(geomPoly[0], this, true);
            // copy by value
            this.bbox = {
                ll: {
                    x: this.exteriorRing.bbox.ll.x,
                    y: this.exteriorRing.bbox.ll.y
                },
                ur: {
                    x: this.exteriorRing.bbox.ur.x,
                    y: this.exteriorRing.bbox.ur.y
                }
            };
            this.interiorRings = [];
            for(let i = 1, iMax = geomPoly.length; i < iMax; i++){
                const ring = new RingIn(geomPoly[i], this, false);
                if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
                if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
                if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
                if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
                this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
        }
        getSweepEvents() {
            const sweepEvents = this.exteriorRing.getSweepEvents();
            for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){
                const ringSweepEvents = this.interiorRings[i].getSweepEvents();
                for(let j = 0, jMax = ringSweepEvents.length; j < jMax; j++)sweepEvents.push(ringSweepEvents[j]);
            }
            return sweepEvents;
        }
    }
    class MultiPolyIn {
        constructor(geom, isSubject){
            if (!Array.isArray(geom)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            try {
                // if the input looks like a polygon, convert it to a multipolygon
                if (typeof geom[0][0][0] === "number") geom = [
                    geom
                ];
            } catch (ex) {
            // The input is either malformed or has empty arrays.
            // In either case, it will be handled later on.
            }
            this.polys = [];
            this.bbox = {
                ll: {
                    x: Number.POSITIVE_INFINITY,
                    y: Number.POSITIVE_INFINITY
                },
                ur: {
                    x: Number.NEGATIVE_INFINITY,
                    y: Number.NEGATIVE_INFINITY
                }
            };
            for(let i = 0, iMax = geom.length; i < iMax; i++){
                const poly = new PolyIn(geom[i], this);
                if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
                if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
                if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
                if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
                this.polys.push(poly);
            }
            this.isSubject = isSubject;
        }
        getSweepEvents() {
            const sweepEvents = [];
            for(let i = 0, iMax = this.polys.length; i < iMax; i++){
                const polySweepEvents = this.polys[i].getSweepEvents();
                for(let j = 0, jMax = polySweepEvents.length; j < jMax; j++)sweepEvents.push(polySweepEvents[j]);
            }
            return sweepEvents;
        }
    }
    class RingOut {
        /* Given the segments from the sweep line pass, compute & return a series
       * of closed rings from all the segments marked to be part of the result */ static factory(allSegments) {
            const ringsOut = [];
            for(let i = 0, iMax = allSegments.length; i < iMax; i++){
                const segment = allSegments[i];
                if (!segment.isInResult() || segment.ringOut) continue;
                let prevEvent = null;
                let event = segment.leftSE;
                let nextEvent = segment.rightSE;
                const events = [
                    event
                ];
                const startingPoint = event.point;
                const intersectionLEs = [];
                /* Walk the chain of linked events to form a closed ring */ while(true){
                    prevEvent = event;
                    event = nextEvent;
                    events.push(event);
                    /* Is the ring complete? */ if (event.point === startingPoint) break;
                    while(true){
                        const availableLEs = event.getAvailableLinkedEvents();
                        /* Did we hit a dead end? This shouldn't happen.
               * Indicates some earlier part of the algorithm malfunctioned. */ if (availableLEs.length === 0) {
                            const firstPt = events[0].point;
                            const lastPt = events[events.length - 1].point;
                            throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);
                        }
                        /* Only one way to go, so cotinue on the path */ if (availableLEs.length === 1) {
                            nextEvent = availableLEs[0].otherSE;
                            break;
                        }
                        /* We must have an intersection. Check for a completed loop */ let indexLE = null;
                        for(let j = 0, jMax = intersectionLEs.length; j < jMax; j++)if (intersectionLEs[j].point === event.point) {
                            indexLE = j;
                            break;
                        }
                        /* Found a completed loop. Cut that off and make a ring */ if (indexLE !== null) {
                            const intersectionLE = intersectionLEs.splice(indexLE)[0];
                            const ringEvents = events.splice(intersectionLE.index);
                            ringEvents.unshift(ringEvents[0].otherSE);
                            ringsOut.push(new RingOut(ringEvents.reverse()));
                            continue;
                        }
                        /* register the intersection */ intersectionLEs.push({
                            index: events.length,
                            point: event.point
                        });
                        /* Choose the left-most option to continue the walk */ const comparator = event.getLeftmostComparator(prevEvent);
                        nextEvent = availableLEs.sort(comparator)[0].otherSE;
                        break;
                    }
                }
                ringsOut.push(new RingOut(events));
            }
            return ringsOut;
        }
        constructor(events){
            this.events = events;
            for(let i = 0, iMax = events.length; i < iMax; i++)events[i].segment.ringOut = this;
            this.poly = null;
        }
        getGeom() {
            // Remove superfluous points (ie extra points along a straight line),
            let prevPt = this.events[0].point;
            const points = [
                prevPt
            ];
            for(let i = 1, iMax = this.events.length - 1; i < iMax; i++){
                const pt = this.events[i].point;
                const nextPt = this.events[i + 1].point;
                if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;
                points.push(pt);
                prevPt = pt;
            }
            // ring was all (within rounding error of angle calc) colinear points
            if (points.length === 1) return null;
            // check if the starting point is necessary
            const pt = points[0];
            const nextPt = points[1];
            if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
            points.push(points[0]);
            const step = this.isExteriorRing() ? 1 : -1;
            const iStart = this.isExteriorRing() ? 0 : points.length - 1;
            const iEnd = this.isExteriorRing() ? points.length : -1;
            const orderedPoints = [];
            for(let i = iStart; i != iEnd; i += step)orderedPoints.push([
                points[i].x,
                points[i].y
            ]);
            return orderedPoints;
        }
        isExteriorRing() {
            if (this._isExteriorRing === undefined) {
                const enclosing = this.enclosingRing();
                this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
            }
            return this._isExteriorRing;
        }
        enclosingRing() {
            if (this._enclosingRing === undefined) this._enclosingRing = this._calcEnclosingRing();
            return this._enclosingRing;
        }
        /* Returns the ring that encloses this one, if any */ _calcEnclosingRing() {
            // start with the ealier sweep line event so that the prevSeg
            // chain doesn't lead us inside of a loop of ours
            let leftMostEvt = this.events[0];
            for(let i = 1, iMax = this.events.length; i < iMax; i++){
                const evt = this.events[i];
                if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
            }
            let prevSeg = leftMostEvt.segment.prevInResult();
            let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            while(true){
                // no segment found, thus no ring can enclose us
                if (!prevSeg) return null;
                // no segments below prev segment found, thus the ring of the prev
                // segment must loop back around and enclose us
                if (!prevPrevSeg) return prevSeg.ringOut;
                // if the two segments are of different rings, the ring of the prev
                // segment must either loop around us or the ring of the prev prev
                // seg, which would make us and the ring of the prev peers
                if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                    if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) return prevSeg.ringOut;
                    else return prevSeg.ringOut.enclosingRing();
                }
                // two segments are from the same ring, so this was a penisula
                // of that ring. iterate downward, keep searching
                prevSeg = prevPrevSeg.prevInResult();
                prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            }
        }
    }
    class PolyOut {
        constructor(exteriorRing){
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
        }
        addInterior(ring) {
            this.interiorRings.push(ring);
            ring.poly = this;
        }
        getGeom() {
            const geom = [
                this.exteriorRing.getGeom()
            ];
            // exterior ring was all (within rounding error of angle calc) colinear points
            if (geom[0] === null) return null;
            for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){
                const ringGeom = this.interiorRings[i].getGeom();
                // interior ring was all (within rounding error of angle calc) colinear points
                if (ringGeom === null) continue;
                geom.push(ringGeom);
            }
            return geom;
        }
    }
    class MultiPolyOut {
        constructor(rings){
            this.rings = rings;
            this.polys = this._composePolys(rings);
        }
        getGeom() {
            const geom = [];
            for(let i = 0, iMax = this.polys.length; i < iMax; i++){
                const polyGeom = this.polys[i].getGeom();
                // exterior ring was all (within rounding error of angle calc) colinear points
                if (polyGeom === null) continue;
                geom.push(polyGeom);
            }
            return geom;
        }
        _composePolys(rings) {
            const polys = [];
            for(let i = 0, iMax = rings.length; i < iMax; i++){
                const ring = rings[i];
                if (ring.poly) continue;
                if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
                else {
                    const enclosingRing = ring.enclosingRing();
                    if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
                    enclosingRing.poly.addInterior(ring);
                }
            }
            return polys;
        }
    }
    /**
     * NOTE:  We must be careful not to change any segments while
     *        they are in the SplayTree. AFAIK, there's no way to tell
     *        the tree to rebalance itself - thus before splitting
     *        a segment that's in the tree, we remove it from the tree,
     *        do the split, then re-insert it. (Even though splitting a
     *        segment *shouldn't* change its correct position in the
     *        sweep line tree, the reality is because of rounding errors,
     *        it sometimes does.)
     */ class SweepLine {
        constructor(queue){
            let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
        }
        process(event) {
            const segment = event.segment;
            const newEvents = [];
            // if we've already been consumed by another segment,
            // clean up our body parts and get out
            if (event.consumedBy) {
                if (event.isLeft) this.queue.remove(event.otherSE);
                else this.tree.remove(segment);
                return newEvents;
            }
            const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
            if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + "in SweepLine tree.");
            let prevNode = node;
            let nextNode = node;
            let prevSeg = undefined;
            let nextSeg = undefined;
            // skip consumed segments still in tree
            while(prevSeg === undefined){
                prevNode = this.tree.prev(prevNode);
                if (prevNode === null) prevSeg = null;
                else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
            }
            // skip consumed segments still in tree
            while(nextSeg === undefined){
                nextNode = this.tree.next(nextNode);
                if (nextNode === null) nextSeg = null;
                else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
            }
            if (event.isLeft) {
                // Check for intersections against the previous segment in the sweep line
                let prevMySplitter = null;
                if (prevSeg) {
                    const prevInter = prevSeg.getIntersection(segment);
                    if (prevInter !== null) {
                        if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
                        if (!prevSeg.isAnEndpoint(prevInter)) {
                            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                            for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++)newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
                // Check for intersections against the next segment in the sweep line
                let nextMySplitter = null;
                if (nextSeg) {
                    const nextInter = nextSeg.getIntersection(segment);
                    if (nextInter !== null) {
                        if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
                        if (!nextSeg.isAnEndpoint(nextInter)) {
                            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                            for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++)newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
                // For simplicity, even if we find more than one intersection we only
                // spilt on the 'earliest' (sweep-line style) of the intersections.
                // The other intersection will be handled in a future process().
                if (prevMySplitter !== null || nextMySplitter !== null) {
                    let mySplitter = null;
                    if (prevMySplitter === null) mySplitter = nextMySplitter;
                    else if (nextMySplitter === null) mySplitter = prevMySplitter;
                    else {
                        const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                        mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                    }
                    // Rounding errors can cause changes in ordering,
                    // so remove afected segments and right sweep events before splitting
                    this.queue.remove(segment.rightSE);
                    newEvents.push(segment.rightSE);
                    const newEventsFromSplit = segment.split(mySplitter);
                    for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++)newEvents.push(newEventsFromSplit[i]);
                }
                if (newEvents.length > 0) {
                    // We found some intersections, so re-do the current event to
                    // make sure sweep line ordering is totally consistent for later
                    // use with the segment 'prev' pointers
                    this.tree.remove(segment);
                    newEvents.push(event);
                } else {
                    // done with left event
                    this.segments.push(segment);
                    segment.prev = prevSeg;
                }
            } else {
                // event.isRight
                // since we're about to be removed from the sweep line, check for
                // intersections between our previous and next segments
                if (prevSeg && nextSeg) {
                    const inter = prevSeg.getIntersection(nextSeg);
                    if (inter !== null) {
                        if (!prevSeg.isAnEndpoint(inter)) {
                            const newEventsFromSplit = this._splitSafely(prevSeg, inter);
                            for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++)newEvents.push(newEventsFromSplit[i]);
                        }
                        if (!nextSeg.isAnEndpoint(inter)) {
                            const newEventsFromSplit = this._splitSafely(nextSeg, inter);
                            for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++)newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
                this.tree.remove(segment);
            }
            return newEvents;
        }
        /* Safely split a segment that is currently in the datastructures
       * IE - a segment other than the one that is currently being processed. */ _splitSafely(seg, pt) {
            // Rounding errors can cause changes in ordering,
            // so remove afected segments and right sweep events before splitting
            // removeNode() doesn't work, so have re-find the seg
            // https://github.com/w8r/splay-tree/pull/5
            this.tree.remove(seg);
            const rightSE = seg.rightSE;
            this.queue.remove(rightSE);
            const newEvents = seg.split(pt);
            newEvents.push(rightSE);
            // splitting can trigger consumption
            if (seg.consumedBy === undefined) this.tree.add(seg);
            return newEvents;
        }
    }
    // Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.
    const POLYGON_CLIPPING_MAX_QUEUE_SIZE = 1000000;
    const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = 1000000;
    class Operation {
        run(type, geom, moreGeoms) {
            operation.type = type;
            rounder.reset();
            /* Convert inputs to MultiPoly objects */ const multipolys = [
                new MultiPolyIn(geom, true)
            ];
            for(let i = 0, iMax = moreGeoms.length; i < iMax; i++)multipolys.push(new MultiPolyIn(moreGeoms[i], false));
            operation.numMultiPolys = multipolys.length;
            /* BBox optimization for difference operation
         * If the bbox of a multipolygon that's part of the clipping doesn't
         * intersect the bbox of the subject at all, we can just drop that
         * multiploygon. */ if (operation.type === "difference") {
                // in place removal
                const subject = multipolys[0];
                let i = 1;
                while(i < multipolys.length)if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;
                else multipolys.splice(i, 1);
            }
            /* BBox optimization for intersection operation
         * If we can find any pair of multipolygons whose bbox does not overlap,
         * then the result will be empty. */ if (operation.type === "intersection") // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
            //       it could be optimized to O(n * ln(n))
            for(let i = 0, iMax = multipolys.length; i < iMax; i++){
                const mpA = multipolys[i];
                for(let j = i + 1, jMax = multipolys.length; j < jMax; j++){
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
                }
            }
            /* Put segment endpoints in a priority queue */ const queue = new Tree(SweepEvent.compare);
            for(let i = 0, iMax = multipolys.length; i < iMax; i++){
                const sweepEvents = multipolys[i].getSweepEvents();
                for(let j = 0, jMax = sweepEvents.length; j < jMax; j++){
                    queue.insert(sweepEvents[j]);
                    if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) // prevents an infinite loop, an otherwise common manifestation of bugs
                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
                }
            }
            /* Pass the sweep line over those endpoints */ const sweepLine = new SweepLine(queue);
            let prevQueueSize = queue.size;
            let node = queue.pop();
            while(node){
                const evt = node.key;
                if (queue.size === prevQueueSize) {
                    // prevents an infinite loop, an otherwise common manifestation of bugs
                    const seg = evt.segment;
                    throw new Error(`Unable to pop() ${evt.isLeft ? "left" : "right"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);
                }
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) // prevents an infinite loop, an otherwise common manifestation of bugs
                throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
                if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) // prevents an infinite loop, an otherwise common manifestation of bugs
                throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
                const newEvents = sweepLine.process(evt);
                for(let i = 0, iMax = newEvents.length; i < iMax; i++){
                    const evt = newEvents[i];
                    if (evt.consumedBy === undefined) queue.insert(evt);
                }
                prevQueueSize = queue.size;
                node = queue.pop();
            }
            // free some memory we don't need anymore
            rounder.reset();
            /* Collect and compile segments we're keeping into a multipolygon */ const ringsOut = RingOut.factory(sweepLine.segments);
            const result = new MultiPolyOut(ringsOut);
            return result.getGeom();
        }
    }
    // singleton available by import
    const operation = new Operation();
    const union = function(geom) {
        for(var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)moreGeoms[_key - 1] = arguments[_key];
        return operation.run("union", geom, moreGeoms);
    };
    const intersection = function(geom) {
        for(var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)moreGeoms[_key2 - 1] = arguments[_key2];
        return operation.run("intersection", geom, moreGeoms);
    };
    const xor = function(geom) {
        for(var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)moreGeoms[_key3 - 1] = arguments[_key3];
        return operation.run("xor", geom, moreGeoms);
    };
    const difference = function(subjectGeom) {
        for(var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)clippingGeoms[_key4 - 1] = arguments[_key4];
        return operation.run("difference", subjectGeom, clippingGeoms);
    };
    var index = {
        union: union,
        intersection: intersection,
        xor: xor,
        difference: difference
    };
    return index;
});

},{}],"7YZBQ":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-crop.00823a57.svg") + "?" + Date.now();

},{}],"3SqSS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clipboardDialog", ()=>clipboardDialog);
var _bb = require("../../../bb/bb");
var _showModal = require("./base/showModal");
var _cropCopy = require("../components/crop-copy");
var _language = require("../../../language/language");
var _math = require("../../../bb/math/math");
var _getMultiPolygonBounds = require("../../../bb/multi-polygon/get-multi-polygon-bounds");
var _checkbox = require("../components/checkbox");
var _base = require("../../../bb/base/base");
let maskSelection = false;
function clipboardDialog(parent, getFullCanvas, cropCallback, output, showCropButton, closeOnBlur = true, selection) {
    let clipboardItemIsSupported = false;
    try {
        clipboardItemIsSupported = !!ClipboardItem;
    } catch (e) {
    /* empty */ }
    const div = document.createElement('div');
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    const maskToggle = selection ? new (0, _checkbox.Checkbox)({
        init: maskSelection,
        label: (0, _language.LANG)('cropcopy-mask'),
        name: 'check-mask-selection',
        css: {
            width: 'fit-content'
        },
        callback: (b)=>{
            maskSelection = b;
            cropCopy.setCanvas(getFullCanvas(b));
        }
    }) : undefined;
    const topWrapper = (0, _bb.BB).el({
        content: [
            maskToggle?.getElement(),
            (0, _language.LANG)('crop-drag-to-crop') + (clipboardItemIsSupported ? '' : '<br>' + (0, _language.LANG)('cropcopy-click-hold'))
        ],
        css: {
            textAlign: 'center'
        }
    });
    div.append(topWrapper);
    const fullCanvas = getFullCanvas(maskSelection);
    let init;
    if (selection) {
        const bounds = (0, _getMultiPolygonBounds.getMultiPolyBounds)(selection);
        const boundsInCanvas = (0, _math.intBoundsWithinArea)(bounds, fullCanvas.width, fullCanvas.height);
        init = boundsInCanvas ? (0, _math.boundsToRect)(boundsInCanvas) : undefined;
    }
    const cropCopy = new (0, _cropCopy.CropCopy)({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 350,
        canvas: fullCanvas,
        enableRightClickCopy: true,
        init
    });
    (0, _base.css)(cropCopy.getElement(), {
        marginTop: '10px',
        marginLeft: '-20px'
    });
    div.append(cropCopy.getElement());
    async function toClipboard() {
        try {
            const blob = cropCopy.getCroppedBlob();
            await navigator.clipboard.write([
                new ClipboardItem({
                    [blob.type]: blob
                })
            ]);
            setTimeout(function() {
                output.out((0, _language.LANG)('cropcopy-copied'), true);
            }, 200);
        } catch (err) {
            console.error(err.name, err.message);
            return;
        }
    }
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, KeyEvent, comboStr) {
            if ([
                'ctrl+c',
                'cmd+c'
            ].includes(comboStr)) {
                toClipboard();
                closeFunc && closeFunc();
            }
        }
    });
    let closeFunc;
    function blur() {
        if (closeOnBlur) closeFunc?.();
    }
    window.addEventListener('blur', blur);
    const buttonArr = [];
    if (clipboardItemIsSupported) buttonArr.push((0, _language.LANG)('cropcopy-btn-copy'));
    if (showCropButton) buttonArr.push((0, _language.LANG)('cropcopy-btn-crop'));
    buttonArr.push('Cancel');
    (0, _showModal.showModal)({
        target: parent,
        message: '<b>' + (showCropButton ? `${(0, _language.LANG)('cropcopy-title-copy')} / ${(0, _language.LANG)('cropcopy-title-crop')}` : `${(0, _language.LANG)('cropcopy-title-copy')}`) + '</b>',
        div: div,
        style: isSmall ? {} : {
            width: '540px'
        },
        buttons: buttonArr,
        primaries: [
            (0, _language.LANG)('cropcopy-btn-copy')
        ],
        callback: function(result) {
            if (result === (0, _language.LANG)('cropcopy-btn-copy')) toClipboard();
            else if (result === (0, _language.LANG)('cropcopy-btn-crop')) {
                const rectObj = cropCopy.getCropRect();
                cropCallback({
                    left: Math.round(-rectObj.x),
                    right: Math.round(rectObj.x + rectObj.width - fullCanvas.width),
                    top: Math.round(-rectObj.y),
                    bottom: Math.round(rectObj.y + rectObj.height - fullCanvas.height)
                });
            }
            window.removeEventListener('blur', blur);
            (0, _bb.BB).freeCanvas(cropCopy.getCroppedCanvas());
            cropCopy.destroy();
            keyListener.destroy();
        },
        clickOnEnter: (0, _language.LANG)('cropcopy-btn-copy'),
        closeFunc: function(func) {
            closeFunc = func;
        }
    });
}

},{"../../../bb/bb":"3zOvT","./base/showModal":"gy3iL","../components/crop-copy":"dtoRN","../../../language/language":"mcywn","../../../bb/math/math":"7x9Fp","../../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","../components/checkbox":"9bXL6","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6LgBa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getMultiPolyBounds", ()=>getMultiPolyBounds);
function getMultiPolyBounds(poly) {
    let x1 = undefined;
    let y1 = undefined;
    let x2 = undefined;
    let y2 = undefined;
    poly.forEach((poly)=>{
        poly.forEach((ring)=>{
            ring.forEach((p)=>{
                x1 = x1 === undefined ? p[0] : Math.min(x1, p[0]);
                y1 = y1 === undefined ? p[1] : Math.min(y1, p[1]);
                x2 = x2 === undefined ? p[0] : Math.max(x2, p[0]);
                y2 = y2 === undefined ? p[1] : Math.max(y2, p[1]);
            });
        });
    });
    if (x1 === undefined || y1 === undefined || x2 === undefined || y2 === undefined) throw 'empty poly';
    return {
        x1,
        y1,
        x2,
        y2
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7R6ie":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LayersUi", ()=>LayersUi);
var _bb = require("../../../../bb/bb");
var _select = require("../../components/select");
var _pointSlider = require("../../components/point-slider");
var _klCanvas = require("../../../canvas/kl-canvas");
var _language = require("../../../../language/language");
var _translateBlending = require("../../../canvas/translate-blending");
var _renameLayerDialog = require("./rename-layer-dialog");
var _mergeLayerDialog = require("./merge-layer-dialog");
var _base = require("../../../../bb/base/base");
var _browser = require("../../../../bb/base/browser");
var _c = require("../../../../bb/base/c");
var _dropdownMenu = require("../../components/dropdown-menu");
var _addLayerSvg = require("url:/src/app/img/ui/add-layer.svg");
var _addLayerSvgDefault = parcelHelpers.interopDefault(_addLayerSvg);
var _duplicateLayerSvg = require("url:/src/app/img/ui/duplicate-layer.svg");
var _duplicateLayerSvgDefault = parcelHelpers.interopDefault(_duplicateLayerSvg);
var _mergeLayersSvg = require("url:/src/app/img/ui/merge-layers.svg");
var _mergeLayersSvgDefault = parcelHelpers.interopDefault(_mergeLayersSvg);
var _removeLayerSvg = require("url:/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _renameLayerSvg = require("url:/src/app/img/ui/rename-layer.svg");
var _renameLayerSvgDefault = parcelHelpers.interopDefault(_renameLayerSvg);
var _caretDownSvg = require("url:/src/app/img/ui/caret-down.svg");
var _caretDownSvgDefault = parcelHelpers.interopDefault(_caretDownSvg);
var _ui = require("../../../../bb/base/ui");
const paddingLeft = 25;
class LayersUi {
    move(oldSpotIndex, newSpotIndex) {
        if (isNaN(oldSpotIndex) || isNaN(newSpotIndex)) throw 'layers-ui - invalid move';
        for(let i = 0; i < this.klCanvasLayerArr.length; i++)((i)=>{
            let posy = this.layerElArr[i].spot; // <- here
            if (this.layerElArr[i].spot === oldSpotIndex) posy = newSpotIndex;
            else {
                if (this.layerElArr[i].spot > oldSpotIndex) posy--;
                if (posy >= newSpotIndex) posy++;
            }
            this.layerElArr[i].spot = posy;
            this.layerElArr[i].posY = (this.layerHeight + this.layerSpacing) * (this.klCanvasLayerArr.length - posy - 1);
            this.layerElArr[i].style.top = this.layerElArr[i].posY + 'px';
        })(i);
        if (oldSpotIndex === newSpotIndex) return;
        this.applyUncommitted();
        this.klCanvas.moveLayer(this.selectedSpotIndex, newSpotIndex - oldSpotIndex);
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        this.selectedSpotIndex = newSpotIndex;
        this.mergeBtn.disabled = this.selectedSpotIndex === 0;
    }
    posToSpot(p) {
        let result = parseInt('' + (p / (this.layerHeight + this.layerSpacing) + 0.5));
        result = Math.min(this.klCanvasLayerArr.length - 1, Math.max(0, result));
        result = this.klCanvasLayerArr.length - result - 1;
        return result;
    }
    /**
     * update css position of all layers that are not being dragged, while dragging
     */ updateLayersVerticalPosition(id, newspot) {
        newspot = Math.min(this.klCanvasLayerArr.length - 1, Math.max(0, newspot));
        if (newspot === this.lastpos) return;
        for(let i = 0; i < this.klCanvasLayerArr.length; i++){
            if (this.layerElArr[i].spot === id) continue;
            let posy = this.layerElArr[i].spot;
            if (this.layerElArr[i].spot > id) posy--;
            if (posy >= newspot) posy++;
            this.layerElArr[i].posY = (this.layerHeight + this.layerSpacing) * (this.klCanvasLayerArr.length - posy - 1);
            this.layerElArr[i].style.top = this.layerElArr[i].posY + 'px';
        }
        this.lastpos = newspot;
    }
    renameLayer(layerSpot) {
        (0, _renameLayerDialog.renameLayerDialog)(this.parentEl, this.klCanvas.getLayerOld(layerSpot).name, (newName)=>{
            if (newName === undefined || newName === this.klCanvas.getLayerOld(layerSpot).name) return;
            this.klCanvas.renameLayer(layerSpot, newName);
            //this.createLayerList();
            this.klHistory.pause(true);
            this.onSelect(layerSpot);
            this.klHistory.pause(false);
        });
    }
    updateHeight() {
        this.layerListEl.style.height = this.layerElArr.length * 35 + 'px';
    }
    createLayerList(force) {
        if (this.klHistory.getChangeCount() === this.oldHistoryState && !force) return;
        this.oldHistoryState = this.klHistory.getChangeCount();
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        const createLayerEntry = (index)=>{
            const klLayer = (0, _base.throwIfNull)(this.klCanvas.getLayerOld(index));
            const layerName = klLayer.name;
            const opacity = this.klCanvasLayerArr[index].opacity;
            const isVisible = klLayer.isVisible;
            const layercanvas = this.klCanvasLayerArr[index].context.canvas;
            const layer = (0, _bb.BB).el({
                className: 'kl-layer'
            });
            this.layerElArr[index] = layer;
            layer.posY = (this.klCanvasLayerArr.length - 1) * 35 - index * 35;
            (0, _base.css)(layer, {
                top: layer.posY + 'px'
            });
            const innerLayer = (0, _bb.BB).el();
            (0, _base.css)(innerLayer, {
                position: 'relative'
            });
            const container1 = (0, _bb.BB).el();
            (0, _base.css)(container1, {
                width: '270px',
                height: '34px'
            });
            const container2 = (0, _bb.BB).el();
            layer.append(innerLayer);
            innerLayer.append(container1, container2);
            layer.spot = index;
            //checkbox - visibility
            {
                const checkWrapper = (0, _bb.BB).el({
                    tagName: 'label',
                    parent: container1,
                    title: (0, _language.LANG)('layers-visibility-toggle'),
                    css: {
                        display: 'flex',
                        width: '25px',
                        height: '100%',
                        justifyContent: 'right',
                        alignItems: 'center',
                        cursor: 'pointer'
                    }
                });
                const check = (0, _bb.BB).el({
                    tagName: 'input',
                    parent: checkWrapper,
                    custom: {
                        type: 'checkbox',
                        tabindex: '-1',
                        name: 'layer-visibility'
                    },
                    css: {
                        display: 'block',
                        cursor: 'pointer',
                        margin: '0',
                        marginRight: '5px'
                    }
                });
                check.checked = isVisible;
                check.onchange = ()=>{
                    this.klCanvas.setLayerIsVisible(layer.spot, check.checked);
                    //this.createLayerList();
                    if (layer.spot === this.selectedSpotIndex) {
                        this.klHistory.pause(true);
                        this.onSelect(this.selectedSpotIndex);
                        this.klHistory.pause(false);
                    }
                };
                // prevent layer getting dragged
                const preventFunc = (e)=>{
                    e.preventDefault();
                    e.stopPropagation();
                };
                if (0, _browser.HAS_POINTER_EVENTS) checkWrapper.onpointerdown = preventFunc;
                else checkWrapper.onmousedown = preventFunc;
            }
            //thumb
            {
                const thumbDimensions = (0, _bb.BB).fitInto(layercanvas.width, layercanvas.height, 30, 30, 1);
                layer.thumb = (0, _bb.BB).canvas(thumbDimensions.width, thumbDimensions.height);
                const thc = (0, _bb.BB).ctx(layer.thumb);
                thc.save();
                if (layer.thumb.width > layercanvas.width) thc.imageSmoothingEnabled = false;
                thc.drawImage(layercanvas, 0, 0, layer.thumb.width, layer.thumb.height);
                thc.restore();
                (0, _base.css)(layer.thumb, {
                    position: 'absolute',
                    left: (32 - layer.thumb.width) / 2 + paddingLeft + 'px',
                    top: (32 - layer.thumb.height) / 2 + 1 + 'px',
                    background: 'var(--kl-checkerboard-background)'
                });
            }
            layer.label = (0, _bb.BB).el({
                className: 'kl-layer__label'
            });
            layer.layerName = layerName;
            layer.label.append(layer.layerName);
            (0, _base.css)(layer.label, {
                position: 'absolute',
                left: 38 + paddingLeft + 'px',
                top: "1px",
                fontSize: '13px',
                width: '165px',
                height: '20px',
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                textOverflow: 'ellipsis'
            });
            layer.label.ondblclick = ()=>{
                this.applyUncommitted();
                this.renameLayer(layer.spot);
            };
            layer.opacityLabel = (0, _bb.BB).el({
                className: 'kl-layer__opacity-label'
            });
            layer.opacity = opacity;
            layer.opacityLabel.append(parseInt('' + layer.opacity * 100) + '%');
            (0, _base.css)(layer.opacityLabel, {
                position: 'absolute',
                left: 189 + paddingLeft + 'px',
                top: "1px",
                fontSize: '13px',
                textAlign: 'right',
                width: '50px',
                transition: 'color 0.2s ease-in-out',
                textDecoration: isVisible ? undefined : 'line-through'
            });
            let oldOpacity;
            const opacitySlider = new (0, _pointSlider.PointSlider)({
                init: layer.opacity,
                width: 200,
                pointSize: 14,
                callback: (sliderValue, isFirst, isLast)=>{
                    if (isFirst) {
                        oldOpacity = this.klCanvas.getLayerOld(layer.spot).opacity;
                        this.klHistory.pause(true);
                        return;
                    }
                    if (isLast) {
                        this.klHistory.pause(false);
                        if (oldOpacity !== sliderValue) this.klCanvas.setOpacity(layer.spot, sliderValue);
                        return;
                    }
                    layer.opacityLabel.innerHTML = Math.round(sliderValue * 100) + '%';
                    this.klCanvas.setOpacity(layer.spot, sliderValue);
                    this.onUpdateProject();
                }
            });
            (0, _base.css)(opacitySlider.getElement(), {
                position: 'absolute',
                left: 39 + paddingLeft + 'px',
                top: '17px'
            });
            layer.opacitySlider = opacitySlider;
            //larger layer preview - hover
            layer.thumb.onpointerover = (e)=>{
                if (e.buttons !== 0 && (!e.pointerType || e.pointerType !== 'touch')) //shouldn't show while dragging
                return;
                const thumbDimensions = (0, _bb.BB).fitInto(layercanvas.width, layercanvas.height, 250, 250, 1);
                if (this.largeThumbCanvas.width !== thumbDimensions.width || this.largeThumbCanvas.height !== thumbDimensions.height) {
                    this.largeThumbCanvas.width = thumbDimensions.width;
                    this.largeThumbCanvas.height = thumbDimensions.height;
                }
                const ctx = (0, _bb.BB).ctx(this.largeThumbCanvas);
                ctx.save();
                if (this.largeThumbCanvas.width > layercanvas.width) ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = 'high';
                ctx.clearRect(0, 0, this.largeThumbCanvas.width, this.largeThumbCanvas.height);
                ctx.drawImage(layercanvas, 0, 0, this.largeThumbCanvas.width, this.largeThumbCanvas.height);
                ctx.restore();
                (0, _base.css)(this.largeThumbDiv, {
                    top: e.clientY - this.largeThumbCanvas.height / 2 + 'px',
                    opacity: '0'
                });
                if (!this.largeThumbInDocument) {
                    document.body.append(this.largeThumbDiv);
                    this.largeThumbInDocument = true;
                }
                clearTimeout(this.largeThumbInTimeout);
                this.largeThumbInTimeout = setTimeout(()=>{
                    (0, _base.css)(this.largeThumbDiv, {
                        opacity: '1'
                    });
                }, 20);
                clearTimeout(this.largeThumbTimeout);
            };
            layer.thumb.onpointerout = ()=>{
                clearTimeout(this.largeThumbInTimeout);
                (0, _base.css)(this.largeThumbDiv, {
                    opacity: '0'
                });
                clearTimeout(this.largeThumbTimeout);
                this.largeThumbTimeout = setTimeout(()=>{
                    if (!this.largeThumbInDocument) return;
                    this.largeThumbDiv.remove();
                    this.largeThumbInDocument = false;
                }, 300);
            };
            container1.append(layer.thumb, layer.label, layer.opacityLabel, opacitySlider.getElement());
            let dragstart = false;
            let freshSelection = false;
            //events for moving layers up and down
            const dragEventHandler = (event)=>{
                if (event.type === 'pointerdown' && event.button === 'left') {
                    (0, _base.css)(layer, {
                        transition: 'box-shadow 0.3s ease-in-out',
                        zIndex: '1'
                    });
                    this.lastpos = layer.spot;
                    freshSelection = false;
                    if (!layer.isSelected) {
                        freshSelection = true;
                        this.activateLayer(layer.spot);
                    }
                    dragstart = true;
                } else if (event.type === 'pointermove' && event.button === 'left') {
                    if (dragstart) {
                        dragstart = false;
                        (0, _base.css)(layer, {
                            boxShadow: '1px 3px 5px rgba(0,0,0,0.4)'
                        });
                    }
                    layer.posY += event.dY;
                    const corrected = Math.max(0, Math.min((this.klCanvasLayerArr.length - 1) * 35, layer.posY));
                    layer.style.top = corrected + 'px';
                    this.updateLayersVerticalPosition(layer.spot, this.posToSpot(layer.posY));
                }
                if (event.type === 'pointerup') {
                    (0, _base.css)(layer, {
                        transition: 'all 0.1s linear'
                    });
                    setTimeout(()=>{
                        (0, _base.css)(layer, {
                            boxShadow: ''
                        });
                    }, 20);
                    layer.posY = Math.max(0, Math.min((this.klCanvasLayerArr.length - 1) * 35, layer.posY));
                    layer.style.zIndex = '';
                    const newSpot = this.posToSpot(layer.posY);
                    const oldSpot = layer.spot;
                    this.move(layer.spot, newSpot);
                    if (oldSpot != newSpot) {
                        this.klHistory.pause(true);
                        this.onSelect(this.selectedSpotIndex);
                        this.klHistory.pause(false);
                    }
                    if (oldSpot === newSpot && freshSelection) {
                        this.applyUncommitted();
                        this.onSelect(this.selectedSpotIndex);
                    }
                    freshSelection = false;
                }
            };
            layer.pointerListener = new (0, _bb.BB).PointerListener({
                target: container1,
                onPointer: dragEventHandler
            });
            this.layerListEl.append(layer);
        };
        this.layerElArr = [];
        while(this.layerListEl.firstChild){
            const child = this.layerListEl.firstChild;
            child.pointerListener.destroy();
            child.opacitySlider.destroy();
            child.remove();
        }
        for(let i = 0; i < this.klCanvasLayerArr.length; i++)createLayerEntry(i);
        this.activateLayer(this.selectedSpotIndex);
        this.updateHeight();
    }
    updateButtons() {
        const maxReached = this.klCanvasLayerArr.length === (0, _klCanvas.MAX_LAYERS);
        const oneLayer = this.klCanvasLayerArr.length === 1;
        this.addBtn.disabled = maxReached;
        this.removeBtn.disabled = oneLayer;
        this.duplicateBtn.disabled = maxReached;
        this.mergeBtn.disabled = this.selectedSpotIndex === 0;
        this.moreDropdown.setEnabled('merge-all', !oneLayer);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.lastpos = 0;
        this.layerHeight = 35;
        this.layerSpacing = 0;
        this.klCanvas = p.klCanvas;
        this.onSelect = p.onSelect;
        this.parentEl = p.parentEl;
        this.uiState = p.uiState;
        this.applyUncommitted = p.applyUncommitted;
        this.klHistory = p.klHistory;
        this.onUpdateProject = p.onUpdateProject;
        this.onClearLayer = p.onClearLayer;
        this.layerElArr = [];
        this.layerHeight = 35;
        this.layerSpacing = 0;
        const width = 270;
        this.largeThumbDiv = (0, _bb.BB).el({
            onClick: (0, _bb.BB).handleClick,
            css: {
                position: 'absolute',
                top: '500px',
                boxShadow: '1px 1px 3px rgba(0,0,0,0.3)',
                pointerEvents: 'none',
                padding: '0',
                border: '1px solid #aaa',
                transition: 'opacity 0.3s ease-out',
                userSelect: 'none',
                background: 'var(--kl-checkerboard-background)'
            }
        });
        this.setUiState(this.uiState);
        this.largeThumbCanvas = (0, _bb.BB).canvas(200, 200);
        this.largeThumbCanvas.style.display = 'block';
        this.largeThumbDiv.append(this.largeThumbCanvas);
        this.largeThumbInDocument = false;
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        this.selectedSpotIndex = this.klCanvasLayerArr.length - 1;
        this.rootEl = (0, _bb.BB).el({
            css: {
                marginRight: '10px',
                marginBottom: '10px',
                marginLeft: '10px',
                marginTop: '10px',
                cursor: 'default',
                position: 'relative',
                zIndex: '0'
            }
        });
        const listDiv = (0, _bb.BB).el({
            css: {
                width: width + 'px',
                position: 'relative',
                margin: '0 -10px',
                zIndex: '0'
            }
        });
        this.layerListEl = (0, _bb.BB).el({
            parent: listDiv
        });
        this.addBtn = (0, _bb.BB).el({
            tagName: 'button'
        });
        this.duplicateBtn = (0, _bb.BB).el({
            tagName: 'button'
        });
        this.mergeBtn = (0, _bb.BB).el({
            tagName: 'button'
        });
        this.removeBtn = (0, _bb.BB).el({
            tagName: 'button'
        });
        const renameBtn = (0, _bb.BB).el({
            tagName: 'button'
        });
        this.moreDropdown = new (0, _dropdownMenu.DropdownMenu)({
            button: (0, _bb.BB).el({
                content: `<img src="${(0, _caretDownSvgDefault.default)}" width="13"/>`,
                css: {
                    display: 'flex',
                    justifyContent: 'center',
                    opacity: '0.9'
                }
            }),
            buttonTitle: (0, _language.LANG)('more'),
            items: [
                [
                    'clear-layer',
                    (0, _language.LANG)('layers-clear')
                ],
                [
                    'merge-all',
                    (0, _language.LANG)('layers-merge-all')
                ]
            ],
            onItemClick: (id)=>{
                if (id === 'clear-layer') {
                    this.applyUncommitted();
                    this.onClearLayer();
                }
                if (id === 'merge-all') {
                    this.applyUncommitted();
                    const newIndex = this.klCanvas.mergeAll();
                    if (newIndex === false) return;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    this.selectedSpotIndex = newIndex;
                    //this.createLayerList();
                    this.klHistory.pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    this.klHistory.pause(false);
                    this.updateButtons();
                }
            }
        });
        this.updateButtons();
        const createButtons = ()=>{
            const div = (0, _bb.BB).el();
            const async = ()=>{
                (0, _ui.makeUnfocusable)(this.addBtn);
                (0, _ui.makeUnfocusable)(this.duplicateBtn);
                (0, _ui.makeUnfocusable)(this.mergeBtn);
                (0, _ui.makeUnfocusable)(this.removeBtn);
                (0, _ui.makeUnfocusable)(renameBtn);
                const commonStyle = {
                    cssFloat: 'left',
                    paddingLeft: '5px',
                    paddingRight: '3px'
                };
                (0, _base.css)(this.addBtn, commonStyle);
                (0, _base.css)(this.duplicateBtn, commonStyle);
                (0, _base.css)(this.mergeBtn, commonStyle);
                (0, _base.css)(this.removeBtn, commonStyle);
                (0, _base.css)(renameBtn, {
                    cssFloat: 'left',
                    height: '30px',
                    lineHeight: '20px'
                });
                this.addBtn.title = (0, _language.LANG)('layers-new');
                this.duplicateBtn.title = (0, _language.LANG)('layers-duplicate');
                this.removeBtn.title = (0, _language.LANG)('layers-remove');
                this.mergeBtn.title = (0, _language.LANG)('layers-merge');
                renameBtn.title = (0, _language.LANG)('layers-rename-title');
                this.addBtn.innerHTML = "<img src='" + (0, _addLayerSvgDefault.default) + "' height='20'/>";
                this.duplicateBtn.innerHTML = "<img src='" + (0, _duplicateLayerSvgDefault.default) + "' height='20'/>";
                this.mergeBtn.innerHTML = "<img src='" + (0, _mergeLayersSvgDefault.default) + "' height='20'/>";
                this.removeBtn.innerHTML = "<img src='" + (0, _removeLayerSvgDefault.default) + "' height='20'/>";
                renameBtn.innerHTML = "<img src='" + (0, _renameLayerSvgDefault.default) + "' height='20'/>";
                div.append((0, _c.c)(',flex,gap-5,mb-10', [
                    this.addBtn,
                    this.removeBtn,
                    this.duplicateBtn,
                    this.mergeBtn,
                    renameBtn,
                    (0, _c.c)(',grow-1'),
                    this.moreDropdown.getElement()
                ]));
                this.addBtn.onclick = ()=>{
                    this.applyUncommitted();
                    if (this.klCanvas.addLayer(this.selectedSpotIndex) === false) return;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    this.selectedSpotIndex = this.selectedSpotIndex + 1;
                    //this.createLayerList();
                    this.klHistory.pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    this.klHistory.pause(false);
                    this.updateButtons();
                };
                this.duplicateBtn.onclick = ()=>{
                    this.applyUncommitted();
                    if (this.klCanvas.duplicateLayer(this.selectedSpotIndex) === false) return;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    this.selectedSpotIndex++;
                    //this.createLayerList();
                    this.klHistory.pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    this.klHistory.pause(false);
                    this.updateButtons();
                };
                this.removeBtn.onclick = ()=>{
                    this.applyUncommitted();
                    if (this.layerElArr.length <= 1) return;
                    this.klCanvas.removeLayer(this.selectedSpotIndex);
                    if (this.selectedSpotIndex > 0) this.selectedSpotIndex--;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    //this.createLayerList();
                    this.klHistory.pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    this.klHistory.pause(false);
                    this.updateButtons();
                };
                this.mergeBtn.onclick = ()=>{
                    this.applyUncommitted();
                    if (this.selectedSpotIndex <= 0) return;
                    (0, _mergeLayerDialog.mergeLayerDialog)(this.parentEl, {
                        topCanvas: this.klCanvasLayerArr[this.selectedSpotIndex].context.canvas,
                        bottomCanvas: this.klCanvasLayerArr[this.selectedSpotIndex - 1].context.canvas,
                        topOpacity: this.klCanvas.getLayerOld(this.selectedSpotIndex).opacity,
                        mixModeStr: this.klCanvasLayerArr[this.selectedSpotIndex].mixModeStr,
                        callback: (mode)=>{
                            this.klCanvas.mergeLayers(this.selectedSpotIndex, this.selectedSpotIndex - 1, mode);
                            this.klCanvasLayerArr = this.klCanvas.getLayers();
                            this.selectedSpotIndex--;
                            //this.createLayerList();
                            this.klHistory.pause(true);
                            this.onSelect(this.selectedSpotIndex);
                            this.klHistory.pause(false);
                            this.updateButtons();
                        }
                    });
                };
                renameBtn.onclick = ()=>{
                    this.applyUncommitted();
                    this.renameLayer(this.selectedSpotIndex);
                };
            };
            setTimeout(async, 1);
            return div;
        };
        this.rootEl.append(createButtons());
        let modeWrapper;
        modeWrapper = (0, _bb.BB).el({
            content: (0, _language.LANG)('layers-blending') + '&nbsp;',
            css: {
                fontSize: '15px'
            }
        });
        this.modeSelect = new (0, _select.Select)({
            optionArr: [
                'source-over',
                undefined,
                'darken',
                'multiply',
                'color-burn',
                undefined,
                'lighten',
                'screen',
                'color-dodge',
                undefined,
                'overlay',
                'soft-light',
                'hard-light',
                undefined,
                'difference',
                'exclusion',
                undefined,
                'hue',
                'saturation',
                'color',
                'luminosity'
            ].map((item)=>{
                return item ? [
                    item,
                    (0, _translateBlending.translateBlending)(item)
                ] : undefined;
            }),
            onChange: (val)=>{
                this.klCanvas.setMixMode(this.selectedSpotIndex, val);
                this.update(this.selectedSpotIndex);
            },
            css: {
                marginBottom: '10px'
            },
            name: 'layer-blend-mode'
        });
        modeWrapper.append(this.modeSelect.getElement());
        this.rootEl.append(modeWrapper);
        this.rootEl.append(listDiv);
        this.klHistory.addListener(()=>{
            if (this.rootEl.style.display !== 'block') return;
            this.createLayerList();
        });
        this.createLayerList();
    }
    // ---- interface ----
    update(activeLayerSpotIndex) {
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        if (activeLayerSpotIndex || activeLayerSpotIndex === 0) this.selectedSpotIndex = activeLayerSpotIndex;
        this.updateButtons();
        setTimeout(()=>this.createLayerList(), 1);
    }
    getSelected() {
        return this.selectedSpotIndex;
    }
    activateLayer(spotIndex) {
        if (spotIndex < 0 || spotIndex > this.layerElArr.length - 1) throw 'invalid spotIndex ' + spotIndex + ', layerElArr.length ' + this.layerElArr.length;
        this.selectedSpotIndex = spotIndex;
        this.modeSelect.setValue(this.klCanvasLayerArr[this.selectedSpotIndex].mixModeStr);
        for(let i = 0; i < this.layerElArr.length; i++){
            const layer = this.layerElArr[i];
            const isSelected = this.selectedSpotIndex === layer.spot;
            (0, _base.css)(layer, {
                boxShadow: ''
            });
            layer.classList.toggle('kl-layer--selected', isSelected);
            layer.opacitySlider.setActive(isSelected);
            layer.isSelected = isSelected;
        }
        this.mergeBtn.disabled = this.selectedSpotIndex === 0;
    }
    setUiState(stateStr) {
        this.uiState = stateStr;
        if (this.uiState === 'left') (0, _base.css)(this.largeThumbDiv, {
            left: '280px',
            right: ''
        });
        else (0, _base.css)(this.largeThumbDiv, {
            left: '',
            right: '280px'
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../../bb/bb":"3zOvT","../../components/select":"iuUFh","../../components/point-slider":"1mvjC","../../../canvas/kl-canvas":"aumh6","../../../../language/language":"mcywn","../../../canvas/translate-blending":"l3XnR","./rename-layer-dialog":"5uRlk","./merge-layer-dialog":"7TGmW","../../../../bb/base/base":"it3mQ","../../../../bb/base/browser":"4hCPW","../../../../bb/base/c":"3KmDH","../../components/dropdown-menu":"c4Lqy","url:/src/app/img/ui/add-layer.svg":"j8xyr","url:/src/app/img/ui/duplicate-layer.svg":"a5dmW","url:/src/app/img/ui/merge-layers.svg":"dc01L","url:/src/app/img/ui/remove-layer.svg":"fV9n3","url:/src/app/img/ui/rename-layer.svg":"4D5To","url:/src/app/img/ui/caret-down.svg":"caVqF","../../../../bb/base/ui":"5dJJW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aumh6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_LAYERS", ()=>MAX_LAYERS);
/**
 * The image/canvas that the user paints on
 * Has layers. layers have names and opacity.
 *
 * Interacts with klHistory
 */ parcelHelpers.export(exports, "KlCanvas", ()=>KlCanvas);
var _bb = require("../../bb/bb");
var _floodFill = require("../image-operations/flood-fill");
var _shapeTool = require("../image-operations/shape-tool");
var _renderText = require("../image-operations/render-text");
var _klTypes = require("../kl-types");
var _drawProject = require("./draw-project");
var _language = require("../../language/language");
var _gradientTool = require("../image-operations/gradient-tool");
var _transformationMatrix = require("transformation-matrix");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _transformMultiPolygon = require("../../bb/multi-polygon/transform-multi-polygon");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
var _math = require("../../bb/math/math");
var _matrixToTuple = require("../../bb/math/matrix-to-tuple");
var _eraseColor = require("../brushes/erase-color");
var _klHistory = require("../history/kl-history");
var _getNextLayerId = require("../history/get-next-layer-id");
var _createFillColorTiles = require("../history/create-fill-color-tiles");
var _updateLayersViaComposed = require("./update-layers-via-composed");
var _isHistoryEntryOpacityChange = require("../history/push-helpers/is-history-entry-opacity-change");
var _isHistoryEntryVisibilityChange = require("../history/push-helpers/is-history-entry-visibility-change");
var _transformBounds = require("../../bb/transform/transform-bounds");
var _getSelectionSampleBounds = require("./get-selection-sample-bounds");
var _createLayerMap = require("../history/push-helpers/create-layer-map");
var _eyedropper = require("./eyedropper");
var _imageDataTile = require("../history/image-data-tile");
var _base = require("../../bb/base/base");
var _getSelectionBounds = require("../select-tool/get-selection-bounds");
var _translateMultiPolygon = require("../../bb/multi-polygon/translate-multi-polygon");
var _getBinaryMask = require("../select-tool/get-binary-mask");
// TODO remove in 2026
// workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
// reported 2021-13 (v96), fixed 2022-02 (v99)
// affects: source-in, source-out, destination-in, destination-atop
function workaroundForChromium1281185(ctx) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.01)';
    ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
    ctx.restore();
}
const allowedMixModes = [
    'source-over',
    'darken',
    'multiply',
    'color-burn',
    'lighten',
    'screen',
    'color-dodge',
    'overlay',
    'soft-light',
    'hard-light',
    'difference',
    'exclusion',
    'hue',
    'saturation',
    'color',
    'luminosity'
];
const MAX_LAYERS = 16;
const KL_CANVAS_DEBUGGING = false;
class KlCanvas {
    updateIndices() {
        this.layers.forEach((item, index)=>{
            item.index = index;
        });
    }
    getSelectionOrFallback() {
        return this.selection ?? [
            [
                [
                    [
                        0,
                        0
                    ],
                    [
                        this.width,
                        0
                    ],
                    [
                        this.width,
                        this.height
                    ],
                    [
                        0,
                        this.height
                    ],
                    [
                        0,
                        0
                    ]
                ]
            ]
        ];
    }
    /**
     * Create selection sample from the current selection. If none, will create of entire layer.
     */ createSelectionSample(layerIndex) {
        const sampleBounds = this.getSelectionArea(layerIndex);
        // empty
        if (!sampleBounds) {
            this.selectionSample = {
                image: undefined,
                transformation: (0, _transformationMatrix.identity)()
            };
            return;
        }
        const srcLayer = this.layers[layerIndex];
        const sampleCanvas = (0, _bb.BB).canvas(sampleBounds.width, sampleBounds.height);
        const sampleCtx = (0, _bb.BB).ctx(sampleCanvas);
        sampleCtx.save();
        sampleCtx.translate(-sampleBounds.x, -sampleBounds.y);
        sampleCtx.drawImage(srcLayer.canvas, 0, 0);
        sampleCtx.restore();
        this.selectionSample = {
            image: sampleCanvas,
            transformation: (0, _transformationMatrix.translate)(sampleBounds.x, sampleBounds.y)
        };
    }
    /**
     * transforms selection and selectionSample
     */ transformSelectionAndSample(transformation) {
        if (!this.selectionSample) throw new Error('no selection sample');
        if (this.selection) this.selection = (0, _transformMultiPolygon.transformMultiPolygon)(this.selection, transformation);
        this.selectionSample.transformation = (0, _transformationMatrix.compose)([
            transformation,
            this.selectionSample.transformation
        ]);
    }
    drawSelectionSample(layerIndex, isPixelated) {
        if (!this.selectionSample) throw new Error('no selection sample');
        if (!this.selectionSample.image) // selection sample, but it's empty. noop
        return;
        const targetLayer = this.layers[layerIndex];
        const targetCtx = (0, _bb.BB).ctx(targetLayer.canvas);
        const selection = this.getSelectionOrFallback();
        const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(selection);
        targetCtx.save();
        targetCtx.clip(selectionPath);
        targetCtx.setTransform(...(0, _matrixToTuple.matrixToTuple)(this.selectionSample.transformation));
        if (isPixelated) targetCtx.imageSmoothingEnabled = false;
        targetCtx.drawImage(this.selectionSample.image, 0, 0);
        targetCtx.restore();
    }
    // ----------------------------------- public -----------------------------------
    constructor(history, layerNrOffset = 0){
        this.layerNrOffset = layerNrOffset;
        this.isDestroyed = false;
        this.selection = undefined;
        this.selectionSample = undefined;
        this.klHistory = history;
        this.layers = [];
        if (KL_CANVAS_DEBUGGING) window.getCanvasLayers = ()=>this.layers;
        this.eyedropper = new (0, _eyedropper.Eyedropper)();
        this.width = 0;
        this.height = 0;
        this.updateViaComposed({
            projectId: {
                value: (0, _base.randomUuid)()
            },
            size: {
                width: 0,
                height: 0
            },
            activeLayerId: '',
            selection: {
                value: []
            },
            layerMap: {}
        }, this.klHistory.getComposed());
    }
    /*
     * Resets canvas -> 1 layer, 100% opacity,
     * unless layers provided.
     * @param p
     */ reset(p) {
        if (!p.width || !p.height || p.width < 1 || p.height < 1 || isNaN(p.width) || isNaN(p.height)) throw new Error('invalid canvas size');
        this.klHistory.pause(true);
        this.width = p.width;
        this.height = p.height;
        this.selection = undefined;
        this.clearSelectionSample();
        this.layers.splice(1, Math.max(0, this.layers.length - 1));
        if (p.layers) for(let i = 0; i < p.layers.length; i++){
            const pItem = p.layers[i];
            if (!this.layers[i]) this.addLayer();
            const layer = this.layers[i];
            layer.id = pItem.id;
            layer.name = pItem.name;
            layer.isVisible = pItem.isVisible;
            layer.mixModeStr = pItem.mixModeStr ? pItem.mixModeStr : 'source-over';
            layer.canvas.width = this.width;
            layer.canvas.height = this.height;
            layer.context.drawImage(pItem.image, 0, 0);
            this.setOpacity(i, pItem.opacity);
        }
        else {
            const layer = this.layers[0];
            layer.name = p.layerName ? p.layerName : (0, _language.LANG)('layers-layer') + ' 1';
            layer.isVisible = true;
            layer.canvas.width = this.width;
            layer.canvas.height = this.height;
            layer.mixModeStr = 'source-over';
            this.setOpacity(0, 1);
            if (p.color) this.layerFill(0, p.color);
            else if (p.image) layer.context.drawImage(p.image, 0, 0);
        }
        this.updateIndices();
        this.klHistory.pause(false);
        if (!this.klHistory.isPaused()) {
            const historyEntryData = {
                projectId: {
                    value: p.projectId ?? (0, _base.randomUuid)()
                },
                size: {
                    width: this.width,
                    height: this.height
                },
                selection: {
                    value: this.selection
                },
                activeLayerId: this.layers[this.layers.length - 1].id,
                layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                    attributes: 'all'
                })
            };
            this.klHistory.push(historyEntryData);
        }
        return this.layers.length - 1;
    }
    isLayerLimitReached() {
        return this.layers.length >= MAX_LAYERS;
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    /**
     * without resizing
     */ setSize(width, height) {
        this.width = width;
        this.height = height;
    }
    getLayerCount() {
        return this.layers.length;
    }
    resize(w, h, algorithm = 'smooth') {
        if (!w || !h || w === this.width && h === this.height || isNaN(w) || isNaN(h) || w < 1 || h < 1) return false;
        w = Math.max(w, 1);
        h = Math.max(h, 1);
        let tmp1, tmp2;
        if (algorithm === 'pixelated') {
            tmp1 = (0, _bb.BB).canvas(w, h);
            const tmp1Ctx = (0, _bb.BB).ctx(tmp1);
            tmp1Ctx.imageSmoothingEnabled = false;
            for(let i = 0; i < this.layers.length; i++){
                if (i > 0) tmp1Ctx.clearRect(0, 0, w, h);
                const layer = this.layers[i];
                tmp1Ctx.drawImage(layer.canvas, 0, 0, w, h);
                layer.canvas.width = w;
                layer.canvas.height = h;
                layer.context.drawImage(tmp1, 0, 0);
            }
        } else if (algorithm === 'smooth') {
            tmp1 = (0, _bb.BB).canvas();
            tmp2 = (0, _bb.BB).canvas();
            for(let i = 0; i < this.layers.length; i++)(0, _bb.BB).resizeCanvas(this.layers[i].canvas, w, h, tmp1, tmp2);
        } else throw new Error('unknown resize algorithm');
        if (this.selection) this.selection = (0, _transformMultiPolygon.transformMultiPolygon)(this.selection, (0, _transformationMatrix.scale)(w / this.width, h / this.height));
        this.width = w;
        this.height = h;
        this.klHistory.push({
            size: {
                width: this.width,
                height: this.height
            },
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'tiles'
                ]
            }),
            ...this.selection ? {
                selection: {
                    value: this.selection
                }
            } : {}
        });
        return true;
    }
    /**
     * crop / extend
     */ resizeCanvas(p) {
        const newW = Math.round(p.left) + this.width + Math.round(p.right);
        const newH = Math.round(p.top) + this.height + Math.round(p.bottom);
        const offX = Math.round(p.left);
        const offY = Math.round(p.top);
        if (isNaN(newW) || isNaN(newH) || newW < 1 || newH < 1) throw new Error('KlCanvas.resizeCanvas - invalid canvas size');
        for(let i = 0; i < this.layers.length; i++){
            const ctemp = (0, _bb.BB).canvas(this.width, this.height);
            const layer = this.layers[i];
            (0, _bb.BB).ctx(ctemp).drawImage(layer.canvas, 0, 0);
            layer.canvas.width = newW;
            layer.canvas.height = newH;
            layer.context.save();
            if (i === 0 && p.fillColor) {
                layer.context.fillStyle = (0, _bb.BB).ColorConverter.toRgbStr(p.fillColor);
                layer.context.fillRect(0, 0, newW, newH);
                layer.context.clearRect(offX, offY, this.width, this.height);
            }
            layer.context.drawImage(ctemp, offX, offY);
            layer.context.restore();
        }
        this.width = newW;
        this.height = newH;
        if (this.selection) this.selection = (0, _translateMultiPolygon.translateMultiPolygon)(this.selection, offX, offY);
        this.klHistory.push({
            size: {
                width: this.width,
                height: this.height
            },
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'tiles'
                ]
            }),
            ...this.selection ? {
                selection: {
                    value: this.selection
                }
            } : {}
        });
    }
    /**
     * will be inserted above of selected
     */ addLayer(selectedIndex, data) {
        if (this.isLayerLimitReached()) return false;
        const index = selectedIndex === undefined ? this.layers.length : selectedIndex + 1;
        const canvas = (0, _bb.BB).canvas(this.width, this.height);
        const context = (0, _bb.BB).ctx(canvas);
        if (data) {
            if (typeof data.image === 'function') data.image(context);
            else context.drawImage(data.image, 0, 0);
        }
        const layerId = (0, _getNextLayerId.getNextLayerId)();
        const layer = {
            id: layerId,
            index,
            name: data && data.name !== undefined ? data.name : (0, _language.LANG)('layers-layer') + ' ' + (this.layers.length + this.layerNrOffset),
            mixModeStr: data ? data.mixModeStr ?? 'source-over' : 'source-over',
            isVisible: data ? data.isVisible : true,
            opacity: data ? data.opacity : 1,
            canvas,
            context
        };
        this.layers.splice(index, 0, layer);
        this.klHistory.pause(true);
        this.setOpacity(index, 1);
        this.klHistory.pause(false);
        this.updateIndices();
        if (!this.klHistory.isPaused()) this.klHistory.push({
            activeLayerId: layerId,
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'index'
                ]
            }, {
                layerId,
                attributes: 'all',
                tiles: data ? undefined : (0, _createFillColorTiles.createFillColorTiles)(this.width, this.height, 'transparent')
            })
        });
        return index;
    }
    duplicateLayer(srcIndex) {
        if (!this.layers[srcIndex] || this.isLayerLimitReached()) return false;
        const srcLayer = this.layers[srcIndex];
        const newIndex = srcIndex + 1;
        const composed = this.klHistory.getComposed();
        const srcComposed = composed.layerMap[srcLayer.id];
        const canvas = (0, _bb.BB).canvas(this.width, this.height);
        const ctx = (0, _bb.BB).ctx(canvas);
        const layerId = (0, _getNextLayerId.getNextLayerId)();
        const newLayer = {
            id: layerId,
            index: newIndex,
            name: srcLayer.name + ' ' + (0, _language.LANG)('layers-copy'),
            mixModeStr: srcLayer.mixModeStr,
            isVisible: srcLayer.isVisible,
            opacity: srcLayer.opacity,
            canvas,
            context: ctx
        };
        this.layers.splice(newIndex, 0, newLayer);
        {
            // draw into new layer from old
            const tilesPerX = Math.ceil(this.width / (0, _klHistory.HISTORY_TILE_SIZE));
            srcComposed.tiles.forEach((tile, index)=>{
                const x = index % tilesPerX;
                const y = Math.floor(index / tilesPerX);
                ctx.save();
                if ((0, _klTypes.isLayerFill)(tile)) {
                    ctx.fillStyle = tile.fill;
                    ctx.fillRect(x * (0, _klHistory.HISTORY_TILE_SIZE), y * (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
                } else ctx.putImageData(tile.data, x * (0, _klHistory.HISTORY_TILE_SIZE), y * (0, _klHistory.HISTORY_TILE_SIZE));
                ctx.restore();
            });
        }
        this.updateIndices();
        if (!this.klHistory.isPaused()) this.klHistory.push({
            activeLayerId: layerId,
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'index'
                ]
            }, {
                layerId,
                attributes: 'all',
                tiles: srcComposed.tiles.map((tile)=>{
                    if ((0, _klTypes.isLayerFill)(tile)) return {
                        ...tile
                    };
                    return (0, _imageDataTile.copyImageDataTile)(tile);
                })
            })
        });
        return srcIndex + 1;
    }
    getLayerContext(index, doReturnNull) {
        if (this.layers[index]) return this.layers[index].context;
        if (doReturnNull) return null;
        throw new Error('layer of index ' + index + ' not found (in ' + this.layers.length + ' layers)');
    }
    removeLayer(index) {
        const toDeleteLayer = this.layers[index];
        if (!toDeleteLayer) return false;
        (0, _bb.BB).freeCanvas(toDeleteLayer.canvas);
        this.layers.splice(index, 1);
        this.updateIndices();
        const activeLayerIndex = Math.max(0, index - 1);
        const activeLayerId = this.layers[activeLayerIndex].id;
        if (!this.klHistory.isPaused()) this.klHistory.push({
            activeLayerId,
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'index'
                ]
            })
        });
        return activeLayerIndex;
    }
    renameLayer(index, name) {
        const targetLayer = this.layers[index];
        if (targetLayer) targetLayer.name = name;
        else return false;
        if (!this.klHistory.isPaused()) this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'name'
                ]
            })
        });
        return true;
    }
    setOpacity(layerIndex, opacity) {
        if (!this.layers[layerIndex]) return;
        opacity = Math.max(0, Math.min(1, opacity));
        this.layers[layerIndex].opacity = opacity;
        if (!this.klHistory.isPaused()) {
            const layerId = this.layers[layerIndex].id;
            const topEntry = this.klHistory.getEntries().at(-1).data;
            const replaceTop = (0, _isHistoryEntryOpacityChange.isHistoryEntryOpacityChange)(topEntry, layerId);
            this.klHistory.push({
                layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                    layerId,
                    attributes: [
                        'opacity'
                    ]
                })
            }, replaceTop);
        }
    }
    setLayerIsVisible(layerIndex, isVisible) {
        if (this.layers[layerIndex]) this.layers[layerIndex].isVisible = isVisible;
        else throw new Error(`layer ${layerIndex} undefined`);
        if (!this.klHistory.isPaused()) {
            const layerId = this.layers[layerIndex].id;
            const topEntry = this.klHistory.getEntries().at(-1).data;
            const replaceTop = (0, _isHistoryEntryVisibilityChange.isHistoryEntryVisibilityChange)(topEntry, layerId);
            this.klHistory.push({
                layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                    layerId,
                    attributes: [
                        'isVisible'
                    ]
                })
            }, replaceTop);
        }
    }
    moveLayer(index, delta) {
        if (delta === 0) return;
        if (!this.layers[index]) return;
        const temp = this.layers[index];
        this.layers.splice(index, 1);
        const targetIndex = Math.max(0, Math.min(index + delta, this.layers.length));
        this.layers.splice(targetIndex, 0, temp);
        this.updateIndices();
        if (!this.klHistory.isPaused()) this.klHistory.push({
            activeLayerId: this.layers[targetIndex].id,
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'index'
                ]
            })
        });
        return targetIndex;
    }
    mergeLayers(layerBottomIndex, layerTopIndex, mixModeStr) {
        if (!this.layers[layerBottomIndex] || !this.layers[layerTopIndex] || layerBottomIndex === layerTopIndex) return;
        //order messed up
        if (layerBottomIndex > layerTopIndex) {
            const temp = layerBottomIndex;
            layerBottomIndex = layerTopIndex;
            layerTopIndex = temp;
        }
        const topLayer = this.layers[layerTopIndex];
        const bottomLayer = this.layers[layerBottomIndex];
        const topOpacity = this.layers[layerTopIndex].opacity;
        const mergedPixelData = topLayer.opacity > 0;
        if (mergedPixelData) {
            const bottomCtx = bottomLayer.context;
            bottomCtx.save();
            if (mixModeStr === 'as-alpha') {
                // todo remove this?
                (0, _bb.BB).convertToAlphaChannelCanvas(topLayer.canvas);
                bottomCtx.globalCompositeOperation = 'destination-in';
                bottomCtx.globalAlpha = topOpacity;
                bottomCtx.drawImage(topLayer.canvas, 0, 0);
            } else {
                if (mixModeStr) bottomCtx.globalCompositeOperation = mixModeStr;
                bottomCtx.globalAlpha = topOpacity;
                bottomCtx.drawImage(topLayer.canvas, 0, 0);
            }
            bottomCtx.restore();
            mixModeStr && workaroundForChromium1281185(bottomCtx);
        }
        this.klHistory.pause(true);
        this.removeLayer(layerTopIndex);
        this.klHistory.pause(false);
        if (!this.klHistory.isPaused()) this.klHistory.push({
            activeLayerId: bottomLayer.id,
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'index'
                ]
            }, mergedPixelData ? {
                layerId: bottomLayer.id,
                attributes: 'all'
            } : undefined)
        });
        return layerBottomIndex;
    }
    mergeAll() {
        if (this.layers.length === 1) return false;
        // draw all on bottom layer
        const bottomLayer = this.layers[0];
        bottomLayer.name = (0, _language.LANG)('layers-layer') + ' 1';
        const bottomCtx = bottomLayer.context;
        for(let i = 1; i < this.layers.length; i++){
            const layer = this.layers[i];
            if (!layer.isVisible || layer.opacity === 0) continue;
            bottomCtx.save();
            bottomCtx.globalCompositeOperation = layer.mixModeStr;
            bottomCtx.globalAlpha = layer.opacity;
            bottomCtx.drawImage(layer.canvas, 0, 0);
            bottomCtx.restore();
        }
        this.klHistory.pause(true);
        // remove upper layers
        for(let i = this.layers.length - 1; i > 0; i--)this.removeLayer(i);
        this.klHistory.pause(false);
        if (!this.klHistory.isPaused()) {
            const activeLayerId = bottomLayer.id;
            this.klHistory.push({
                activeLayerId,
                layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                    attributes: [
                        'tiles'
                    ]
                })
            });
        }
        return 0;
    }
    // rotates the canvas with all layers. either by 90, 180, or 270 degrees
    rotate(deg) {
        while(deg < 0)deg += 360;
        deg %= 360;
        if (deg !== 90 && deg !== 180 && deg !== 270) return;
        const temp = (0, _bb.BB).canvas();
        if (deg === 180) {
            temp.width = this.width;
            temp.height = this.height;
        } else if (deg === 90 || deg === 270) {
            temp.width = this.height;
            temp.height = this.width;
        }
        let matrix = (0, _transformationMatrix.identity)();
        if (deg === 90) matrix = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(this.height, 0), (0, _transformationMatrix.rotate)(Math.PI / 2));
        else if (deg === 180) matrix = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(this.width, this.height), (0, _transformationMatrix.rotate)(Math.PI));
        else if (deg === 270) matrix = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(0, this.width), (0, _transformationMatrix.rotate)(3 * Math.PI / 2));
        const ctx = (0, _bb.BB).ctx(temp);
        for(let i = 0; i < this.layers.length; i++){
            ctx.clearRect(0, 0, temp.width, temp.height);
            ctx.save();
            ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(matrix));
            ctx.drawImage(this.layers[i].canvas, 0, 0);
            ctx.restore();
            this.layers[i].canvas.width = temp.width;
            this.layers[i].canvas.height = temp.height;
            this.layers[i].context.drawImage(temp, 0, 0);
        }
        this.width = temp.width;
        this.height = temp.height;
        if (this.selection) this.selection = (0, _transformMultiPolygon.transformMultiPolygon)(this.selection, matrix);
        this.klHistory.push({
            size: {
                width: this.width,
                height: this.height
            },
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                attributes: [
                    'tiles'
                ]
            }),
            ...this.selection ? {
                selection: {
                    value: this.selection
                }
            } : {}
        });
    }
    flip(isHorizontal, isVertical, layerIndex) {
        if (!isHorizontal && !isVertical) return;
        const temp = (0, _bb.BB).canvas(this.width, this.height);
        temp.width = this.width;
        temp.height = this.height;
        const tempCtx = (0, _bb.BB).ctx(temp);
        const matrix = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(temp.width / 2, temp.height / 2), (0, _transformationMatrix.scale)(isHorizontal ? -1 : 1, isVertical ? -1 : 1), (0, _transformationMatrix.translate)(-temp.width / 2, -temp.height / 2));
        for(let i = 0; i < this.layers.length; i++){
            if ((layerIndex || layerIndex === 0) && i !== layerIndex) continue;
            tempCtx.save();
            tempCtx.clearRect(0, 0, temp.width, temp.height);
            tempCtx.setTransform(...(0, _matrixToTuple.matrixToTuple)(matrix));
            tempCtx.drawImage(this.layers[i].canvas, 0, 0);
            tempCtx.restore();
            this.layers[i].context.clearRect(0, 0, this.layers[i].canvas.width, this.layers[i].canvas.height);
            this.layers[i].context.drawImage(temp, 0, 0);
        }
        if (this.selection) this.selection = (0, _transformMultiPolygon.transformMultiPolygon)(this.selection, matrix);
        const targetLayer = layerIndex === undefined ? undefined : this.layers[layerIndex];
        this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, targetLayer ? {
                layerId: targetLayer.id,
                attributes: [
                    'tiles'
                ]
            } : {
                attributes: [
                    'tiles'
                ]
            }),
            ...this.selection ? {
                selection: {
                    value: this.selection
                }
            } : {}
        });
    }
    // arbitrary drawing operation & focus layer
    drawOperation(layerIndex, operation) {
        const targetLayer = this.layers[layerIndex];
        const ctx = targetLayer.context;
        operation(ctx);
        if (!this.klHistory.isPaused()) this.klHistory.push({
            activeLayerId: targetLayer.id,
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'tiles'
                ]
            })
        });
    }
    layerFill(layerIndex, colorObj, compositeOperation, doClipSelection) {
        const ctx = this.layers[layerIndex].context;
        ctx.save();
        const isUniformFill = !(doClipSelection && this.selection) && compositeOperation === undefined;
        if (compositeOperation) ctx.globalCompositeOperation = compositeOperation;
        let bounds;
        if (doClipSelection && this.selection) {
            const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(this.selection);
            ctx.clip(selectionPath);
            bounds = (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection));
        }
        const fill = 'rgba(' + colorObj.r + ',' + colorObj.g + ',' + colorObj.b + ',1)';
        ctx.fillStyle = fill;
        ctx.fillRect(0, 0, this.layers[layerIndex].canvas.width, this.layers[layerIndex].canvas.height);
        ctx.restore();
        // workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
        // TODO remove if chrome updated
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.01)';
        ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
        ctx.restore();
        /*if (!document.getElementById('testocanvas')) {
            layerCanvasArr[layerIndex].id = 'testocanvas';
            document.body.append(layerCanvasArr[layerIndex]);
            BB.css(layerCanvasArr[layerIndex], {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }
        if (!document.getElementById('testocanvas')) {
            let c = document.createElement('canvas');
            c.width = 1000;
            c.height = 1000;
            let ctx2 = c.getContext('2d');
            ctx2.drawImage(layerCanvasArr[layerIndex], 0, 0);
            c.id = 'testocanvas';
            document.body.append(c);
            BB.css(c, {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }*/ if (!this.klHistory.isPaused()) {
            const targetLayer = this.layers[layerIndex];
            this.klHistory.push({
                layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                    layerId: targetLayer.id,
                    attributes: [
                        'tiles'
                    ],
                    tiles: isUniformFill ? (0, _createFillColorTiles.createFillColorTiles)(this.width, this.height, fill) : undefined,
                    bounds
                })
            });
        }
    }
    floodFill(layerIndex, x, y, rgb, opacity, tolerance, sampleStr, grow, isContiguous) {
        if (x < 0 || y < 0 || x >= this.width || y >= this.height || opacity === 0) return;
        tolerance = Math.round(tolerance);
        x = Math.round(x);
        y = Math.round(y);
        if (![
            'above',
            'current',
            'all'
        ].includes(sampleStr)) throw new Error('invalid sampleStr');
        const selectionMask = this.selection ? (0, _getBinaryMask.getBinaryMask)(this.selection, this.width, this.height) : undefined;
        if (selectionMask && selectionMask[y * this.width + x] === 0) // don't fill if outside of selection
        return;
        const targetLayer = this.layers[layerIndex];
        let result;
        let targetCtx;
        let targetImageData;
        if (sampleStr === 'all') {
            const srcCanvas = this.layers.length === 1 ? this.layers[0].canvas : this.getCompleteCanvas(1);
            const srcCtx = (0, _bb.BB).ctx(srcCanvas);
            const srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            const srcData = srcImageData.data;
            result = (0, _floodFill.floodFillBits)(srcData, selectionMask, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            targetCtx = targetLayer.context;
            targetImageData = targetCtx.getImageData(0, 0, this.width, this.height);
        } else {
            const srcIndex = sampleStr === 'above' ? layerIndex + 1 : layerIndex;
            if (srcIndex >= this.layers.length) return;
            const srcCtx = this.layers[srcIndex].context;
            const srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            const srcData = srcImageData.data;
            result = (0, _floodFill.floodFillBits)(srcData, selectionMask, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            targetCtx = layerIndex === srcIndex ? srcCtx : targetLayer.context;
            targetImageData = layerIndex === srcIndex ? srcImageData : targetCtx.getImageData(0, 0, this.width, this.height);
        }
        const targetData = targetImageData.data;
        if (rgb) {
            if (opacity === 1) {
                for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) {
                    targetData[i * 4] = rgb.r;
                    targetData[i * 4 + 1] = rgb.g;
                    targetData[i * 4 + 2] = rgb.b;
                    targetData[i * 4 + 3] = 255;
                }
            } else {
                for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) {
                    targetData[i * 4] = (0, _bb.BB).mix(targetData[i * 4], rgb.r, opacity);
                    targetData[i * 4 + 1] = (0, _bb.BB).mix(targetData[i * 4 + 1], rgb.g, opacity);
                    targetData[i * 4 + 2] = (0, _bb.BB).mix(targetData[i * 4 + 2], rgb.b, opacity);
                    targetData[i * 4 + 3] = (0, _bb.BB).mix(targetData[i * 4 + 3], 255, opacity);
                }
            }
        } else // erase
        if (opacity === 1) {
            for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) targetData[i * 4 + 3] = 0;
        } else {
            for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) targetData[i * 4 + 3] = (0, _bb.BB).mix(targetData[i * 4 + 3], 0, opacity);
        }
        targetCtx.putImageData(targetImageData, 0, 0);
        // const ctx = this.layers[layerIndex].context;
        // ctx.save();
        // ctx.fillStyle = 'rgba(255,0,0,0.2)';
        // ctx.fillRect(
        //     result.bounds.x1,
        //     result.bounds.y1,
        //     result.bounds.x2 - result.bounds.x1,
        //     result.bounds.y2 - result.bounds.y1,
        // );
        // ctx.restore();
        if (!this.klHistory.isPaused()) this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'tiles'
                ],
                bounds: result.bounds
            })
        });
    }
    /**
     * draw geometric shape (circle, line, rect)
     * @param layerIndex
     * @param shapeObj
     */ drawShape(layerIndex, shapeObj) {
        if (shapeObj.x1 === shapeObj.x2 && shapeObj.y1 === shapeObj.y2) return;
        const targetLayer = this.layers[layerIndex];
        const selectionPath = this.selection ? new Path2D((0, _getSelectionPath2D.getSelectionPath2d)(this.selection)) : undefined;
        const bounds = (0, _math.integerBounds)((0, _shapeTool.drawShape)(targetLayer.context, shapeObj, selectionPath));
        // debug
        /*const ctx = this.layers[layerIndex].context;
        ctx.save();
        ctx.fillStyle = 'rgba(255,0,0,0.2)';
        ctx.fillRect(bounds.x1, bounds.y1, bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
        ctx.restore();*/ if (!this.klHistory.isPaused()) this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'tiles'
                ],
                bounds
            })
        });
    }
    drawGradient(layerIndex, gradientObj) {
        const targetLayer = this.layers[layerIndex];
        const selectionPath = this.selection ? new Path2D((0, _getSelectionPath2D.getSelectionPath2d)(this.selection)) : undefined;
        (0, _gradientTool.drawGradient)(targetLayer.context, gradientObj, selectionPath);
        if (!this.klHistory.isPaused()) this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'tiles'
                ]
            })
        });
    }
    text(layerIndex, p) {
        const targetLayer = this.layers[layerIndex];
        const rect = (0, _renderText.renderText)(targetLayer.canvas, (0, _bb.BB).copyObj(p), this.selection ? new Path2D((0, _getSelectionPath2D.getSelectionPath2d)(this.selection)) : undefined);
        // add 2, because rect not entirely accurate
        const padding = 2 + (p.stroke ? p.stroke.lineWidth / 2 : 0);
        let changedBounds = (0, _transformBounds.transformBounds)({
            x1: rect.x,
            y1: rect.y,
            x2: rect.x + rect.width,
            y2: rect.y + rect.height
        }, (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(p.x, p.y), (0, _transformationMatrix.rotate)(-p.angleRad)));
        changedBounds = (0, _math.integerBounds)({
            x1: changedBounds.x1 - padding,
            y1: changedBounds.y1 - padding,
            x2: changedBounds.x2 + padding,
            y2: changedBounds.y2 + padding
        });
        // const ctx = this.layers[layerIndex].context;
        // ctx.save();
        // ctx.fillStyle = 'rgba(255,0,0,0.2)';
        // ctx.fillRect(bounds.x1, bounds.y1, bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
        // ctx.restore();
        if (!this.klHistory.isPaused()) this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'tiles'
                ],
                bounds: changedBounds
            })
        });
    }
    eraseLayer(p) {
        const targetLayer = this.layers[p.layerIndex];
        const ctx = targetLayer.context;
        ctx.save();
        let bounds;
        if (p.useSelection && this.selection) {
            const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(this.selection);
            ctx.clip(selectionPath);
            bounds = (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection));
        }
        if (p.useAlphaLock) ctx.globalCompositeOperation = 'source-in';
        else ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = (0, _bb.BB).ColorConverter.toRgbStr((0, _eraseColor.getEraseColor)());
        ctx.fillRect(0, 0, this.width, this.height);
        ctx.restore();
        const isUniformFill = !p.useAlphaLock && !(p.useSelection && this.selection);
        if (!this.klHistory.isPaused()) this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'tiles'
                ],
                tiles: isUniformFill ? (0, _createFillColorTiles.createFillColorTiles)(this.width, this.height, 'transparent') : undefined,
                bounds
            })
        });
    }
    getLayers() {
        return this.layers.map((layer)=>{
            return {
                id: layer.id,
                canvas: layer.canvas,
                context: layer.context,
                isVisible: layer.isVisible,
                opacity: layer.opacity,
                name: layer.name,
                mixModeStr: layer.mixModeStr
            };
        });
    }
    getLayersFast() {
        return this.layers.map((item)=>{
            return {
                canvas: item.canvas,
                isVisible: item.isVisible,
                opacity: item.opacity,
                name: item.name,
                mixModeStr: item.mixModeStr,
                ...item.compositeObj ? {
                    compositeObj: item.compositeObj
                } : {}
            };
        });
    }
    getLayerIndex(canvasObj, doReturnNull) {
        for(let i = 0; i < this.layers.length; i++){
            if (this.layers[i].canvas === canvasObj) return i;
        }
        if (!doReturnNull) throw new Error('layer not found (in ' + this.layers.length + ' layers)');
        return null;
    }
    getLayerOld(index, doReturnNull) {
        if (this.layers[index]) return {
            context: this.layers[index].context,
            isVisible: this.layers[index].isVisible,
            opacity: this.layers[index].opacity,
            name: this.layers[index].name,
            id: index
        };
        if (!doReturnNull) throw new Error('layer of index ' + index + ' not found (in ' + this.layers.length + ' layers)');
        return null;
    }
    getLayer(index) {
        return this.layers[index];
    }
    getColorAt(x, y) {
        return this.eyedropper.getColorAt(x, y, this.klHistory.getComposed());
    }
    getCompleteCanvas(factor, maskSelection) {
        return (0, _drawProject.drawProject)(this.getProject(), factor, maskSelection ? this.selection : undefined);
    }
    getProject() {
        return {
            projectId: this.klHistory.getComposed().projectId.value,
            width: this.width,
            height: this.height,
            layers: this.layers.map((layer)=>{
                return {
                    name: layer.name,
                    isVisible: layer.isVisible,
                    opacity: layer.opacity,
                    mixModeStr: layer.mixModeStr,
                    image: layer.canvas
                };
            })
        };
    }
    setMixMode(layerIndex, mixModeStr) {
        const targetLayer = this.layers[layerIndex];
        targetLayer.mixModeStr = mixModeStr;
        if (!this.klHistory.isPaused()) this.klHistory.push({
            layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                layerId: targetLayer.id,
                attributes: [
                    'mixModeStr'
                ]
            })
        });
    }
    /**
     * Set composite drawing step for KlCanvasWorkspace.
     * To apply temporary manipulations to a layer.
     *
     * @param layerIndex
     * @param compositeObj
     */ setComposite(layerIndex, compositeObj) {
        if (!this.layers[layerIndex]) throw new Error('invalid layer');
        this.layers[layerIndex].compositeObj = compositeObj;
    }
    setSelection(selection) {
        if (!this.selection && !selection) return;
        this.selection = selection;
        this.klHistory.push({
            selection: {
                value: selection
            }
        });
    }
    getSelection() {
        return this.selection;
    }
    /**
     * Transforms (move, not clone) the selected region (or the entire canvas if no selection).
     * Also transforms the selection, unless there is no selection.
     * Creates a new selection sample.
     */ transformViaSelection(p) {
        this.klHistory.pause(true);
        this.createSelectionSample(p.sourceLayer);
        const srcBounds = (0, _getSelectionSampleBounds.getSelectionSampleBounds)(this.selectionSample);
        this.eraseLayer({
            layerIndex: p.sourceLayer,
            useSelection: true,
            useAlphaLock: p.sourceLayer === 0 && !p.backgroundIsTransparent
        });
        this.transformSelectionAndSample(p.transformation);
        const targetBounds = (0, _getSelectionSampleBounds.getSelectionSampleBounds)(this.selectionSample);
        this.drawSelectionSample(p.targetLayer ?? p.sourceLayer, p.isPixelated ?? false);
        this.klHistory.pause(false);
        const srcAndTargetEqual = !p.targetLayer || p.sourceLayer === p.targetLayer;
        // if (srcBounds) {
        //     const layerCtx = this.layers[p.sourceLayer].context;
        //     layerCtx.save();
        //     layerCtx.fillStyle = 'rgba(255,0,0,0.2)';
        //     layerCtx.fillRect(
        //         srcBounds.x1,
        //         srcBounds.y1,
        //         srcBounds.x2 - srcBounds.x1,
        //         srcBounds.y2 - srcBounds.y1,
        //     );
        //     layerCtx.restore();
        // }
        // if (targetBounds) {
        //     const layerCtx = this.layers[p.targetLayer ?? p.sourceLayer].context;
        //     layerCtx.save();
        //     layerCtx.fillStyle = 'rgba(0,0,255,0.2)';
        //     layerCtx.fillRect(
        //         targetBounds.x1,
        //         targetBounds.y1,
        //         targetBounds.x2 - targetBounds.x1,
        //         targetBounds.y2 - targetBounds.y1,
        //     );
        //     layerCtx.restore();
        // }
        if (!this.klHistory.isPaused()) {
            const srcLayer = this.layers[p.sourceLayer];
            const targetLayer = p.targetLayer !== undefined && p.targetLayer !== p.sourceLayer ? this.layers[p.targetLayer] : undefined;
            this.klHistory.push({
                selection: {
                    value: this.selection
                },
                layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                    layerId: srcLayer.id,
                    attributes: [
                        'tiles'
                    ],
                    bounds: srcAndTargetEqual ? (0, _bb.BB).updateBounds(srcBounds, targetBounds) : srcBounds
                }, targetLayer ? {
                    layerId: targetLayer.id,
                    attributes: [
                        'tiles'
                    ],
                    bounds: targetBounds
                } : undefined)
            });
        }
    }
    /**
     * Transforms the selection sample (creates one if there's none, same way as in transformViaSelection)
     * and draws a clone on target layer.
     * Also transforms the selection, unless there is no selection.
     */ transformCloneViaSelection(p) {
        this.klHistory.pause(true);
        if (!this.selectionSample) {
            if (p.sourceLayer === undefined) throw new Error('no source layer');
            this.createSelectionSample(p.sourceLayer);
        }
        this.transformSelectionAndSample(p.transformation);
        this.drawSelectionSample(p.targetLayer, p.isPixelated ?? false);
        const targetBounds = (0, _getSelectionSampleBounds.getSelectionSampleBounds)(this.selectionSample);
        this.klHistory.pause(false);
        // if (targetBounds) {
        //     const layerCtx = this.layers[p.targetLayer ?? p.sourceLayer].context;
        //     layerCtx.save();
        //     layerCtx.fillStyle = 'rgba(0,0,255,0.2)';
        //     layerCtx.fillRect(
        //         targetBounds.x1,
        //         targetBounds.y1,
        //         targetBounds.x2 - targetBounds.x1,
        //         targetBounds.y2 - targetBounds.y1,
        //     );
        //     layerCtx.restore();
        // }
        if (!this.klHistory.isPaused() && targetBounds) {
            const targetLayer = this.layers[p.targetLayer];
            this.klHistory.push({
                selection: {
                    value: this.selection
                },
                layerMap: (0, _createLayerMap.createLayerMap)(this.layers, {
                    layerId: targetLayer.id,
                    attributes: [
                        'tiles'
                    ],
                    bounds: targetBounds
                })
            });
        }
    }
    // todo remove - requires rewrite of transform via selection, though
    clearSelectionSample() {
        if (!this.selectionSample) return;
        this.selectionSample.image && (0, _bb.BB).freeCanvas(this.selectionSample.image);
        this.selectionSample = undefined;
    }
    getSelectionArea(layerIndex) {
        const srcLayer = this.layers[layerIndex];
        const selection = this.getSelectionOrFallback();
        return (0, _getSelectionBounds.getSelectionBounds)(selection, srcLayer.context);
    }
    getSelectionSample() {
        return this.selectionSample;
    }
    /**
     * called after undo/redo, to apply the changes to the klCanvas.
     * before - before undo/redo was called - equivalent to current state of klCanvas.
     * after - after undo/redo was called.
     */ updateViaComposed(before, after) {
        this.width = after.size.width;
        this.height = after.size.height;
        this.selection = after.selection.value;
        this.layers = (0, _updateLayersViaComposed.updateLayersViaComposed)(this.layers, before, after);
    }
    destroy() {
        if (this.isDestroyed) return;
        this.layers.forEach((layer)=>{
            (0, _bb.BB).freeCanvas(layer.canvas);
            layer.canvas = {};
            layer.context = {};
        });
        this.layers = [];
        this.isDestroyed = true;
    }
}

},{"../../bb/bb":"3zOvT","../image-operations/flood-fill":"28yMC","../image-operations/shape-tool":"diljP","../image-operations/render-text":"5Zm2S","../kl-types":"E0RUG","./draw-project":"8dpes","../../language/language":"mcywn","../image-operations/gradient-tool":"1HqrJ","transformation-matrix":"70QDB","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../bb/multi-polygon/transform-multi-polygon":"54b2I","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","../../bb/math/math":"7x9Fp","../../bb/math/matrix-to-tuple":"8BP1P","../brushes/erase-color":"4wlOt","../history/kl-history":"l5YQK","../history/get-next-layer-id":"friOj","../history/create-fill-color-tiles":"4gttJ","./update-layers-via-composed":"052ni","../history/push-helpers/is-history-entry-opacity-change":"dqoUk","../history/push-helpers/is-history-entry-visibility-change":"k4JcA","../../bb/transform/transform-bounds":"gealJ","./get-selection-sample-bounds":"gKXVg","../history/push-helpers/create-layer-map":"9TNRi","./eyedropper":"gGv8J","../history/image-data-tile":"gpqSK","../../bb/base/base":"it3mQ","../select-tool/get-selection-bounds":"jrEMM","../../bb/multi-polygon/translate-multi-polygon":"ciUlD","../select-tool/get-binary-mask":"iRxtk","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"28yMC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Does flood fill, and returns that. an array - 0 not filled, 255 filled.
 */ parcelHelpers.export(exports, "floodFillBits", ()=>floodFillBits);
/**
 * Set values in data within rect to 254, unless they're 255
 *
 * @param data Uint8Array
 * @param width int
 * @param x0 int
 * @param y0 int
 * @param x1 int >x0
 * @param y1 int >y0
 */ function fillRect(data, width, x0, y0, x1, y1) {
    for(let x = x0; x <= x1; x++)for(let y = y0; y <= y1; y++){
        if (data[y * width + x] === 255) continue;
        data[y * width + x] = 254;
    }
}
// test, should fill, if there is a tolerance < 255
function toleranceTest(srcArr, initR, initG, initB, initA, toleranceSquared, i) {
    return (srcArr[i * 4] - initR) ** 2 <= toleranceSquared && (srcArr[i * 4 + 1] - initG) ** 2 <= toleranceSquared && (srcArr[i * 4 + 2] - initB) ** 2 <= toleranceSquared && (srcArr[i * 4 + 3] - initA) ** 2 <= toleranceSquared;
}
// check is within selection
function selectionMaskTest(selectionMaskArr, i) {
    return !selectionMaskArr || !!selectionMaskArr[i];
}
/**
 *
 * @param srcArr Uint8ClampedArray rgba
 * @param selectionMaskArr Uint8Array width x height, 0 or 1 values
 * @param targetArr Uint8Array
 * @param width int
 * @param height int
 * @param px int
 * @param py int
 * @param tolerance int 0 - 255
 * @param grow int >= 0
 * @param isContiguous boolean
 */ function floodFill(srcArr, selectionMaskArr, targetArr, width, height, px, py, tolerance, grow, isContiguous) {
    const initR = srcArr[(py * width + px) * 4];
    const initG = srcArr[(py * width + px) * 4 + 1];
    const initB = srcArr[(py * width + px) * 4 + 2];
    const initA = srcArr[(py * width + px) * 4 + 3];
    const view = new DataView(srcArr.buffer);
    const init = view.getUint32((py * width + px) * 4, true);
    const toleranceSquared = tolerance ** 2;
    const bounds = {
        x1: px,
        y1: py,
        x2: px,
        y2: py
    };
    if (isContiguous) {
        const q = []; // queue of pixel indices. they are already filled.
        q.push(py * width + px); // starting pixel, where the user clicked to fill
        targetArr[py * width + px] = 255;
        let i, e;
        let x, y;
        while(q.length){
            // checks neighbors of queued pixels, fills, and queues them.
            // Adds to queue after filling it. Skip if was already filled.
            i = q.pop();
            y = Math.floor(i / width);
            x = i % width;
            if (x > 0) {
                // can go left
                e = i - 1;
                if (targetArr[e] !== 255 && selectionMaskTest(selectionMaskArr, e) && (view.getUint32(e * 4, true) === init || tolerance > 0 && toleranceTest(srcArr, initR, initG, initB, initA, toleranceSquared, e))) {
                    bounds.x1 = Math.min(bounds.x1, x - 1);
                    targetArr[e] = 255;
                    q.push(e);
                }
            }
            if (x < width - 1) {
                // can go right
                e = i + 1;
                if (targetArr[e] !== 255 && selectionMaskTest(selectionMaskArr, e) && (view.getUint32(e * 4, true) === init || tolerance > 0 && toleranceTest(srcArr, initR, initG, initB, initA, toleranceSquared, e))) {
                    bounds.x2 = Math.max(bounds.x2, x + 1);
                    targetArr[e] = 255;
                    q.push(e);
                }
            }
            if (y > 0) {
                // can go up
                e = i - width;
                if (targetArr[e] !== 255 && selectionMaskTest(selectionMaskArr, e) && (view.getUint32(e * 4, true) === init || tolerance > 0 && toleranceTest(srcArr, initR, initG, initB, initA, toleranceSquared, e))) {
                    bounds.y1 = Math.min(bounds.y1, y - 1);
                    targetArr[e] = 255;
                    q.push(e);
                }
            }
            if (y < height - 1) {
                // can go down
                e = i + width;
                if (targetArr[e] !== 255 && selectionMaskTest(selectionMaskArr, e) && (view.getUint32(e * 4, true) === init || tolerance > 0 && toleranceTest(srcArr, initR, initG, initB, initA, toleranceSquared, e))) {
                    bounds.y2 = Math.max(bounds.y2, y + 1);
                    targetArr[e] = 255;
                    q.push(e);
                }
            }
        }
    } else // not contiguous
    for(let y = 0, i = 0; y < height; y++){
        for(let x = 0; x < width; x++, i++)if (view.getUint32(i * 4, true) === init || selectionMaskTest(selectionMaskArr, i) && tolerance > 0 && toleranceTest(srcArr, initR, initG, initB, initA, toleranceSquared, i)) {
            targetArr[i] = 255;
            if (x < bounds.x1) bounds.x1 = x;
            if (y < bounds.y1) bounds.y1 = y;
            if (x > bounds.x2) bounds.x2 = x;
            if (y > bounds.y2) bounds.y2 = y;
        }
    }
    if (grow === 0) return bounds;
    // --- grow ---
    // how does it grow? it finds all pixel at the edge.
    // then depending on what kind of edge it is, it draws a rectangle into target
    // In the rectangle each pixel has the value 254, or else it will mess it all up.
    // after it's all done, replaces it with 255
    let x0, x1, y0, y1;
    let l, tl, t, tr, r, br, b, bl; // left, top left, top, top right, etc.
    for(let x = bounds.x1; x <= bounds.x2; x++)for(let y = bounds.y1; y <= bounds.y2; y++){
        if (targetArr[y * width + x] !== 255) continue;
        // bounds of rectangle
        x0 = x;
        x1 = x;
        y0 = y;
        y1 = y;
        l = targetArr[y * width + x - 1] !== 255;
        tl = targetArr[(y - 1) * width + x - 1] !== 255;
        t = targetArr[(y - 1) * width + x] !== 255;
        tr = targetArr[(y - 1) * width + x + 1] !== 255;
        r = targetArr[y * width + x + 1] !== 255;
        br = targetArr[(y + 1) * width + x + 1] !== 255;
        b = targetArr[(y + 1) * width + x] !== 255;
        bl = targetArr[(y + 1) * width + x - 1] !== 255;
        if (l) // left
        x0 = x - grow;
        if (l && tl && t) {
            // top left
            x0 = x - grow;
            y0 = y - grow;
        }
        if (t) // top
        y0 = Math.min(y0, y - grow);
        if (t && tr && r) {
            // top right
            y0 = Math.min(y0, y - grow);
            x1 = x + grow;
        }
        if (r) // right
        x1 = Math.max(x1, x + grow);
        if (r && br && b) {
            // bottom right
            x1 = Math.max(x1, x + grow);
            y1 = Math.max(y1, y + grow);
        }
        if (b) // bottom
        y1 = Math.max(y1, y + grow);
        if (b && bl && l) {
            // bottom left
            x0 = Math.min(x0, x - grow);
            y1 = Math.max(y1, y + grow);
        }
        if (!l && !tl && !t && !tr && !r && !br && !b && !bl) continue;
        fillRect(targetArr, width, Math.max(0, x0), Math.max(0, y0), Math.min(width - 1, x1), Math.min(height - 1, y1));
    }
    for(let i = 0; i < width * height; i++)if (targetArr[i] === 254) targetArr[i] = 255;
    // expand bounds by grow
    bounds.x1 -= grow;
    bounds.y1 -= grow;
    bounds.x2 += grow;
    bounds.y2 += grow;
    return bounds;
}
function floodFillBits(rgbaArr, // width x height, 0 or 1 values
selectionMaskArr, width, height, x, y, tolerance, grow, isContiguous) {
    x = Math.round(x); // just in case
    y = Math.round(y);
    const resultArr = new Uint8Array(new ArrayBuffer(width * height));
    const bounds = floodFill(rgbaArr, selectionMaskArr, resultArr, width, height, x, y, tolerance, grow, isContiguous);
    return {
        data: resultArr,
        bounds
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"diljP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Input processor for shape tool.
 * Coordinates are in canvas space.
 * angleRad is the angle of the canvas.
 */ parcelHelpers.export(exports, "ShapeTool", ()=>ShapeTool);
/**
 * Draw a shape (rectangle, ellipse, line)
 */ parcelHelpers.export(exports, "drawShape", ()=>drawShape);
var _bb = require("../../bb/bb");
var _transformBounds = require("../../bb/transform/transform-bounds");
var _transformationMatrix = require("transformation-matrix");
var _matrixToTuple = require("../../bb/math/matrix-to-tuple");
class ShapeTool {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.downX = 0;
        this.downY = 0;
        this.downAngleRad = 0;
        this.onShape = p.onShape;
    }
    onDown(x, y, angleRad) {
        this.downX = x;
        this.downY = y;
        this.downAngleRad = angleRad;
    }
    onMove(x, y) {
        this.onShape(false, this.downX, this.downY, x, y, this.downAngleRad);
    }
    onUp(x, y) {
        this.onShape(true, this.downX, this.downY, x, y, this.downAngleRad);
    }
}
function drawShape(ctx, shapeObj, selectionPath) {
    shapeObj = {
        // defaults
        angleRad: 0,
        isOutwards: false,
        opacity: 1,
        isEraser: false,
        doLockAlpha: false,
        ...(0, _bb.BB).copyObj(shapeObj)
    };
    let bounds = {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
    };
    if ([
        'rect',
        'ellipse',
        'line'
    ].includes(shapeObj.type)) {
        if (shapeObj.angleRad === undefined) throw new Error('angleRad undefined');
        const lineWidth = shapeObj.lineWidth === undefined ? -1 : Math.round(shapeObj.lineWidth);
        const angleDeg = shapeObj.angleRad * 180 / Math.PI;
        // --- prep color ---
        if (!shapeObj.isEraser && shapeObj.fillRgb === undefined && shapeObj.strokeRgb === undefined) throw new Error('fillRgb and strokeRgb undefined');
        const colorRgb = shapeObj.isEraser ? {
            r: 255,
            g: 255,
            b: 255
        } : shapeObj.fillRgb ? shapeObj.fillRgb : shapeObj.strokeRgb;
        // --- prep canvas ---
        ctx.save();
        selectionPath && ctx.clip(selectionPath);
        if (shapeObj.opacity) ctx.globalAlpha = shapeObj.opacity;
        if (shapeObj.isEraser) ctx.globalCompositeOperation = 'destination-out';
        if (shapeObj.doLockAlpha) ctx.globalCompositeOperation = 'source-atop';
        const transformation = (0, _transformationMatrix.compose)((0, _transformationMatrix.rotate)(-shapeObj.angleRad));
        ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(transformation));
        if (shapeObj.fillRgb) ctx.fillStyle = (0, _bb.BB).ColorConverter.toRgbStr(colorRgb);
        else if (shapeObj.strokeRgb) {
            ctx.strokeStyle = (0, _bb.BB).ColorConverter.toRgbStr(colorRgb);
            ctx.lineWidth = lineWidth;
        }
        let x1 = shapeObj.x1;
        let y1 = shapeObj.y1;
        let x2 = shapeObj.x2;
        let y2 = shapeObj.y2;
        // --- angle snapping ---
        if (shapeObj.isAngleSnap) {
            const r1 = (0, _bb.BB).rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            const r2 = (0, _bb.BB).rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            const pAngleDeg = (0, _bb.BB).pointsToAngleDeg(r1, r2) + 90;
            const pAngleDegSnapped = Math.round(pAngleDeg / 45) * 45;
            const rotated = (0, _bb.BB).rotateAround({
                x: x1,
                y: y1
            }, {
                x: x2,
                y: y2
            }, pAngleDegSnapped - pAngleDeg);
            x2 = rotated.x;
            y2 = rotated.y;
            // needs to be perfect if p1->p2 aligns with canvas x- or y-axis
            if ((angleDeg + pAngleDegSnapped) % 90 === 0) {
                if (Math.round((angleDeg - pAngleDegSnapped) / 90) % 2 === 0) // up or down
                x2 = x1;
                else // left or right
                y2 = y1;
            }
        }
        let x = x1;
        let y = y1;
        let dX = x2 - x1;
        let dY = y2 - y1;
        // --- 1:1 ratio ---
        if (shapeObj.type !== 'line' && shapeObj.isFixedRatio) {
            let r1 = (0, _bb.BB).rotate(shapeObj.x1, shapeObj.y1, shapeObj.angleRad / Math.PI * 180);
            let r2 = (0, _bb.BB).rotate(shapeObj.x2, shapeObj.y2, shapeObj.angleRad / Math.PI * 180);
            const rx = r1.x;
            const ry = r1.y;
            let rdX = r2.x - r1.x;
            let rdY = r2.y - r1.y;
            if (Math.abs(rdX) < Math.abs(rdY)) rdY = Math.abs(rdX) * (rdY < 0 ? -1 : 1);
            else rdX = Math.abs(rdY) * (rdX < 0 ? -1 : 1);
            r2.x = rx + rdX;
            r2.y = ry + rdY;
            r1 = (0, _bb.BB).rotate(r1.x, r1.y, -shapeObj.angleRad / Math.PI * 180);
            r2 = (0, _bb.BB).rotate(r2.x, r2.y, -shapeObj.angleRad / Math.PI * 180);
            x1 = r1.x;
            y1 = r1.y;
            x2 = r2.x;
            y2 = r2.y;
            x = x1;
            y = y1;
            dX = x2 - x1;
            dY = y2 - y1;
        }
        // outwards modifier
        if (shapeObj.isOutwards) {
            x -= dX;
            y -= dY;
            dX *= 2;
            dY *= 2;
            x1 = x;
            y1 = y;
            x2 = x + dX;
            y2 = y + dY;
        }
        let p1;
        let p2;
        if (shapeObj.type === 'line') {
            // --- line ---
            // rounded
            const x1r = Math.round(x1);
            const y1r = Math.round(y1);
            const x2r = Math.round(x2);
            const y2r = Math.round(y2);
            // floored
            const x1f = Math.floor(x1);
            const y1f = Math.floor(y1);
            const x2f = Math.floor(x2);
            const y2f = Math.floor(y2);
            if (lineWidth % 2 === 0) {
                if (y1r === y2r) {
                    p1 = {
                        x: x1f,
                        y: y1r
                    };
                    p2 = {
                        x: x2f,
                        y: y2r
                    };
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                } else if (x1r === x2r) {
                    p1 = {
                        x: x1r,
                        y: y1f
                    };
                    p2 = {
                        x: x2r,
                        y: y2f
                    };
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                } else {
                    p1 = {
                        x: x1,
                        y: y1
                    };
                    p2 = {
                        x: x2,
                        y: y2
                    };
                }
            } else {
                p1 = {
                    x: x1f,
                    y: y1f
                };
                p2 = {
                    x: x2f,
                    y: y2f
                };
                if (y1f === y2f) {
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                    p1.y += 0.5;
                    p2.y += 0.5;
                } else if (x1f === x2f) {
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                    p1.x += 0.5;
                    p2.x += 0.5;
                } else {
                    p1.x = x1;
                    p1.y = y1;
                    p2.x = x2;
                    p2.y = y2;
                }
            }
            bounds = {
                x1: Math.min(p1.x, p2.x) - lineWidth / 2,
                y1: Math.min(p1.y, p2.y) - lineWidth / 2,
                x2: Math.max(p1.x, p2.x) + lineWidth / 2,
                y2: Math.max(p1.y, p2.y) + lineWidth / 2
            };
            p1 = (0, _bb.BB).rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        } else if (shapeObj.type === 'rect') {
            // --- rect ---
            // floored
            const x1f = Math.floor(x1);
            const y1f = Math.floor(y1);
            const x2f = Math.floor(x2);
            const y2f = Math.floor(y2);
            if (angleDeg % 90 === 0) {
                if (shapeObj.fillRgb) {
                    if (x1 % 1 === 0) x1 += 1;
                    if (y1 % 1 === 0) y1 += 1;
                    if (x2 % 1 === 0) x2 += 1;
                    if (y2 % 1 === 0) y2 += 1;
                    p1 = {
                        x: x1 < x2 ? x1f : x2f,
                        y: y1 < y2 ? y1f : y2f
                    };
                    p2 = {
                        x: Math.ceil((x1 < x2 ? x2 : x1) - p1.x),
                        y: Math.ceil((y1 < y2 ? y2 : y1) - p1.y)
                    };
                    p2.x = p1.x + p2.x;
                    p2.y = p1.y + p2.y;
                } else if (lineWidth % 2 === 0) {
                    p1 = {
                        x: x1f,
                        y: y1f
                    };
                    p2 = {
                        x: x2f,
                        y: y2f
                    };
                } else {
                    p1 = {
                        x: x1f + 0.5,
                        y: y1f + 0.5
                    };
                    p2 = {
                        x: x2f + 0.5,
                        y: y2f + 0.5
                    };
                }
            } else {
                p1 = {
                    x: x1,
                    y: y1
                };
                p2 = {
                    x: x2,
                    y: y2
                };
            }
            p1 = (0, _bb.BB).rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            const rect = {
                x: p1.x,
                y: p1.y,
                width: p2.x - p1.x,
                height: p2.y - p1.y
            };
            const padding = shapeObj.fillRgb ? 0 : lineWidth / 2;
            bounds = (0, _transformBounds.transformBounds)({
                x1: Math.min(p1.x, p2.x) - padding,
                y1: Math.min(p1.y, p2.y) - padding,
                x2: Math.max(p1.x, p2.x) + padding,
                y2: Math.max(p1.y, p2.y) + padding
            }, transformation);
            if (shapeObj.fillRgb) ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            else ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        } else {
            // --- circle ---
            p1 = (0, _bb.BB).rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            x = p1.x;
            y = p1.y;
            dX = p2.x - p1.x;
            dY = p2.y - p1.y;
            const center = {
                x: x + dX / 2,
                y: y + dY / 2
            };
            const rX = Math.abs(dX / 2);
            const rY = Math.abs(dY / 2);
            ctx.beginPath();
            ctx.ellipse(center.x, center.y, rX, rY, 0, 0, Math.PI * 2);
            if (shapeObj.fillRgb) ctx.fill();
            else ctx.stroke();
            const padding = shapeObj.fillRgb ? 0 : lineWidth / 2;
            // bounds are bigger than they need to be when it's rotated and rX ~ rY. should be good enough though.
            bounds = (0, _transformBounds.transformBounds)({
                x1: center.x - rX - padding,
                y1: center.y - rY - padding,
                x2: center.x + rX + padding,
                y2: center.y + rY + padding
            }, transformation);
        }
        ctx.restore();
    } else throw new Error('unknown shape');
    return bounds;
}

},{"../../bb/bb":"3zOvT","../../bb/transform/transform-bounds":"gealJ","transformation-matrix":"70QDB","../../bb/math/matrix-to-tuple":"8BP1P","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gealJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transformBounds", ()=>transformBounds);
var _transformationMatrix = require("transformation-matrix");
function transformBounds(bounds, transform) {
    const p1 = (0, _transformationMatrix.applyToPoint)(transform, {
        x: bounds.x1,
        y: bounds.y1
    });
    const p2 = (0, _transformationMatrix.applyToPoint)(transform, {
        x: bounds.x2,
        y: bounds.y1
    });
    const p3 = (0, _transformationMatrix.applyToPoint)(transform, {
        x: bounds.x2,
        y: bounds.y2
    });
    const p4 = (0, _transformationMatrix.applyToPoint)(transform, {
        x: bounds.x1,
        y: bounds.y2
    });
    return {
        x1: Math.min(p1.x, p2.x, p3.x, p4.x),
        y1: Math.min(p1.y, p2.y, p3.y, p4.y),
        x2: Math.max(p1.x, p2.x, p3.x, p4.x),
        y2: Math.max(p1.y, p2.y, p3.y, p4.y)
    };
}

},{"transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Zm2S":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Draws text on a canvas.
 * Return bounds, relative to p.x, p.y.
 */ parcelHelpers.export(exports, "renderText", ()=>renderText);
var _bb = require("../../bb/bb");
// accurately represents the bounds of the text, even it's fancy Zalgo text that tries to break layout
function textMetricToRect(metrics, align) {
    const ascent = metrics.actualBoundingBoxAscent;
    const descent = metrics.actualBoundingBoxDescent;
    const left = metrics.actualBoundingBoxLeft;
    const right = metrics.actualBoundingBoxRight;
    const width = right + left; // More accurate width calculation considering left/right bounds
    const height = ascent + descent;
    if (align === 'left') return {
        x: -left,
        y: -ascent,
        width: width,
        height
    };
    if (align === 'right') return {
        x: -width,
        y: -ascent,
        width: width,
        height
    };
    // center
    return {
        x: -left,
        y: -ascent,
        width: width,
        height
    };
}
function renderText(canvas, p, selectionPath) {
    p = (0, _bb.BB).copyObj(p);
    // setup context
    const ctx = (0, _bb.BB).ctx(canvas);
    ctx.save();
    selectionPath && ctx.clip(selectionPath);
    ctx.textAlign = p.align;
    ctx.letterSpacing = p.letterSpacing ? p.letterSpacing + 'px' : '0';
    // font
    const fontArr = [
        p.size + 'px ' + (p.font ? p.font : 'sans-serif')
    ];
    if (p.isBold) fontArr.unshift('bold');
    if (p.isItalic) fontArr.unshift('italic');
    ctx.font = fontArr.join(' ');
    // fill
    ctx.fillStyle = p.fill ? (0, _bb.BB).ColorConverter.toRgbaStr(p.fill.color) : 'transparent';
    // stroke
    ctx.strokeStyle = p.stroke ? (0, _bb.BB).ColorConverter.toRgbaStr(p.stroke.color) : 'transparent';
    if (p.stroke) {
        ctx.lineWidth = p.stroke.lineWidth;
        ctx.lineJoin = 'round';
    }
    ctx.translate(p.x, p.y);
    ctx.rotate(-p.angleRad);
    const lines = p.text.split('\n').map((line)=>line.replaceAll('\t', '    '));
    // bounds
    const bounds = {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
    };
    {
        let isFirst = true;
        lines.forEach((line, lineIndex)=>{
            const metrics = ctx.measureText(line);
            const x = 0;
            const y = p.size * (p.lineHeight ?? 1) * lineIndex;
            const mRect = textMetricToRect(metrics, p.align);
            if (isFirst) {
                isFirst = false;
                bounds.x1 = x + mRect.x;
                bounds.y1 = y + mRect.y;
                bounds.x2 = x + mRect.x + mRect.width;
                bounds.y2 = y + mRect.y + mRect.height;
            } else {
                bounds.x1 = Math.min(bounds.x1, x + mRect.x);
                bounds.y1 = Math.min(bounds.y1, y + mRect.y);
                bounds.x2 = Math.max(bounds.x2, x + mRect.x + mRect.width);
                bounds.y2 = Math.max(bounds.y2, y + mRect.y + mRect.height);
            }
        });
    }
    // draw stroke
    lines.forEach((line, lineIndex)=>{
        const x = 0;
        const y = p.size * (p.lineHeight ?? 1) * lineIndex;
        ctx.strokeText(line, x, y);
    });
    // draw fill
    lines.forEach((line, lineIndex)=>{
        const x = 0;
        const y = p.size * (p.lineHeight ?? 1) * lineIndex;
        ctx.fillText(line, x, y);
    });
    ctx.restore();
    return {
        x: bounds.x1,
        y: bounds.y1,
        width: bounds.x2 - bounds.x1,
        height: bounds.y2 - bounds.y1
    };
}

},{"../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8dpes":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawProject", ()=>drawProject);
var _bb = require("../../bb/bb");
var _klTypes = require("../kl-types");
var _transformMultiPolygon = require("../../bb/multi-polygon/transform-multi-polygon");
var _transformationMatrix = require("transformation-matrix");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
function drawProject(project, factor, selection) {
    const resultCanvas = (0, _bb.BB).canvas(Math.max(1, Math.round(project.width * factor)), Math.max(1, Math.round(project.height * factor)));
    const transformedSelection = selection ? (0, _transformMultiPolygon.transformMultiPolygon)(selection, (0, _transformationMatrix.scale)(resultCanvas.width / project.width, resultCanvas.height / project.height)) : undefined;
    const ctx = (0, _bb.BB).ctx(resultCanvas);
    ctx.save();
    if (transformedSelection) ctx.clip((0, _getSelectionPath2D.getSelectionPath2d)(transformedSelection));
    if (factor > 1) ctx.imageSmoothingEnabled = false;
    for(let i = 0; i < project.layers.length; i++){
        const layer = project.layers[i];
        if (!layer.isVisible || layer.opacity === 0) continue;
        ctx.globalAlpha = layer.opacity;
        const mixModeStr = layer.mixModeStr;
        ctx.globalCompositeOperation = mixModeStr !== undefined ? mixModeStr : 'source-over';
        if ((0, _klTypes.isLayerFill)(layer.image)) {
            ctx.fillStyle = layer.image.fill;
            ctx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
        } else if (layer.image instanceof Array) throw new Error('not implemented');
        else ctx.drawImage(layer.image, 0, 0, resultCanvas.width, resultCanvas.height);
    }
    ctx.restore();
    return resultCanvas;
}

},{"../../bb/bb":"3zOvT","../kl-types":"E0RUG","../../bb/multi-polygon/transform-multi-polygon":"54b2I","transformation-matrix":"70QDB","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1HqrJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Input processor for gradient tool.
 * Coordinates are in canvas space.
 * angleRad is the angle of the canvas.
 */ parcelHelpers.export(exports, "GradientTool", ()=>GradientTool);
parcelHelpers.export(exports, "drawGradient", ()=>drawGradient);
var _bb = require("../../bb/bb");
class GradientTool {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.downX = 0;
        this.downY = 0;
        this.downAngleRad = 0;
        this.onGradient = p.onGradient;
    }
    onDown(x, y, angleRad) {
        this.downX = x;
        this.downY = y;
        this.downAngleRad = angleRad;
    }
    onMove(x, y) {
        this.onGradient(false, this.downX, this.downY, x, y, this.downAngleRad);
    }
    onUp(x, y) {
        this.onGradient(true, this.downX, this.downY, x, y, this.downAngleRad);
    }
}
function drawGradient(ctx, gradientObj, selectionPath) {
    ctx.save();
    selectionPath && ctx.clip(selectionPath);
    const x1 = gradientObj.x1;
    const y1 = gradientObj.y1;
    let x2 = gradientObj.x2;
    let y2 = gradientObj.y2;
    if (gradientObj.doSnap) {
        const angleDeg = gradientObj.angleRad * 180 / Math.PI;
        const r1 = (0, _bb.BB).rotate(x1, y1, gradientObj.angleRad / Math.PI * 180);
        const r2 = (0, _bb.BB).rotate(x2, y2, gradientObj.angleRad / Math.PI * 180);
        const pAngleDeg = (0, _bb.BB).pointsToAngleDeg(r1, r2) + 90;
        const pAngleDegSnapped = Math.round(pAngleDeg / 45) * 45;
        const rotated = (0, _bb.BB).rotateAround({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        }, pAngleDegSnapped - pAngleDeg);
        x2 = rotated.x;
        y2 = rotated.y;
        // needs to be perfect if p1->p2 aligns with canvas x- or y-axis
        if ((angleDeg + pAngleDegSnapped) % 90 === 0) {
            if (Math.round((angleDeg - pAngleDegSnapped) / 90) % 2 === 0) // up or down
            x2 = x1;
            else // left or right
            y2 = y1;
        }
    }
    let baseColor = gradientObj.color1;
    if (gradientObj.isEraser && gradientObj.doLockAlpha) baseColor = {
        r: 255,
        g: 255,
        b: 255
    };
    let color1 = {
        ...baseColor,
        a: gradientObj.opacity
    };
    let color2 = {
        ...baseColor,
        a: 0
    };
    if (gradientObj.isReversed) {
        const temp = color1;
        color1 = color2;
        color2 = temp;
    }
    let gradient;
    if (gradientObj.type === 'linear') {
        gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    } else if (gradientObj.type === 'linear-mirror') {
        const d = {
            x: x2 - x1,
            y: y2 - y1
        };
        gradient = ctx.createLinearGradient(x1 - d.x, y1 - d.y, x2, y2);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
        gradient.addColorStop(0.5, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    } else if (gradientObj.type === 'radial') {
        const r = (0, _bb.BB).Vec2.dist({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        });
        gradient = ctx.createRadialGradient(x1, y1, 0, x1, y1, r);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    }
    ctx.fillStyle = gradient;
    if (gradientObj.isEraser) ctx.globalCompositeOperation = 'destination-out';
    if (gradientObj.doLockAlpha) ctx.globalCompositeOperation = 'source-atop';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.restore();
}

},{"../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"friOj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getNextLayerId", ()=>getNextLayerId);
let layerId = 0;
function getNextLayerId() {
    return '' + layerId++;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4gttJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createFillColorTiles", ()=>createFillColorTiles);
var _klHistory = require("./kl-history");
function createFillColorTiles(width, height, fill) {
    const result = [];
    const tilesX = Math.ceil(width / (0, _klHistory.HISTORY_TILE_SIZE));
    const tilesY = Math.ceil(height / (0, _klHistory.HISTORY_TILE_SIZE));
    for(let y = 0; y < tilesY; y++)for(let x = 0; x < tilesX; x++)result.push({
        fill
    });
    return result;
}

},{"./kl-history":"l5YQK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"052ni":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Applies history delta to the project, optimized for performance.
 * note: modifies the canvases in project
 */ parcelHelpers.export(exports, "updateLayersViaComposed", ()=>updateLayersViaComposed);
var _klHistory = require("../history/kl-history");
var _bb = require("../../bb/bb");
var _sortLayerMap = require("../history/sort-layer-map");
var _klTypes = require("../kl-types");
function updateLayersViaComposed(layers, before, after) {
    const sizeDidChange = before.size.width !== after.size.width || before.size.height !== after.size.height;
    return Object.entries(after.layerMap).map(([id, composedAfterLayer])=>{
        let canvas = {};
        let context = {};
        const composedBeforeLayer = before.layerMap[id];
        const tilesPerX = Math.ceil(after.size.width / (0, _klHistory.HISTORY_TILE_SIZE));
        if (sizeDidChange || !composedBeforeLayer) {
            // create new canvas
            canvas = (0, _bb.BB).canvas(after.size.width, after.size.height);
            context = (0, _bb.BB).ctx(canvas);
            composedAfterLayer.tiles.forEach((item, index)=>{
                const x = index % tilesPerX;
                const y = Math.floor(index / tilesPerX);
                if ((0, _klTypes.isLayerFill)(item)) {
                    context.save();
                    context.fillStyle = item.fill;
                    context.fillRect(x * (0, _klHistory.HISTORY_TILE_SIZE), y * (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
                    context.restore();
                } else context.putImageData(item.data, x * (0, _klHistory.HISTORY_TILE_SIZE), y * (0, _klHistory.HISTORY_TILE_SIZE));
            });
        } else {
            canvas = layers[composedBeforeLayer.index].canvas;
            context = layers[composedBeforeLayer.index].context;
            composedAfterLayer.tiles.forEach((item, index)=>{
                if (item === composedBeforeLayer.tiles[index]) // todo more advanced check ^
                return;
                const x = index % tilesPerX;
                const y = Math.floor(index / tilesPerX);
                if ((0, _klTypes.isLayerFill)(item)) {
                    context.save();
                    context.fillStyle = item.fill;
                    context.clearRect(x * (0, _klHistory.HISTORY_TILE_SIZE), y * (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
                    context.fillRect(x * (0, _klHistory.HISTORY_TILE_SIZE), y * (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
                    context.restore();
                } else context.putImageData(item.data, x * (0, _klHistory.HISTORY_TILE_SIZE), y * (0, _klHistory.HISTORY_TILE_SIZE));
            });
        }
        return {
            id,
            index: composedAfterLayer.index,
            name: composedAfterLayer.name,
            mixModeStr: composedAfterLayer.mixModeStr,
            isVisible: composedAfterLayer.isVisible,
            opacity: composedAfterLayer.opacity,
            canvas,
            context
        };
    }).sort((0, _sortLayerMap.sortLayerMap));
}

},{"../history/kl-history":"l5YQK","../../bb/bb":"3zOvT","../history/sort-layer-map":"cIR0B","../kl-types":"E0RUG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cIR0B":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sortLayerMap", ()=>sortLayerMap);
function sortLayerMap(a, b) {
    if (a.index > b.index) return 1;
    if (a.index < b.index) return -1;
    return 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dqoUk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Is it a history entry where the *only* change is the opacity of layerId
parcelHelpers.export(exports, "isHistoryEntryOpacityChange", ()=>isHistoryEntryOpacityChange);
function isHistoryEntryOpacityChange(entry, layerId) {
    const keys = Object.keys(entry);
    if (keys.length !== 1 || !entry.layerMap) return false;
    const ids = Object.keys(entry.layerMap);
    for(let i = 0; i < ids.length; i++){
        const id = ids[i];
        const layer = entry.layerMap[id];
        if (id === layerId) {
            const layerKeys = Object.keys(layer);
            if (layerKeys.length !== 1 || layerKeys[0] !== 'opacity') return false;
        } else {
            const layerKeys = Object.keys(layer);
            if (layerKeys.length > 0) return false;
        }
    }
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k4JcA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Is it a history entry where the *only* change is the visibility of layerId
parcelHelpers.export(exports, "isHistoryEntryVisibilityChange", ()=>isHistoryEntryVisibilityChange);
function isHistoryEntryVisibilityChange(entry, layerId) {
    const keys = Object.keys(entry);
    if (keys.length !== 1 || !entry.layerMap) return false;
    const ids = Object.keys(entry.layerMap);
    for(let i = 0; i < ids.length; i++){
        const id = ids[i];
        const layer = entry.layerMap[id];
        if (id === layerId) {
            const layerKeys = Object.keys(layer);
            if (layerKeys.length !== 1 || layerKeys[0] !== 'isVisible') return false;
        } else {
            const layerKeys = Object.keys(layer);
            if (layerKeys.length > 0) return false;
        }
    }
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gKXVg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSelectionSampleBounds", ()=>getSelectionSampleBounds);
var _transformBounds = require("../../bb/transform/transform-bounds");
var _math = require("../../bb/math/math");
function getSelectionSampleBounds(selectionSample) {
    if (!selectionSample.image) return undefined;
    return (0, _math.integerBounds)((0, _transformBounds.transformBounds)({
        x1: 0,
        y1: 0,
        x2: selectionSample.image.width,
        y2: selectionSample.image.height
    }, selectionSample.transformation));
}

},{"../../bb/transform/transform-bounds":"gealJ","../../bb/math/math":"7x9Fp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9TNRi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates THistoryEntryData.layerMap from KlCanvas layers that can be pushed into history.
 *
 * items control what attributes will be set for each layer. Examples:
 * { attributes: ['index'] } - each layer only has index attribute. all layers will be in the map.
 * { layerId: '0', attributes: ['name']} - map only contains layer '0'. it only has 'name' attribute.
 * { layerId: '0', attributes: 'all'} - map only contains layer '0', with all attributes.
 * { layerId: '0', attributes: 'all'}, { attributes: ['index'] }
 *      - layer '0' has all attributes.
 *      - all other layers will be in the map, but only contain attribute 'index'.
 *
 *  Can further customize by setting what bounds changed, or provide custom tiles.
 */ parcelHelpers.export(exports, "createLayerMap", ()=>createLayerMap);
var _canvasToLayerTiles = require("./canvas-to-layer-tiles");
// create individual THistoryEntryLayer
function createEntryLayer(layer, attributes, bounds, tiles) {
    const useAll = attributes === 'all';
    const result = {};
    if (useAll || attributes.includes('name')) result.name = layer.name;
    if (useAll || attributes.includes('opacity')) result.opacity = layer.opacity;
    if (useAll || attributes.includes('isVisible')) result.isVisible = layer.isVisible;
    if (useAll || attributes.includes('mixModeStr')) result.mixModeStr = layer.mixModeStr;
    if (useAll || attributes.includes('index')) result.index = layer.index;
    if (useAll || attributes.includes('tiles')) result.tiles = tiles ?? (0, _canvasToLayerTiles.canvasToLayerTiles)(layer.context.canvas, bounds);
    return result;
}
function createLayerMap(layers, ...items) {
    const generic = items.find((item)=>item && !('layerId' in item)) ?? {
        attributes: []
    };
    const targets = items.filter((item)=>!!item).filter((item)=>'layerId' in item);
    return Object.fromEntries(layers.map((layer, index)=>{
        for (const target of targets){
            if (target.layerId === layer.id) return [
                layer.id,
                createEntryLayer(layer, target.attributes, target.bounds, target.tiles)
            ];
        }
        return [
            layer.id,
            createEntryLayer(layer, generic.attributes)
        ];
    }));
}

},{"./canvas-to-layer-tiles":"byCWA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"byCWA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canvasAndChangedTilesToLayerTiles", ()=>canvasAndChangedTilesToLayerTiles);
parcelHelpers.export(exports, "canvasToLayerTiles", ()=>canvasToLayerTiles);
var _klHistory = require("../kl-history");
var _getTileFromCanvas = require("./get-tile-from-canvas");
var _changedTiles = require("./changed-tiles");
var _imageDataTile = require("../image-data-tile");
function canvasAndChangedTilesToLayerTiles(canvas, changedTiles) {
    const result = [];
    const tilesX = Math.ceil(canvas.width / (0, _klHistory.HISTORY_TILE_SIZE));
    const tilesY = Math.ceil(canvas.height / (0, _klHistory.HISTORY_TILE_SIZE));
    for(let row = 0; row < tilesY; row++)for(let col = 0; col < tilesX; col++)result.push(changedTiles[row * tilesX + col] ? (0, _imageDataTile.createImageDataTile)((0, _getTileFromCanvas.getTileFromCanvas)(canvas, col, row, (0, _klHistory.HISTORY_TILE_SIZE))) : undefined);
    return result;
}
function canvasToLayerTiles(canvas, bounds) {
    if (bounds) {
        const changedTiles = (0, _changedTiles.getChangedTiles)(bounds, canvas.width, canvas.height);
        return canvasAndChangedTilesToLayerTiles(canvas, changedTiles);
    } else {
        // only do a single read back
        const ctx = canvas.getContext('2d');
        const fullImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tilesX = Math.ceil(canvas.width / (0, _klHistory.HISTORY_TILE_SIZE));
        const tilesY = Math.ceil(canvas.height / (0, _klHistory.HISTORY_TILE_SIZE));
        const result = [];
        // manually transfer into tiles
        for(let row = 0; row < tilesY; row++)for(let col = 0; col < tilesX; col++){
            const x = col * (0, _klHistory.HISTORY_TILE_SIZE);
            const y = row * (0, _klHistory.HISTORY_TILE_SIZE);
            const tileWidth = Math.min((0, _klHistory.HISTORY_TILE_SIZE), canvas.width - x);
            const tileHeight = Math.min((0, _klHistory.HISTORY_TILE_SIZE), canvas.height - y);
            const tileData = new ImageData(tileWidth, tileHeight);
            for(let line = 0; line < tileHeight; line++){
                const srcStart = ((y + line) * canvas.width + x) * 4;
                const destStart = line * tileWidth * 4;
                tileData.data.set(fullImageData.data.subarray(srcStart, srcStart + tileWidth * 4), destStart);
            }
            result.push((0, _imageDataTile.createImageDataTile)(tileData));
        }
        return result;
    }
}

},{"../kl-history":"l5YQK","./get-tile-from-canvas":"gRV63","./changed-tiles":"fEQ1q","../image-data-tile":"gpqSK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gRV63":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTileFromCanvas", ()=>getTileFromCanvas);
var _bb = require("../../../bb/bb");
function getTileFromCanvas(canvas, col, row, tileSize) {
    const ctx = (0, _bb.BB).ctx(canvas);
    const width = Math.min(canvas.width, (col + 1) * tileSize) - col * tileSize;
    const height = Math.min(canvas.height, (row + 1) * tileSize) - row * tileSize;
    if (width <= 0 || height <= 0) throw new Error('invalid out-of-bounds tile');
    return ctx.getImageData(col * tileSize, row * tileSize, width, height);
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fEQ1q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// returns array, each entry represents a tile, as a boolean
// true - intersected with bounds
parcelHelpers.export(exports, "getChangedTiles", ()=>getChangedTiles);
// Combines old and new changes.
// A tile is changed if it's changed in new or old.
parcelHelpers.export(exports, "updateChangedTiles", ()=>updateChangedTiles);
var _klHistory = require("../kl-history");
var _math = require("../../../bb/math/math");
var _base = require("../../../bb/base/base");
function getChangedTiles(bounds, width, height, tileSize = (0, _klHistory.HISTORY_TILE_SIZE)) {
    // ensure: 1 top left, 2 bottom right
    bounds = {
        x1: Math.min(bounds.x1, bounds.x2),
        y1: Math.min(bounds.y1, bounds.y2),
        x2: Math.max(bounds.x1, bounds.x2),
        y2: Math.max(bounds.y1, bounds.y2)
    };
    const boundsInCanvas = (0, _math.boundsInArea)(bounds, width, height);
    const tilesX = Math.ceil(width / tileSize);
    const tilesY = Math.ceil(height / tileSize);
    if (!boundsInCanvas) // no change if bounds don't overlap canvas
    return (0, _base.createArray)(tilesX * tilesY, false);
    const result = (0, _base.createArray)(tilesX * tilesY, false);
    const tileBounds = {
        x1: (0, _math.clamp)(Math.floor(bounds.x1 / tileSize), 0, tilesX - 1),
        y1: (0, _math.clamp)(Math.floor(bounds.y1 / tileSize), 0, tilesY - 1),
        x2: (0, _math.clamp)(Math.floor(bounds.x2 / tileSize), 0, tilesX - 1),
        y2: (0, _math.clamp)(Math.floor(bounds.y2 / tileSize), 0, tilesY - 1)
    };
    for(let i = tileBounds.x1; i <= tileBounds.x2; i++)for(let e = tileBounds.y1; e <= tileBounds.y2; e++)result[e * tilesX + i] = true;
    return result;
}
function updateChangedTiles(oldChangedOrEmpty, newChanged) {
    return newChanged.map((newItem, index)=>{
        return newItem || !!oldChangedOrEmpty[index];
    });
}

},{"../kl-history":"l5YQK","../../../bb/math/math":"7x9Fp","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gpqSK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createImageDataTile", ()=>createImageDataTile);
// copy with different id
parcelHelpers.export(exports, "copyImageDataTile", ()=>copyImageDataTile);
var _copyImageData = require("../utils/copy-image-data");
var _base = require("../../bb/base/base");
function createImageDataTile(data) {
    return {
        id: (0, _base.randomUuid)(),
        // timestamp: new Date().getTime(),
        data: data
    };
}
function copyImageDataTile(tile) {
    return {
        id: (0, _base.randomUuid)(),
        // timestamp: new Date().getTime(),
        data: (0, _copyImageData.copyImageData)(tile.data)
    };
}

},{"../utils/copy-image-data":"ceH2z","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ceH2z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copyImageData", ()=>copyImageData);
const copyImageData = (imageData)=>{
    return new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gGv8J":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Eyedropper", ()=>Eyedropper);
var _klTypes = require("../kl-types");
var _bb = require("../../bb/bb");
var _klHistory = require("../history/kl-history");
var _sortLayerMap = require("../history/sort-layer-map");
class Eyedropper {
    // ----------------------------------- public -----------------------------------
    constructor(){}
    // Reads from history (ImageData) to avoid reading from canvas.
    getColorAt(x, y, composed) {
        x = Math.floor(x);
        y = Math.floor(y);
        if (x < 0 || x >= composed.size.width || y < 0 || y >= composed.size.height) return new (0, _bb.BB).RGB(0, 0, 0);
        const canvas = (0, _bb.BB).canvas(1, 1);
        const ctx = (0, _bb.BB).ctx(canvas);
        ctx.imageSmoothingEnabled = false;
        const tilesX = Math.ceil(composed.size.width / (0, _klHistory.HISTORY_TILE_SIZE));
        const tileCol = Math.floor(x / (0, _klHistory.HISTORY_TILE_SIZE));
        const tileRow = Math.floor(y / (0, _klHistory.HISTORY_TILE_SIZE));
        const tileIndex = tileRow * tilesX + tileCol;
        Object.values(composed.layerMap).sort((0, _sortLayerMap.sortLayerMap)).forEach((layer)=>{
            if (!layer.isVisible || layer.opacity === 0) return;
            const tile = layer.tiles[tileIndex];
            let fillStyle = '';
            if ((0, _klTypes.isLayerFill)(tile)) fillStyle = tile.fill;
            else {
                let tileWidth = (0, _klHistory.HISTORY_TILE_SIZE);
                if (composed.size.width % (0, _klHistory.HISTORY_TILE_SIZE) !== 0 && tileCol === tilesX - 1) tileWidth = composed.size.width % (0, _klHistory.HISTORY_TILE_SIZE);
                const pixelIndex = y % (0, _klHistory.HISTORY_TILE_SIZE) * tileWidth + x % (0, _klHistory.HISTORY_TILE_SIZE);
                if (tile.data.data[pixelIndex * 4 + 3] === 0) return;
                fillStyle = (0, _bb.BB).ColorConverter.toRgbaStr({
                    r: tile.data.data[pixelIndex * 4],
                    g: tile.data.data[pixelIndex * 4 + 1],
                    b: tile.data.data[pixelIndex * 4 + 2],
                    a: tile.data.data[pixelIndex * 4 + 3] / 255
                });
            }
            ctx.fillStyle = fillStyle;
            ctx.globalAlpha = layer.opacity;
            ctx.globalCompositeOperation = layer.mixModeStr;
            ctx.fillRect(0, 0, 1, 1);
        });
        const imData = ctx.getImageData(0, 0, 1, 1);
        return new (0, _bb.BB).RGB(imData.data[0], imData.data[1], imData.data[2]);
    }
}

},{"../kl-types":"E0RUG","../../bb/bb":"3zOvT","../history/kl-history":"l5YQK","../history/sort-layer-map":"cIR0B","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jrEMM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// returns bounds of selection, where layer is not empty (transparent)
parcelHelpers.export(exports, "getSelectionBounds", ()=>getSelectionBounds);
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
var _math = require("../../bb/math/math");
var _canvas = require("../../bb/base/canvas");
function getSelectionBounds(selection, context) {
    const selectionBounds = (0, _getMultiPolygonBounds.getMultiPolyBounds)(selection);
    // integer bounds that are within the canvas
    const canvasSelectionBounds = (0, _math.intBoundsWithinArea)(selectionBounds, context.canvas.width, context.canvas.height, true);
    // selection area outside of canvas
    if (!canvasSelectionBounds) return undefined;
    // bounds of where pixels are non-transparent
    return (0, _canvas.canvasBounds)(context, canvasSelectionBounds);
}

},{"../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","../../bb/math/math":"7x9Fp","../../bb/base/canvas":"86XNv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ciUlD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translateMultiPolygon", ()=>translateMultiPolygon);
function translateMultiPolygon(poly, x, y) {
    return poly.map((poly)=>{
        return poly.map((ring)=>{
            return ring.map((p)=>{
                return [
                    p[0] + x,
                    p[1] + y
                ];
            });
        });
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iRxtk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBinaryMask", ()=>getBinaryMask);
var _bb = require("../../bb/bb");
var _canvas = require("../../bb/base/canvas");
function getBinaryMask(selection, width, height) {
    const result = new Uint8Array(new ArrayBuffer(width * height));
    const canvas = (0, _bb.BB).canvas(width, height);
    const ctx = (0, _bb.BB).ctx(canvas);
    (0, _canvas.drawSelectionMask)(selection, ctx);
    const imageData = ctx.getImageData(0, 0, width, height);
    (0, _bb.BB).freeCanvas(canvas);
    const len = width * height;
    for(let i = 0, e = 0; i < len; i++, e += 4)result[i] = imageData.data[e] >>> 7;
    return result;
}

},{"../../bb/bb":"3zOvT","../../bb/base/canvas":"86XNv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l3XnR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translateBlending", ()=>translateBlending);
var _language = require("../../language/language");
function translateBlending(blendMode) {
    if (!blendMode) return (0, _language.LANG)('layers-blend-normal');
    const codes = {
        'source-over': 'layers-blend-normal',
        darken: 'layers-blend-darken',
        multiply: 'layers-blend-multiply',
        'color-burn': 'layers-blend-color-burn',
        lighten: 'layers-blend-lighten',
        screen: 'layers-blend-screen',
        'color-dodge': 'layers-blend-color-dodge',
        overlay: 'layers-blend-overlay',
        'soft-light': 'layers-blend-soft-light',
        'hard-light': 'layers-blend-hard-light',
        difference: 'layers-blend-difference',
        exclusion: 'layers-blend-exclusion',
        hue: 'layers-blend-hue',
        saturation: 'layers-blend-saturation',
        color: 'layers-blend-color',
        luminosity: 'layers-blend-luminosity'
    };
    if (!(blendMode in codes)) throw new Error('unknown blend mode');
    return (0, _language.LANG)(codes[blendMode]);
}

},{"../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5uRlk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "renameLayerDialog", ()=>renameLayerDialog);
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _showModal = require("../../modals/base/showModal");
var _removeLayerSvg = require("url:/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
function renameLayerDialog(parentEl, currentName, callback) {
    const div = (0, _bb.BB).el();
    const label = (0, _bb.BB).el({
        content: (0, _language.LANG)('layers-rename-name') + ':',
        css: {
            marginRight: '5px'
        }
    });
    const row = (0, _bb.BB).el({
        css: {
            display: 'flex'
        }
    });
    const input = (0, _bb.BB).el({
        tagName: 'input'
    });
    input.value = currentName;
    input.setAttribute('data-ignore-focus', 'true');
    input.style.flexGrow = '1';
    const clearBtn = (0, _bb.BB).el({
        tagName: 'button',
        content: '<img src="' + (0, _removeLayerSvgDefault.default) + '" height="20"/>',
        title: (0, _language.LANG)('layers-rename-clear'),
        css: {
            marginLeft: '10px'
        },
        onClick: ()=>{
            input.value = '';
            input.focus();
        }
    });
    const suggestions = [
        (0, _language.LANG)('layers-rename-sketch'),
        (0, _language.LANG)('layers-rename-colors'),
        (0, _language.LANG)('layers-rename-shading'),
        (0, _language.LANG)('layers-rename-lines'),
        (0, _language.LANG)('layers-rename-effects'),
        (0, _language.LANG)('background'),
        (0, _language.LANG)('layers-rename-foreground')
    ];
    const suggestionBtns = [];
    const row2 = (0, _bb.BB).el({
        css: {
            display: 'flex',
            flexWrap: 'wrap',
            marginTop: '5px',
            marginLeft: '-5px'
        }
    });
    suggestions.forEach((item)=>{
        const btn = (0, _bb.BB).el({
            parent: row2,
            tagName: 'button',
            content: item,
            onClick: ()=>{
                input.value = '' + btn.textContent;
            },
            css: {
                margin: '5px 0 0 5px'
            }
        });
        suggestionBtns.push(btn);
    });
    div.append(label);
    label.append(row, row2);
    row.append(input, clearBtn);
    setTimeout(()=>{
        input.focus();
        input.select();
    }, 10);
    (0, _showModal.showModal)({
        target: parentEl,
        message: `<b>${(0, _language.LANG)('layers-rename-title')}</b>`,
        div: div,
        buttons: [
            (0, _language.LANG)('layers-rename'),
            'Cancel'
        ],
        primaries: [
            (0, _language.LANG)('layers-rename')
        ],
        callback: (val)=>{
            (0, _bb.BB).destroyEl(clearBtn);
            suggestionBtns.forEach((item)=>{
                (0, _bb.BB).destroyEl(item);
            });
            suggestionBtns.splice(0, suggestionBtns.length);
            if (val === (0, _language.LANG)('layers-rename')) callback(input.value);
            else callback(undefined);
        },
        clickOnEnter: (0, _language.LANG)('layers-rename')
    });
}

},{"../../../../bb/bb":"3zOvT","../../../../language/language":"mcywn","../../modals/base/showModal":"gy3iL","url:/src/app/img/ui/remove-layer.svg":"fV9n3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7TGmW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeLayerDialog", ()=>mergeLayerDialog);
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _options = require("../../components/options");
var _translateBlending = require("../../../canvas/translate-blending");
var _showModal = require("../../modals/base/showModal");
function mergeLayerDialog(parentEl, p) {
    const div = (0, _bb.BB).el();
    div.innerHTML = (0, _language.LANG)('layers-merge-description');
    const options = new (0, _options.Options)({
        optionArr: [
            {
                id: p.mixModeStr,
                label: (0, _translateBlending.translateBlending)(p.mixModeStr)
            },
            {
                id: 'source-in',
                label: 'source-in'
            },
            {
                id: 'source-out',
                label: 'source-out'
            },
            {
                id: 'source-atop',
                label: 'source-atop'
            },
            {
                id: 'destination-in',
                label: 'destination-in'
            },
            {
                id: 'destination-out',
                label: 'destination-out'
            },
            {
                id: 'destination-atop',
                label: 'destination-atop'
            },
            {
                id: 'xor',
                label: 'xor'
            }
        ],
        initId: p.mixModeStr,
        onChange: ()=>{
            update();
        },
        isSmall: true,
        css: {
            marginTop: '5px'
        }
    });
    div.append(options.getElement());
    const thumbDimensions = (0, _bb.BB).fitInto(p.topCanvas.width, p.topCanvas.height, 200, 200, 1);
    const preview = (0, _bb.BB).canvas(thumbDimensions.width, thumbDimensions.height);
    preview.title = (0, _language.LANG)('preview');
    preview.className = 'kl-merge-preview';
    const spacer = (0, _bb.BB).el({
        content: '<br/>',
        css: {
            clear: 'both'
        }
    });
    div.append(spacer, preview);
    const alphaCanvas = (0, _bb.BB).copyCanvas(preview);
    (0, _bb.BB).ctx(alphaCanvas).drawImage(p.topCanvas, 0, 0, alphaCanvas.width, alphaCanvas.height);
    (0, _bb.BB).convertToAlphaChannelCanvas(alphaCanvas);
    const update = ()=>{
        const ctx = (0, _bb.BB).ctx(preview);
        ctx.save();
        ctx.clearRect(0, 0, preview.width, preview.height);
        if (preview.width > p.topCanvas.width) ctx.imageSmoothingEnabled = false;
        ctx.drawImage(p.bottomCanvas, 0, 0, preview.width, preview.height);
        if (options.getValue() === 'as-alpha') {
            ctx.globalCompositeOperation = 'destination-in';
            ctx.globalAlpha = p.topOpacity;
            ctx.drawImage(alphaCanvas, 0, 0, preview.width, preview.height);
        } else {
            ctx.globalCompositeOperation = options.getValue();
            ctx.globalAlpha = p.topOpacity;
            ctx.drawImage(p.topCanvas, 0, 0, preview.width, preview.height);
        }
        ctx.restore();
    };
    update();
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: (keyStr)=>{
            if (keyStr === 'right') options.next();
            if (keyStr === 'left') options.previous();
        }
    });
    (0, _showModal.showModal)({
        target: parentEl,
        message: `<b>${(0, _language.LANG)('layers-merge-modal-title')}</b>`,
        div: div,
        buttons: [
            'Ok',
            'Cancel'
        ],
        clickOnEnter: 'Ok',
        callback: (val)=>{
            keyListener.destroy();
            options.destroy();
            if (val === 'Ok') p.callback(options.getValue());
        }
    });
}

},{"../../../../bb/bb":"3zOvT","../../../../language/language":"mcywn","../../components/options":"7kiPU","../../../canvas/translate-blending":"l3XnR","../../modals/base/showModal":"gy3iL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c4Lqy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DropdownMenu", ()=>DropdownMenu);
var _c = require("../../../bb/base/c");
var _ui = require("../../../bb/base/ui");
class DropdownMenu {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isExpanded = false;
        this.onSetEnabled = ()=>0;
        const button = (0, _c.c)('button,w-full,h-full', [
            p.button
        ]);
        button.onclick = ()=>{
            toggle(!this.isExpanded);
        };
        if (p.buttonTitle) button.title = p.buttonTitle;
        (0, _ui.makeUnfocusable)(button);
        const items = [];
        const itemMap = {};
        p.items.forEach((item)=>{
            const itemButton = (0, _c.c)('button', item[1]);
            (0, _ui.makeUnfocusable)(itemButton);
            itemButton.onclick = ()=>{
                toggle(false);
                p.onItemClick(item[0]);
            };
            items.push(itemButton);
            itemMap[item[0]] = itemButton;
        });
        this.onSetEnabled = (id, enabled)=>{
            itemMap[id].disabled = !enabled;
        };
        const menu = (0, _c.c)('.kl-dropdown-menu,right-0,top-full,nowrap,hidden', items);
        this.rootElement = (0, _c.c)(',pos-relative', [
            button,
            menu
        ]);
        const toggle = (force)=>{
            this.isExpanded = force;
            menu.style.display = this.isExpanded ? '' : 'none';
            if (this.isExpanded) {
                document.addEventListener('pointerdown', onPointerDown, {
                    passive: false
                });
                window.addEventListener('blur', onBlur);
            } else {
                document.removeEventListener('pointerdown', onPointerDown);
                window.removeEventListener('blur', onBlur);
            }
        };
        const onPointerDown = (e)=>{
            const target = e.target;
            if (button.contains(target) || menu.contains(target)) return;
            toggle(false);
        };
        const onBlur = ()=>toggle(false);
    }
    getElement() {
        return this.rootElement;
    }
    setEnabled(id, enabled) {
        this.onSetEnabled(id, enabled);
    }
}

},{"../../../bb/base/c":"3KmDH","../../../bb/base/ui":"5dJJW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j8xyr":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("add-layer.37588650.svg") + "?" + Date.now();

},{}],"a5dmW":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("duplicate-layer.2d570064.svg") + "?" + Date.now();

},{}],"dc01L":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("merge-layers.7ab3b9d8.svg") + "?" + Date.now();

},{}],"4D5To":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("rename-layer.5136b61a.svg") + "?" + Date.now();

},{}],"caVqF":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("caret-down.438553b3.svg") + "?" + Date.now();

},{}],"2vGJF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * preview of image with layers. can do mix modes and opacity.
 * creates a canvas.
 */ parcelHelpers.export(exports, "KlCanvasPreview", ()=>KlCanvasPreview);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class KlCanvasPreview {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.layers = p.layers;
        const scale = p.width / p.layers[0].image.width;
        const width = scale > 1 ? p.layers[0].image.width : p.width;
        const height = scale > 1 ? p.layers[0].image.height : p.height;
        this.canvas = (0, _bb.BB).canvas(width, height);
        this.ctx = (0, _bb.BB).ctx(this.canvas);
        (0, _base.css)(this.canvas, {
            width: '100%',
            height: '100%',
            imageRendering: scale > 1 ? 'pixelated' : undefined,
            background: 'var(--kl-checkerboard-background)',
            backgroundSize: '16px'
        });
        setTimeout(()=>this.render(), 0);
    }
    getElement() {
        return this.canvas;
    }
    render() {
        if (!this.ctx) return;
        this.ctx.save();
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for(let i = 0; i < this.layers.length; i++){
            const layer = this.layers[i];
            if (!layer.isVisible || layer.opacity === 0) continue;
            this.ctx.globalAlpha = this.layers[i].opacity;
            this.ctx.globalCompositeOperation = this.layers[i].mixModeStr;
            if (this.canvas.width > this.layers[i].image.width) this.ctx.imageSmoothingEnabled = false;
            this.ctx.drawImage(this.layers[i].image, 0, 0, this.canvas.width, this.canvas.height);
        }
        this.ctx.restore();
    }
    destroy() {}
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2fR2j":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Free Transform UI
 * rotate, scale, translate
 *
 * - if rotation is multiple of 90 it will snap to pixels, to be more useful for pixel art
 * - when rotation goes from non-multiple of 90 to a multiple, it will snap position and width height to pixels
 * - transform.x, transform.y can sit between pixels (by 0.5) if width or height is odd number.
 *      - this is what complicates things
 * - if transform region small, corner grips move out of the way
 *
 * iX iY, iP.x, iP.y - i indicates image space
 * tX tY, tP.x, tP.y - t indicates transform space
 *
 * Not sure if it can be used for navigable canvas. (especially if canvas rotates view)
 * Probably can't be extended for distort. Needs a different approach.
 *
 * --- DOM structure ---
 * rootEl {
 * 	transEl [
 * 		boundsEl
 * 		edges[]
 * 		corners[] - round grips in the corner of transform region
 * 		angleGrip
 * 	]
 * }
 *
 */ parcelHelpers.export(exports, "FreeTransform", ()=>FreeTransform);
var _bb = require("../../../bb/bb");
var _cursorRotatePng = require("url:/src/app/img/ui/cursor-rotate.png");
var _cursorRotatePngDefault = parcelHelpers.interopDefault(_cursorRotatePng);
var _freeTransformUtils = require("./free-transform-utils");
var _base = require("../../../bb/base/base");
class FreeTransform {
    updateScaled() {
        this.scaled.x = this.value.x * this.viewportTransform.scale;
        this.scaled.y = this.value.y * this.viewportTransform.scale;
        this.scaled.width = this.value.width * this.viewportTransform.scale;
        this.scaled.height = this.value.height * this.viewportTransform.scale;
        this.scaled.corners = this.corners.map((item)=>{
            return {
                x: item.x * this.viewportTransform.scale,
                y: item.y * this.viewportTransform.scale
            };
        });
    }
    /**
     * Returns snapped point, if ix, iy snaps. If no snapping, returns point unchanged.
     * both in image space
     *
     * @param iX - image space
     * @param iY - image space
     * @private
     */ snapCorner(iX, iY) {
        if (!this.snappingEnabled) return {
            x: iX,
            y: iY
        };
        let dist;
        const snap = {
            x: undefined,
            y: undefined,
            dist: {
                x: undefined,
                y: undefined
            }
        };
        for(let e = 0; e < this.snapX.length; e++){
            dist = Math.abs(iX - this.snapX[e]);
            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                if (snap.x === undefined || dist < snap.dist.x) {
                    snap.x = this.snapX[e];
                    snap.dist.x = dist;
                }
            }
        }
        for(let e = 0; e < this.snapY.length; e++){
            dist = Math.abs(iY - this.snapY[e]);
            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                if (snap.y === undefined || dist < snap.dist.y) {
                    snap.y = this.snapY[e];
                    snap.dist.y = dist;
                }
            }
        }
        if (snap.x === undefined && snap.y === undefined) return {
            x: iX,
            y: iY
        };
        return {
            x: snap.x ?? iX,
            y: snap.y ?? iY
        };
    }
    /**
     * If constrained return nearest corner pos that fits aspect ratio
     *
     * @param cornerIndex
     * @param iX
     * @param iY
     * @private
     */ constrainCorner(cornerIndex, iX, iY) {
        if (!this.isConstrained) return {
            x: iX,
            y: iY
        };
        const flip = this.value.width * this.value.height < 0 ? -1 : 1;
        return (0, _bb.BB).projectPointOnLine({
            x: this.value.x,
            y: this.value.y
        }, (0, _freeTransformUtils.toImageSpace)(this.ratio, flip * ([
            0,
            2
        ].includes(cornerIndex) ? 1 : -1), this.value), {
            x: iX,
            y: iY
        });
    }
    /**
     * Update corners according to width height.
     * Not their DOM.
     */ updateCornerPositions() {
        this.corners[0].x = -this.value.width / 2; // top left
        this.corners[0].y = -this.value.height / 2;
        this.corners[1].x = this.value.width / 2; // top right
        this.corners[1].y = -this.value.height / 2;
        this.corners[2].x = this.value.width / 2; // bottom right
        this.corners[2].y = this.value.height / 2;
        this.corners[3].x = -this.value.width / 2; // bottom left
        this.corners[3].y = this.value.height / 2;
    }
    /**
     * If constrained and dragging an edge, restore aspect ratio
     * Updates corner positions.
     *
     * @param widthChanged
     * @param heightChanged
     * @private
     */ restoreRatio(widthChanged, heightChanged) {
        if (!this.isConstrained) return;
        const angle90 = Math.abs(this.value.angleDeg) % 90 === 0;
        const whSwapped = Math.abs(this.value.angleDeg - 90) % 180 === 0;
        if (heightChanged && !widthChanged) {
            const newHeight = Math.abs(this.corners[3].y - this.corners[0].y);
            let newWidth = this.ratio * newHeight;
            if (angle90) newWidth = (whSwapped ? this.value.y % 1 : this.value.x % 1) === 0 ? (0, _bb.BB).roundEven(newWidth) : (0, _bb.BB).roundUneven(newWidth);
            if (this.corners[1].x - this.corners[0].x < 0) newWidth *= -1;
            this.corners[0].x = -newWidth / 2;
            this.corners[3].x = -newWidth / 2;
            this.corners[1].x = newWidth / 2;
            this.corners[2].x = newWidth / 2;
        }
        if (!heightChanged && widthChanged) {
            const newWidth = Math.abs(this.corners[0].x - this.corners[1].x);
            let newHeight = newWidth / this.ratio;
            if (angle90) newHeight = (whSwapped ? this.value.x % 1 : this.value.y % 1) === 0 ? (0, _bb.BB).roundEven(newHeight) : (0, _bb.BB).roundUneven(newHeight);
            if (this.corners[3].y - this.corners[0].y < 0) newHeight *= -1;
            this.corners[0].y = -newHeight / 2;
            this.corners[1].y = -newHeight / 2;
            this.corners[2].y = newHeight / 2;
            this.corners[3].y = newHeight / 2;
        }
    }
    /**
     * update transform based on corners
     * @private
     */ updateTransformViaCorners() {
        // calc transform center in image space
        const rot = (0, _bb.BB).rotateAround({
            x: 0,
            y: 0
        }, {
            x: (this.corners[0].x + this.corners[1].x) / 2,
            y: (this.corners[0].y + this.corners[3].y) / 2
        }, this.value.angleDeg);
        this.value.x = rot.x + this.value.x;
        this.value.y = rot.y + this.value.y;
        // update size
        this.value.width = this.corners[1].x - this.corners[0].x;
        this.value.height = this.corners[3].y - this.corners[0].y;
        // new center means corners changed their position
        this.updateCornerPositions();
        this.updateDOM();
    }
    /**
     * updates DOM according to transform
     * @param skipCallback
     */ updateDOM(skipCallback) {
        this.updateScaled();
        (0, _base.css)(this.transEl, {
            left: this.viewportTransform.x + this.scaled.x + 'px',
            top: this.viewportTransform.y + this.scaled.y + 'px',
            transformOrigin: '0 0',
            transform: 'rotate(' + this.value.angleDeg + 'deg)'
        });
        (0, _base.css)(this.boundsEl, {
            width: Math.abs(this.scaled.width) + 'px',
            height: Math.abs(this.scaled.height) + 'px',
            left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + 'px',
            top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + 'px'
        });
        this.corners[0].updateDOM();
        this.corners[1].updateDOM();
        this.corners[2].updateDOM();
        this.corners[3].updateDOM();
        this.edges[0].updateDOM();
        this.edges[1].updateDOM();
        this.edges[2].updateDOM();
        this.edges[3].updateDOM();
        this.angleGrip.x = 0;
        this.angleGrip.y = -Math.abs(this.value.height * this.viewportTransform.scale) / 2 - 20;
        this.angleGrip.updateDOM();
        if (!skipCallback) {
            if (this.callback) // why should updateDOM trigger the callback?
            this.callback((0, _freeTransformUtils.copyTransform)(this.value));
        }
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.scaled = {
            // scaled coordinates and dimensions for screen space
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            corners: [
                {
                    x: 0,
                    y: 0
                }
            ]
        };
        this.minSnapDist = 7 // minimal snapping distance in px screen space
        ;
        this.cornerCursors = [
            'nw',
            'n',
            'ne',
            'e',
            'se',
            's',
            'sw',
            'w'
        ];
        this.gripSize = 16;
        this.edgeSize = 10;
        this.corners = [];
        this.edges = [];
        this.viewportTransform = {
            ...p.viewportTransform
        };
        this.value = {
            // coordinates and dimensions of transformation
            x: p.x,
            y: p.y,
            width: p.width,
            height: p.height,
            angleDeg: p.angleDeg
        };
        this.isConstrained = p.isConstrained;
        this.snapX = p.snapX;
        this.snapY = p.snapY;
        this.callback = p.callback;
        this.snappingEnabled = true;
        this.ratio = this.value.width / this.value.height;
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-free-transform',
            css: {
                userSelect: 'none'
            }
        });
        this.transEl = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                position: 'absolute'
            }
        });
        this.boundsEl = (0, _bb.BB).el({
            css: {
                position: 'absolute',
                cursor: 'move',
                boxShadow: 'rgba(255, 255, 255, 0.5) 0 0 0 1px inset, rgba(0, 0, 0, 0.5) 0 0 0 1px'
            }
        });
        const pointerRemainder = {
            x: 0,
            y: 0
        };
        function resetRemainder() {
            pointerRemainder.x = 0;
            pointerRemainder.y = 0;
        }
        this.keyListener = new (0, _bb.BB).KeyListener({});
        let boundsStartP = {
            x: 0,
            y: 0
        };
        this.boundsPointerListener = new (0, _bb.BB).PointerListener({
            target: this.boundsEl,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointerdown') boundsStartP = {
                    x: this.value.x,
                    y: this.value.y
                };
                if (event.type === 'pointermove' && event.button === 'left') {
                    this.value.x = boundsStartP.x + (event.pageX - event.downPageX) / this.viewportTransform.scale;
                    this.value.y = boundsStartP.y + (event.pageY - event.downPageY) / this.viewportTransform.scale;
                    let dist;
                    let snap = {
                        distX: -1,
                        distY: -1
                    };
                    if (this.snappingEnabled) {
                        let i;
                        for(i = 0; i < this.snapX.length; i++){
                            dist = Math.abs(this.value.x - this.snapX[i]);
                            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                if (snap.x === undefined || dist < snap.distX) {
                                    snap.x = this.snapX[i];
                                    snap.distX = dist;
                                }
                            }
                        }
                        for(i = 0; i < this.snapY.length; i++){
                            dist = Math.abs(this.value.y - this.snapY[i]);
                            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                if (snap.y === undefined || dist < snap.distY) {
                                    snap.y = this.snapY[i];
                                    snap.distY = dist;
                                }
                            }
                        }
                        let iP;
                        for(i = 0; i < 4; i++){
                            iP = (0, _freeTransformUtils.toImageSpace)(this.corners[i].x, this.corners[i].y, this.value);
                            let j;
                            for(j = 0; j < this.snapX.length; j++){
                                dist = Math.abs(iP.x - this.snapX[j]);
                                if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                    if (snap.x === undefined || dist < snap.distX) {
                                        snap.x = this.snapX[j] - (iP.x - this.value.x);
                                        snap.distX = dist;
                                    }
                                }
                            }
                            for(j = 0; j < this.snapY.length; j++){
                                dist = Math.abs(iP.y - this.snapY[j]);
                                if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                    if (snap.y === undefined || dist < snap.distY) {
                                        snap.y = this.snapY[j] - (iP.y - this.value.y);
                                        snap.distY = dist;
                                    }
                                }
                            }
                        }
                    }
                    if (this.keyListener.getComboStr() === 'shift') {
                        let projected = (0, _bb.BB).projectPointOnLine({
                            x: 0,
                            y: boundsStartP.y
                        }, {
                            x: 10,
                            y: boundsStartP.y
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        let dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: 0
                        }, {
                            x: boundsStartP.x,
                            y: 10
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        if (dist < snap.distX) snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y + 1
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        if (dist < snap.distX) snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y - 1
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        if (dist < snap.distX) snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                    }
                    if (snap.x != undefined) this.value.x = snap.x;
                    if (snap.y != undefined) this.value.y = snap.y;
                    // snap to pixels
                    if (Math.abs(this.value.angleDeg) % 90 === 0) {
                        (0, _freeTransformUtils.snapToPixel)(this.value);
                        this.updateCornerPositions();
                    }
                    this.updateDOM();
                }
            }
        });
        for(let i = 0; i < 4; i++)((i)=>{
            const g = this.corners[i] = {
                i: i,
                el: (0, _bb.BB).el({
                    css: {
                        width: this.gripSize + 'px',
                        height: this.gripSize + 'px',
                        background: '#fff',
                        /*background: [
                                '#ff0000',
                                '#00ff00',
                                '#0000ff',
                                '#ff00ff',
                            ][i],*/ borderRadius: this.gripSize + 'px',
                        position: 'absolute',
                        border: '2px solid #000'
                    }
                }),
                x: 0,
                y: 0,
                virtualPos: {
                    x: 0,
                    y: 0
                }
            };
            g.updateDOM = ()=>{
                // grip position
                // if it gets small: slightly offset grips, so easier to handle
                const offsetArr = [
                    [
                        -1,
                        -1
                    ],
                    [
                        1,
                        -1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        1
                    ]
                ].map((item)=>{
                    item[0] *= this.value.width > 0 ? 1 : -1;
                    item[1] *= this.value.height > 0 ? 1 : -1;
                    return item;
                });
                const tinyOffset = Math.abs(this.scaled.width) < 20 || Math.abs(this.scaled.height) < 20 ? 10 : 0;
                (0, _base.css)(g.el, {
                    left: this.scaled.corners[g.i].x - this.gripSize / 2 + offsetArr[i][0] * tinyOffset + 'px',
                    top: this.scaled.corners[g.i].y - this.gripSize / 2 + offsetArr[i][1] * tinyOffset + 'px'
                });
                // cursor
                let angle = (0, _bb.BB).pointsToAngleDeg({
                    x: this.value.x,
                    y: this.value.y
                }, (0, _freeTransformUtils.toImageSpace)(g.x, g.y, this.value)) + 135; // offset so nw is 0
                while(angle < 0)angle += 360;
                const index = Math.round(angle / 45) % this.cornerCursors.length;
                (0, _base.css)(g.el, {
                    cursor: this.cornerCursors[index] + '-resize'
                });
            };
            g.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.corners[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === 'pointerdown' && event.button === 'left') this.corners[i].virtualPos = (0, _freeTransformUtils.toImageSpace)(this.corners[i].x, this.corners[i].y, this.value);
                    else if (event.type === 'pointermove' && event.button === 'left') {
                        this.corners[i].virtualPos.x += event.dX / this.viewportTransform.scale;
                        this.corners[i].virtualPos.y += event.dY / this.viewportTransform.scale;
                        let iP = {
                            x: this.corners[i].virtualPos.x,
                            y: this.corners[i].virtualPos.y
                        };
                        iP = this.constrainCorner(i, iP.x, iP.y);
                        if (!this.isConstrained) iP = this.snapCorner(iP.x, iP.y);
                        if (Math.abs(this.value.angleDeg) % 90 === 0) {
                            iP.x = Math.round(iP.x);
                            iP.y = Math.round(iP.y);
                        }
                        const tP = (0, _freeTransformUtils.toTransformSpace)(iP.x, iP.y, this.value);
                        const dX = tP.x - this.corners[i].x;
                        const dY = tP.y - this.corners[i].y;
                        this.corners[i].x = tP.x;
                        this.corners[i].y = tP.y;
                        let indexes = [];
                        if (i === 0) // top left
                        indexes = [
                            3,
                            1,
                            2
                        ];
                        else if (i === 1) // top right
                        indexes = [
                            2,
                            0,
                            3
                        ];
                        else if (i === 2) // bottom right
                        indexes = [
                            1,
                            3,
                            0
                        ];
                        else if (i === 3) // bottom left
                        indexes = [
                            0,
                            2,
                            1
                        ];
                        this.corners[indexes[0]].x = this.corners[i].x;
                        this.corners[indexes[1]].y = this.corners[i].y;
                        if (this.keyListener.isPressed('shift')) {
                            this.corners[indexes[2]].x -= dX;
                            this.corners[indexes[2]].y -= dY;
                            this.corners[indexes[1]].x = this.corners[indexes[2]].x;
                            this.corners[indexes[0]].y = this.corners[indexes[2]].y;
                        }
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i);
        this.updateCornerPositions();
        this.updateScaled();
        let isInverted;
        for(let i = 0; i < 4; i++)((i)=>{
            this.edges[i] = {
                el: (0, _bb.BB).el({
                    css: {
                        width: this.edgeSize + 'px',
                        height: this.edgeSize + 'px',
                        /*background: [
                                '#ff000044',
                                '#00ff0044',
                                '#0000ff44',
                                '#ff00ff44',
                            ][i],*/ position: 'absolute'
                    }
                })
            };
            const g = this.edges[i];
            g.updateDOM = ()=>{
                if (i === 0) (0, _base.css)(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + 'px',
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) - this.edgeSize + 'px',
                    width: Math.abs(this.scaled.width) + 'px',
                    height: this.edgeSize + 'px'
                });
                else if (i === 1) (0, _base.css)(g.el, {
                    left: Math.max(this.scaled.corners[0].x, this.scaled.corners[1].x) + 'px',
                    top: Math.min(this.scaled.corners[1].y, this.scaled.corners[2].y) + 'px',
                    width: this.edgeSize + 'px',
                    height: Math.abs(this.scaled.height) + 'px'
                });
                else if (i === 2) (0, _base.css)(g.el, {
                    left: Math.min(this.scaled.corners[3].x, this.scaled.corners[2].x) + 'px',
                    top: Math.max(this.scaled.corners[0].y, this.scaled.corners[3].y) + 'px',
                    width: Math.abs(this.scaled.width) + 'px',
                    height: this.edgeSize + 'px'
                });
                else if (i === 3) (0, _base.css)(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) - this.edgeSize + 'px',
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + 'px',
                    width: this.edgeSize + 'px',
                    height: Math.abs(this.scaled.height) + 'px'
                });
                let angleOffset = Math.round(this.value.angleDeg / 45);
                while(angleOffset < 0)angleOffset += 8;
                angleOffset = (i * 2 + 1 + angleOffset) % this.cornerCursors.length;
                g.el.style.cursor = this.cornerCursors[angleOffset] + '-resize';
            };
            const isVertical = [
                0,
                2
            ].includes(i);
            g.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.edges[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === 'pointerdown' && event.button === 'left') {
                        if (isVertical) // top bottom
                        isInverted = this.corners[0].y >= this.corners[3].y;
                        else // left right
                        isInverted = this.corners[0].x >= this.corners[1].x;
                        resetRemainder();
                    }
                    if (event.type === 'pointermove' && event.button === 'left') {
                        const tfD = (0, _bb.BB).rotateAround({
                            x: 0,
                            y: 0
                        }, {
                            x: event.dX / this.viewportTransform.scale,
                            y: event.dY / this.viewportTransform.scale
                        }, -this.value.angleDeg);
                        let ti = {
                            dX: tfD.x,
                            dY: tfD.y
                        };
                        if (Math.abs(this.value.angleDeg) % 90 === 0) ti = (0, _bb.BB).intDxy(pointerRemainder, tfD.x, tfD.y);
                        let indexes = [];
                        if (i === 0) // top
                        indexes = [
                            2,
                            3,
                            0,
                            1
                        ];
                        else if (i === 1) // right
                        indexes = [
                            0,
                            3,
                            1,
                            2
                        ];
                        else if (i === 2) // bottom
                        indexes = [
                            0,
                            1,
                            2,
                            3
                        ];
                        else if (i === 3) // left
                        indexes = [
                            1,
                            2,
                            0,
                            3
                        ];
                        const dimension = isVertical ? 'y' : 'x';
                        const d = isVertical ? ti.dY : ti.dX;
                        if (isInverted) {
                            this.corners[indexes[0]][dimension] += d;
                            this.corners[indexes[1]][dimension] += d;
                        } else {
                            this.corners[indexes[2]][dimension] += d;
                            this.corners[indexes[3]][dimension] += d;
                        }
                        if (this.keyListener.isPressed('shift')) {
                            if (isInverted) {
                                this.corners[indexes[2]][dimension] -= d;
                                this.corners[indexes[3]][dimension] -= d;
                            } else {
                                this.corners[indexes[0]][dimension] -= d;
                                this.corners[indexes[1]][dimension] -= d;
                            }
                        }
                        if (isVertical) // top bottom
                        this.restoreRatio(false, true);
                        else // left right
                        this.restoreRatio(true, false);
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i);
        this.angleGrip = {
            el: (0, _bb.BB).el({
                css: {
                    cursor: 'url(' + (0, _cursorRotatePngDefault.default) + ') 10 10, move',
                    width: this.gripSize + 'px',
                    height: this.gripSize + 'px',
                    background: '#0ff',
                    borderRadius: this.gripSize + 'px',
                    position: 'absolute',
                    boxShadow: 'inset 0 0 0 2px #000'
                }
            }),
            x: 0,
            y: 0,
            snap: false,
            updateDOM: ()=>{
                (0, _base.css)(this.angleGrip.el, {
                    left: this.angleGrip.x - this.gripSize / 2 + 'px',
                    top: this.angleGrip.y - this.gripSize / 2 + 'px'
                });
            }
        };
        (0, _bb.BB).el({
            parent: this.angleGrip.el,
            css: {
                width: '2px',
                height: '13px',
                left: this.gripSize / 2 - 1 + 'px',
                top: this.gripSize + 'px',
                background: '#0ff',
                position: 'absolute'
            }
        });
        this.anglePointerListener = new (0, _bb.BB).PointerListener({
            target: this.angleGrip.el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const bounds = this.rootEl.getBoundingClientRect();
                    const offset = {
                        x: bounds.left - this.rootEl.scrollLeft + this.viewportTransform.x,
                        y: bounds.top - this.rootEl.scrollTop + this.viewportTransform.y
                    };
                    const iP = {
                        x: (event.clientX - offset.x) / this.viewportTransform.scale,
                        y: (event.clientY - offset.y) / this.viewportTransform.scale
                    };
                    const a = (0, _bb.BB).pointsToAngleDeg({
                        x: this.value.x,
                        y: this.value.y
                    }, iP) + 90;
                    this.value.angleDeg = a;
                    const snapDeg = Math.round(a / 360 * 8) * 45;
                    if (this.keyListener.getComboStr() === 'shift') this.value.angleDeg = snapDeg;
                    else if (this.snappingEnabled && Math.abs(snapDeg - a) < 8) this.value.angleDeg = snapDeg;
                    this.updateDOM();
                }
                if (event.type === 'pointerup') {
                    if (Math.abs(this.value.angleDeg) % 90 === 0) {
                        (0, _freeTransformUtils.snapToPixel)(this.value);
                        this.updateCornerPositions();
                        this.updateDOM();
                    }
                }
            }
        });
        (0, _freeTransformUtils.snapToPixel)(this.value);
        this.updateDOM(true);
        (0, _bb.BB).append(this.transEl, [
            this.boundsEl,
            this.edges[0].el,
            this.edges[1].el,
            this.edges[2].el,
            this.edges[3].el,
            this.corners[0].el,
            this.corners[1].el,
            this.corners[2].el,
            this.corners[3].el,
            this.angleGrip.el
        ]);
    }
    getValue() {
        return (0, _freeTransformUtils.copyTransform)(this.value);
    }
    setIsConstrained(b) {
        this.isConstrained = b;
        if (b && this.value.width !== 0 && this.value.height !== 0) this.ratio = Math.abs(this.value.width / this.value.height);
    }
    setSnapping(b) {
        this.snappingEnabled = b;
    }
    setPos(p) {
        this.value.x = p.x;
        this.value.y = p.y;
        this.updateDOM(true);
    }
    move(dX, dY) {
        this.value.x += dX;
        this.value.y += dY;
        this.updateDOM(false);
    }
    setSize(w, h) {
        this.value.width = w;
        this.value.height = h;
        if (Math.abs(this.value.angleDeg) % 90 === 0) (0, _freeTransformUtils.snapToPixel)(this.value);
        this.updateCornerPositions();
        this.updateDOM(false);
    }
    setAngleDeg(a) {
        this.value.angleDeg = a;
        if (Math.abs(this.value.angleDeg) % 90 === 0) {
            (0, _freeTransformUtils.snapToPixel)(this.value);
            this.updateCornerPositions();
        }
        this.updateDOM(true);
    }
    setViewportTransform(transform) {
        this.viewportTransform = transform;
        this.updateScaled();
        this.updateDOM();
    }
    getElement() {
        return this.rootEl;
    }
    getRatio() {
        return this.ratio;
    }
    destroy() {
        this.keyListener.destroy();
        this.boundsPointerListener.destroy();
        this.corners.forEach((item)=>item.pointerListener.destroy());
        this.edges.forEach((item)=>item.pointerListener.destroy());
        this.anglePointerListener.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","url:/src/app/img/ui/cursor-rotate.png":"hU1eL","./free-transform-utils":"9xZqc","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hU1eL":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("cursor-rotate.f5078486.png") + "?" + Date.now();

},{}],"9xZqc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * snap entire transform to pixel grid. changes transform
 *
 * for x y:
 * If a dimension has an even size, it will be an integer.
 * If it's uneven, it sits exactly half-way between two pixels.
 *
 * @param transform
 */ parcelHelpers.export(exports, "snapToPixel", ()=>snapToPixel);
parcelHelpers.export(exports, "copyTransform", ()=>copyTransform);
/**
 * image space to transform space
 * - origin of transform space is at center of transform bounds.
 * - same scale as image space. -> one unit is x: 1/width, y: 1/height
 * - up is where transform points up
 * - x goes right
 * - y goes down
 * @param x
 * @param y
 * @param transform
 */ parcelHelpers.export(exports, "toTransformSpace", ()=>toTransformSpace);
/**
 * transform space to image space
 * @param x
 * @param y
 * @param transform
 */ parcelHelpers.export(exports, "toImageSpace", ()=>toImageSpace);
var _bb = require("../../../bb/bb");
function snapToPixel(transform) {
    if (Math.abs(transform.angleDeg) % 90 !== 0) return;
    transform.width = Math.round(transform.width);
    transform.height = Math.round(transform.height);
    // 0 is original orientation.
    // At 90 and 270 width and height become swapped due to different orientation.
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    transform.x = (whSwapped ? transform.height : transform.width) % 2 === 0 ? Math.round(transform.x) : Math.round(transform.x - 0.5) + 0.5;
    transform.y = (whSwapped ? transform.width : transform.height) % 2 === 0 ? Math.round(transform.y) : Math.round(transform.y - 0.5) + 0.5;
}
function copyTransform(transform) {
    return {
        x: transform.x,
        y: transform.y,
        width: transform.width,
        height: transform.height,
        angleDeg: transform.angleDeg
    };
}
function toTransformSpace(x, y, transform) {
    let px, py;
    px = x - transform.x;
    py = y - transform.y;
    const rot = (0, _bb.BB).rotateAround({
        x: 0,
        y: 0
    }, {
        x: px,
        y: py
    }, -transform.angleDeg);
    px = rot.x;
    py = rot.y;
    return {
        x: px,
        y: py
    };
}
function toImageSpace(x, y, transform) {
    const rot = (0, _bb.BB).rotateAround({
        x: 0,
        y: 0
    }, {
        x: x,
        y: y
    }, transform.angleDeg);
    return {
        x: rot.x + transform.x,
        y: rot.y + transform.y
    };
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2itGC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * a basic canvas where you can transform one layer(move around, rotate, scale)
 */ parcelHelpers.export(exports, "FreeTransformCanvas", ()=>FreeTransformCanvas);
var _bb = require("../../../bb/bb");
var _freeTransform = require("./free-transform");
var _preview = require("../project-viewport/preview");
var _base = require("../../../bb/base/base");
class FreeTransformCanvas {
    updatePreview() {
        const transform = this.freeTransform.getValue();
        const ctx = (0, _bb.BB).ctx(this.previewCanvas);
        ctx.save();
        ctx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        (0, _bb.BB).drawTransformedImageWithBounds(ctx, this.layers[this.transformIndex].image, transform, undefined, this.algorithm === 'pixelated' || (0, _bb.BB).testShouldPixelate(transform, transform.width / this.initTransform.width, transform.height / this.initTransform.height));
        ctx.restore();
        this.preview.render();
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.algorithm = 'smooth';
        this.imageWidth = p.imageWidth;
        this.imageHeight = p.imageHeight;
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-preview-wrapper',
            css: {
                width: p.elementWidth + 'px',
                height: p.elementHeight + 'px'
            }
        });
        this.rootEl.oncontextmenu = ()=>{
            return false;
        };
        this.layers = p.layers;
        this.transformIndex = p.transformIndex;
        this.previewLayerArr = this.layers.map((item)=>{
            return {
                image: item.image,
                isVisible: item.isVisible,
                mixModeStr: item.mixModeStr ?? 'source-over',
                opacity: item.opacity,
                hasClipping: false
            };
        });
        this.previewCanvas = (0, _bb.BB).canvas(this.imageWidth, this.imageHeight);
        this.previewLayerArr[this.previewLayerArr.length - 1].image = this.previewCanvas;
        this.preview = new (0, _preview.Preview)({
            width: p.elementWidth,
            height: p.elementHeight,
            project: {
                width: p.imageWidth,
                height: p.imageHeight,
                layers: this.previewLayerArr
            },
            hasEditMode: true,
            onModeChange: (m)=>{
                (0, _base.css)(this.freeTransform.getElement(), {
                    pointerEvents: m === 'edit' ? '' : 'none',
                    opacity: m === 'edit' ? '' : '0.5'
                });
            },
            onTransformChange: (transform)=>{
                this.freeTransform.setViewportTransform(transform);
            },
            padding: 30
        });
        (0, _base.css)(this.preview.getElement(), {
            overflow: 'hidden',
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        this.rootEl.append(this.preview.getElement());
        this.initTransform = {
            x: this.imageWidth / 2,
            y: this.imageHeight / 2,
            width: this.layers[this.transformIndex].image.width,
            height: this.layers[this.transformIndex].image.height
        };
        this.freeTransform = new (0, _freeTransform.FreeTransform)({
            x: this.initTransform.x,
            y: this.initTransform.y,
            width: this.initTransform.width,
            height: this.initTransform.height,
            angleDeg: 0,
            isConstrained: true,
            snapX: [
                0,
                this.imageWidth
            ],
            snapY: [
                0,
                this.imageHeight
            ],
            viewportTransform: this.preview.getTransform(),
            callback: ()=>{
                this.updatePreview();
            }
        });
        this.preview.getElement().append(this.freeTransform.getElement());
        (0, _base.css)(this.freeTransform.getElement(), {
            position: 'absolute',
            left: '0',
            top: '0'
        });
        setTimeout(()=>this.updatePreview(), 0);
    }
    // ---- interface ----
    move(dX, dY) {
        this.freeTransform.move(dX, dY);
    }
    reset() {
        const w = this.layers[this.transformIndex].image.width;
        const h = this.layers[this.transformIndex].image.height;
        this.freeTransform.setSize(w, h);
        this.freeTransform.setPos({
            x: w / 2,
            y: h / 2
        });
        this.freeTransform.setAngleDeg(0);
        this.updatePreview();
    }
    setTransformFit() {
        const fit = (0, _bb.BB).fitInto(this.layers[this.transformIndex].image.width, this.layers[this.transformIndex].image.height, this.imageWidth, this.imageHeight, 1);
        this.freeTransform.setSize(fit.width, fit.height);
        this.freeTransform.setPos({
            x: fit.width / 2,
            y: fit.height / 2
        });
        this.freeTransform.setAngleDeg(0);
        this.updatePreview();
    }
    setTransformCenter() {
        this.freeTransform.setPos({
            x: this.imageWidth / 2,
            y: this.imageHeight / 2
        });
        this.freeTransform.setAngleDeg(0);
        this.updatePreview();
    }
    setAlgorithm(algo) {
        this.algorithm = algo;
        this.updatePreview();
    }
    /**
     * gives you the transformation in the original scale
     */ getTransformation() {
        return this.freeTransform.getValue();
    }
    getIsPixelated() {
        const transform = this.freeTransform.getValue();
        return this.algorithm === 'pixelated' || (0, _bb.BB).testShouldPixelate(transform, transform.width / this.initTransform.width, transform.height / this.initTransform.height);
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.freeTransform.destroy();
        this.preview.destroy();
        (0, _bb.BB).freeCanvas(this.previewCanvas);
    }
}

},{"../../../bb/bb":"3zOvT","./free-transform":"2fR2j","../project-viewport/preview":"j8zOr","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dNjUU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Interactive preview for crop filter. Corners and edges can be dragged.
 * the div that you append this to must be relative
 */ parcelHelpers.export(exports, "Cropper", ()=>Cropper);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class Cropper {
    update() {
        this.edges[0].update();
        this.edges[1].update();
        this.edges[2].update();
        this.edges[3].update();
        this.cornerElArr[0].update();
        this.cornerElArr[1].update();
        this.cornerElArr[2].update();
        this.cornerElArr[3].update();
        this.darken[0].update();
        this.darken[1].update();
        this.darken[2].update();
        this.darken[3].update();
        this.outline.update();
        this.thirdsHorizontal.update();
        this.thirdsVertical.update();
    }
    commit() {
        this.pointerRemainder.x = 0;
        this.pointerRemainder.y = 0;
        this.callback(this.getTransform());
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.x = p.x;
        this.y = p.y;
        this.width = p.width;
        this.height = p.height;
        this.scale = p.scale;
        this.callback = p.callback;
        const maxW = p.maxW;
        const maxH = p.maxW;
        this.rootEl = (0, _bb.BB).el();
        const gripCursors = [
            'nw',
            'n',
            'ne',
            'e',
            'se',
            's',
            'sw',
            'w'
        ];
        this.keyListener = new (0, _bb.BB).KeyListener({});
        (0, _base.css)(this.rootEl, {
            position: 'absolute',
            left: this.x * this.scale + 'px',
            top: this.y * this.scale + 'px'
        });
        this.outline = {
            el: (0, _bb.BB).el({
                css: {
                    position: 'absolute',
                    border: '1px dashed #fff',
                    cursor: 'move'
                }
            }),
            update: ()=>{
                (0, _base.css)(this.outline.el, {
                    left: this.grips[0].x * this.scale - 1 + 'px',
                    top: this.grips[0].y * this.scale - 1 + 'px',
                    width: (this.grips[2].x - this.grips[0].x) * this.scale + 'px',
                    height: (this.grips[2].y - this.grips[0].y) * this.scale + 'px'
                });
            }
        };
        this.pointerRemainder = {
            // needs to be reset after dragging complete
            x: 0,
            y: 0
        };
        this.outlinePointerListener = new (0, _bb.BB).PointerListener({
            target: this.outline.el,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    this.grips[0].x += dX;
                    this.grips[0].y += dY;
                    this.grips[1].x += dX;
                    this.grips[1].y += dY;
                    this.grips[2].x += dX;
                    this.grips[2].y += dY;
                    this.grips[3].x += dX;
                    this.grips[3].y += dY;
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        this.thirdsHorizontal = {
            el: (0, _bb.BB).el({
                css: {
                    position: 'absolute',
                    borderTop: '1px solid #0ff',
                    borderBottom: '1px solid #0ff'
                }
            }),
            update: ()=>{
                (0, _base.css)(this.thirdsHorizontal.el, {
                    left: this.grips[0].x * this.scale + 'px',
                    top: (this.grips[0].y + (this.grips[2].y - this.grips[0].y) / 3) * this.scale + 'px',
                    width: (this.grips[2].x - this.grips[0].x) * this.scale + 'px',
                    height: (this.grips[2].y - this.grips[0].y) / 3 * this.scale + 'px'
                });
            }
        };
        this.thirdsVertical = {
            el: (0, _bb.BB).el({
                css: {
                    position: 'absolute',
                    borderLeft: '1px solid #0ff',
                    borderRight: '1px solid #0ff'
                }
            }),
            update: ()=>{
                (0, _base.css)(this.thirdsVertical.el, {
                    left: (this.grips[0].x + (this.grips[2].x - this.grips[0].x) / 3) * this.scale + 'px',
                    top: this.grips[0].y * this.scale + 'px',
                    width: (this.grips[2].x - this.grips[0].x) / 3 * this.scale + 'px',
                    height: (this.grips[2].y - this.grips[0].y) * this.scale + 'px'
                });
            }
        };
        const gripSize = 40;
        const gripOverlay = 10;
        if (p.init) this.grips = [
            {
                x: p.init.x1,
                y: p.init.y1
            },
            {
                x: p.init.x2,
                y: p.init.y1
            },
            {
                x: p.init.x2,
                y: p.init.y2
            },
            {
                x: p.init.x1,
                y: p.init.y2
            }
        ];
        else this.grips = [
            {
                x: 0,
                y: 0
            },
            {
                x: this.width,
                y: 0
            },
            {
                x: this.width,
                y: this.height
            },
            {
                x: 0,
                y: this.height
            }
        ];
        const transformTop = (dY)=>{
            this.grips[0].y += dY;
            this.grips[0].y = (0, _bb.BB).clamp(this.grips[0].y, this.grips[3].y - maxH, this.grips[3].y - 1);
            this.grips[1].y = this.grips[0].y;
        };
        const transformRight = (dX)=>{
            this.grips[1].x += dX;
            this.grips[1].x = (0, _bb.BB).clamp(this.grips[1].x, this.grips[0].x + 1, this.grips[0].x + maxW);
            this.grips[2].x = this.grips[1].x;
        };
        const transformBottom = (dY)=>{
            this.grips[2].y += dY;
            this.grips[2].y = (0, _bb.BB).clamp(this.grips[2].y, this.grips[1].y + 1, this.grips[1].y + maxH);
            this.grips[3].y = this.grips[2].y;
        };
        const transformLeft = (dX)=>{
            this.grips[0].x += dX;
            this.grips[0].x = (0, _bb.BB).clamp(this.grips[0].x, this.grips[1].x - maxW, this.grips[1].x - 1);
            this.grips[3].x = this.grips[0].x;
        };
        this.edges = [];
        for(let i = 0; i < 4; i++)((i)=>{
            const el = (0, _bb.BB).el({
                css: {
                    width: gripSize + 'px',
                    height: gripSize + 'px',
                    //background: '#0f0',
                    position: 'absolute'
                }
            });
            const update = ()=>{
                if (i === 0) //top
                (0, _base.css)(el, {
                    left: this.grips[0].x * this.scale + gripOverlay + 'px',
                    top: this.grips[0].y * this.scale - gripSize * 2 + gripOverlay + 'px',
                    width: (this.grips[1].x - this.grips[0].x) * this.scale - gripOverlay * 2 + 'px',
                    height: gripSize * 2 + 'px'
                });
                else if (i === 1) //right
                (0, _base.css)(el, {
                    left: this.grips[1].x * this.scale - gripOverlay + 'px',
                    top: this.grips[1].y * this.scale + gripOverlay + 'px',
                    width: gripSize * 2 + 'px',
                    height: (this.grips[2].y - this.grips[1].y) * this.scale - gripOverlay * 2 + 'px'
                });
                else if (i === 2) //bottom
                (0, _base.css)(el, {
                    left: this.grips[3].x * this.scale + gripOverlay + 'px',
                    top: this.grips[3].y * this.scale - gripOverlay + 'px',
                    width: (this.grips[2].x - this.grips[3].x) * this.scale - gripOverlay * 2 + 'px',
                    height: gripSize * 2 + 'px'
                });
                else if (i === 3) //left
                (0, _base.css)(el, {
                    left: this.grips[0].x * this.scale - gripSize * 2 + gripOverlay + 'px',
                    top: this.grips[0].y * this.scale + gripOverlay + 'px',
                    width: gripSize * 2 + 'px',
                    height: (this.grips[3].y - this.grips[0].y) * this.scale - gripOverlay * 2 + 'px'
                });
                const angleOffset = i * 2 + 1;
                el.style.cursor = gripCursors[angleOffset] + '-resize';
            };
            this.edges[i] = {
                el,
                update
            };
        })(i);
        this.darken = [];
        for(let i = 0; i < 4; i++)((i)=>{
            const g = (0, _bb.BB).el({
                css: {
                    position: 'absolute',
                    background: '#000',
                    opacity: '0.5'
                }
            });
            const update = ()=>{
                if (i === 0) (0, _base.css)(g, {
                    left: this.grips[0].x * this.scale + 'px',
                    top: this.grips[0].y * this.scale - 8000 + 'px',
                    width: (this.grips[1].x - this.grips[0].x) * this.scale + 'px',
                    height: '8000px'
                });
                else if (i === 1) (0, _base.css)(g, {
                    left: this.grips[1].x * this.scale + 'px',
                    top: this.grips[1].y * this.scale - 8000 + 'px',
                    width: '8000px',
                    height: "16000px"
                });
                else if (i === 2) (0, _base.css)(g, {
                    left: this.grips[3].x * this.scale + 'px',
                    top: this.grips[3].y * this.scale + 'px',
                    width: (this.grips[2].x - this.grips[3].x) * this.scale + 'px',
                    height: '8000px'
                });
                else if (i === 3) (0, _base.css)(g, {
                    left: this.grips[0].x * this.scale - 8000 + 'px',
                    top: this.grips[0].y * this.scale - 8000 + 'px',
                    width: '8000px',
                    height: "16000px"
                });
            };
            this.darken[i] = {
                el: g,
                update
            };
        })(i);
        this.edge0PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[0].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformTop(dY);
                    if (this.keyListener.isPressed('shift')) transformBottom(-dY);
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        this.edge1PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[1].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformRight(dX);
                    if (this.keyListener.isPressed('shift')) transformLeft(-dX);
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        this.edge2PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[2].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformBottom(dY);
                    if (this.keyListener.isPressed('shift')) transformTop(-dY);
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        this.edge3PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[3].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformLeft(dX);
                    if (this.keyListener.isPressed('shift')) transformRight(-dX);
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        this.cornerElArr = [];
        (()=>{
            for(let i = 0; i < 4; i++)((i)=>{
                const g = (0, _bb.BB).el({
                    css: {
                        //background: '#f00',
                        width: gripSize * 2 + 'px',
                        height: gripSize * 2 + 'px',
                        position: 'absolute',
                        cursor: [
                            'nwse-resize',
                            'nesw-resize'
                        ][i % 2]
                    }
                });
                const update = ()=>{
                    if (i === 0) //top left
                    (0, _base.css)(g, {
                        left: this.grips[0].x * this.scale - gripSize * 2 + gripOverlay + 'px',
                        top: this.grips[0].y * this.scale - gripSize * 2 + gripOverlay + 'px'
                    });
                    else if (i === 1) //top right
                    (0, _base.css)(g, {
                        left: this.grips[1].x * this.scale - gripOverlay + 'px',
                        top: this.grips[1].y * this.scale - gripSize * 2 + gripOverlay + 'px'
                    });
                    else if (i === 2) //bottom right
                    (0, _base.css)(g, {
                        left: this.grips[1].x * this.scale - gripOverlay + 'px',
                        top: this.grips[2].y * this.scale - gripOverlay + 'px'
                    });
                    else if (i === 3) //bottom left
                    (0, _base.css)(g, {
                        left: this.grips[0].x * this.scale - gripSize * 2 + gripOverlay + 'px',
                        top: this.grips[2].y * this.scale - gripOverlay + 'px'
                    });
                };
                this.cornerElArr[i] = {
                    el: g,
                    update
                };
            })(i);
        })();
        //top left
        this.corner0PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[0].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformLeft(dX);
                    transformTop(dY);
                    if (this.keyListener.isPressed('shift')) {
                        transformRight(-dX);
                        transformBottom(-dY);
                    }
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        //top right
        this.corner1PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[1].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformRight(dX);
                    transformTop(dY);
                    if (this.keyListener.isPressed('shift')) {
                        transformLeft(-dX);
                        transformBottom(-dY);
                    }
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        //bottom right
        this.corner2PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[2].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformRight(dX);
                    transformBottom(dY);
                    if (this.keyListener.isPressed('shift')) {
                        transformLeft(-dX);
                        transformTop(-dY);
                    }
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        //bottom left
        this.corner3PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[3].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformLeft(dX);
                    transformBottom(dY);
                    if (this.keyListener.isPressed('shift')) {
                        transformRight(-dX);
                        transformTop(-dY);
                    }
                    this.update();
                }
                if (event.type === 'pointerup') this.commit();
            }
        });
        this.rootEl.append(this.darken[1].el, this.darken[0].el, this.darken[2].el, this.darken[3].el, this.thirdsHorizontal.el, this.thirdsVertical.el, this.outline.el, this.edges[1].el, this.edges[0].el, this.edges[2].el, this.edges[3].el, this.cornerElArr[0].el, this.cornerElArr[1].el, this.cornerElArr[2].el, this.cornerElArr[3].el);
        this.update();
    }
    // ---- interface ----
    getTransform() {
        this.grips[1].x -= this.grips[0].x;
        this.grips[1].y -= this.grips[0].y;
        this.grips[2].x -= this.grips[0].x;
        this.grips[2].y -= this.grips[0].y;
        this.grips[3].x -= this.grips[0].x;
        this.grips[3].y -= this.grips[0].y;
        this.x += this.grips[0].x;
        this.y += this.grips[0].y;
        this.grips[0].x = 0;
        this.grips[0].y = 0;
        return {
            x: this.x,
            y: this.y,
            width: this.grips[1].x,
            height: this.grips[2].y
        };
    }
    setTransform(p) {
        this.x = p.x;
        this.y = p.y;
        this.width = p.width;
        this.height = p.height;
        (0, _base.css)(this.rootEl, {
            left: this.x * this.scale + 'px',
            top: this.y * this.scale + 'px'
        });
        this.grips[0].x = 0;
        this.grips[0].y = 0;
        this.grips[1].x = this.width;
        this.grips[1].y = 0;
        this.grips[2].x = this.width;
        this.grips[2].y = this.height;
        this.grips[3].x = 0;
        this.grips[3].y = this.height;
        this.update();
        this.commit();
    }
    setScale(s) {
        this.scale = s;
        (0, _base.css)(this.rootEl, {
            left: this.x * this.scale + 'px',
            top: this.y * this.scale + 'px'
        });
        this.update();
    }
    showThirds(b) {
        this.thirdsHorizontal.el.style.display = b ? 'block' : 'none';
        this.thirdsVertical.el.style.display = b ? 'block' : 'none';
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.keyListener.destroy();
        this.outlinePointerListener.destroy();
        this.corner0PointerListener.destroy();
        this.corner1PointerListener.destroy();
        this.corner2PointerListener.destroy();
        this.corner3PointerListener.destroy();
        this.edge0PointerListener.destroy();
        this.edge1PointerListener.destroy();
        this.edge2PointerListener.destroy();
        this.edge3PointerListener.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aPNnS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Previews currently active layer
 * thumbnail (hover shows bigger preview), layer name, opacity
 *
 * internally listens to kl history. updates when there's a change.
 * but you need to update it when the active layer changed. (different canvas object)
 *
 * update visibility for performance
 */ parcelHelpers.export(exports, "LayerPreview", ()=>LayerPreview);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _theme = require("../../../theme/theme");
var _base = require("../../../bb/base/base");
class LayerPreview {
    updateCheckerPatterns() {
        const checker = (0, _bb.BB).createCheckerCanvas(4, (0, _theme.THEME).isDark());
        this.animationCanvasCheckerPattern = (0, _base.throwIfNull)(this.animationCanvasCtx.createPattern(checker, 'repeat'));
        this.largeCanvasCheckerPattern = (0, _base.throwIfNull)(this.canvasCtx.createPattern(checker, 'repeat'));
    }
    animate() {
        if (this.animationCount === 0) return;
        this.animationCount--;
        this.canvasCtx.save();
        this.canvasCtx.globalAlpha = Math.pow((this.animationLength - this.animationCount) / this.animationLength, 2);
        this.canvasCtx.drawImage(this.animationCanvas, 0, 0);
        this.canvasCtx.restore();
        if (this.animationCount > 0) requestAnimationFrame(()=>this.animate());
    }
    /**
     * is always instant
     */ drawLargeCanvas() {
        if (!this.largeCanvasIsVisible || !this.layer) return;
        const layerCanvas = this.layer.canvas;
        const canvasDimensions = (0, _bb.BB).fitInto(layerCanvas.width, layerCanvas.height, this.largeCanvasSize, this.largeCanvasSize, 1);
        this.largeCanvas.width = Math.round(canvasDimensions.width);
        this.largeCanvas.height = Math.round(canvasDimensions.height);
        this.largeCanvasCtx.save();
        if (this.largeCanvas.width > layerCanvas.width) this.largeCanvasCtx.imageSmoothingEnabled = false;
        else {
            this.largeCanvasCtx.imageSmoothingEnabled = true;
            this.largeCanvasCtx.imageSmoothingQuality = 'high';
        }
        this.largeCanvasCtx.fillStyle = this.largeCanvasCheckerPattern;
        this.largeCanvasCtx.fillRect(0, 0, this.largeCanvas.width, this.largeCanvas.height);
        this.largeCanvasCtx.drawImage(layerCanvas, 0, 0, this.largeCanvas.width, this.largeCanvas.height);
        this.largeCanvasCtx.restore();
        const bounds = this.rootEl.getBoundingClientRect();
        (0, _base.css)(this.largeCanvasWrapper, {
            top: Math.max(10, bounds.top + this.height / 2 - this.largeCanvas.height / 2) + 'px'
        });
    }
    updateLabel() {
        if (!this.isPreviewVisible || !this.layer) return;
        const layerIsVisible = this.layer.isVisible;
        this.checkEl.parentElement.title = layerIsVisible ? (0, _language.LANG)('layers-active-layer-visible') : (0, _language.LANG)('layers-active-layer-hidden');
        this.checkEl.checked = layerIsVisible;
        this.checkEl.style.boxShadow = layerIsVisible ? '' : '0 0 0 1px red';
        this.nameLabelEl.textContent = this.layer.name;
        if (this.layer.isVisible) this.opacityEl.innerHTML = (0, _language.LANG)('opacity') + '<br>' + Math.round(this.layer.opacity * 100) + '%';
        else this.opacityEl.innerHTML = (0, _language.LANG)('opacity') + '<br><s>' + Math.round(this.layer.opacity * 100) + '%</s>';
    }
    draw(isInstant) {
        if (!this.isPreviewVisible || !this.layer) return;
        this.updateLabel();
        const layerCanvas = this.layer.canvas;
        if (layerCanvas.width !== this.lastDrawnSize.width || layerCanvas.height !== this.lastDrawnSize.height) {
            const canvasDimensions = (0, _bb.BB).fitInto(layerCanvas.width, layerCanvas.height, this.canvasSize, this.canvasSize, 1);
            this.canvas.width = Math.round(canvasDimensions.width);
            this.canvas.height = Math.round(canvasDimensions.height);
            isInstant = true; // can't animate when size changed
        }
        this.animationCanvas.width = this.canvas.width;
        this.animationCanvas.height = this.canvas.height;
        this.animationCanvasCtx.save();
        this.animationCanvasCtx.imageSmoothingEnabled = false;
        this.animationCanvasCtx.fillStyle = this.animationCanvasCheckerPattern;
        this.animationCanvasCtx.fillRect(0, 0, this.animationCanvas.width, this.animationCanvas.height);
        this.animationCanvasCtx.drawImage(layerCanvas, 0, 0, this.animationCanvas.width, this.animationCanvas.height);
        this.animationCanvasCtx.restore();
        if (isInstant) {
            this.animationCount = 0;
            this.canvasCtx.save();
            this.canvasCtx.drawImage(this.animationCanvas, 0, 0);
            this.canvasCtx.restore();
        } else {
            this.animationCount = this.animationLength;
            this.animate();
        }
        this.drawLargeCanvas();
        this.lastDrawnState = this.klHistory.getChangeCount();
        this.lastDrawnSize.width = layerCanvas.width;
        this.lastDrawnSize.height = layerCanvas.height;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.animationCanvasCheckerPattern = {};
        this.largeCanvasCheckerPattern = {};
        // internally redraws with in an interval. checks history is something changed
        // this update will be animated
        // it will not be animated if the resolution changed
        // also redraws when you call updateLayer - not animated
        // syncs via updateLayer, and internally updates layer opacity via a hack
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-layer-preview'
        });
        this.klHistory = p.klHistory;
        this.isPreviewVisible = true;
        this.height = 40;
        this.canvasSize = this.height - 10;
        this.largeCanvasSize = 300;
        this.lastDrawnState = -2;
        this.lastDrawnSize = {
            width: 0,
            height: 0
        };
        this.animationCanvas = (0, _bb.BB).canvas(); // to help animate the transition
        this.animationCanvasCtx = (0, _bb.BB).ctx(this.animationCanvas);
        this.animationLength = 30;
        this.animationCount = 0;
        this.largeCanvasIsVisible = false;
        let largeCanvasAnimationTimeout;
        const largeCanvasAnimationDurationMs = 300;
        this.uiState = p.uiState;
        // --- setup dom ---
        this.contentWrapperEl = (0, _bb.BB).el({
            css: {
                display: 'flex',
                alignItems: 'center',
                height: this.height + 'px'
            }
        });
        const checkWrapper = (0, _bb.BB).el({
            css: {
                display: 'flex',
                justifyContent: 'flex-end',
                alignItems: 'center',
                width: '23px',
                flexShrink: '0'
            }
        });
        this.checkEl = (0, _bb.BB).el({
            parent: checkWrapper,
            tagName: 'input',
            css: {
                pointerEvents: 'none'
            },
            custom: {
                type: 'checkbox',
                disabled: 'true',
                name: 'layer-visible'
            }
        });
        const canvasWrapperEl = (0, _bb.BB).el({
            css: {
                //background: '#f00',
                minWidth: this.height + 'px',
                height: this.height + 'px',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center'
            }
        });
        this.canvas = (0, _bb.BB).canvas(this.canvasSize, this.canvasSize);
        this.canvasCtx = (0, _bb.BB).ctx(this.canvas);
        this.canvas.title = (0, _language.LANG)('layers-active-layer');
        const nameWrapper = (0, _bb.BB).el({
            css: {
                //background: '#ff0',
                flexGrow: '1',
                paddingLeft: '10px',
                fontSize: '13px',
                overflow: 'hidden',
                position: 'relative'
            }
        });
        this.nameLabelEl = (0, _bb.BB).el({
            content: '',
            css: {
                cssFloat: 'left',
                whiteSpace: 'nowrap'
            }
        });
        const clickableEl = (0, _bb.BB).el({
            css: {
                // background: 'rgba(0,255,0,0.6)',
                position: 'absolute',
                left: '10px',
                top: '0',
                width: '90px',
                height: '100%'
            }
        });
        if (p.onClick) {
            clickableEl.addEventListener('click', ()=>p.onClick(), {
                passive: false
            });
            this.canvas.addEventListener('click', ()=>p.onClick(), {
                passive: false
            });
            checkWrapper.addEventListener('click', ()=>p.onClick(), {
                passive: false
            });
        }
        this.opacityEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('opacity') + '<br>100%',
            css: {
                minWidth: '60px',
                fontSize: '12px',
                textAlign: 'center'
            }
        });
        this.largeCanvasWrapper = (0, _bb.BB).el({
            onClick: (0, _bb.BB).handleClick,
            css: {
                pointerEvents: 'none',
                background: '#fff',
                position: 'absolute',
                right: '280px',
                top: '10px',
                border: '1px solid #aaa',
                boxShadow: '1px 1px 3px rgba(0,0,0,0.3)',
                transition: 'opacity ' + largeCanvasAnimationDurationMs + 'ms ease-in-out',
                userSelect: 'none',
                display: 'block',
                ['webkitTouchCallout']: 'none'
            }
        });
        this.largeCanvas = (0, _bb.BB).canvas(this.largeCanvasSize, this.largeCanvasSize);
        this.largeCanvasWrapper.append(this.largeCanvas);
        this.largeCanvasCtx = (0, _bb.BB).ctx(this.largeCanvas);
        (0, _base.css)(this.largeCanvas, {
            display: 'block'
        });
        canvasWrapperEl.append(this.canvas);
        nameWrapper.append(this.nameLabelEl, clickableEl);
        this.contentWrapperEl.append(checkWrapper, canvasWrapperEl, nameWrapper, this.opacityEl);
        this.rootEl.append(this.contentWrapperEl);
        this.updateCheckerPatterns();
        (0, _theme.THEME).addIsDarkListener(()=>{
            this.updateCheckerPatterns();
            this.draw(true);
        });
        // --- update logic ---
        // cross-fade done via 2 canvases (old and new state)
        // both have checkerboard background drawn on them, both fully opaque
        // -> no "lighter" is needed for accurate cross-fading
        // label should update instantly
        this.klHistory.addListener(()=>{
            this.updateLabel();
        });
        setInterval(()=>{
            if (!this.layer) return;
            const currentState = this.klHistory.getChangeCount();
            if (currentState === this.lastDrawnState) return;
            this.draw(false);
        }, 2000);
        const removeLargeCanvas = ()=>{
            this.largeCanvasWrapper.remove();
        };
        const showLargeCanvas = (b)=>{
            if (this.largeCanvasIsVisible === b) return;
            clearTimeout(largeCanvasAnimationTimeout);
            this.largeCanvasIsVisible = b;
            if (b) largeCanvasAnimationTimeout = setTimeout(()=>{
                this.drawLargeCanvas();
                this.largeCanvasWrapper.style.opacity = '0';
                p.klRootEl.append(this.largeCanvasWrapper);
                setTimeout(()=>{
                    this.largeCanvasWrapper.style.opacity = '1';
                }, 20);
            }, 250);
            else {
                this.largeCanvasWrapper.style.opacity = '0';
                largeCanvasAnimationTimeout = setTimeout(removeLargeCanvas, largeCanvasAnimationDurationMs + 20);
            }
        };
        const pointerListener = new (0, _bb.BB).PointerListener({
            target: this.canvas,
            onEnterLeave: (b)=>{
                showLargeCanvas(b);
            }
        });
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    setIsVisible(b) {
        if (this.isPreviewVisible === b) return;
        this.isPreviewVisible = b;
        this.contentWrapperEl.style.display = this.isPreviewVisible ? 'flex' : 'none';
        this.rootEl.style.marginBottom = this.isPreviewVisible ? '' : '10px';
        const currentState = this.klHistory.getChangeCount();
        if (b && this.lastDrawnState !== currentState) this.draw(true);
    }
    //when the layer might have changed
    setLayer(layer) {
        this.layer = layer;
        this.draw(true);
    }
    setUiState(stateStr) {
        this.uiState = stateStr;
        if (this.uiState === 'left') (0, _base.css)(this.largeCanvasWrapper, {
            left: '280px',
            right: ''
        });
        else (0, _base.css)(this.largeCanvasWrapper, {
            left: '',
            right: '280px'
        });
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","../../../theme/theme":"cVh0j","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gebP9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showImportAsLayerDialog", ()=>showImportAsLayerDialog);
var _bb = require("../../../bb/bb");
var _freeTransformCanvas = require("../components/free-transform-canvas");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
var _testIsSmall = require("../utils/test-is-small");
var _previewSize = require("../utils/preview-size");
var _select = require("../components/select");
var _base = require("../../../bb/base/base");
function showImportAsLayerDialog(params) {
    const div = document.createElement('div');
    (0, _bb.BB).appendTextDiv(div, (0, _language.LANG)('import-as-layer-description'));
    if (params.klCanvas.isLayerLimitReached()) {
        const noteEl = (0, _bb.BB).el({
            className: 'kl-import-note',
            content: (0, _language.LANG)('import-as-layer-limit-reached')
        });
        div.append(noteEl);
    }
    const isSmall = (0, _testIsSmall.testIsSmall)();
    const buttonRowEl = (0, _bb.BB).el({
        css: {
            display: 'flex'
        }
    });
    const originalSizeBtn = (0, _bb.BB).el({
        tagName: 'button',
        content: '1:1',
        css: {
            marginRight: '10px'
        },
        onClick: function() {
            freeTransformCanvas.reset();
        }
    });
    const fitSizeBtn = (0, _bb.BB).el({
        tagName: 'button',
        content: (0, _language.LANG)('import-as-layer-fit'),
        css: {
            marginRight: '10px'
        },
        onClick: function() {
            freeTransformCanvas.setTransformFit();
        }
    });
    const centerBtn = (0, _bb.BB).el({
        tagName: 'button',
        content: (0, _language.LANG)('center'),
        css: {
            marginRight: '10px'
        },
        onClick: function() {
            freeTransformCanvas.setTransformCenter();
        }
    });
    const algorithmSelect = new (0, _select.Select)({
        isFocusable: true,
        optionArr: [
            [
                'smooth',
                (0, _language.LANG)('algorithm-smooth')
            ],
            [
                'pixelated',
                (0, _language.LANG)('algorithm-pixelated')
            ]
        ],
        initValue: 'smooth',
        title: (0, _language.LANG)('scaling-algorithm'),
        onChange: (val)=>{
            freeTransformCanvas.setAlgorithm(val);
        },
        name: 'interpolation-algorithm'
    });
    buttonRowEl.append(originalSizeBtn, fitSizeBtn, centerBtn, (0, _bb.BB).el({
        css: {
            flexGrow: '1'
        }
    }), algorithmSelect.getElement());
    div.append(buttonRowEl);
    const layers = [];
    {
        const klCanvasLayerArr = params.klCanvas.getLayers();
        for(let i = 0; i < klCanvasLayerArr.length; i++)layers.push({
            image: klCanvasLayerArr[i].context.canvas,
            isVisible: klCanvasLayerArr[i].isVisible,
            opacity: klCanvasLayerArr[i].opacity,
            mixModeStr: klCanvasLayerArr[i].mixModeStr
        });
    }
    layers.push({
        image: params.importImage,
        isVisible: true,
        opacity: 1,
        mixModeStr: 'source-over'
    });
    const freeTransformCanvas = new (0, _freeTransformCanvas.FreeTransformCanvas)({
        elementWidth: (0, _previewSize.getPreviewWidth)(isSmall),
        elementHeight: (0, _previewSize.getPreviewHeight)(isSmall) + 50,
        imageWidth: params.klCanvas.getLayerContext(0).canvas.width,
        imageHeight: params.klCanvas.getLayerContext(0).canvas.height,
        layers: layers,
        transformIndex: layers.length - 1
    });
    (0, _base.css)(freeTransformCanvas.getElement(), {
        marginTop: '10px',
        marginLeft: '-20px'
    });
    div.append(freeTransformCanvas.getElement());
    function move(x, y) {
        freeTransformCanvas.move(x, y);
    }
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr) {
            if (keyStr === 'left') move(-1, 0);
            if (keyStr === 'right') move(1, 0);
            if (keyStr === 'up') move(0, -1);
            if (keyStr === 'down') move(0, 1);
        }
    });
    (0, _showModal.showModal)({
        target: params.target,
        message: `<b>${(0, _language.LANG)('import-as-layer-title')}</b>`,
        div: div,
        style: isSmall ? undefined : {
            width: '540px'
        },
        buttons: [
            'Ok',
            'Cancel'
        ],
        clickOnEnter: 'Ok',
        callback: function(buttonStr) {
            keyListener.destroy();
            freeTransformCanvas.destroy();
            (0, _bb.BB).destroyEl(originalSizeBtn);
            (0, _bb.BB).destroyEl(fitSizeBtn);
            (0, _bb.BB).destroyEl(centerBtn);
            if (buttonStr === 'Ok') params.callback(freeTransformCanvas.getTransformation(), freeTransformCanvas.getIsPixelated());
            else params.callback();
        }
    });
}

},{"../../../bb/bb":"3zOvT","../components/free-transform-canvas":"2itGC","./base/showModal":"gy3iL","../../../language/language":"mcywn","../utils/test-is-small":"5jelf","../utils/preview-size":"eOdff","../components/select":"iuUFh","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5jelf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "testIsSmall", ()=>testIsSmall);
function testIsSmall() {
    return window.innerWidth < 550;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eOdff":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SMALL_PREVIEW", ()=>SMALL_PREVIEW);
parcelHelpers.export(exports, "MEDIUM_PREVIEW", ()=>MEDIUM_PREVIEW);
parcelHelpers.export(exports, "getPreviewWidth", ()=>getPreviewWidth);
parcelHelpers.export(exports, "getPreviewHeight", ()=>getPreviewHeight);
const SMALL_PREVIEW = {
    width: 340,
    height: 220
};
const MEDIUM_PREVIEW = {
    width: 540,
    height: 300
};
function getPreviewWidth(isSmall) {
    return isSmall ? SMALL_PREVIEW.width : MEDIUM_PREVIEW.width;
}
function getPreviewHeight(isSmall) {
    return isSmall ? SMALL_PREVIEW.height : MEDIUM_PREVIEW.height;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dAMCR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Not really generalized. UI when you drag/drop an image into window.
 * The moment you create it, it will listen.
 * */ parcelHelpers.export(exports, "KlImageDropper", ()=>KlImageDropper);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
class KlImageDropper {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        //set up DOM
        this.rootEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('dropper-drop'),
            css: {
                paddingTop: '100px',
                position: 'fixed',
                left: '0',
                top: '0',
                width: '100%',
                height: '100%',
                background: 'rgba(50, 50, 50, 0.7)',
                color: '#fff',
                textShadow: '2px 2px #000',
                textAlign: 'center',
                fontSize: '25px'
            }
        });
        const wrapperEl = (0, _bb.BB).el({
            css: {
                marginTop: '50px',
                display: 'flex',
                justifyContent: 'center'
            }
        });
        const optionStyle = {
            width: '200px',
            padding: '50px',
            margin: '10px',
            //opacity: 0.5,
            borderRadius: '20px',
            border: '1px dashed #fff',
            background: '#00aefe',
            fontWeight: 'bold'
        };
        const optionLayerEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('dropper-as-layer'),
            css: optionStyle
        });
        const optionImageEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('dropper-as-image'),
            css: optionStyle
        });
        this.rootEl.append(wrapperEl);
        wrapperEl.append(optionLayerEl, optionImageEl);
        let rootCounter = 0;
        let optionLayerCounter = 0;
        let optionImageCounter = 0;
        const destroy = ()=>{
            rootCounter = 0;
            optionLayerCounter = 0;
            optionImageCounter = 0;
            this.rootEl.remove();
        };
        /**
         * check, can drop content be imported
         */ const testAcceptType = (event)=>{
            return !!event.dataTransfer && !event.dataTransfer.types.includes('text/plain');
        };
        const updateOptions = ()=>{
            const boxShadow = '0 0 20px 4px #fff';
            if (optionLayerCounter > 0) {
                optionLayerEl.style.boxShadow = boxShadow;
                optionImageEl.style.boxShadow = '';
            } else if (optionImageCounter > 0) {
                optionLayerEl.style.boxShadow = '';
                optionImageEl.style.boxShadow = boxShadow;
            } else {
                optionLayerEl.style.boxShadow = '';
                optionImageEl.style.boxShadow = '';
            }
        };
        optionLayerEl.addEventListener('dragenter', ()=>{
            optionLayerCounter++;
            updateOptions();
        }, {
            passive: false
        });
        optionLayerEl.addEventListener('dragleave', ()=>{
            optionLayerCounter--;
            updateOptions();
        }, {
            passive: false
        });
        optionImageEl.addEventListener('dragenter', ()=>{
            optionImageCounter++;
            updateOptions();
        }, {
            passive: false
        });
        optionImageEl.addEventListener('dragleave', ()=>{
            optionImageCounter--;
            updateOptions();
        }, {
            passive: false
        });
        const rootDragOver = (event)=>{
            if (!testAcceptType(event)) return;
            event.stopPropagation();
            event.preventDefault();
        };
        const rootDragEnter = (event)=>{
            if (!p.enabledTest() || !testAcceptType(event)) return;
            if (rootCounter === 0) p.target.append(this.rootEl);
            rootCounter++;
        };
        const rootDragLeave = (event)=>{
            if (!testAcceptType(event) || rootCounter === 0) return;
            rootCounter = Math.max(0, rootCounter - 1);
            if (rootCounter === 0) this.rootEl.remove();
        };
        const rootDrop = (event)=>{
            if (!testAcceptType(event) || !event.dataTransfer || event.dataTransfer.files.length === 0) {
                destroy();
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            let optionStr = 'default';
            if (optionLayerCounter > 0) optionStr = 'layer';
            else if (optionImageCounter > 0) optionStr = 'image';
            p.onDrop(event.dataTransfer.files, optionStr);
            if (rootCounter > 0) this.rootEl.remove();
            rootCounter = 0;
            optionLayerCounter = 0;
            optionImageCounter = 0;
            updateOptions();
        };
        window.addEventListener('dragover', rootDragOver, {
            passive: false
        });
        window.addEventListener('dragenter', rootDragEnter, {
            passive: false
        });
        window.addEventListener('dragleave', rootDragLeave, {
            passive: false
        });
        window.addEventListener('drop', rootDrop, {
            passive: false
        });
        // if something goes wrong and you're stuck with overlay
        this.rootEl.addEventListener('pointerdown', ()=>{
            destroy();
        }, {
            passive: false
        });
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr)=>{
                if (rootCounter > 0 && keyStr === 'esc') destroy();
            }
        });
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gwFLq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Compressed HUD toolspace. When you hold ctrl+alt.
 * small color picker, brush settings
 */ parcelHelpers.export(exports, "OverlayToolspace", ()=>OverlayToolspace);
var _bb = require("../../../bb/bb");
var _klColorSliderSmall = require("./kl-color-slider-small");
var _klSlider = require("./kl-slider");
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
class OverlayToolspace {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        const sizeObj = {
            width: 150,
            svHeight: 90,
            hHeight: 20,
            sliderHeight: 25
        };
        let isVisible = false;
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-overlay-toolspace'
        });
        const queuedObj = {
            color: null,
            size: null,
            opacity: null
        };
        // --- inputs ---
        //color selection
        const colorEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'kl-overlay-toolspace__color'
        });
        const colorSlider = new (0, _klColorSliderSmall.KlColorSliderSmall)({
            width: sizeObj.width,
            heightSV: sizeObj.svHeight,
            heightH: sizeObj.hHeight,
            color: p.brushSettingService.getColor(),
            callback: (rgbObj)=>{
                selectedColorEl.style.backgroundColor = 'rgb(' + rgbObj.r + ',' + rgbObj.g + ',' + rgbObj.b + ')';
                p.brushSettingService.setColor(rgbObj, subscriptionFunc);
            }
        });
        const selectedColorEl = (0, _bb.BB).el({
            css: {
                width: sizeObj.width + 'px',
                height: sizeObj.hHeight + 'px',
                pointerEvents: 'none'
            }
        });
        {
            const initialColor = p.brushSettingService.getColor();
            selectedColorEl.style.backgroundColor = 'rgb(' + initialColor.r + ',' + initialColor.g + ',' + initialColor.b + ')';
        }
        colorEl.append(selectedColorEl, colorSlider.getElement());
        const updateColor = (rgbObj)=>{
            colorSlider.setColor(rgbObj);
            selectedColorEl.style.backgroundColor = 'rgb(' + rgbObj.r + ',' + rgbObj.g + ',' + rgbObj.b + ')';
        };
        //brushsize slider
        const sizeSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('brush-size'),
            width: sizeObj.width,
            height: sizeObj.sliderHeight,
            min: 0,
            max: 500,
            value: 50,
            resolution: 225,
            eventResMs: 1000 / 30,
            toDisplayValue: (val)=>val * 2,
            toValue: (displayValue)=>displayValue / 2,
            onChange: (v)=>{
                p.brushSettingService.setSize(v);
            },
            formatFunc: (displayValue)=>{
                if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                else return Math.round(displayValue);
            }
        });
        (0, _base.css)(sizeSlider.getElement(), {
            marginTop: '2px'
        });
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('opacity'),
            width: sizeObj.width,
            height: sizeObj.sliderHeight,
            min: 0,
            max: 1,
            value: 1,
            resolution: 225,
            eventResMs: 1000 / 30,
            toDisplayValue: (val)=>val * 100,
            toValue: (displayValue)=>displayValue / 100,
            onChange: (v)=>{
                p.brushSettingService.setOpacity(v);
            }
        });
        (0, _base.css)(opacitySlider.getElement(), {
            margin: '2px 0'
        });
        this.rootEl.append(sizeSlider.getElement(), opacitySlider.getElement());
        // --- general setup ---
        const subscriptionFunc = (event)=>{
            if (event.type === 'color') {
                if (!isVisible) queuedObj.color = event.value;
                else updateColor(event.value);
            }
            if (event.type === 'size') {
                if (!isVisible) queuedObj.size = event.value;
                else sizeSlider.setValue(event.value);
            }
            if (event.type === 'opacity') {
                if (!isVisible) queuedObj.opacity = event.value;
                else opacitySlider.setValue(event.value);
            }
            if (event.type === 'sliderConfig') {
                sizeSlider.update(event.value.sizeSlider);
                opacitySlider.update(event.value.opacitySlider);
            }
        };
        p.brushSettingService.subscribe(subscriptionFunc);
        {
            const sliderConfig = p.brushSettingService.getSliderConfig();
            sizeSlider.update(sliderConfig.sizeSlider);
            opacitySlider.update(sliderConfig.opacitySlider);
            sizeSlider.setValue(p.brushSettingService.getSize());
            opacitySlider.setValue(p.brushSettingService.getOpacity());
        }
        const updateUI = ()=>{
            // unfocus manual slider input
            (0, _bb.BB).unfocusAnyInput();
            this.rootEl.style.display = isVisible ? 'block' : 'none';
            if (isVisible && mousePos) (0, _base.css)(this.rootEl, {
                left: mousePos.x - Math.round(sizeObj.width / 2) + 'px',
                top: mousePos.y - Math.round(sizeObj.svHeight + sizeObj.hHeight * 3 / 2) + 'px'
            });
        };
        let mousePos = null;
        document.addEventListener('pointermove', (event)=>{
            mousePos = {
                x: event.pageX,
                y: event.pageY
            };
        }, {
            passive: false
        });
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, event, comboStr, isRepeat)=>{
                if (isRepeat) return;
                if (isVisible) {
                    isVisible = false;
                    updateUI();
                    return;
                }
                if (!p.enabledTest() || !mousePos) return;
                if ([
                    'ctrl+alt',
                    'cmd+alt',
                    'alt+ctrl',
                    'alt+cmd'
                ].includes(comboStr)) {
                    event.preventDefault();
                    isVisible = true;
                    if (queuedObj.color !== null) {
                        updateColor(queuedObj.color);
                        queuedObj.color = null;
                    }
                    if (queuedObj.size !== null) {
                        sizeSlider.setValue(queuedObj.size);
                        queuedObj.size = null;
                    }
                    if (queuedObj.opacity !== null) {
                        opacitySlider.setValue(queuedObj.opacity);
                        queuedObj.opacity = null;
                    }
                    updateUI();
                }
            },
            onUp: (keyStr, event, oldComboStr)=>{
                if ([
                    'ctrl+alt',
                    'cmd+alt',
                    'alt+ctrl',
                    'alt+cmd'
                ].includes(oldComboStr) && isVisible) {
                    isVisible = false;
                    colorSlider.end();
                    updateUI();
                }
            },
            onBlur: ()=>{
                if (isVisible) {
                    isVisible = false;
                    colorSlider.end();
                    updateUI();
                }
            }
        });
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","./kl-color-slider-small":"j88oi","./kl-slider":"fQOKQ","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bRD8T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Topmost row of buttons in toolspace (with the app logo)
 */ parcelHelpers.export(exports, "ToolspaceTopRow", ()=>ToolspaceTopRow);
var _bb = require("../../../bb/bb");
var _klecksLogoPng = require("url:/src/app/img/klecks-logo.png");
var _klecksLogoPngDefault = parcelHelpers.interopDefault(_klecksLogoPng);
var _newImageSvg = require("url:/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
var _importSvg = require("url:/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
var _exportSvg = require("url:/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
var _shareSvg = require("url:/src/app/img/ui/share.svg");
var _shareSvgDefault = parcelHelpers.interopDefault(_shareSvg);
var _helpSvg = require("url:/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
class ToolspaceTopRow {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-toolspace-row',
            css: {
                height: '36px',
                display: 'flex'
            }
        });
        function createButton(p) {
            const padding = 6 + (p.extraPadding ? p.extraPadding : 0);
            const el = (0, _bb.BB).el({
                className: 'toolspace-row-button nohighlight',
                title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.contain ? padding + 'px 0' : ''
                }
            });
            const im = (0, _bb.BB).el({
                className: p.darkInvert ? 'dark-invert' : undefined,
                css: {
                    backgroundImage: "url('" + p.image + "')",
                    backgroundRepeat: 'no-repeat',
                    backgroundPosition: 'center',
                    backgroundSize: p.contain ? 'contain' : '',
                    //filter: 'grayscale(1)',
                    height: '100%'
                }
            });
            im.style.pointerEvents = 'none';
            el.append(im);
            const pointerListener = new (0, _bb.BB).PointerListener({
                // because :hover causes problems w touch
                target: el,
                onEnterLeave: function(isOver) {
                    el.classList.toggle('toolspace-row-button-hover', isOver);
                }
            });
            return {
                el,
                pointerListener
            };
        }
        const logoButton = createButton({
            onClick: p.onLogo,
            title: (0, _language.LANG)('home'),
            image: p.logoImg ? p.logoImg : (0, _klecksLogoPngDefault.default),
            contain: true,
            darkInvert: true
        });
        logoButton.el.classList.add('kl-tool-row-border-right');
        (0, _base.css)(logoButton.el, {
            width: '46px'
        });
        const newButton = createButton({
            onClick: p.onNew,
            title: (0, _language.LANG)('file-new'),
            image: (0, _newImageSvgDefault.default),
            extraPadding: 1,
            contain: true
        });
        const importButton = createButton({
            onClick: p.onImport,
            title: (0, _language.LANG)('file-import'),
            image: (0, _importSvgDefault.default),
            extraPadding: 1,
            contain: true
        });
        const saveButton = createButton({
            onClick: p.onSave,
            title: (0, _language.LANG)('file-save'),
            image: (0, _exportSvgDefault.default),
            extraPadding: 1,
            contain: true
        });
        let shareButton = null;
        if ((0, _bb.BB).canShareFiles()) shareButton = createButton({
            onClick: p.onShare,
            title: (0, _language.LANG)('file-share'),
            image: (0, _shareSvgDefault.default),
            contain: true,
            darkInvert: true
        });
        const helpButton = createButton({
            onClick: p.onHelp,
            title: (0, _language.LANG)('help'),
            image: (0, _helpSvgDefault.default),
            contain: true,
            darkInvert: true
        });
        (0, _bb.BB).append(this.rootEl, [
            logoButton.el,
            newButton.el,
            importButton.el,
            saveButton.el,
            shareButton ? shareButton.el : undefined,
            helpButton.el
        ]);
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","url:/src/app/img/klecks-logo.png":"dpGLi","url:/src/app/img/ui/new-image.svg":"1y5Oa","url:/src/app/img/ui/import.svg":"fa9CT","url:/src/app/img/ui/export.svg":"imwXl","url:/src/app/img/ui/share.svg":"6LMSL","url:/src/app/img/ui/help.svg":"4kIsD","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dpGLi":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("klecks-logo.7f87808a.png") + "?" + Date.now();

},{}],"1y5Oa":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("new-image.39d1f21f.svg") + "?" + Date.now();

},{}],"fa9CT":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("import.dbac8211.svg") + "?" + Date.now();

},{}],"imwXl":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("export.04e2b31c.svg") + "?" + Date.now();

},{}],"6LMSL":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("share.90d065cc.svg") + "?" + Date.now();

},{}],"4kIsD":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("help.8e9a4a1c.svg") + "?" + Date.now();

},{}],"Yid1i":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Toolrow Dropdown. The button where you select: brush, fill, select, transform, etc.
 */ parcelHelpers.export(exports, "ToolDropdown", ()=>ToolDropdown);
var _bb = require("../../../bb/bb");
var _modalCount = require("../modals/modal-count");
var _toolPaintSvg = require("url:/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
var _toolFillSvg = require("url:/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
var _toolGradientSvg = require("url:/src/app/img/ui/tool-gradient.svg");
var _toolGradientSvgDefault = parcelHelpers.interopDefault(_toolGradientSvg);
var _toolTextSvg = require("url:/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
var _toolShapeSvg = require("url:/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
var _toolSelectSvg = require("url:/src/app/img/ui/tool-select.svg");
var _toolSelectSvgDefault = parcelHelpers.interopDefault(_toolSelectSvg);
var _language = require("../../../language/language");
var _pointerListener = require("../../../bb/input/pointer-listener");
var _c = require("../../../bb/base/c");
var _base = require("../../../bb/base/base");
class ToolDropdown {
    updateButton() {
        this.activeButton.title = this.titleArr[this.currentActiveIndex] + (this.isActive ? ' (' + (0, _language.LANG)('tool-more-tools-click-again') + ')' : '');
        this.activeButtonIm.style.backgroundImage = "url('" + this.imArr[this.currentActiveIndex] + "')";
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.smallMargin = '6px 0';
        this.optionArr = [
            'brush',
            'paintBucket',
            'gradient',
            'text',
            'shape',
            'select'
        ];
        this.imArr = [
            (0, _toolPaintSvgDefault.default),
            (0, _toolFillSvgDefault.default),
            (0, _toolGradientSvgDefault.default),
            (0, _toolTextSvgDefault.default),
            (0, _toolShapeSvgDefault.default),
            (0, _toolSelectSvgDefault.default)
        ];
        this.titleArr = [
            `${(0, _language.LANG)('tool-brush')} [B]`,
            `${(0, _language.LANG)('tool-paint-bucket')} [G]`,
            `${(0, _language.LANG)('tool-gradient')} [G]`,
            `${(0, _language.LANG)('tool-text')} [T]`,
            `${(0, _language.LANG)('tool-shape')} [U]`,
            `${(0, _language.LANG)('tool-select')} [L]`
        ];
        this.currentActiveIndex = 0;
        this.isActive = true;
        let isOpen = false;
        //preload images
        setTimeout(()=>{
            for(let i = 1; i < this.imArr.length; i++){
                const im = new Image();
                im.src = this.imArr[i];
            }
        }, 100);
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: 'relative',
                flexGrow: '1'
            }
        });
        let openTimeout;
        let isDragging = false;
        let startX;
        let startY;
        let pointerListener;
        if ((0, _bb.BB).hasPointerEvents) pointerListener = new (0, _bb.BB).PointerListener({
            target: this.rootEl,
            onPointer: (event)=>{
                if (event.type === 'pointerdown') {
                    if (isOpen) return;
                    openTimeout = setTimeout(()=>{
                        showDropdown();
                    }, 400);
                    isDragging = true;
                    startX = event.pageX;
                    startY = event.pageY;
                } else if (event.type === 'pointermove' && isDragging) {
                    if (!isOpen && (0, _bb.BB).dist(startX, startY, event.pageX, event.pageY) > 5) {
                        clearTimeout(openTimeout);
                        showDropdown();
                    }
                } else if (event.type === 'pointerup' && isDragging) {
                    clearTimeout(openTimeout);
                    isDragging = false;
                    if (isOpen) {
                        const target = document.elementFromPoint(event.pageX, event.pageY);
                        for(let i = 0; i < this.dropdownBtnArr.length; i++)if (target === this.dropdownBtnArr[i].wrapper) {
                            closeDropdown();
                            this.isActive = true;
                            this.currentActiveIndex = i;
                            this.updateButton();
                            p.onChange(this.optionArr[this.currentActiveIndex]);
                            break;
                        }
                    }
                }
            }
        });
        this.activeButton = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'toolspace-row-button nohighlight toolspace-row-button-activated',
            title: this.titleArr[this.currentActiveIndex],
            onClick: (e)=>{
                if (this.isActive && !isOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    showDropdown();
                    return;
                }
                this.isActive = true;
                p.onChange(this.optionArr[this.currentActiveIndex]);
                if (isOpen) closeDropdown();
            },
            css: {
                padding: '10px 0',
                pointerEvents: 'auto',
                height: '100%',
                boxSizing: 'border-box',
                zIndex: '1'
            }
        });
        // hover via JS, so hover-state not stuck on mobile
        const activeButtonPointerListener = new (0, _pointerListener.PointerListener)({
            target: this.activeButton,
            onEnterLeave: (isOver)=>{
                this.activeButton.classList.toggle('kl-tool-button--hover', isOver);
            }
        });
        this.activeButtonIm = (0, _bb.BB).el({
            parent: this.activeButton,
            className: 'dark-invert',
            css: {
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'center',
                backgroundSize: 'contain',
                width: 'calc(100% - 7px)',
                height: '100%',
                pointerEvents: 'none',
                opacity: '0.75'
            }
        });
        this.arrowButton = (0, _bb.BB).el({
            parent: this.activeButton,
            className: 'kl-tooldropdown-caret',
            content: (0, _c.c)('.dark-invert'),
            title: (0, _language.LANG)('tool-more-tools'),
            onClick: (e)=>{
                e.preventDefault();
                e.stopPropagation();
                showDropdown();
            }
        });
        const overlay = (0, _bb.BB).el({
            css: {
                position: 'absolute',
                //background: 'rgba(255,0,0,0.5)',
                left: '0',
                top: '0',
                right: '0',
                bottom: '0'
            }
        });
        const overlayPointerListener = new (0, _bb.BB).PointerListener({
            target: overlay,
            onPointer: (e)=>{
                if (e.type === 'pointerdown') {
                    e.eventPreventDefault();
                    closeDropdown();
                }
            }
        });
        const dropdownWrapper = (0, _bb.BB).el({
            className: 'tool-dropdown-wrapper',
            css: {
                position: 'absolute',
                width: '100%',
                height: 100 * (this.optionArr.length - 1) + '%',
                top: '100%',
                left: '0',
                zIndex: '-1',
                boxSizing: 'border-box',
                cursor: 'pointer',
                transition: 'height 0.1s ease-in-out, opacity 0.1s ease-in-out',
                borderBottomLeftRadius: '5px',
                borderBottomRightRadius: '5px',
                overflow: 'hidden'
            }
        });
        this.dropdownBtnArr = [];
        const createDropdownButton = (p)=>{
            const wrapper = (0, _bb.BB).el({
                parent: dropdownWrapper,
                className: 'tool-dropdown-button',
                title: p.title,
                css: {
                    padding: '10px 0',
                    height: 100 / (this.optionArr.length - 1) + '%',
                    boxSizing: 'border-box'
                },
                onClick: (e)=>{
                    e.preventDefault();
                    e.stopPropagation();
                    p.onClick(p.index);
                }
            });
            (0, _bb.BB).el({
                parent: wrapper,
                className: 'dark-invert',
                css: {
                    backgroundImage: "url('" + p.image + "')",
                    backgroundRepeat: 'no-repeat',
                    backgroundPosition: 'center',
                    backgroundSize: 'contain',
                    height: '100%',
                    pointerEvents: 'none',
                    opacity: '0.75'
                }
            });
            // --- interface ---
            const show = (b)=>{
                wrapper.style.display = b ? 'block' : 'none';
            };
            const setIsSmall = (b)=>{
                wrapper.style.padding = b ? this.smallMargin : '10px 0';
            };
            return {
                wrapper,
                show,
                setIsSmall
            };
        };
        const onClickDropdownBtn = (index)=>{
            closeDropdown();
            this.isActive = true;
            this.currentActiveIndex = index;
            this.updateButton();
            p.onChange(this.optionArr[this.currentActiveIndex]);
        };
        for(let i = 0; i < this.optionArr.length; i++)this.dropdownBtnArr.push(createDropdownButton({
            index: i,
            id: this.optionArr[i],
            image: this.imArr[i],
            title: this.titleArr[i],
            onClick: onClickDropdownBtn
        }));
        const showDropdown = ()=>{
            if ((0, _modalCount.DIALOG_COUNTER).get() > 0) return;
            (0, _modalCount.DIALOG_COUNTER).increase(0.5);
            isOpen = true;
            for(let i = 0; i < this.optionArr.length; i++)this.dropdownBtnArr[i].show(this.currentActiveIndex !== i);
            this.arrowButton.style.setProperty('opacity', '0');
            this.arrowButton.style.setProperty('pointer-events', 'none');
            this.rootEl.style.zIndex = '1';
            document.body.append(overlay);
            this.rootEl.append(dropdownWrapper);
        };
        const closeDropdown = ()=>{
            (0, _modalCount.DIALOG_COUNTER).decrease(0.5);
            isOpen = false;
            this.arrowButton.style.removeProperty('opacity');
            this.arrowButton.style.removeProperty('pointer-events');
            this.rootEl.style.removeProperty('z-index');
            overlay.remove();
            dropdownWrapper.remove();
        };
        this.updateButton();
    }
    // ---- interface ----
    setIsSmall(b) {
        this.activeButton.style.padding = b ? this.smallMargin : '10px 0';
        for(let i = 0; i < this.optionArr.length; i++)this.dropdownBtnArr[i].setIsSmall(b);
        (0, _base.css)(this.arrowButton, {
            width: b ? '14px' : '18px',
            height: b ? '14px' : '18px'
        });
    }
    setActive(activeStr) {
        if (this.optionArr.includes(activeStr)) {
            this.isActive = true;
            for(let i = 0; i < this.optionArr.length; i++)if (this.optionArr[i] === activeStr) {
                this.currentActiveIndex = i;
                break;
            }
            this.activeButton.classList.add('toolspace-row-button-activated');
            this.updateButton();
        } else {
            this.isActive = false;
            this.activeButton.classList.remove('toolspace-row-button-activated');
            this.updateButton();
        }
    }
    getActive() {
        return this.optionArr[this.currentActiveIndex];
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","../modals/modal-count":"60MST","url:/src/app/img/ui/tool-paint.svg":"kLnEj","url:/src/app/img/ui/tool-fill.svg":"kD7Tz","url:/src/app/img/ui/tool-gradient.svg":"hOixx","url:/src/app/img/ui/tool-text.svg":"9MRtp","url:/src/app/img/ui/tool-shape.svg":"1cHcj","url:/src/app/img/ui/tool-select.svg":"lLXhX","../../../language/language":"mcywn","../../../bb/input/pointer-listener":"kDObC","../../../bb/base/c":"3KmDH","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kLnEj":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-paint.930c7296.svg") + "?" + Date.now();

},{}],"kD7Tz":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-fill.4b7343af.svg") + "?" + Date.now();

},{}],"hOixx":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-gradient.6622cb4e.svg") + "?" + Date.now();

},{}],"9MRtp":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-text.9ec464d3.svg") + "?" + Date.now();

},{}],"1cHcj":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-shape.260b5138.svg") + "?" + Date.now();

},{}],"lLXhX":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-select.c1a25046.svg") + "?" + Date.now();

},{}],"gVM0D":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Row of buttons in toolspace. image-operations (draw, hand), zoom, undo/redo
 * Need to do syncing. So tool is correct, and zoom/undo/redo buttons are properly enabled/disabled
 * heights: 54px tall, 36px small -> via setIsSmall
 */ parcelHelpers.export(exports, "ToolspaceToolRow", ()=>ToolspaceToolRow);
var _bb = require("../../../bb/bb");
var _toolDropdown = require("./tool-dropdown");
var _toolHandSvg = require("url:/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
var _toolZoomInSvg = require("url:/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
var _toolZoomOutSvg = require("url:/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _toolUndoSvg = require("url:/src/app/img/ui/tool-undo.svg");
var _toolUndoSvgDefault = parcelHelpers.interopDefault(_toolUndoSvg);
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
class ToolspaceToolRow {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-toolspace-row',
            css: {
                height: '54px',
                display: 'flex'
            }
        });
        this.onActivate = p.onActivate;
        this.currentActiveStr = 'brush';
        const createButton = (p)=>{
            const smallMargin = p.doLighten ? '6px 0' : '8px 0';
            const el = (0, _bb.BB).el({
                className: 'toolspace-row-button nohighlight',
                //title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.contain ? '10px 0' : ''
                }
            });
            const im = (0, _bb.BB).el({
                className: 'dark-invert',
                css: {
                    backgroundImage: "url('" + p.image + "')",
                    backgroundRepeat: 'no-repeat',
                    backgroundPosition: 'center',
                    backgroundSize: p.contain ? 'contain' : '',
                    //filter: 'grayscale(1)',
                    height: '100%',
                    transform: p.doMirror ? 'scale(-1, 1)' : '',
                    pointerEvents: 'none',
                    opacity: p.doLighten ? '0.75' : '1'
                }
            });
            el.append(im);
            const pointerListener = new (0, _bb.BB).PointerListener({
                // because :hover causes problems w touch
                target: el,
                onEnterLeave: (isOver)=>{
                    el.classList.toggle('toolspace-row-button-hover', isOver);
                }
            });
            const setIsSmall = (b)=>{
                el.style.padding = p.contain ? b ? smallMargin : '10px 0' : '';
            };
            return {
                el,
                pointerListener,
                setIsSmall
            };
        };
        const createTriangleButton = (p)=>{
            // because IE and Edge don't support clip path
            const result = (0, _bb.BB).el({
                css: {
                    flexGrow: '1',
                    position: 'relative'
                }
            });
            const svg = (0, _bb.BB).createSvg({
                elementType: 'svg',
                width: '67px',
                height: '54px',
                viewBox: '0 0 100 100',
                preserveAspectRatio: 'none'
            });
            (0, _base.css)(svg, {
                position: 'absolute',
                left: '0',
                top: '0'
            });
            const blurRadius = 10;
            const blurOffsetX = 2;
            const blurOffsetY = 2;
            const defs = (0, _bb.BB).createSvg({
                // inset shadow via svg
                elementType: 'defs',
                childrenArr: [
                    {
                        elementType: 'filter',
                        id: 'innershadow',
                        x0: '-50%',
                        y0: '-50%',
                        width: '200%',
                        height: '200%',
                        childrenArr: [
                            {
                                elementType: 'feGaussianBlur',
                                in: 'SourceAlpha',
                                stdDeviation: '' + blurRadius,
                                result: 'blur'
                            },
                            {
                                elementType: 'feOffset',
                                dx: '' + blurOffsetX,
                                dy: '' + blurOffsetY
                            },
                            {
                                elementType: 'feComposite',
                                in2: 'SourceAlpha',
                                operator: 'arithmetic',
                                k2: '-1',
                                k3: '1',
                                result: 'shadowDiff'
                            },
                            {
                                elementType: 'feFlood',
                                'flood-color': '#000',
                                'flood-opacity': '0.2'
                            },
                            {
                                elementType: 'feComposite',
                                in2: 'shadowDiff',
                                operator: 'in'
                            },
                            {
                                elementType: 'feComposite',
                                in2: 'SourceGraphic',
                                operator: 'over',
                                result: 'firstfilter'
                            },
                            {
                                elementType: 'feGaussianBlur',
                                in: 'firstfilter',
                                stdDeviation: '' + blurRadius,
                                result: 'blur2'
                            },
                            {
                                elementType: 'feOffset',
                                dx: '' + blurOffsetX,
                                dy: '' + blurOffsetY
                            },
                            {
                                elementType: 'feComposite',
                                in2: 'firstfilter',
                                operator: 'arithmetic',
                                k2: '-1',
                                k3: '1',
                                result: 'shadowDiff'
                            },
                            {
                                elementType: 'feFlood',
                                'flood-color': '#000',
                                'flood-opacity': '0.2'
                            },
                            {
                                elementType: 'feComposite',
                                in2: 'shadowDiff',
                                operator: 'in'
                            },
                            {
                                elementType: 'feComposite',
                                in2: 'firstfilter',
                                operator: 'over'
                            }
                        ]
                    }
                ]
            });
            const svgTriangleLeft = (0, _bb.BB).createSvg({
                elementType: 'path',
                'vector-effect': 'non-scaling-stroke',
                d: 'M0,0 L 100,0 0,100 z',
                fill: 'rgba(0,0,0,0)',
                class: 'toolspace-svg-triangle-button'
            });
            svgTriangleLeft.onclick = ()=>{
                p.onLeft();
                svgTriangleLeft.classList.remove('toolspace-svg-triangle-button-hover');
            };
            const svgTriangleRight = (0, _bb.BB).createSvg({
                elementType: 'path',
                'vector-effect': 'non-scaling-stroke',
                d: 'M100,100 L 100,0 0,100 z',
                fill: 'rgba(0,0,0,0)',
                class: 'toolspace-svg-triangle-button'
            });
            svgTriangleRight.onclick = ()=>{
                p.onRight();
                svgTriangleRight.classList.remove('toolspace-svg-triangle-button-hover');
            };
            // because :hover causes problems w touch
            const leftPointerListener = new (0, _bb.BB).PointerListener({
                target: svgTriangleLeft,
                onEnterLeave: (isOver)=>{
                    svgTriangleLeft.classList.toggle('toolspace-svg-triangle-button-hover', isOver);
                }
            });
            const rightPointerListener = new (0, _bb.BB).PointerListener({
                target: svgTriangleRight,
                onEnterLeave: (isOver)=>{
                    svgTriangleRight.classList.toggle('toolspace-svg-triangle-button-hover', isOver);
                }
            });
            svg.append(defs, svgTriangleLeft, svgTriangleRight);
            result.append(svg);
            const leftIm = (0, _bb.BB).el({
                parent: result,
                className: 'dark-invert',
                css: {
                    backgroundImage: "url('" + p.leftImage + "')",
                    backgroundRepeat: 'no-repeat',
                    backgroundSize: 'contain',
                    width: '20px',
                    height: '20px',
                    position: 'absolute',
                    left: '10px',
                    top: '8px',
                    //transform: p.doMirror ? 'scale(-1, 1)' : '',
                    pointerEvents: 'none'
                }
            });
            result.append(leftIm);
            const rightIm = (0, _bb.BB).el({
                parent: result,
                className: 'dark-invert',
                css: {
                    backgroundImage: "url('" + (p.rightImage ? p.rightImage : p.leftImage) + "')",
                    backgroundRepeat: 'no-repeat',
                    backgroundSize: 'contain',
                    width: '20px',
                    height: '20px',
                    position: 'absolute',
                    right: '10px',
                    bottom: '8px',
                    transform: p.rightImage ? '' : 'scale(-1, 1)',
                    pointerEvents: 'none'
                }
            });
            const setIsEnabledLeft = (b)=>{
                svgTriangleLeft.classList.toggle('toolspace-row-button-disabled', !b);
                leftIm.classList.toggle('toolspace-row-button-disabled', !b);
            };
            const setIsEnabledRight = (b)=>{
                svgTriangleRight.classList.toggle('toolspace-row-button-disabled', !b);
                rightIm.classList.toggle('toolspace-row-button-disabled', !b);
            };
            return {
                el: result,
                setIsEnabledLeft,
                setIsEnabledRight,
                leftPointerListener,
                rightPointerListener
            };
        };
        this.toolDropdown = new (0, _toolDropdown.ToolDropdown)({
            onChange: (activeStr)=>{
                this.setActive(activeStr, true);
            }
        });
        this.rootEl.append(this.toolDropdown.getElement());
        this.handButton = createButton({
            onClick: ()=>{
                this.setActive('hand', true);
            },
            image: (0, _toolHandSvgDefault.default),
            contain: true,
            doLighten: true
        });
        this.handButton.el.classList.add('kl-tool-row-border-right');
        this.handButton.el.title = (0, _language.LANG)('tool-hand');
        this.rootEl.append(this.handButton.el);
        this.zoomInNOutButton = createTriangleButton({
            onLeft: p.onZoomIn,
            onRight: p.onZoomOut,
            leftImage: (0, _toolZoomInSvgDefault.default),
            rightImage: (0, _toolZoomOutSvgDefault.default)
        });
        this.zoomInNOutButton.el.title = (0, _language.LANG)('tool-zoom');
        this.rootEl.append(this.zoomInNOutButton.el);
        this.zoomInButton = createButton({
            onClick: p.onZoomIn,
            image: (0, _toolZoomInSvgDefault.default),
            contain: true
        });
        this.zoomInButton.el.title = (0, _language.LANG)('zoom-in');
        this.rootEl.append(this.zoomInButton.el);
        this.zoomOutButton = createButton({
            onClick: p.onZoomOut,
            image: (0, _toolZoomOutSvgDefault.default),
            contain: true
        });
        this.zoomOutButton.el.title = (0, _language.LANG)('zoom-out');
        this.rootEl.append(this.zoomOutButton.el);
        this.undoNRedoButton = createTriangleButton({
            onLeft: p.onUndo,
            onRight: p.onRedo,
            leftImage: (0, _toolUndoSvgDefault.default),
            rightImage: null
        });
        this.undoNRedoButton.el.title = (0, _language.LANG)('undo') + '/' + (0, _language.LANG)('redo');
        this.undoNRedoButton.setIsEnabledLeft(false);
        this.undoNRedoButton.setIsEnabledRight(false);
        this.rootEl.append(this.undoNRedoButton.el);
        this.undoButton = createButton({
            onClick: p.onUndo,
            image: (0, _toolUndoSvgDefault.default),
            contain: true
        });
        this.undoButton.el.title = (0, _language.LANG)('undo');
        this.undoButton.el.classList.add('toolspace-row-button-disabled');
        this.rootEl.append(this.undoButton.el);
        this.redoButton = createButton({
            onClick: p.onRedo,
            image: (0, _toolUndoSvgDefault.default),
            contain: true,
            doMirror: true
        });
        this.redoButton.el.title = (0, _language.LANG)('redo');
        this.redoButton.el.classList.add('toolspace-row-button-disabled');
        this.rootEl.append(this.redoButton.el);
        this.zoomInButton.el.style.display = 'none';
        this.zoomOutButton.el.style.display = 'none';
        this.undoButton.el.style.display = 'none';
        this.redoButton.el.style.display = 'none';
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    setIsSmall(b) {
        (0, _base.css)(this.rootEl, {
            height: b ? '36px' : '54px'
        });
        this.toolDropdown.setIsSmall(b);
        this.handButton.setIsSmall(b);
        this.zoomInButton.setIsSmall(b);
        this.zoomOutButton.setIsSmall(b);
        this.undoButton.setIsSmall(b);
        this.redoButton.setIsSmall(b);
        if (b) {
            this.zoomInNOutButton.el.style.display = 'none';
            this.undoNRedoButton.el.style.display = 'none';
            this.zoomInButton.el.style.display = 'block';
            this.zoomOutButton.el.style.display = 'block';
            this.undoButton.el.style.display = 'block';
            this.redoButton.el.style.display = 'block';
        } else {
            this.zoomInNOutButton.el.style.display = 'block';
            this.undoNRedoButton.el.style.display = 'block';
            this.zoomInButton.el.style.display = 'none';
            this.zoomOutButton.el.style.display = 'none';
            this.undoButton.el.style.display = 'none';
            this.redoButton.el.style.display = 'none';
        }
    }
    setEnableZoomIn(b) {
        this.zoomInButton.el.classList.toggle('toolspace-row-button-disabled', !b);
        this.zoomInNOutButton.setIsEnabledLeft(b);
    }
    setEnableZoomOut(b) {
        this.zoomOutButton.el.classList.toggle('toolspace-row-button-disabled', !b);
        this.zoomInNOutButton.setIsEnabledRight(b);
    }
    setEnableUndo(b) {
        this.undoButton.el.classList.toggle('toolspace-row-button-disabled', !b);
        this.undoNRedoButton.setIsEnabledLeft(b);
    }
    setEnableRedo(b) {
        this.redoButton.el.classList.toggle('toolspace-row-button-disabled', !b);
        this.undoNRedoButton.setIsEnabledRight(b);
    }
    setActive(activeStr, doEmit) {
        if (this.currentActiveStr === activeStr) return;
        this.currentActiveStr = activeStr;
        this.toolDropdown.setActive(this.currentActiveStr);
        this.handButton.el.classList.toggle('toolspace-row-button-activated', this.currentActiveStr === 'hand');
        if (doEmit) this.onActivate(this.currentActiveStr);
    }
    getActive() {
        return this.currentActiveStr;
    }
}

},{"../../../bb/bb":"3zOvT","./tool-dropdown":"Yid1i","url:/src/app/img/ui/tool-hand.svg":"3vXJO","url:/src/app/img/ui/tool-zoom-in.svg":"6SrvZ","url:/src/app/img/ui/tool-zoom-out.svg":"ifF9F","url:/src/app/img/ui/tool-undo.svg":"aulny","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aulny":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tool-undo.885233fb.svg") + "?" + Date.now();

},{}],"iITGN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui to select stabilizer level. 4 options. returned as 0-3
 */ parcelHelpers.export(exports, "ToolspaceStabilizerRow", ()=>ToolspaceStabilizerRow);
var _bb = require("../../../bb/bb");
var _select = require("./select");
var _language = require("../../../language/language");
class ToolspaceStabilizerRow {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            tagName: 'label',
            className: 'kl-stabilizer',
            content: (0, _language.LANG)('stabilizer') + '&nbsp;',
            title: (0, _language.LANG)('stabilizer-title')
        });
        const strengthSelect = new (0, _select.Select)({
            optionArr: [
                [
                    '0',
                    '0'
                ],
                [
                    '1',
                    '1'
                ],
                [
                    '2',
                    '2'
                ],
                [
                    '3',
                    '3'
                ],
                [
                    '4',
                    '4'
                ],
                [
                    '5',
                    '5'
                ]
            ],
            initValue: '' + p.smoothing,
            onChange: function(val) {
                p.onSelect(parseInt(val));
            },
            name: 'stabilizer-strength'
        });
        this.rootEl.append(strengthSelect.getElement());
        this.pointerListener = new (0, _bb.BB).PointerListener({
            target: this.rootEl,
            onWheel: function(e) {
                strengthSelect.setDeltaValue(e.deltaY);
            }
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","./select":"iuUFh","../../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bJoVm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * row of tabs. uses css class .tabrow__tab
 */ parcelHelpers.export(exports, "TabRow", ()=>TabRow);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class TabRow {
    // update
    update() {
        for(let i = 0; i < this.tabArr.length; i++)this.tabArr[i].update(this.activeTab);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        const height = p.height ?? 35;
        this.rootEl = (0, _bb.BB).el({
            className: 'tabrow',
            css: {
                height: height + 1 + 'px'
            }
        });
        this.tabArr = []; //creates its own internal arr
        const roundSize = 10;
        this.roundRight = (0, _bb.BB).el({
            className: 'tabrow__tab__rounding-left'
        });
        this.roundLeft = (0, _bb.BB).el({
            className: 'tabrow__tab__rounding-right'
        });
        const createTab = (pTabObj, initialId, useAccent)=>{
            const isVisible = 'isVisible' in pTabObj && pTabObj.isVisible !== undefined ? pTabObj.isVisible : true;
            const result = {
                id: pTabObj.id,
                isVisible: isVisible,
                onOpen: pTabObj.onOpen,
                onClose: pTabObj.onClose,
                update: (openedTabObj)=>{
                    result.el.className = openedTabObj === result ? useAccent ? 'tabrow__tab tabrow__tab--opened-accented' : 'tabrow__tab tabrow__tab--opened' : 'tabrow__tab';
                    result.el.style.display = result.isVisible ? 'block' : 'none';
                },
                el: (0, _bb.BB).el({
                    parent: this.rootEl,
                    content: 'label' in pTabObj ? pTabObj.label : '',
                    title: 'title' in pTabObj ? pTabObj.title : undefined,
                    className: initialId === pTabObj.id ? useAccent ? 'tabrow__tab tabrow__tab--opened-accented' : 'tabrow__tab tabrow__tab--opened' : 'tabrow__tab',
                    css: {
                        lineHeight: height + 'px',
                        display: isVisible ? 'block' : 'none'
                    },
                    onClick: ()=>{
                        if (this.activeTab === result) return;
                        this.open(result.id);
                    }
                }),
                pointerListener: {}
            };
            if ('image' in pTabObj) (0, _bb.BB).el({
                tagName: 'span',
                parent: result.el,
                className: 'dark-invert',
                css: {
                    backgroundImage: `url("${pTabObj.image}")`,
                    backgroundSize: 'contain',
                    backgroundPosition: 'center',
                    backgroundRepeat: 'no-repeat',
                    display: 'flex',
                    height: height - 7 + 'px',
                    justifyContent: 'center',
                    margin: '4px auto'
                }
            });
            if ('css' in pTabObj && pTabObj.css !== undefined) (0, _base.css)(result.el, pTabObj.css);
            result.pointerListener = new (0, _bb.BB).PointerListener({
                // because :hover causes problems w touch
                target: result.el,
                onEnterLeave: (isOver)=>{
                    result.el.classList.toggle('tabrow__tab-hover', isOver);
                }
            });
            if (initialId === result.id) {
                result.onOpen();
                result.el.append(this.roundRight, this.roundLeft);
            } else result.onClose();
            return result;
        };
        let initTabObj = null;
        for(let i = 0; i < p.tabArr.length; i++){
            const tab = createTab(p.tabArr[i], p.initialId, p.useAccent || false);
            if (tab.id === p.initialId) initTabObj = tab;
            this.tabArr.push(tab);
        }
        if (!initTabObj) throw 'invalid initialId';
        this.activeTab = initTabObj;
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    open(tabId) {
        for(let i = 0; i < this.tabArr.length; i++)if (this.tabArr[i].id === tabId) {
            if (this.activeTab === this.tabArr[i]) // already open
            return;
            this.activeTab.onClose();
            this.activeTab = this.tabArr[i];
            this.activeTab.onOpen();
            this.activeTab.el.append(this.roundRight, this.roundLeft);
            this.update();
            return;
        }
        throw 'TabRow.open - invalid tabId';
    }
    getOpenedTabId() {
        return '' + this.activeTab.id;
    }
    setIsVisible(tabId, isVisible) {
        for(let i = 0; i < this.tabArr.length; i++)if (this.tabArr[i].id === tabId) {
            this.tabArr[i].isVisible = isVisible;
            this.update();
            return;
        }
        throw 'TabRow.setIsVisible - invalid tabId';
    }
    destroy() {
        this.tabArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item.el);
            item.pointerListener.destroy();
        });
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k62XM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui, when hand tool tab is open.
 */ parcelHelpers.export(exports, "HandUi", ()=>HandUi);
var _bb = require("../../../bb/bb");
var _angleSvg = require("url:/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
var _editRotateSvg = require("url:/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
var _language = require("../../../language/language");
var _checkbox = require("../components/checkbox");
var _localStorage = require("../../../bb/base/local-storage");
var _base = require("../../../bb/base/base");
var _ui = require("../../../bb/base/ui");
const LS_INERTIA_KEY = 'kl-inertia-scroll';
class HandUi {
    updateUi() {
        this.scaleEl.innerHTML = Math.round(this.scale * 100) + '%';
        this.angleEl.innerHTML = Math.round(this.angleDeg) + "\xb0";
        (0, _base.css)(this.angleIm, {
            transform: 'rotate(' + this.angleDeg + 'deg)',
            boxShadow: this.angleDeg % 90 === 0 ? 'inset 0 0 0 1px rgba(255,255,255, 1), 0 0 0 1px rgba(0, 0, 0, 0.3)' : ''
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isVisible = true;
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: '10px'
            }
        });
        this.scale = p.scale;
        this.angleDeg = p.angleDeg;
        this.onAngleChange = p.onAngleChange;
        const row1 = (0, _bb.BB).el({
            css: {
                marginBottom: '10px',
                display: 'flex'
            }
        });
        const row2 = (0, _bb.BB).el({
            css: {
                display: 'flex',
                marginBottom: '10px'
            }
        });
        const row3 = (0, _bb.BB).el({
            css: {
                display: 'flex'
            }
        });
        this.rootEl.append(row1, row2, row3);
        this.scaleEl = (0, _bb.BB).el({
            css: {
                width: '65px',
                userSelect: 'none',
                fontFamily: 'monospace'
            }
        });
        row1.append(this.scaleEl);
        this.angleIm = new Image();
        this.angleIm.src = (0, _angleSvgDefault.default);
        (0, _base.css)(this.angleIm, {
            verticalAlign: 'bottom',
            width: '20px',
            height: '20px',
            marginRight: '5px',
            borderRadius: '10px',
            background: 'rgba(0,0,0,0.2)',
            userSelect: 'none'
        });
        row1.append(this.angleIm);
        this.angleEl = (0, _bb.BB).el({
            parent: row1,
            css: {
                userSelect: 'none'
            }
        });
        this.updateUi();
        const resetButton = (0, _bb.BB).el({
            tagName: 'button',
            content: (0, _language.LANG)('hand-reset'),
            onClick: p.onReset
        });
        (0, _ui.makeUnfocusable)(resetButton);
        const fitButton = (0, _bb.BB).el({
            tagName: 'button',
            content: (0, _language.LANG)('hand-fit'),
            css: {
                marginLeft: '10px'
            },
            onClick: p.onFit
        });
        (0, _ui.makeUnfocusable)(fitButton);
        row2.append(resetButton, fitButton);
        const leftRotateIcon = new Image();
        leftRotateIcon.height = 20;
        leftRotateIcon.src = (0, _editRotateSvgDefault.default);
        leftRotateIcon.alt = 'Rotate';
        (0, _base.css)(leftRotateIcon, {
            transform: 'scale(-1, 1)'
        });
        const leftRotateButton = (0, _bb.BB).el({
            tagName: 'button',
            content: leftRotateIcon,
            onClick: function() {
                p.onAngleChange(-15, true);
            }
        });
        (0, _ui.makeUnfocusable)(leftRotateButton);
        const resetAngleButton = (0, _bb.BB).el({
            tagName: 'button',
            content: "0\xb0",
            css: {
                marginLeft: '10px'
            },
            onClick: function() {
                p.onAngleChange(0);
            }
        });
        (0, _ui.makeUnfocusable)(resetAngleButton);
        const rightRotateButton = (0, _bb.BB).el({
            tagName: 'button',
            content: '<img height="20" src="' + (0, _editRotateSvgDefault.default) + '" alt="Rotate"/>',
            css: {
                marginLeft: '10px'
            },
            onClick: function() {
                p.onAngleChange(15, true);
            }
        });
        (0, _ui.makeUnfocusable)(rightRotateButton);
        row3.append(leftRotateButton, resetAngleButton, rightRotateButton);
        const inertiaToggle = new (0, _checkbox.Checkbox)({
            label: (0, _language.LANG)('hand-inertia-scrolling'),
            init: (0, _localStorage.LocalStorage).getItem(LS_INERTIA_KEY) === 'true',
            callback: (b)=>{
                (0, _localStorage.LocalStorage).setItem(LS_INERTIA_KEY, '' + b);
                p.onChangeUseInertiaScrolling(b);
            },
            name: 'enable-inertia-scrolling'
        });
        setTimeout(()=>{
            p.onChangeUseInertiaScrolling(inertiaToggle.getValue());
        }, 500);
        (0, _base.css)(inertiaToggle.getElement(), {
            marginTop: '10px',
            display: 'inline-block'
        });
        this.rootEl.append(inertiaToggle.getElement());
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = pIsVisible;
        this.rootEl.style.display = this.isVisible ? 'block' : 'none';
        if (this.isVisible) this.updateUi();
    }
    update(pScale, pAngleDeg) {
        this.scale = pScale;
        this.angleDeg = pAngleDeg;
        if (this.isVisible) this.updateUi();
    }
}

},{"../../../bb/bb":"3zOvT","url:/src/app/img/ui/angle.svg":"lzYt5","url:/src/app/img/ui/edit-rotate.svg":"hKhwU","../../../language/language":"mcywn","../components/checkbox":"9bXL6","../../../bb/base/local-storage":"itqB1","../../../bb/base/base":"it3mQ","../../../bb/base/ui":"5dJJW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hKhwU":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-rotate.0bf5c419.svg") + "?" + Date.now();

},{}],"6xOom":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Paint Bucket tab contents (color slider, opacity slider, etc)
 */ parcelHelpers.export(exports, "FillUi", ()=>FillUi);
var _bb = require("../../../bb/bb");
var _klSlider = require("../components/kl-slider");
var _select = require("../components/select");
var _checkbox = require("../components/checkbox");
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
class FillUi {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: '10px'
            }
        });
        this.isVisible = true;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: '10px'
            }
        });
        this.colorSlider = p.colorSlider;
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('opacity'),
            width: 250,
            height: 30,
            min: 0.01,
            max: 1,
            value: 1,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100
        });
        this.rootEl.append(this.opacitySlider.getElement());
        this.toleranceSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('bucket-tolerance'),
            width: 250,
            height: 30,
            min: 0,
            max: 255,
            value: 51,
            toValue: (displayValue)=>displayValue * 2.55,
            toDisplayValue: (value)=>value / 2.55
        });
        (0, _base.css)(this.toleranceSlider.getElement(), {
            marginTop: '10px'
        });
        this.rootEl.append(this.toleranceSlider.getElement());
        const selectRow = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: 'flex',
                marginTop: '10px'
            }
        });
        const modeWrapper = (0, _bb.BB).el({
            content: (0, _language.LANG)('bucket-sample') + '&nbsp;',
            title: (0, _language.LANG)('bucket-sample-title'),
            css: {
                fontSize: '15px'
            }
        });
        this.modeSelect = new (0, _select.Select)({
            optionArr: [
                [
                    'all',
                    (0, _language.LANG)('bucket-sample-all')
                ],
                [
                    'current',
                    (0, _language.LANG)('bucket-sample-active')
                ],
                [
                    'above',
                    (0, _language.LANG)('bucket-sample-above')
                ]
            ],
            initValue: 'all',
            name: 'sampling-mode'
        });
        const modePointerListener = new (0, _bb.BB).PointerListener({
            target: this.modeSelect.getElement(),
            onWheel: (e)=>{
                this.modeSelect.setDeltaValue(e.deltaY);
            }
        });
        modeWrapper.append(this.modeSelect.getElement());
        selectRow.append(modeWrapper);
        const growWrapper = (0, _bb.BB).el({
            content: (0, _language.LANG)('bucket-grow') + '&nbsp;',
            title: (0, _language.LANG)('bucket-grow-title'),
            css: {
                fontSize: '15px',
                marginLeft: '10px'
            }
        });
        this.growSelect = new (0, _select.Select)({
            optionArr: [
                [
                    '0',
                    '0'
                ],
                [
                    '1',
                    '1'
                ],
                [
                    '2',
                    '2'
                ],
                [
                    '3',
                    '3'
                ],
                [
                    '4',
                    '4'
                ],
                [
                    '5',
                    '5'
                ],
                [
                    '6',
                    '6'
                ],
                [
                    '7',
                    '7'
                ]
            ],
            initValue: '0',
            name: 'fill-growth'
        });
        const growPointerListener = new (0, _bb.BB).PointerListener({
            target: this.growSelect.getElement(),
            onWheel: (e)=>{
                this.growSelect.setDeltaValue(e.deltaY);
            }
        });
        growWrapper.append(this.growSelect.getElement());
        selectRow.append(growWrapper);
        this.isContiguous = true;
        const contiguousToggle = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)('bucket-contiguous'),
            title: (0, _language.LANG)('bucket-contiguous-title'),
            callback: (b)=>{
                this.isContiguous = b;
            },
            name: 'is-contiguous'
        });
        this.eraserToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('eraser'),
            name: 'eraser-toggle'
        });
        this.rootEl.append((0, _bb.BB).el({
            content: [
                contiguousToggle.getElement(),
                this.eraserToggle.getElement()
            ],
            css: {
                display: 'flex',
                marginTop: '10px',
                gap: '10px'
            }
        }));
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = pIsVisible;
        this.rootEl.style.display = this.isVisible ? 'block' : 'none';
        if (this.isVisible) this.colorDiv.append(this.colorSlider.getElement(), this.colorSlider.getOutputElement());
    }
    /**
     * [0, 1]
     */ getTolerance() {
        // slider may display 0 when value is 1 -> avoid confusing users
        if (Math.round(this.toleranceSlider.getDisplayValue()) === 0) return 0;
        return this.toleranceSlider.getValue();
    }
    getOpacity() {
        return this.opacitySlider.getValue();
    }
    getSample() {
        return this.modeSelect.getValue();
    }
    getGrow() {
        return parseInt(this.growSelect.getValue(), 10);
    }
    getContiguous() {
        return this.isContiguous;
    }
    getIsEraser() {
        return this.eraserToggle.getValue();
    }
}

},{"../../../bb/bb":"3zOvT","../components/kl-slider":"fQOKQ","../components/select":"iuUFh","../components/checkbox":"9bXL6","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i2rnK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Text Tool tab contents (color slider)
 */ parcelHelpers.export(exports, "TextUi", ()=>TextUi);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
class TextUi {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isVisible = true;
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: '10px'
            }
        });
        this.colorSlider = p.colorSlider;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: '10px'
            }
        });
        const hint = (0, _bb.BB).el({
            parent: this.rootEl,
            content: (0, _language.LANG)('text-instruction')
        });
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = pIsVisible;
        this.rootEl.style.display = this.isVisible ? 'block' : 'none';
        if (this.isVisible) this.colorDiv.append(this.colorSlider.getElement(), this.colorSlider.getOutputElement());
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Tqq5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Shape Tool tab contents
 */ parcelHelpers.export(exports, "ShapeUi", ()=>ShapeUi);
var _bb = require("../../../bb/bb");
var _options = require("../components/options");
var _checkbox = require("../components/checkbox");
var _klSlider = require("../components/kl-slider");
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
class ShapeUi {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.shape = 'rect';
        this.mode = 'stroke';
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: '10px'
            }
        });
        this.isVisible = true;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: '10px'
            }
        });
        this.colorSlider = p.colorSlider;
        const previewSize = 35;
        const previewPadding = 8;
        const rectStrokeSvgRect = (0, _bb.BB).createSvg({
            elementType: 'rect',
            x: '' + previewPadding,
            width: '' + (previewSize - previewPadding * 2)
        });
        const rectStrokeSvg = (0, _bb.BB).createSvg({
            elementType: 'svg',
            width: '' + previewSize,
            height: '' + previewSize
        });
        rectStrokeSvg.classList.add('dark-invert');
        rectStrokeSvg.append(rectStrokeSvgRect);
        (0, _base.css)(rectStrokeSvg, {
            display: 'block'
        });
        const rectFilledSvgRect = (0, _bb.BB).createSvg({
            elementType: 'rect',
            x: '' + previewPadding,
            width: '' + (previewSize - previewPadding * 2)
        });
        const rectFilledSvg = (0, _bb.BB).createSvg({
            elementType: 'svg',
            width: '' + previewSize,
            height: '' + previewSize
        });
        rectFilledSvg.classList.add('dark-invert');
        rectFilledSvg.append(rectFilledSvgRect);
        (0, _base.css)(rectFilledSvg, {
            display: 'block'
        });
        const ellipseStrokeSvgEllipse = (0, _bb.BB).createSvg({
            elementType: 'ellipse',
            cx: '' + previewSize / 2,
            cy: '' + previewSize / 2,
            rx: '' + (previewSize / 2 - previewPadding)
        });
        const ellipseStrokeSvg = (0, _bb.BB).createSvg({
            elementType: 'svg',
            width: '' + previewSize,
            height: '' + previewSize
        });
        ellipseStrokeSvg.classList.add('dark-invert');
        ellipseStrokeSvg.append(ellipseStrokeSvgEllipse);
        (0, _base.css)(ellipseStrokeSvg, {
            display: 'block'
        });
        const ellipseFilledSvgEllipse = (0, _bb.BB).createSvg({
            elementType: 'ellipse',
            cx: '' + previewSize / 2,
            cy: '' + previewSize / 2,
            rx: '' + (previewSize / 2 - previewPadding)
        });
        const ellipseFilledSvg = (0, _bb.BB).createSvg({
            elementType: 'svg',
            width: '' + previewSize,
            height: '' + previewSize
        });
        ellipseFilledSvg.classList.add('dark-invert');
        ellipseFilledSvg.append(ellipseFilledSvgEllipse);
        (0, _base.css)(ellipseFilledSvg, {
            display: 'block'
        });
        const lineSvgLine = (0, _bb.BB).createSvg({
            elementType: 'line',
            x1: '' + previewPadding,
            x2: '' + (previewSize - previewPadding)
        });
        const lineSvg = (0, _bb.BB).createSvg({
            elementType: 'svg',
            width: '' + previewSize,
            height: '' + previewSize
        });
        lineSvg.classList.add('dark-invert');
        lineSvg.append(lineSvgLine);
        (0, _base.css)(lineSvg, {
            display: 'block'
        });
        const updatePreviews = ()=>{
            const strokeWidth = (0, _bb.BB).clamp(Math.round(this.lineWidthSlider.getValue() / 10), 1, 10) + 'px';
            const squish = 1.35;
            (0, _base.css)(rectStrokeSvgRect, {
                fill: 'none',
                stroke: 'black',
                strokeWidth: strokeWidth
            });
            (0, _base.css)(rectFilledSvgRect, {
                fill: 'black',
                stroke: 'none'
            });
            (0, _base.css)(ellipseStrokeSvgEllipse, {
                fill: 'none',
                stroke: 'black',
                strokeWidth: strokeWidth
            });
            (0, _base.css)(ellipseFilledSvgEllipse, {
                fill: 'black',
                stroke: 'none'
            });
            (0, _base.css)(lineSvgLine, {
                fill: 'none',
                stroke: 'black',
                strokeWidth: strokeWidth
            });
            if (this.fixedToggle.getValue()) {
                rectStrokeSvgRect.setAttribute('y', '' + previewPadding);
                rectStrokeSvgRect.setAttribute('height', '' + (previewSize - previewPadding * 2));
                rectFilledSvgRect.setAttribute('y', '' + previewPadding);
                rectFilledSvgRect.setAttribute('height', '' + (previewSize - previewPadding * 2));
                ellipseStrokeSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding));
                ellipseFilledSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding));
            } else {
                rectStrokeSvgRect.setAttribute('y', '' + previewPadding * squish);
                rectStrokeSvgRect.setAttribute('height', '' + (previewSize - previewPadding * squish * 2));
                rectFilledSvgRect.setAttribute('y', '' + previewPadding * squish);
                rectFilledSvgRect.setAttribute('height', '' + (previewSize - previewPadding * squish * 2));
                ellipseStrokeSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding * squish));
                ellipseFilledSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding * squish));
            }
            if (this.snapToggle.getValue()) {
                lineSvgLine.setAttribute('y1', '' + (previewSize - previewPadding));
                lineSvgLine.setAttribute('y2', '' + previewPadding);
            } else {
                lineSvgLine.setAttribute('y1', '' + (previewSize - previewPadding * squish));
                lineSvgLine.setAttribute('y2', '' + previewPadding * squish);
            }
        };
        const row1 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'start'
            }
        });
        const shapeOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'rect-stroke',
                    label: rectStrokeSvg,
                    title: (0, _language.LANG)('shape-rect') + ' ' + (0, _language.LANG)('shape-stroke')
                },
                {
                    id: 'ellipse-stroke',
                    label: ellipseStrokeSvg,
                    title: (0, _language.LANG)('shape-ellipse') + ' ' + (0, _language.LANG)('shape-stroke')
                },
                {
                    id: 'line',
                    label: lineSvg,
                    title: (0, _language.LANG)('shape-line')
                },
                {
                    id: 'rect-fill',
                    label: rectFilledSvg,
                    title: (0, _language.LANG)('shape-rect') + ' ' + (0, _language.LANG)('shape-fill')
                },
                {
                    id: 'ellipse-fill',
                    label: ellipseFilledSvg,
                    title: (0, _language.LANG)('shape-ellipse') + ' ' + (0, _language.LANG)('shape-fill')
                }
            ],
            initId: this.shape + ' ' + this.mode,
            onChange: (id)=>{
                const split = id.split('-');
                this.shape = split[0];
                this.mode = split[1];
                (0, _base.css)(this.fixedToggle.getElement(), {
                    display: this.shape === 'line' ? 'none' : ''
                });
                (0, _base.css)(this.snapToggle.getElement(), {
                    display: this.shape === 'line' ? '' : 'none'
                });
                (0, _base.css)(this.lineWidthSlider.getElement(), {
                    display: this.shape !== 'line' && this.mode === 'fill' ? 'none' : ''
                });
            },
            changeOnInit: true,
            css: {
                width: '120px'
            }
        });
        row1.append(shapeOptions.getElement());
        this.eraserToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('eraser'),
            callback: ()=>{
                updatePreviews();
            },
            name: 'enable-eraser'
        });
        this.lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('lock-alpha'),
            title: (0, _language.LANG)('lock-alpha-title'),
            doHighlight: true,
            name: 'enable-alpha-lock'
        });
        this.lockAlphaToggle.getElement().style.marginTop = '10px';
        this.panningToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('shape-auto-pan'),
            title: (0, _language.LANG)('shape-auto-pan-title'),
            callback: (b)=>p.onChangePanning(b),
            name: 'enable-auto-pan'
        });
        this.panningToggle.getElement().style.marginTop = '10px';
        row1.append((0, _bb.BB).el({
            content: [
                this.eraserToggle.getElement(),
                this.lockAlphaToggle.getElement(),
                this.panningToggle.getElement()
            ]
        }));
        this.lineWidthSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('shape-line-width'),
            width: 250,
            height: 30,
            min: 1,
            max: 200,
            value: 4,
            curve: 'quadratic',
            onChange: ()=>{
                updatePreviews();
            }
        });
        (0, _base.css)(this.lineWidthSlider.getElement(), {
            marginTop: '10px'
        });
        this.rootEl.append(this.lineWidthSlider.getElement());
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('opacity'),
            width: 250,
            height: 30,
            min: 0.01,
            max: 1,
            value: 1,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100
        });
        (0, _base.css)(this.opacitySlider.getElement(), {
            marginTop: '10px'
        });
        this.rootEl.append(this.opacitySlider.getElement());
        const row2 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: 'flex',
                alignItems: 'center',
                marginTop: '10px',
                gap: '10px'
            }
        });
        this.outwardsToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('shape-outwards'),
            name: 'enable-outwards'
        });
        row2.append(this.outwardsToggle.getElement());
        this.fixedToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('shape-fixed'),
            callback: ()=>{
                updatePreviews();
            },
            name: 'enable-fixed-proportions'
        });
        row2.append(this.fixedToggle.getElement());
        this.snapToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('angle-snap'),
            title: (0, _language.LANG)('angle-snap-title'),
            callback: ()=>{
                updatePreviews();
            },
            name: 'enable-angle-snapping'
        });
        row2.append(this.snapToggle.getElement());
        updatePreviews();
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = pIsVisible;
        this.rootEl.style.display = this.isVisible ? 'block' : 'none';
        if (this.isVisible) {
            this.colorDiv.append(this.colorSlider.getElement());
            this.colorDiv.append(this.colorSlider.getOutputElement());
        //update();
        }
    }
    getShape() {
        return this.shape;
    }
    getMode() {
        return this.mode;
    }
    getIsEraser() {
        return this.eraserToggle.getValue();
    }
    getOpacity() {
        return this.opacitySlider.getValue();
    }
    getLineWidth() {
        return this.lineWidthSlider.getValue();
    }
    getIsOutwards() {
        return this.outwardsToggle.getValue();
    }
    getIsFixed() {
        return this.fixedToggle.getValue();
    }
    getIsSnap() {
        return this.snapToggle.getValue();
    }
    getDoLockAlpha() {
        return this.lockAlphaToggle.getValue();
    }
}

},{"../../../bb/bb":"3zOvT","../components/options":"7kiPU","../components/checkbox":"9bXL6","../components/kl-slider":"fQOKQ","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dwpUK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "newImageDialog", ()=>newImageDialog);
var _bb = require("../../../bb/bb");
var _select = require("../components/select");
var _colorOptions = require("../components/color-options");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
var _table = require("../components/table");
var _base = require("../../../bb/base/base");
function newImageDialog(p) {
    const currentColor = p.currentColor;
    const secondaryColor = p.secondaryColor;
    const maxCanvasSize = p.maxCanvasSize;
    const canvasWidth = p.canvasWidth;
    const canvasHeight = p.canvasHeight;
    const workspaceWidth = p.workspaceWidth;
    const workspaceHeight = p.workspaceHeight;
    const onConfirm = p.onConfirm;
    const onCancel = p.onCancel;
    function createRatioSize(ratioX, ratioY, width, height, padding) {
        return (0, _bb.BB).fitInto(ratioX, ratioY, Math.min(maxCanvasSize, width - padding), Math.min(maxCanvasSize, height - padding), 1);
    }
    const newImDiv = (0, _bb.BB).el();
    const widthInput = (0, _bb.BB).el({
        tagName: 'input',
        custom: {
            name: 'image-width'
        }
    });
    const unitStyle = {
        color: '#888',
        fontSize: '12px',
        marginLeft: '5px'
    };
    const widthUnit = (0, _bb.BB).el({
        textContent: (0, _language.LANG)('new-px'),
        css: unitStyle
    });
    const heightInput = (0, _bb.BB).el({
        tagName: 'input',
        custom: {
            name: 'image-height'
        }
    });
    const heightUnit = (0, _bb.BB).el({
        textContent: (0, _language.LANG)('new-px'),
        css: unitStyle
    });
    widthInput.setAttribute('data-ignore-focus', 'true');
    heightInput.setAttribute('data-ignore-focus', 'true');
    widthInput.type = 'number';
    widthInput.min = '1';
    widthInput.max = '' + maxCanvasSize;
    (0, _base.css)(widthInput, {
        width: '70px'
    });
    heightInput.type = 'number';
    heightInput.min = '1';
    heightInput.max = '' + maxCanvasSize;
    heightInput.style.width = '70px';
    widthInput.value = '' + canvasWidth;
    heightInput.value = '' + canvasHeight;
    widthInput.onclick = ()=>{
        widthInput.focus();
        updateRatio();
    };
    heightInput.onclick = ()=>{
        heightInput.focus();
        updateRatio();
    };
    const sizeTable = (0, _table.table)([
        [
            (0, _language.LANG)('width') + ':&nbsp;',
            widthInput,
            widthUnit
        ],
        [
            (0, _bb.BB).el({
                css: {
                    height: '5px'
                }
            }),
            '',
            ''
        ],
        [
            (0, _language.LANG)('height') + ':&nbsp;',
            heightInput,
            heightUnit
        ]
    ]);
    (0, _base.css)(sizeTable, {
        marginBottom: '10px'
    });
    const ratioWrapper = (0, _bb.BB).el({
        css: {
            marginTop: '5px',
            color: '#888'
        }
    });
    const templateWrapper = (0, _bb.BB).el({
        css: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '5px',
            marginBottom: '10px'
        }
    });
    const presetBtnConfig = {
        tagName: 'button',
        css: {
            flexGrow: '1'
        }
    };
    const presetFitBtn = (0, _bb.BB).el(presetBtnConfig);
    const presetCurrentBtn = (0, _bb.BB).el(presetBtnConfig);
    const presetSquareBtn = (0, _bb.BB).el(presetBtnConfig);
    const presetLandscapeBtn = (0, _bb.BB).el(presetBtnConfig);
    const presetPortraitBtn = (0, _bb.BB).el(presetBtnConfig);
    const presetOversizeBtn = (0, _bb.BB).el(presetBtnConfig);
    presetCurrentBtn.textContent = (0, _language.LANG)('new-current');
    presetFitBtn.textContent = (0, _language.LANG)('new-fit');
    presetOversizeBtn.textContent = (0, _language.LANG)('new-oversize');
    presetLandscapeBtn.textContent = (0, _language.LANG)('new-landscape');
    presetPortraitBtn.textContent = (0, _language.LANG)('new-portrait');
    presetSquareBtn.textContent = (0, _language.LANG)('new-square');
    templateWrapper.append(presetCurrentBtn, presetFitBtn, presetOversizeBtn, presetSquareBtn, presetLandscapeBtn, presetPortraitBtn);
    const templatePadding = 0;
    presetCurrentBtn.onclick = function() {
        widthInput.value = '' + canvasWidth;
        heightInput.value = '' + canvasHeight;
        updateRatio();
    };
    presetFitBtn.onclick = function() {
        widthInput.value = '' + workspaceWidth;
        heightInput.value = '' + workspaceHeight;
        updateRatio();
    };
    presetOversizeBtn.onclick = function() {
        widthInput.value = '' + (workspaceWidth + 500);
        heightInput.value = '' + (workspaceHeight + 500);
        updateRatio();
    };
    presetSquareBtn.onclick = function() {
        const sizeObj = createRatioSize(1, 1, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = '' + Math.round(sizeObj.width);
        heightInput.value = '' + Math.round(sizeObj.height);
        updateRatio();
    };
    presetLandscapeBtn.onclick = function() {
        const sizeObj = createRatioSize(4, 3, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = '' + Math.round(sizeObj.width);
        heightInput.value = '' + Math.round(sizeObj.height);
        updateRatio();
    };
    presetPortraitBtn.onclick = function() {
        const sizeObj = createRatioSize(3, 4, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = '' + Math.round(sizeObj.width);
        heightInput.value = '' + Math.round(sizeObj.height);
        updateRatio();
    };
    const select = new (0, _select.Select)({
        isFocusable: true,
        optionArr: [
            [
                'screen',
                (0, _language.LANG)('new-screen')
            ],
            [
                '16 9',
                (0, _language.LANG)('new-video') + ' 16:9'
            ],
            [
                '3 2',
                '3:2'
            ],
            [
                '5 3',
                '5:3'
            ],
            [
                '2 1',
                '2:1'
            ],
            [
                'paper',
                (0, _language.LANG)('new-din-paper') + " \u221A2:1"
            ],
            [
                '9 16',
                '9:16'
            ],
            [
                '2 3',
                '2:3'
            ],
            [
                '3 5',
                '3:5'
            ],
            [
                '1 2',
                '1:2'
            ],
            [
                '1 1.4142135623730951',
                "1:\u221A2"
            ]
        ],
        onChange: function(val) {
            if (val === 'screen') {
                widthInput.value = '' + window.screen.width;
                heightInput.value = '' + window.screen.height;
            } else if (val === 'paper') {
                const sizeObj = createRatioSize(Math.sqrt(2), 1, workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = '' + Math.round(sizeObj.width);
                heightInput.value = '' + Math.round(sizeObj.height);
            } else {
                const split = val.split(' ');
                const sizeObj = createRatioSize(parseFloat(split[0]), parseFloat(split[1]), workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = '' + Math.round(sizeObj.width);
                heightInput.value = '' + Math.round(sizeObj.height);
            }
            updateRatio();
            select.setValue(undefined);
        },
        name: 'image-format'
    });
    setTimeout(()=>{
        // safari: not empty without also setting it to null via timeout
        select.setValue(undefined);
    }, 0);
    (0, _base.css)(select.getElement(), {
        width: '80px',
        flexGrow: '1'
    });
    templateWrapper.append(select.getElement());
    let backgroundRgba = {
        r: 255,
        g: 255,
        b: 255,
        a: 1
    };
    const colorOptionsArr = [
        {
            r: 255,
            g: 255,
            b: 255,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        },
        {
            r: currentColor.r,
            g: currentColor.g,
            b: currentColor.b,
            a: 1
        },
        {
            r: secondaryColor.r,
            g: secondaryColor.g,
            b: secondaryColor.b,
            a: 1
        }
    ];
    const colorOptions = new (0, _colorOptions.ColorOptions)({
        colorArr: colorOptionsArr,
        initialIndex: 0,
        onChange: function(rgbaObj) {
            backgroundRgba = rgbaObj;
            preview.style.backgroundColor = 'rgba(' + rgbaObj.r + ',' + rgbaObj.g + ',' + rgbaObj.b + ', ' + rgbaObj.a + ')';
        }
    });
    const previewWrapper = (0, _bb.BB).el({
        className: 'kl-transparent-preview',
        css: {
            boxSizing: 'border-box',
            width: '340px',
            height: '140px',
            display: 'table',
            padding: '10px',
            marginTop: '10px',
            marginLeft: '-20px',
            background: 'var(--kl-checkerboard-background)'
        }
    });
    const preview = (0, _bb.BB).el({
        className: 'kl-transparent-preview__canvas',
        css: {
            width: "200px",
            height: "100px",
            backgroundColor: 'rgba(' + backgroundRgba.r + ',' + backgroundRgba.g + ',' + backgroundRgba.b + ', ' + backgroundRgba.a + ')',
            marginLeft: 'auto',
            marginRight: 'auto',
            color: '#aaa',
            fontSize: '16px',
            fontWeight: 'bold',
            textAlign: 'center',
            verticalAlign: 'center',
            display: 'table',
            overflow: 'hidden'
        }
    });
    (0, _bb.BB).el({
        parent: previewWrapper,
        content: preview,
        css: {
            display: 'table-cell',
            verticalAlign: 'middle'
        }
    });
    (0, _bb.BB).el({
        parent: preview,
        css: {
            display: 'table-cell',
            verticalAlign: 'middle'
        }
    });
    function updateRatio() {
        widthInput.value = '' + Math.min(maxCanvasSize, parseInt(widthInput.value));
        heightInput.value = '' + Math.min(maxCanvasSize, parseInt(heightInput.value));
        function hcf(u, v) {
            let U = u, V = v;
            while(true){
                if (!(U %= V)) return V;
                if (!(V %= U)) return U;
            }
        }
        let w = parseInt(widthInput.value);
        let h = parseInt(heightInput.value);
        if (w < 1 || w > maxCanvasSize || h < 1 || h > maxCanvasSize) {
            if (w > maxCanvasSize) w = maxCanvasSize;
            else if (h > maxCanvasSize) h = maxCanvasSize;
            widthInput.value = '' + w;
            heightInput.value = '' + h;
        }
        //generated canvas size doesn't always match ratio. so check if a common ratio is very close
        const commonRatios = [
            [
                1,
                2
            ],
            [
                2,
                1
            ],
            [
                2,
                3
            ],
            [
                3,
                2
            ],
            [
                3,
                4
            ],
            [
                4,
                3
            ],
            [
                4,
                5
            ],
            [
                5,
                4
            ],
            [
                16,
                9
            ],
            [
                9,
                16
            ],
            [
                3,
                2
            ],
            [
                2,
                3
            ],
            [
                5,
                3
            ],
            [
                3,
                5
            ],
            [
                2,
                1
            ],
            [
                1,
                2
            ],
            [
                1.414,
                1
            ],
            [
                1,
                1.414
            ]
        ];
        const reducedArr = (0, _bb.BB).reduce(w, h);
        let closestRatio = commonRatios[0];
        let closestDistance = Math.abs(commonRatios[0][0] / commonRatios[0][1] - reducedArr[0] / reducedArr[1]);
        for(let i = 0; i < commonRatios.length; i++)if (Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]) < closestDistance) {
            closestRatio = commonRatios[i];
            closestDistance = Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]);
        }
        //display ratio
        if (closestDistance > 0 && closestDistance < 0.005) ratioWrapper.innerText = (0, _language.LANG)('new-ratio') + ': ~' + closestRatio[0] + ':' + closestRatio[1];
        else ratioWrapper.innerText = (0, _language.LANG)('new-ratio') + ': ' + reducedArr[0] + ':' + reducedArr[1];
        const realw = w;
        const T = hcf(w, h);
        w /= T;
        h /= T;
        w *= 260;
        h *= 260;
        if (w > 260) {
            h = 260 / w * h;
            w = 260;
        }
        if (h > 100) {
            w = 100 / h * w;
            h = 100;
        }
        preview.style.width = w + 'px';
        preview.style.height = h + 'px';
        previewWrapper.style.backgroundSize = Math.round(Math.max(4, 60 * (w / realw))) + 'px';
    }
    widthInput.onchange = ()=>{
        if (widthInput.value === '' || parseInt(widthInput.value) < 0) widthInput.value = '1';
        updateRatio();
    };
    widthInput.onkeyup = ()=>{
        updateRatio();
    };
    heightInput.onchange = ()=>{
        if (heightInput.value === '' || parseFloat(heightInput.value) < 0) heightInput.value = '1';
        updateRatio();
    };
    heightInput.onkeyup = ()=>{
        updateRatio();
    };
    updateRatio();
    newImDiv.append(templateWrapper);
    const secondRow = (0, _bb.BB).el({
        parent: newImDiv,
        css: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'flex-end'
        }
    });
    const secondRowLeft = (0, _bb.BB).el({
        parent: secondRow
    });
    secondRowLeft.append(sizeTable, ratioWrapper);
    secondRow.append(colorOptions.getElement());
    newImDiv.append(previewWrapper);
    (0, _showModal.showModal)({
        target: document.body,
        message: `<b>${(0, _language.LANG)('new-title')}</b>`,
        div: newImDiv,
        buttons: [
            'Ok',
            'Cancel'
        ],
        callback: function(result) {
            (0, _bb.BB).unsetEventHandler(widthInput, 'onclick', 'onchange', 'onkeyup');
            (0, _bb.BB).unsetEventHandler(widthInput, 'onclick', 'onchange', 'onkeyup');
            (0, _bb.BB).unsetEventHandler(presetCurrentBtn, 'onclick');
            (0, _bb.BB).unsetEventHandler(presetFitBtn, 'onclick');
            (0, _bb.BB).unsetEventHandler(presetOversizeBtn, 'onclick');
            (0, _bb.BB).unsetEventHandler(presetSquareBtn, 'onclick');
            (0, _bb.BB).unsetEventHandler(presetLandscapeBtn, 'onclick');
            (0, _bb.BB).unsetEventHandler(presetPortraitBtn, 'onclick');
            select.destroy();
            colorOptions.destroy();
            if (result === 'Cancel' || parseInt(widthInput.value) <= 0 || parseInt(heightInput.value) <= 0 || isNaN(parseInt(widthInput.value)) || isNaN(parseInt(heightInput.value))) {
                onCancel();
                return;
            }
            onConfirm(parseInt(widthInput.value), parseInt(heightInput.value), backgroundRgba);
        },
        clickOnEnter: 'Ok'
    });
}

},{"../../../bb/bb":"3zOvT","../components/select":"iuUFh","../components/color-options":"1nMl0","./base/showModal":"gy3iL","../../../language/language":"mcywn","../components/table":"lM08M","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lM08M":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "table", ()=>table);
var _bb = require("../../../bb/bb");
function table(data, cellProps) {
    const result = (0, _bb.BB).el({
        tagName: 'table',
        className: 'kl-table'
    });
    data.forEach((row, rowIndex)=>{
        const rowEl = (0, _bb.BB).el({
            tagName: 'tr'
        });
        rowEl.append(...row.map((el, colIndex)=>{
            const cellEl = (0, _bb.BB).el({
                tagName: 'td',
                content: el
            });
            const key = rowIndex + '.' + colIndex;
            if (cellProps !== undefined && key in cellProps) cellEl.rowSpan = cellProps[key].rowspan;
            return cellEl;
        }));
        result.append(rowEl);
    });
    return result;
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lr9fj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * button that allows to collapse toolspace (for mobile)
 */ parcelHelpers.export(exports, "ToolspaceCollapser", ()=>ToolspaceCollapser);
var _bb = require("../../../bb/bb");
var _uiCollapseSvg = require("url:/src/app/img/ui/ui-collapse.svg");
var _uiCollapseSvgDefault = parcelHelpers.interopDefault(_uiCollapseSvg);
var _language = require("../../../language/language");
class ToolspaceCollapser {
    update() {
        if (this.orientation === 'left') this.icon.style.transform = this.stateIsOpen ? 'rotate(180deg)' : '';
        else this.icon.style.transform = this.stateIsOpen ? '' : 'rotate(180deg)';
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.stateIsOpen = true;
        this.orientation = 'right';
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-toolspace-toggle',
            css: {
                width: '36px',
                height: '36px',
                background: 'rgba(100, 100, 100, 0.9)',
                color: '#fff',
                textAlign: 'center',
                lineHeight: '36px',
                cursor: 'pointer',
                userSelect: 'none',
                padding: '6px',
                boxSizing: 'border-box'
            },
            title: (0, _language.LANG)('toggle-show-tools'),
            onClick: (e)=>{
                e.preventDefault();
                this.stateIsOpen = !this.stateIsOpen;
                this.update();
                p.onChange();
            }
        });
        this.icon = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                backgroundImage: `url(${(0, _uiCollapseSvgDefault.default)})`,
                width: '100%',
                height: '100%',
                backgroundSize: 'contain',
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'center',
                userSelect: 'none'
            }
        });
        this.update();
        this.rootEl.oncontextmenu = ()=>{
            return false;
        };
    }
    // ---- interface ----
    isOpen() {
        return this.stateIsOpen;
    }
    setIsOpen(b) {
        this.stateIsOpen = b;
        this.update();
    }
    setOrientation(dirStr) {
        this.orientation = dirStr;
        this.update();
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","url:/src/app/img/ui/ui-collapse.svg":"6vVTY","../../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6vVTY":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("ui-collapse.0d2f3fb5.svg") + "?" + Date.now();

},{}],"7EFYg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "textToolDialog", ()=>textToolDialog);
var _bb = require("../../../../bb/bb");
var _showModal = require("../base/showModal");
var _language = require("../../../../language/language");
var _textToolFillUi = require("./text-tool-fill-ui");
var _textToolFontUi = require("./text-tool-font-ui");
var _textToolStrokeUi = require("./text-tool-stroke-ui");
var _textToolTextUi = require("./text-tool-text-ui");
var _textToolViewportUi = require("./text-tool-viewport-ui");
var _textToolDialogModuleScss = require("./text-tool-dialog.module.scss");
var _c = require("../../../../bb/base/c");
var _tabRow = require("../../components/tab-row");
function textToolDialog(p) {
    const rootEl = (0, _bb.BB).el({});
    let text = (0, _bb.BB).copyObj(p.text);
    const viewportWrapper = (0, _bb.BB).el({
        className: _textToolDialogModuleScss.viewportWrapper
    });
    const viewportUI = new (0, _textToolViewportUi.TextToolViewportUI)({
        text: text,
        klCanvas: p.klCanvas,
        layerIndex: p.layerIndex,
        onDragEnd: ()=>tabs.getOpenedTabId() === 'text' ? textUI.focus() : 0
    });
    viewportUI.render();
    function onUpdate(p) {
        text = {
            ...text,
            ...p
        };
        viewportUI.setText(text);
    }
    const fontUI = new (0, _textToolFontUi.TextToolFontUI)({
        ...text,
        onUpdate: (p)=>{
            onUpdate(p);
        }
    });
    const colorWrapper = (0, _bb.BB).el({
        css: {
            display: 'flex',
            gap: '10px',
            flexDirection: 'column'
        }
    });
    const fillUI = new (0, _textToolFillUi.TextToolFillUI)({
        fill: text.fill,
        primaryColor: p.primaryColor,
        secondaryColor: p.secondaryColor,
        onUpdate: (p)=>{
            onUpdate(p);
        }
    });
    const strokeUI = new (0, _textToolStrokeUi.TextToolStrokeUI)({
        stroke: text.stroke,
        primaryColor: p.primaryColor,
        secondaryColor: p.secondaryColor,
        onUpdate: (p)=>{
            onUpdate(p);
        }
    });
    const textUI = new (0, _textToolTextUi.TextToolTextUI)({
        text: text.text,
        onUpdate: (p)=>{
            p.text !== undefined && modal.setIgnoreBackground(p.text.length > 0);
            onUpdate(p);
        }
    });
    const tabs = new (0, _tabRow.TabRow)({
        initialId: 'text',
        height: 40,
        tabArr: [
            {
                id: 'text',
                label: (0, _language.LANG)('text-text'),
                onOpen: ()=>{
                    textUI.getElement().style.display = '';
                    textUI.focus();
                },
                onClose: ()=>{
                    textUI.getElement().style.display = 'none';
                }
            },
            {
                id: 'font',
                label: (0, _language.LANG)('text-font'),
                onOpen: ()=>{
                    fontUI.getElement().style.display = 'flex';
                },
                onClose: ()=>{
                    fontUI.getElement().style.display = 'none';
                }
            },
            {
                id: 'color',
                label: (0, _language.LANG)('text-color'),
                onOpen: ()=>{
                    colorWrapper.style.display = 'flex';
                },
                onClose: ()=>{
                    colorWrapper.style.display = 'none';
                }
            }
        ]
    });
    tabs.getElement().classList.add(_textToolDialogModuleScss.tab);
    rootEl.append((0, _c.c)('', [
        (0, _c.c)(viewportWrapper, [
            viewportUI.getElement()
        ]),
        (0, _c.c)('.' + _textToolDialogModuleScss.viewportInputs, [
            viewportUI.getInputsElement()
        ]),
        (0, _c.c)('.tabrow.' + _textToolDialogModuleScss.tabWrapper, [
            (0, _c.c)(',w-240,h-40'),
            tabs.getElement()
        ]),
        (0, _c.c)('.' + _textToolDialogModuleScss.inputs, [
            (0, _c.c)(colorWrapper, [
                fillUI.getElement(),
                strokeUI.getElement()
            ]),
            fontUI.getElement(),
            textUI.getElement()
        ])
    ]));
    const onResize = ()=>{
        const b = viewportWrapper.getBoundingClientRect();
        const w = Math.ceil(b.width);
        const h = Math.ceil(b.height);
        viewportUI.setSize(w, h);
    };
    window.addEventListener('resize', onResize);
    setTimeout(()=>{
        onResize();
    });
    setTimeout(()=>{
        textUI.focus();
    }, 100);
    // prevent mobile keyboards scrolling page
    function onScroll() {
        window.scrollTo(0, 0);
    }
    window.addEventListener('scroll', onScroll, {
        passive: false
    });
    const onModalExit = (val)=>{
        window.removeEventListener('resize', onResize);
        window.removeEventListener('scroll', onScroll);
        viewportUI.destroy();
        fontUI.destroy();
        fillUI.destroy();
        strokeUI.destroy();
        textUI.destroy();
        tabs.destroy();
        if (val === 'Ok') p.onConfirm({
            ...viewportUI.getValues(),
            ...fontUI.getValues(),
            ...fillUI.getValues(),
            ...strokeUI.getValues(),
            ...textUI.getValues()
        });
    };
    const modal = (0, _showModal.showModal)({
        target: document.body,
        message: `<b>${(0, _language.LANG)('text-title')}</b>`,
        div: rootEl,
        buttons: [
            'Ok',
            'Cancel'
        ],
        ignoreBackground: p.text.text.length > 0,
        callback: onModalExit,
        style: {
            width: 'calc(100% - 50px)',
            maxWidth: '1000px',
            minWidth: '300px',
            boxSizing: 'border-box'
        },
        clickOnEnter: 'Ok'
    });
}

},{"../../../../bb/bb":"3zOvT","../base/showModal":"gy3iL","../../../../language/language":"mcywn","./text-tool-fill-ui":"fw1br","./text-tool-font-ui":"4dsbc","./text-tool-stroke-ui":"aAsxb","./text-tool-text-ui":"7CoUL","./text-tool-viewport-ui":"knXox","./text-tool-dialog.module.scss":"le1Yb","../../../../bb/base/c":"3KmDH","../../components/tab-row":"bJoVm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fw1br":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolFillUI", ()=>TextToolFillUI);
var _colorOptions = require("../../components/color-options");
var _klSlider = require("../../components/kl-slider");
var _language = require("../../../../language/language");
var _c = require("../../../../bb/base/c");
var _base = require("../../../../bb/base/base");
class TextToolFillUI {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        const emit = ()=>{
            p.onUpdate(this.getValues());
        };
        const colorOptionsArr = [
            null,
            p.fill ? {
                ...p.fill.color,
                a: 1
            } : null,
            {
                ...p.primaryColor,
                a: 1
            },
            {
                ...p.secondaryColor,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }
        ];
        this.colorOptions = new (0, _colorOptions.ColorOptions)({
            colorArr: colorOptionsArr,
            initialIndex: p.fill ? 1 : 0,
            title: (0, _language.LANG)('shape-fill'),
            onChange: (c)=>{
                this.opacitySlider.getElement().style.display = c !== null ? '' : 'none';
                emit();
            }
        });
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('opacity'),
            width: 150,
            height: 30,
            min: 0.01,
            max: 1,
            value: p.fill ? p.fill.color.a : 1,
            resolution: 225,
            eventResMs: 1000 / 30,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: ()=>emit()
        });
        this.opacitySlider.getElement().style.display = p.fill ? '' : 'none';
        const svg = (0, _base.createSvg)({
            elementType: 'svg',
            class: 'dark-invert',
            width: '25px',
            height: '25px',
            viewBox: '0 0 30 30',
            childrenArr: [
                {
                    elementType: 'polyline',
                    points: '0,0 30,0 30,8 19,8 19,30 11,30 11,8 0,8 0,0 1,0',
                    'transform-origin': '15px 15px',
                    transform: 'scale(0.8)',
                    fill: '#000c'
                }
            ]
        });
        this.rootEl = (0, _c.c)(',flex,gap-10,items-center,flexWrap,minh-30', [
            svg,
            this.colorOptions.getElement(),
            this.opacitySlider.getElement()
        ]);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        const c = this.colorOptions.getValue();
        if (c === null || c?.a === 0) return {
            fill: undefined
        };
        const color = {
            ...c,
            a: this.opacitySlider.getValue()
        };
        return {
            fill: {
                color
            }
        };
    }
    destroy() {
        this.colorOptions.destroy();
        this.opacitySlider.destroy();
    }
}

},{"../../components/color-options":"1nMl0","../../components/kl-slider":"fQOKQ","../../../../language/language":"mcywn","../../../../bb/base/c":"3KmDH","../../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4dsbc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolFontUI", ()=>TextToolFontUI);
var _bb = require("../../../../bb/bb");
var _input = require("../../components/input");
var _language = require("../../../../language/language");
var _imageRadioList = require("../../components/image-radio-list");
var _alignLeftSvg = require("url:/src/app/img/ui/align-left.svg");
var _alignLeftSvgDefault = parcelHelpers.interopDefault(_alignLeftSvg);
var _alignCenterSvg = require("url:/src/app/img/ui/align-center.svg");
var _alignCenterSvgDefault = parcelHelpers.interopDefault(_alignCenterSvg);
var _alignRightSvg = require("url:/src/app/img/ui/align-right.svg");
var _alignRightSvgDefault = parcelHelpers.interopDefault(_alignRightSvg);
var _typoItalicSvg = require("url:/src/app/img/ui/typo-italic.svg");
var _typoItalicSvgDefault = parcelHelpers.interopDefault(_typoItalicSvg);
var _typoBoldSvg = require("url:/src/app/img/ui/typo-bold.svg");
var _typoBoldSvgDefault = parcelHelpers.interopDefault(_typoBoldSvg);
var _imageToggle = require("../../components/image-toggle");
var _select = require("../../components/select");
var _c = require("../../../../bb/base/c");
var _fonts = require("../../../../../fonts/fonts");
var _showModal = require("../base/showModal");
const importedFonts = [
    {
        fontFamily: 'sans-serif',
        fontName: 'Sans-serif'
    },
    {
        fontFamily: 'serif',
        fontName: 'Serif'
    },
    {
        fontFamily: 'monospace',
        fontName: 'Monospace'
    },
    {
        fontFamily: 'cursive',
        fontName: 'Cursive'
    },
    {
        fontFamily: 'fantasy',
        fontName: 'Fantasy'
    },
    ...(0, _fonts.FONTS).map((item)=>{
        return {
            fontFamily: item.name,
            fontName: item.name
        };
    })
];
let didLoadBundledFonts = false;
async function loadBundledFonts() {
    if (didLoadBundledFonts) return;
    didLoadBundledFonts = true;
    const promises = (0, _fonts.FONTS).map(async (item)=>{
        const response = await fetch(item.url);
        const buffer = await response.arrayBuffer();
        const font = new FontFace(item.name, buffer);
        // await font.load();
        document.fonts.add(font);
    });
    await Promise.all(promises);
}
class TextToolFontUI {
    // only load fonts when interacting with the font input
    loadBundledFonts() {
        !didLoadBundledFonts && loadBundledFonts().then(()=>{
            this.onUpdate({
                font: this.fontSelect.getValue()
            });
        });
    }
    importFont() {
        const acceptedExtensions = [
            'ttf',
            'otf',
            'woff',
            'woff2',
            'eot'
        ];
        const input = document.createElement('input');
        input.type = 'file';
        input.multiple = true;
        input.accept = acceptedExtensions.map((item)=>'.' + item).join(', ');
        input.focus();
        input.click();
        input.onchange = async ()=>{
            if (!input.files || input.files.length === 0) return;
            let toSelect = undefined;
            const failedToLoadFilenames = [];
            let acceptedAtLeastOne = false;
            const fontFamilies = importedFonts.map((i)=>i.fontFamily);
            for(let i = 0; i < input.files.length; i++){
                const file = input.files[i];
                const fontName = 'kl-' + importedFonts.length;
                if (fontFamilies.includes(fontName)) continue;
                if (!toSelect) {
                    toSelect = fontName;
                    this.importButton.disabled = true;
                    this.importButton.innerText = (0, _language.LANG)('loading');
                }
                const split = file.name.split('.');
                split.pop();
                importedFonts.push({
                    fontFamily: fontName,
                    fontName: split.join('.')
                });
                const font = new FontFace(fontName, await file.arrayBuffer());
                try {
                    await font.load();
                    document.fonts.add(font);
                    acceptedAtLeastOne = true;
                } catch (err) {
                    failedToLoadFilenames.push(file.name);
                }
            }
            if (failedToLoadFilenames.length > 0) (0, _showModal.showModal)({
                target: document.body,
                message: (0, _bb.BB).el({
                    content: [
                        (0, _language.LANG)('text-failed-import'),
                        (0, _c.c)('br'),
                        failedToLoadFilenames.join(', '),
                        (0, _c.c)('br'),
                        (0, _c.c)('br'),
                        (0, _language.LANG)('text-supported-formats'),
                        (0, _c.c)('br'),
                        acceptedExtensions.join(', ')
                    ]
                }),
                type: 'error'
            });
            if (!acceptedAtLeastOne) {
                this.importButton.disabled = false;
                this.importButton.innerText = (0, _language.LANG)('file-import');
                return;
            }
            // update font selection
            setTimeout(()=>{
                this.fontSelect.setOptionArr(importedFonts.map((i)=>{
                    return [
                        i.fontFamily,
                        i.fontName,
                        {
                            css: {
                                fontFamily: i.fontFamily,
                                fontSize: '1.2em'
                            }
                        }
                    ];
                }));
                this.fontSelect.setValue(toSelect);
                this.onUpdate({
                    font: toSelect
                });
                this.importButton.disabled = false;
                this.importButton.innerText = (0, _language.LANG)('file-import');
            });
        };
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.onUpdate = p.onUpdate;
        this.fontSelect = new (0, _select.Select)({
            initValue: p.font,
            optionArr: importedFonts.map((i)=>{
                return [
                    i.fontFamily,
                    i.fontName,
                    {
                        css: {
                            fontFamily: i.fontFamily,
                            fontSize: '1.2em'
                        }
                    }
                ];
            }),
            isFocusable: true,
            css: {
                width: '180px'
            },
            onChange: (v)=>{
                this.loadBundledFonts();
                p.onUpdate({
                    font: v
                });
            },
            name: 'font'
        });
        this.onFocus = ()=>this.loadBundledFonts();
        this.fontSelect.getElement().addEventListener('focus', this.onFocus);
        this.fontPointerListener = new (0, _bb.BB).PointerListener({
            target: this.fontSelect.getElement(),
            onWheel: (e)=>this.fontSelect.setDeltaValue(e.deltaY)
        });
        this.importButton = (0, _bb.BB).el({
            tagName: 'button',
            content: (0, _language.LANG)('file-import'),
            onClick: ()=>{
                this.importFont();
            }
        });
        const sizeLabel = (0, _bb.BB).el({
            content: [
                (0, _bb.BB).el({
                    tagName: 'span',
                    content: 'A',
                    css: {
                        fontSize: '0.6em'
                    }
                }),
                'A'
            ],
            css: {
                width: '25px',
                height: '25px',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                fontSize: '1.2em',
                userSelect: 'none'
            }
        });
        this.sizeInput = new (0, _input.Input)({
            title: (0, _language.LANG)('text-size'),
            type: 'number',
            min: 0,
            max: 1000,
            init: p.size,
            onChange: (v)=>{
                p.onUpdate({
                    size: parseFloat(v)
                });
            },
            doResetIfInvalid: true,
            doScrollWithoutFocus: true,
            css: {
                width: '70px'
            },
            name: 'font-size'
        });
        this.lineHeightInput = new (0, _input.Input)({
            label: (0, _language.LANG)('text-line-height'),
            type: 'number',
            min: 0,
            max: 10,
            step: 0.1,
            init: p.lineHeight ?? 1,
            onChange: (v)=>{
                p.onUpdate({
                    lineHeight: parseFloat(v)
                });
            },
            doResetIfInvalid: true,
            doScrollWithoutFocus: true,
            css: {
                width: '60px'
            },
            name: 'line-height'
        });
        this.letterSpacingInput = new (0, _input.Input)({
            label: (0, _language.LANG)('text-letter-spacing'),
            type: 'number',
            min: -100,
            max: 100,
            init: p.letterSpacing ?? 0,
            onChange: (v)=>{
                p.onUpdate({
                    letterSpacing: parseFloat(v)
                });
            },
            doResetIfInvalid: true,
            doScrollWithoutFocus: true,
            css: {
                width: '60px'
            },
            name: 'letter-spacing'
        });
        this.alignRadioList = new (0, _imageRadioList.ImageRadioList)({
            optionArr: [
                {
                    id: 'left',
                    title: (0, _language.LANG)('text-left'),
                    image: (0, _alignLeftSvgDefault.default),
                    darkInvert: true
                },
                {
                    id: 'center',
                    title: (0, _language.LANG)('text-center'),
                    image: (0, _alignCenterSvgDefault.default),
                    darkInvert: true
                },
                {
                    id: 'right',
                    title: (0, _language.LANG)('text-right'),
                    image: (0, _alignRightSvgDefault.default),
                    darkInvert: true
                }
            ],
            initId: p.align,
            onChange: (v)=>p.onUpdate({
                    align: v
                })
        });
        this.italicToggle = new (0, _imageToggle.ImageToggle)({
            image: (0, _typoItalicSvgDefault.default),
            title: (0, _language.LANG)('text-italic'),
            initValue: p.isItalic,
            onChange: (v)=>p.onUpdate({
                    isItalic: v
                }),
            darkInvert: true
        });
        this.boldToggle = new (0, _imageToggle.ImageToggle)({
            image: (0, _typoBoldSvgDefault.default),
            title: (0, _language.LANG)('text-bold'),
            initValue: p.isBold,
            onChange: (v)=>p.onUpdate({
                    isBold: v
                }),
            darkInvert: true
        });
        this.rootEl = (0, _c.c)(',flex,flexWrap,gap-10-15,items-center', [
            (0, _c.c)(',flex,gap-5,items-center', [
                sizeLabel,
                this.sizeInput.getElement()
            ]),
            (0, _c.c)(',flex,gap-5', [
                this.fontSelect.getElement(),
                this.importButton
            ]),
            (0, _c.c)(',flex,gap-7', [
                this.alignRadioList.getElement(),
                this.italicToggle.getElement(),
                this.boldToggle.getElement()
            ]),
            this.letterSpacingInput.getElement(),
            this.lineHeightInput.getElement()
        ]);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        return {
            font: this.fontSelect.getValue(),
            size: +this.sizeInput.getValue(),
            letterSpacing: +this.letterSpacingInput.getValue(),
            lineHeight: +this.lineHeightInput.getValue(),
            align: this.alignRadioList.getValue(),
            isItalic: this.italicToggle.getValue(),
            isBold: this.boldToggle.getValue()
        };
    }
    destroy() {
        this.fontPointerListener.destroy();
        this.fontSelect.getElement().removeEventListener('focus', this.onFocus);
        this.fontSelect.destroy();
        (0, _bb.BB).destroyEl(this.importButton);
        this.sizeInput.destroy();
        this.lineHeightInput.destroy();
        this.letterSpacingInput.destroy();
        this.alignRadioList.destroy();
        this.italicToggle.destroy();
        this.boldToggle.destroy();
    }
}

},{"../../../../bb/bb":"3zOvT","../../components/input":"e8FQP","../../../../language/language":"mcywn","../../components/image-radio-list":"fAfrJ","url:/src/app/img/ui/align-left.svg":"1lv32","url:/src/app/img/ui/align-center.svg":"6TnIg","url:/src/app/img/ui/align-right.svg":"aUu5b","url:/src/app/img/ui/typo-italic.svg":"a0BnP","url:/src/app/img/ui/typo-bold.svg":"hTiTR","../../components/image-toggle":"6pxUz","../../components/select":"iuUFh","../../../../bb/base/c":"3KmDH","../../../../../fonts/fonts":"5uzYC","../base/showModal":"gy3iL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1lv32":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("align-left.c601c367.svg") + "?" + Date.now();

},{}],"6TnIg":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("align-center.f8d393aa.svg") + "?" + Date.now();

},{}],"aUu5b":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("align-right.202af848.svg") + "?" + Date.now();

},{}],"a0BnP":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("typo-italic.57b6dde7.svg") + "?" + Date.now();

},{}],"hTiTR":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("typo-bold.11d19099.svg") + "?" + Date.now();

},{}],"5uzYC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FONTS", ()=>FONTS);
var _caveatRegularWoff2 = require("url:./Caveat-Regular.woff2");
var _caveatRegularWoff2Default = parcelHelpers.interopDefault(_caveatRegularWoff2);
var _climateCrisisRegularVariableFontYEARWoff2 = require("url:./ClimateCrisis-Regular-VariableFont_YEAR.woff2");
var _climateCrisisRegularVariableFontYEARWoff2Default = parcelHelpers.interopDefault(_climateCrisisRegularVariableFontYEARWoff2);
var _correctionBrushWoff2 = require("url:./CorrectionBrush.woff2");
var _correctionBrushWoff2Default = parcelHelpers.interopDefault(_correctionBrushWoff2);
var _dancingScriptRegularWoff2 = require("url:./DancingScript-Regular.woff2");
var _dancingScriptRegularWoff2Default = parcelHelpers.interopDefault(_dancingScriptRegularWoff2);
var _diabolikRegularVFWoff2 = require("url:./Diabolik-Regular-VF.woff2");
var _diabolikRegularVFWoff2Default = parcelHelpers.interopDefault(_diabolikRegularVFWoff2);
var _freckleFaceRegularWoff2 = require("url:./FreckleFace-Regular.woff2");
var _freckleFaceRegularWoff2Default = parcelHelpers.interopDefault(_freckleFaceRegularWoff2);
var _gloockRegularWoff2 = require("url:./Gloock-Regular.woff2");
var _gloockRegularWoff2Default = parcelHelpers.interopDefault(_gloockRegularWoff2);
var _pachaWoff2 = require("url:./Pacha.woff2");
var _pachaWoff2Default = parcelHelpers.interopDefault(_pachaWoff2);
var _gochiHandRegularWoff2 = require("url:./GochiHand-Regular.woff2");
var _gochiHandRegularWoff2Default = parcelHelpers.interopDefault(_gochiHandRegularWoff2);
var _passionOneBoldWoff2 = require("url:./PassionOne-Bold.woff2");
var _passionOneBoldWoff2Default = parcelHelpers.interopDefault(_passionOneBoldWoff2);
var _pixeloidSansWoff2 = require("url:./PixeloidSans.woff2");
var _pixeloidSansWoff2Default = parcelHelpers.interopDefault(_pixeloidSansWoff2);
var _playpenSansThinWoff2 = require("url:./PlaypenSans-Thin.woff2");
var _playpenSansThinWoff2Default = parcelHelpers.interopDefault(_playpenSansThinWoff2);
var _quicksandLightWoff2 = require("url:./Quicksand-Light.woff2");
var _quicksandLightWoff2Default = parcelHelpers.interopDefault(_quicksandLightWoff2);
var _silkscreenRegularWoff2 = require("url:./Silkscreen-Regular.woff2");
var _silkscreenRegularWoff2Default = parcelHelpers.interopDefault(_silkscreenRegularWoff2);
var _tehrocRegularWoff2 = require("url:./Tehroc-Regular.woff2");
var _tehrocRegularWoff2Default = parcelHelpers.interopDefault(_tehrocRegularWoff2);
var _yungaDisplayWoff2 = require("url:./YUNGA-Display.woff2");
var _yungaDisplayWoff2Default = parcelHelpers.interopDefault(_yungaDisplayWoff2);
const FONTS = [
    {
        name: 'Caveat',
        url: (0, _caveatRegularWoff2Default.default)
    },
    {
        name: 'ClimateCrisis',
        url: (0, _climateCrisisRegularVariableFontYEARWoff2Default.default)
    },
    {
        name: 'CorrectionBrush',
        url: (0, _correctionBrushWoff2Default.default)
    },
    {
        name: 'DancingScript',
        url: (0, _dancingScriptRegularWoff2Default.default)
    },
    {
        name: 'Diabolik',
        url: (0, _diabolikRegularVFWoff2Default.default)
    },
    {
        name: 'FreckleFace',
        url: (0, _freckleFaceRegularWoff2Default.default)
    },
    {
        name: 'Gloock',
        url: (0, _gloockRegularWoff2Default.default)
    },
    {
        name: 'GochiHand',
        url: (0, _gochiHandRegularWoff2Default.default)
    },
    {
        name: 'Pacha',
        url: (0, _pachaWoff2Default.default)
    },
    {
        name: 'PassionOne',
        url: (0, _passionOneBoldWoff2Default.default)
    },
    {
        name: 'PixeloidSans',
        url: (0, _pixeloidSansWoff2Default.default)
    },
    {
        name: 'PlaypenSans',
        url: (0, _playpenSansThinWoff2Default.default)
    },
    {
        name: 'Quicksand',
        url: (0, _quicksandLightWoff2Default.default)
    },
    {
        name: 'Silkscreen',
        url: (0, _silkscreenRegularWoff2Default.default)
    },
    {
        name: 'Tehroc',
        url: (0, _tehrocRegularWoff2Default.default)
    },
    {
        name: 'YUNGA',
        url: (0, _yungaDisplayWoff2Default.default)
    }
];

},{"url:./Caveat-Regular.woff2":"3Jozw","url:./ClimateCrisis-Regular-VariableFont_YEAR.woff2":"3tuTV","url:./CorrectionBrush.woff2":"931dO","url:./DancingScript-Regular.woff2":"gnw6e","url:./Diabolik-Regular-VF.woff2":"dtkYZ","url:./FreckleFace-Regular.woff2":"crOV0","url:./Gloock-Regular.woff2":"jaV8K","url:./Pacha.woff2":"hMzV4","url:./GochiHand-Regular.woff2":"a3mC4","url:./PassionOne-Bold.woff2":"DTzQP","url:./PixeloidSans.woff2":"jIQdl","url:./PlaypenSans-Thin.woff2":"4oEnA","url:./Quicksand-Light.woff2":"hi8a5","url:./Silkscreen-Regular.woff2":"2oCMd","url:./Tehroc-Regular.woff2":"lsvmp","url:./YUNGA-Display.woff2":"4ZVGi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Jozw":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("Caveat-Regular.50521ece.woff2") + "?" + Date.now();

},{}],"3tuTV":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("ClimateCrisis-Regular-VariableFont_YEAR.b0c25ef5.woff2") + "?" + Date.now();

},{}],"931dO":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("CorrectionBrush.38545121.woff2") + "?" + Date.now();

},{}],"gnw6e":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("DancingScript-Regular.b20219dc.woff2") + "?" + Date.now();

},{}],"dtkYZ":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("Diabolik-Regular-VF.cefbc30e.woff2") + "?" + Date.now();

},{}],"crOV0":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("FreckleFace-Regular.e438c5c5.woff2") + "?" + Date.now();

},{}],"jaV8K":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("Gloock-Regular.29fd06d3.woff2") + "?" + Date.now();

},{}],"hMzV4":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("Pacha.985a6859.woff2") + "?" + Date.now();

},{}],"a3mC4":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("GochiHand-Regular.7e3e9420.woff2") + "?" + Date.now();

},{}],"DTzQP":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("PassionOne-Bold.eef4c2c8.woff2") + "?" + Date.now();

},{}],"jIQdl":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("PixeloidSans.bd2cd19a.woff2") + "?" + Date.now();

},{}],"4oEnA":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("PlaypenSans-Thin.afb1d197.woff2") + "?" + Date.now();

},{}],"hi8a5":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("Quicksand-Light.dd9b8927.woff2") + "?" + Date.now();

},{}],"2oCMd":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("Silkscreen-Regular.412b5f16.woff2") + "?" + Date.now();

},{}],"lsvmp":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("Tehroc-Regular.4bbc1157.woff2") + "?" + Date.now();

},{}],"4ZVGi":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("YUNGA-Display.c64dbbaa.woff2") + "?" + Date.now();

},{}],"aAsxb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolStrokeUI", ()=>TextToolStrokeUI);
var _bb = require("../../../../bb/bb");
var _colorOptions = require("../../components/color-options");
var _klSlider = require("../../components/kl-slider");
var _language = require("../../../../language/language");
var _c = require("../../../../bb/base/c");
var _base = require("../../../../bb/base/base");
class TextToolStrokeUI {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                boxShadow: '0 0 0 1px #aaa'
            }
        });
        const emit = ()=>{
            p.onUpdate(this.getValues());
        };
        const colorOptionsArr = [
            null,
            p.stroke ? {
                ...p.stroke.color,
                a: 1
            } : null,
            {
                ...p.secondaryColor,
                a: 1
            },
            {
                ...p.primaryColor,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        ];
        this.colorOptions = new (0, _colorOptions.ColorOptions)({
            colorArr: colorOptionsArr,
            initialIndex: p.stroke ? 1 : 0,
            title: (0, _language.LANG)('shape-stroke'),
            onChange: (c)=>{
                this.opacitySlider.getElement().style.display = c !== null ? '' : 'none';
                this.lineWidthSlider.getElement().style.display = c !== null ? '' : 'none';
                emit();
            }
        });
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('opacity'),
            width: 150,
            height: 30,
            min: 0.01,
            max: 1,
            value: p.stroke ? p.stroke.color.a : 1,
            resolution: 225,
            eventResMs: 1000 / 30,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: ()=>emit()
        });
        this.lineWidthSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('shape-line-width'),
            width: 150,
            height: 30,
            min: 0.5,
            max: 100,
            value: p.stroke ? p.stroke.lineWidth : 2,
            eventResMs: 1000 / 30,
            curve: 'quadratic',
            onChange: ()=>emit()
        });
        this.opacitySlider.getElement().style.display = p.stroke ? '' : 'none';
        this.lineWidthSlider.getElement().style.display = p.stroke ? '' : 'none';
        const svg = (0, _base.createSvg)({
            elementType: 'svg',
            class: 'dark-invert',
            width: '25px',
            height: '25px',
            viewBox: '0 0 30 30',
            childrenArr: [
                {
                    elementType: 'polyline',
                    points: '0,0 30,0 30,8 19,8 19,30 11,30 11,8 0,8 0,0 1,0',
                    fill: 'none',
                    stroke: '#000c',
                    'stroke-width': '3',
                    'transform-origin': '15px 15px',
                    transform: 'scale(0.8)'
                }
            ]
        });
        this.rootEl = (0, _c.c)(',flex,gap-10,items-center,flexWrap,minh-30', [
            svg,
            this.colorOptions.getElement(),
            this.opacitySlider.getElement(),
            this.lineWidthSlider.getElement()
        ]);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        const c = this.colorOptions.getValue();
        if (c === null || c?.a === 0) return {
            stroke: undefined
        };
        const color = {
            ...c,
            a: this.opacitySlider.getValue()
        };
        return {
            stroke: {
                color,
                lineWidth: this.lineWidthSlider.getValue()
            }
        };
    }
    destroy() {
        this.colorOptions.destroy();
        this.opacitySlider.destroy();
        this.lineWidthSlider.destroy();
    }
}

},{"../../../../bb/bb":"3zOvT","../../components/color-options":"1nMl0","../../components/kl-slider":"fQOKQ","../../../../language/language":"mcywn","../../../../bb/base/c":"3KmDH","../../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7CoUL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolTextUI", ()=>TextToolTextUI);
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _c = require("../../../../bb/base/c");
class TextToolTextUI {
    emit() {
        const text = this.textInput.value;
        if (text === this.lastEmittedText) return;
        this.lastEmittedText = text;
        this.onUpdate({
            text
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.onInput = ()=>{
            this.emit();
        };
        this.lastEmittedText = p.text;
        this.onUpdate = p.onUpdate;
        this.rootEl = (0, _c.c)('');
        this.textInput = (0, _bb.BB).el({
            tagName: 'textarea',
            parent: this.rootEl,
            content: p.text,
            custom: {
                placeholder: (0, _language.LANG)('text-placeholder')
            },
            css: {
                whiteSpace: 'pre',
                overflow: 'auto',
                width: '100%',
                height: '70px',
                resize: 'vertical'
            },
            onChange: ()=>{
                this.emit();
            }
        });
        this.textInput.addEventListener('input', this.onInput);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        return {
            text: this.textInput.value
        };
    }
    focus() {
        this.textInput.focus();
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.textInput);
        this.textInput.removeEventListener('input', this.onInput);
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../language/language":"mcywn","../../../../bb/base/c":"3KmDH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"knXox":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolViewportUI", ()=>TextToolViewportUI);
var _bb = require("../../../../bb/bb");
var _base = require("../../../../bb/base/base");
var _theme = require("../../../../theme/theme");
var _renderText = require("../../../image-operations/render-text");
var _klSlider = require("../../components/kl-slider");
var _language = require("../../../../language/language");
var _toolZoomInSvg = require("url:/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
var _toolZoomOutSvg = require("url:/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _c = require("../../../../bb/base/c");
var _getSelectionPath2D = require("../../../../bb/multi-polygon/get-selection-path-2d");
class TextToolViewportUI {
    canZoom(d) {
        return this.zoomFac !== Math.min(2, Math.max(-2, this.zoomFac + d));
    }
    changeZoomFac(d) {
        this.zoomFac = Math.min(2, Math.max(-2, this.zoomFac + d));
        this.render();
        this.zoomInBtn.disabled = !this.canZoom(1);
        this.zoomOutBtn.disabled = !this.canZoom(-1);
    }
    /** Move text by x y **/ move(x, y) {
        const rotated = (0, _bb.BB).rotate(x, y, -this.rotationSlider.getValue() / Math.PI * 180);
        this.text.x += rotated.x / this.scale;
        this.text.y += rotated.y / this.scale;
        this.render();
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.offset = {
            x: 0,
            y: 0
        };
        this.zoomFac = 0;
        this.scale = 1;
        this.layerArr = [];
        this.onDarkChange = ()=>{
            this.checkerPattern = (0, _base.throwIfNull)(this.previewCtx.createPattern((0, _bb.BB).createCheckerCanvas(8, (0, _theme.THEME).isDark()), 'repeat'));
            this.render();
        };
        this.rootEl = (0, _c.c)();
        this.text = p.text;
        this.layerIndex = p.layerIndex;
        const selection = p.klCanvas.getSelection();
        this.selectionPath = selection ? new Path2D((0, _getSelectionPath2D.getSelectionPath2d)(selection)) : undefined;
        const isSmallWidth = window.innerWidth < 550;
        const isSmallHeight = window.innerHeight < 630;
        // --- preview ---
        // Text drawn on klCanvas-sized canvas: textCanvas
        // LayerArr[target].canvas & textCanvas then drawn on targetCanvas
        //      they are transformed. canvas size of final preview
        // All layers and targetCanvas drawn on layersCanvas. transformed and size of final preview
        // Checkerboard, layersCanvas, and outline then drawn on previewCanvas
        this.width = isSmallWidth ? 340 : 540;
        this.height = isSmallWidth ? isSmallHeight ? 210 : 260 : isSmallHeight ? 230 : 350;
        this.layerArr = p.klCanvas.getLayersFast();
        this.textCanvas = (0, _bb.BB).canvas(p.klCanvas.getWidth(), p.klCanvas.getHeight());
        this.textCtx = (0, _bb.BB).ctx(this.textCanvas);
        this.targetCanvas = (0, _bb.BB).canvas(this.width, this.height);
        this.targetCtx = (0, _bb.BB).ctx(this.targetCanvas);
        this.layersCanvas = (0, _bb.BB).canvas(this.width, this.height);
        this.layersCtx = (0, _bb.BB).ctx(this.layersCanvas);
        this.previewCanvas = (0, _bb.BB).canvas(this.width, this.height); // the one that is visible
        this.previewCtx = (0, _bb.BB).ctx(this.previewCanvas);
        (0, _base.css)(this.previewCanvas, {
            display: 'block'
        });
        this.previewWrapper = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                position: 'relative',
                width: this.width + 'px',
                cursor: 'move',
                touchAction: 'none'
            }
        });
        (0, _bb.BB).el({
            // inset shadow on preview
            parent: this.previewWrapper,
            className: 'kl-text-preview-wrapper'
        });
        this.previewWrapper.append(this.previewCanvas);
        this.checkerPattern = (0, _base.throwIfNull)(this.previewCtx.createPattern((0, _bb.BB).createCheckerCanvas(8, (0, _theme.THEME).isDark()), 'repeat'));
        this.emptyCanvas = (0, _bb.BB).canvas(1, 1);
        this.emptyCanvasLight = (0, _bb.BB).canvas(1, 1);
        {
            let ctx = (0, _bb.BB).ctx(this.emptyCanvas);
            ctx.fillRect(0, 0, 1, 1);
            ctx = (0, _bb.BB).ctx(this.emptyCanvasLight);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, 1, 1);
        }
        (0, _theme.THEME).addIsDarkListener(this.onDarkChange);
        this.previewCanvas.oncontextmenu = (e)=>e.preventDefault();
        let dragged = false;
        let isDown = false;
        let offsetDragged = false;
        this.previewPointerListener = new (0, _bb.BB).PointerListener({
            target: this.previewCanvas,
            onPointer: (e)=>{
                // drag detect
                if (e.type === 'pointerdown') {
                    dragged = false;
                    isDown = true;
                }
                if (e.type === 'pointermove' && isDown) dragged = true;
                if (e.type === 'pointerup') {
                    if (isDown && dragged && e.pointerType === 'mouse') // With touch/pen it would be annoying to focus again,
                    // because it probably pops out the keyboard.
                    p.onDragEnd();
                    dragged = false;
                    isDown = false;
                }
                if (e.type === 'pointermove' && e.button === 'left') {
                    e.eventPreventDefault();
                    this.offset = {
                        x: 0,
                        y: 0
                    };
                    this.move(-e.dX, -e.dY);
                }
                if (e.type === 'pointerdown' && e.button === 'right') document.body.append(this.eventCapture);
                if (e.type === 'pointerup') setTimeout(()=>this.eventCapture.remove(), 20);
                if (e.type === 'pointermove' && e.button === 'right') {
                    offsetDragged = true;
                    e.eventPreventDefault();
                    this.offset.x -= e.dX;
                    this.offset.y -= e.dY;
                    this.render();
                }
                if (e.type === 'pointerup' && offsetDragged) {
                    let count = 0;
                    this.interval = setInterval(()=>{
                        if (count > 8) {
                            clearInterval(this.interval);
                            this.offset = {
                                x: 0,
                                y: 0
                            };
                            this.render();
                        }
                        this.offset = {
                            x: this.offset.x * 0.6,
                            y: this.offset.y * 0.6
                        };
                        this.render();
                        count++;
                    }, 10);
                    this.offset = {
                        x: this.offset.x * 0.6,
                        y: this.offset.y * 0.6
                    };
                    this.render();
                }
            },
            onWheel: (e)=>{
                this.changeZoomFac(-e.deltaY);
            }
        });
        const wheelPrevent = (event)=>event.preventDefault();
        this.previewCanvas.addEventListener('wheel', wheelPrevent, {
            passive: false
        });
        this.rotationSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-transform-rotation'),
            width: 150,
            height: 30,
            min: -Math.PI,
            max: Math.PI,
            value: p.text.angleRad,
            resolution: 225,
            // eventResMs: 1000 / 30,
            toValue: (deg)=>deg * Math.PI / 180,
            toDisplayValue: (rad)=>rad / Math.PI * 180,
            onChange: ()=>{
                this.offset = {
                    x: 0,
                    y: 0
                };
                this.render();
            },
            unit: "\xb0"
        });
        this.zoomInBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: `<img height="20" src="${(0, _toolZoomInSvgDefault.default)}">`,
            title: (0, _language.LANG)('zoom-in'),
            onClick: ()=>this.changeZoomFac(1),
            css: {
                fontWeight: 'bold'
            }
        });
        this.zoomOutBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: `<img height="20" src="${(0, _toolZoomOutSvgDefault.default)}">`,
            title: (0, _language.LANG)('zoom-out'),
            onClick: ()=>this.changeZoomFac(-1),
            css: {
                fontWeight: 'bold'
            }
        });
        this.eventCapture = (0, _bb.BB).el({
            css: {
                position: 'absolute',
                left: '0',
                top: '0',
                right: '0',
                bottom: '0',
                zIndex: '999',
                cursor: 'move'
            }
        });
        this.eventCapture.oncontextmenu = (e)=>e.preventDefault();
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr)=>{
                if ((0, _bb.BB).isInputFocused(true)) return;
                const factor = this.keyListener.isPressed('shift') ? 4 : 1;
                if (keyStr === 'left') this.move(-factor, 0);
                if (keyStr === 'right') this.move(factor, 0);
                if (keyStr === 'up') this.move(0, -factor);
                if (keyStr === 'down') this.move(0, factor);
            }
        });
        this.inputsRootEl = (0, _c.c)(',flex,gap-5', [
            this.rotationSlider.getElement(),
            (0, _c.c)(),
            this.zoomInBtn,
            this.zoomOutBtn
        ]);
    }
    render() {
        // try to draw very much like klCanvasWorkspace
        const angleRad = this.rotationSlider.getValue();
        // --- draw text ---
        this.textCtx.clearRect(0, 0, this.textCanvas.width, this.textCanvas.height);
        const bounds = (0, _renderText.renderText)(this.textCanvas, {
            ...this.text,
            x: this.text.x,
            y: this.text.y,
            angleRad: this.rotationSlider.getValue()
        }, this.selectionPath);
        if (this.selectionPath) {
            this.textCtx.save();
            this.textCtx.setLineDash([
                4
            ]);
            this.textCtx.strokeStyle = '#000';
            this.textCtx.stroke(this.selectionPath);
            this.textCtx.lineDashOffset = 4;
            this.textCtx.strokeStyle = '#fff';
            this.textCtx.stroke(this.selectionPath);
            this.textCtx.restore();
        }
        // transform offset
        const transformedOffset = (0, _bb.BB).Vec2.mul((0, _bb.BB).rotate(this.offset.x, this.offset.y, -angleRad / Math.PI * 180), 1 / this.scale);
        // --- determine transformation of viewport ---
        // text should always be visible
        bounds.x -= 3;
        bounds.y -= 3;
        bounds.width += 6;
        bounds.height += 6;
        const rotatedXY = (0, _bb.BB).rotate(bounds.x, bounds.y, -angleRad / Math.PI * 180);
        const rotatedWH = (0, _bb.BB).rotate(bounds.width, bounds.height, -angleRad / Math.PI * 180);
        const centerX = this.text.x + rotatedXY.x + rotatedWH.x / 2 + transformedOffset.x;
        const centerY = this.text.y + rotatedXY.y + rotatedWH.y / 2 + transformedOffset.y;
        const padding = 100;
        const fitBounds = (0, _bb.BB).fitInto(bounds.width, bounds.height, this.width - padding, this.height - padding);
        this.scale = Math.min(1, fitBounds.width / bounds.width);
        this.scale = Math.min(4, this.scale * Math.pow(2, this.zoomFac));
        // --- compose text and target layer ---
        this.targetCtx.save();
        if (this.scale >= 4) this.targetCtx.imageSmoothingEnabled = false;
        else {
            this.targetCtx.imageSmoothingEnabled = true;
            this.targetCtx.imageSmoothingQuality = this.scale >= 1 ? 'low' : 'medium';
        }
        this.targetCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        this.targetCtx.translate(this.width / 2, this.height / 2);
        this.targetCtx.scale(this.scale, this.scale);
        this.targetCtx.rotate(angleRad);
        this.targetCtx.drawImage(this.layerArr[this.layerIndex].canvas, -centerX, -centerY);
        this.targetCtx.drawImage(this.textCanvas, -centerX, -centerY);
        this.targetCtx.restore();
        const isDark = (0, _theme.THEME).isDark();
        // --- layers ---
        this.layersCtx.save();
        this.layersCtx.fillStyle = isDark ? 'rgb(33,33,33)' : 'rgb(158,158,158)';
        this.layersCtx.fillRect(0, 0, this.width, this.height);
        {
            // bg
            this.layersCtx.save();
            this.layersCtx.translate(this.width / 2, this.height / 2);
            this.layersCtx.scale(this.scale, this.scale);
            this.layersCtx.rotate(angleRad);
            this.layersCtx.imageSmoothingEnabled = false;
            //outline
            const borderSize = 1 / this.scale;
            this.layersCtx.globalAlpha = isDark ? 0.25 : 0.2;
            this.layersCtx.drawImage(isDark ? this.emptyCanvasLight : this.emptyCanvas, -centerX - borderSize, -centerY - borderSize, this.textCanvas.width + borderSize * 2, this.textCanvas.height + borderSize * 2);
            this.layersCtx.globalAlpha = 1;
            //erase
            this.layersCtx.globalCompositeOperation = 'destination-out';
            this.layersCtx.drawImage(this.emptyCanvas, -centerX, -centerY, this.textCanvas.width, this.textCanvas.height);
            this.layersCtx.restore();
        }
        // individual layers
        if (this.scale >= 4) this.layersCtx.imageSmoothingEnabled = false;
        else {
            this.layersCtx.imageSmoothingEnabled = true;
            this.layersCtx.imageSmoothingQuality = this.scale >= 1 ? 'low' : 'medium';
        }
        // layers below
        this.layersCtx.save();
        this.layersCtx.translate(this.width / 2, this.height / 2);
        this.layersCtx.scale(this.scale, this.scale);
        this.layersCtx.rotate(angleRad);
        for(let i = 0; i < this.layerIndex; i++)if (this.layerArr[i].isVisible && this.layerArr[i].opacity > 0) {
            this.layersCtx.globalAlpha = this.layerArr[i].opacity;
            this.layersCtx.globalCompositeOperation = this.layerArr[i].mixModeStr;
            this.layersCtx.drawImage(this.layerArr[i].canvas, -centerX, -centerY);
        }
        this.layersCtx.restore();
        // target layer
        this.layersCtx.globalAlpha = this.layerArr[this.layerIndex].opacity * (this.layerArr[this.layerIndex].isVisible ? 1 : 0);
        this.layersCtx.globalCompositeOperation = this.layerArr[this.layerIndex].mixModeStr;
        this.layersCtx.drawImage(this.targetCanvas, 0, 0);
        // layers above
        this.layersCtx.save();
        this.layersCtx.translate(this.width / 2, this.height / 2);
        this.layersCtx.scale(this.scale, this.scale);
        this.layersCtx.rotate(angleRad);
        for(let i = this.layerIndex + 1; i < this.layerArr.length; i++)if (this.layerArr[i].isVisible && this.layerArr[i].opacity > 0) {
            this.layersCtx.globalAlpha = this.layerArr[i].opacity;
            this.layersCtx.globalCompositeOperation = this.layerArr[i].mixModeStr;
            this.layersCtx.drawImage(this.layerArr[i].canvas, -centerX, -centerY);
        }
        this.layersCtx.restore();
        this.layersCtx.restore();
        // --- final composite ---
        this.previewCtx.save();
        this.previewCtx.fillStyle = this.checkerPattern;
        this.previewCtx.fillRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        this.previewCtx.drawImage(this.layersCanvas, 0, 0);
        this.previewCtx.restore();
        // bounds
        this.previewCtx.save();
        this.previewCtx.globalCompositeOperation = 'difference';
        this.previewCtx.strokeStyle = '#fff';
        this.previewCtx.lineWidth = 0.5;
        this.previewCtx.translate(-this.offset.x, -this.offset.y);
        this.previewCtx.strokeRect(Math.round(this.width / 2 - bounds.width / 2 * this.scale) + 0.5, Math.round(this.height / 2 - bounds.height / 2 * this.scale) + 0.5, Math.round(bounds.width * this.scale), Math.round(bounds.height * this.scale));
        this.previewCtx.restore();
    }
    getElement() {
        return this.rootEl;
    }
    getInputsElement() {
        return this.inputsRootEl;
    }
    getValues() {
        return {
            x: this.text.x,
            y: this.text.y,
            angleRad: this.rotationSlider.getValue()
        };
    }
    setText(text) {
        const x = this.text.x;
        const y = this.text.y;
        const angleRad = this.text.angleRad;
        this.text = {
            ...text,
            x,
            y,
            angleRad
        };
        this.render();
    }
    setSize(width, height) {
        // prevents: Failed to execute 'drawImage' on 'CanvasRenderingContext2D':
        // The image argument is a canvas element with a width or height of 0.
        width = Math.max(1, width);
        height = Math.max(1, height);
        if (width === this.width && height === this.height) return;
        this.width = width;
        this.height = height;
        this.targetCanvas.width = this.width;
        this.targetCanvas.height = this.height;
        this.layersCanvas.width = this.width;
        this.layersCanvas.height = this.height;
        this.previewCanvas.width = this.width;
        this.previewCanvas.height = this.height;
        this.previewWrapper.style.width = this.width + 'px';
        this.render();
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.rootEl);
        (0, _bb.BB).destroyEl(this.inputsRootEl);
        (0, _bb.BB).destroyEl(this.previewWrapper);
        clearInterval(this.interval);
        this.rotationSlider.destroy();
        (0, _bb.BB).destroyEl(this.zoomInBtn);
        (0, _bb.BB).destroyEl(this.zoomOutBtn);
        this.eventCapture.remove();
        this.previewPointerListener.destroy();
        this.keyListener.destroy();
        (0, _theme.THEME).removeIsDarkListener(this.onDarkChange);
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../bb/base/base":"it3mQ","../../../../theme/theme":"cVh0j","../../../image-operations/render-text":"5Zm2S","../../components/kl-slider":"fQOKQ","../../../../language/language":"mcywn","url:/src/app/img/ui/tool-zoom-in.svg":"6SrvZ","url:/src/app/img/ui/tool-zoom-out.svg":"ifF9F","../../../../bb/base/c":"3KmDH","../../../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"le1Yb":[function(require,module,exports,__globalThis) {
module.exports["inputs"] = `_5vlQAW_inputs`;
module.exports["tab"] = `_5vlQAW_tab`;
module.exports["tabWrapper"] = `_5vlQAW_tabWrapper`;
module.exports["viewportInputs"] = `_5vlQAW_viewportInputs`;
module.exports["viewportWrapper"] = `_5vlQAW_viewportWrapper`;

},{}],"hEFCl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Shows first dialog when importing an image.
 * Where you can crop, and select import as layer or as image.
 */ parcelHelpers.export(exports, "showImportImageDialog", ()=>showImportImageDialog);
var _bb = require("../../../bb/bb");
var _cropCopy = require("../components/crop-copy");
var _checkbox = require("../components/checkbox");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
function showImportImageDialog(p) {
    const rootEl = (0, _bb.BB).el();
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    const style = isSmall ? {} : {
        width: '540px'
    };
    const resolutionEl = (0, _bb.BB).el({
        css: {
            marginTop: '10px',
            textAlign: 'center',
            color: '#888',
            lineHeight: '20px'
        }
    });
    const cropCopy = new (0, _cropCopy.CropCopy)({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 400,
        canvas: p.image.canvas,
        enableRightClickCopy: false,
        onChange: (width, height)=>{
            if (!resolutionEl) return;
            updateResolution(width, height);
        }
    });
    (0, _base.css)(cropCopy.getElement(), {
        marginLeft: '-20px'
    });
    cropCopy.getElement().title = (0, _language.LANG)('crop-drag-to-crop');
    rootEl.append(cropCopy.getElement(), resolutionEl);
    function updateResolution(w, h) {
        const fit = (0, _bb.BB).fitInto(w, h, p.maxSize, p.maxSize);
        if (fit.width < w) {
            resolutionEl.innerHTML = `<span class="kl-text-error">${w} X ${h}</span> \u{27F6} ${Math.round(fit.width)} X ${Math.round(fit.height)}`;
            resolutionEl.title = (0, _language.LANG)('import-too-large');
        } else {
            resolutionEl.innerHTML = `${w} X ${h}`;
            resolutionEl.title = '';
        }
    }
    updateResolution(p.image.width, p.image.height);
    let doFlatten = false;
    function showWarnings(psdWarningArr) {
        const contentArr = [];
        const warningMap = {
            mask: 'Masks not supported. Mask was applied.',
            clipping: 'Clipping not supported. Clipping layers were merged.',
            group: 'Groups not supported. Layers were ungrouped.',
            adjustment: 'Adjustment layers not supported.',
            'layer-effect': 'Layer effects not supported.',
            'smart-object': 'Smart objects not supported.',
            'blend-mode': 'Unsupported layer blend mode.',
            'bits-per-channel': 'Unsupported color depth. Only 8bit per channel supported.'
        };
        for(let i = 0; i < psdWarningArr.length; i++)contentArr.push('- ' + warningMap[psdWarningArr[i]]);
        alert(contentArr.join('\n'));
    }
    let flattenCheckbox;
    let warningsEl;
    if (p.image.type === 'psd') {
        if (p.image.layers) {
            flattenCheckbox = new (0, _checkbox.Checkbox)({
                init: doFlatten,
                label: (0, _language.LANG)('import-flatten'),
                callback: (b)=>{
                    doFlatten = b;
                },
                name: 'flatten-image'
            });
            rootEl.append(flattenCheckbox.getElement());
            if (p.image.warningArr) {
                const noteEl = (0, _bb.BB).el({
                    className: 'kl-import-note',
                    content: (0, _language.LANG)('import-psd-limited-support')
                });
                const warnings = p.image.warningArr;
                warningsEl = (0, _bb.BB).el({
                    parent: noteEl,
                    tagName: 'a',
                    content: 'Details',
                    css: {
                        marginLeft: '5px'
                    },
                    onClick: ()=>showWarnings(warnings)
                });
                rootEl.append(noteEl);
            }
        } else {
            const noteEl = (0, _bb.BB).el({
                className: 'kl-import-note',
                content: (0, _language.LANG)('import-psd-unsupported')
            });
            rootEl.append(noteEl);
        }
    }
    function callback(result) {
        const croppedCanvas = cropCopy.getCroppedCanvas();
        const cropRect = cropCopy.getCropRect();
        const isCropped = p.image.width !== cropRect.width || p.image.height !== cropRect.height;
        cropCopy.destroy();
        (0, _bb.BB).destroyEl(warningsEl);
        if (flattenCheckbox) flattenCheckbox.destroy();
        if (result === (0, _language.LANG)('import-btn-as-layer')) {
            p.callback({
                type: 'as-layer',
                image: isCropped ? croppedCanvas : p.image.canvas
            });
            if (!isCropped) (0, _bb.BB).freeCanvas(croppedCanvas);
        } else if (result === (0, _language.LANG)('import-btn-as-image')) {
            if (p.image.type === 'psd') {
                if (doFlatten) delete p.image.layers;
                p.callback({
                    type: 'as-image-psd',
                    image: p.image,
                    cropObj: cropRect
                });
                (0, _bb.BB).freeCanvas(croppedCanvas);
            } else if (p.image.type === 'image') p.callback({
                type: 'as-image',
                image: croppedCanvas
            });
        } else {
            p.callback({
                type: 'cancel'
            });
            (0, _bb.BB).freeCanvas(croppedCanvas);
        }
    }
    (0, _showModal.showModal)({
        target: p.target,
        message: `<b>${(0, _language.LANG)('import-title')}</b>`,
        div: rootEl,
        style,
        buttons: [
            (0, _language.LANG)('import-btn-as-layer'),
            (0, _language.LANG)('import-btn-as-image'),
            'Cancel'
        ],
        primaries: [
            (0, _language.LANG)('import-btn-as-layer'),
            (0, _language.LANG)('import-btn-as-image')
        ],
        callback,
        autoFocus: 'As Image'
    });
}

},{"../../../bb/bb":"3zOvT","../components/crop-copy":"dtoRN","../components/checkbox":"9bXL6","./base/showModal":"gy3iL","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"erBJa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendPsdToKl", ()=>blendPsdToKl);
parcelHelpers.export(exports, "blendKlToPsd", ()=>blendKlToPsd);
/**
 * Converts ag-psd object into something that KlCanvas can represent
 * @param psdObj
 */ parcelHelpers.export(exports, "readPsd", ()=>readPsd);
parcelHelpers.export(exports, "klPsdToKlProject", ()=>klPsdToKlProject);
var _createCanvas = require("../../bb/base/create-canvas");
var _language = require("../../language/language");
var _klCanvas = require("../canvas/kl-canvas");
var _bb = require("../../bb/bb");
var _base = require("../../bb/base/base");
let kl2PsdMap;
let psd2KlMap;
function init() {
    if (kl2PsdMap) return;
    kl2PsdMap = {
        'source-over': 'normal',
        darken: 'darken',
        multiply: 'multiply',
        'color-burn': 'color burn',
        lighten: 'lighten',
        screen: 'screen',
        'color-dodge': 'color dodge',
        overlay: 'overlay',
        'soft-light': 'soft light',
        'hard-light': 'hard light',
        difference: 'difference',
        exclusion: 'exclusion',
        hue: 'hue',
        saturation: 'saturation',
        color: 'color',
        luminosity: 'luminosity'
    };
    psd2KlMap = Object.fromEntries(Object.entries(kl2PsdMap).map((a)=>a.reverse()));
}
function blendPsdToKl(str) {
    init();
    return psd2KlMap[str];
}
function blendKlToPsd(str) {
    init();
    return kl2PsdMap[str];
}
function readPsd(psdObj) {
    if (!psdObj.canvas) throw new Error('psdObj.canvas undefined');
    const result = {
        type: 'psd',
        canvas: psdObj.canvas,
        width: psdObj.width,
        height: psdObj.height
    };
    function addWarning(warningStr) {
        if (!result.warningArr) result.warningArr = [];
        if (result.warningArr.includes(warningStr)) return;
        result.warningArr.push(warningStr);
    }
    function getMixModeStr(blendMode) {
        let mixModeStr = blendPsdToKl(blendMode);
        if (!mixModeStr) {
            addWarning('blend-mode');
            mixModeStr = 'source-over';
        }
        return mixModeStr;
    }
    if (psdObj.bitsPerChannel !== 8) addWarning('bits-per-channel');
    if (!psdObj.children) {
        result.error = true;
        return result;
    }
    // count resulting layers
    const maxLayers = (0, _klCanvas.MAX_LAYERS);
    let layerCount = 0;
    function countWithinGroup(groupObj) {
        let result = 0;
        if (groupObj.blendMode) {
            const mixModeStr = blendPsdToKl(groupObj.blendMode);
            if (mixModeStr && mixModeStr !== 'source-over') return 1;
        }
        if (groupObj.children) for(let i = 0; i < groupObj.children.length; i++){
            const item = groupObj.children[i];
            if (item.clipping || item.adjustment) continue;
            if (item.children) {
                addWarning('group');
                result += countWithinGroup(item);
            } else result++;
        }
        return result;
    }
    layerCount += countWithinGroup(psdObj);
    if (layerCount > maxLayers) {
        result.error = true;
        return result;
    }
    result.layers = [];
    function prepareMask(maskCanvas, defaultColor) {
        const groupMaskCtx = (0, _bb.BB).ctx(maskCanvas);
        const imData = groupMaskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
        if (defaultColor === 0) for(let i = 0; i < imData.data.length; i += 4)imData.data[i + 3] = imData.data[i];
        else for(let i = 0; i < imData.data.length; i += 4)imData.data[i + 3] = 255 - imData.data[i];
        groupMaskCtx.putImageData(imData, 0, 0);
    }
    function convertGroup(psdGroupObj) {
        let resultArr = [];
        const groupIsVisible = !psdGroupObj.hidden;
        const groupOpacity = (0, _base.throwIfUndefined)(psdGroupObj.opacity, 'groupOpacity is undefined');
        const groupMixModeStr = getMixModeStr(psdGroupObj.blendMode);
        let groupCanvas;
        let groupCtx;
        if (groupMixModeStr !== 'source-over') {
            groupCanvas = (0, _createCanvas.createCanvas)(result.width, result.height);
            groupCtx = (0, _bb.BB).ctx(groupCanvas);
        }
        // prepare group mask
        if (psdGroupObj.mask) {
            addWarning('mask');
            prepareMask(psdGroupObj.mask.canvas, psdGroupObj.mask.defaultColor);
        }
        if (psdGroupObj.children) for(let i = 0; i < psdGroupObj.children.length; i++){
            const item = psdGroupObj.children[i];
            if (item.clipping) continue;
            if (item.adjustment) {
                addWarning('adjustment');
                continue;
            }
            const hasClipping = (item.children || item.canvas) && psdGroupObj.children[i + 1] && psdGroupObj.children[i + 1].clipping;
            if (hasClipping) addWarning('clipping');
            if (item.children) {
                const convertedChildGroupItems = convertGroup(item);
                for(let e = 0; e < convertedChildGroupItems.length; e++){
                    const innerItem = convertedChildGroupItems[e];
                    const innerCtx = (0, _bb.BB).ctx(innerItem.image);
                    // clipping
                    if (hasClipping) {
                        const clippingCanvas = (0, _createCanvas.createCanvas)(result.width, result.height);
                        const clippingCtx = (0, _bb.BB).ctx(clippingCanvas);
                        clippingCtx.drawImage(innerItem.image, 0, 0);
                        for(let f = i + 1; f < psdGroupObj.children.length && psdGroupObj.children[f].clipping; f++){
                            const clippingItem = psdGroupObj.children[f];
                            if (clippingItem.opacity === 0 || clippingItem.hidden) continue;
                            if (clippingItem.blendMode === undefined) throw new Error('clippingItem.blendMode undefined');
                            if (clippingItem.opacity === undefined) throw new Error('clippingItem.opacity undefined');
                            if (clippingItem.canvas === undefined) throw new Error('clippingItem.canvas undefined');
                            if (clippingItem.left === undefined) throw new Error('clippingItem.left undefined');
                            if (clippingItem.top === undefined) throw new Error('clippingItem.top undefined');
                            clippingCtx.globalCompositeOperation = getMixModeStr(clippingItem.blendMode);
                            clippingCtx.globalAlpha = clippingItem.opacity;
                            clippingCtx.drawImage(clippingItem.canvas, clippingItem.left, clippingItem.top);
                        }
                        innerCtx.globalCompositeOperation = 'source-atop';
                        innerCtx.drawImage(clippingCanvas, 0, 0);
                    }
                    // group mask
                    if (psdGroupObj.mask) {
                        innerCtx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? 'destination-in' : 'destination-out';
                        if (psdGroupObj.mask.canvas === undefined) throw new Error('psdGroupObj.mask.canvas undefined');
                        if (psdGroupObj.mask.left === undefined) throw new Error('psdGroupObj.mask.left undefined');
                        if (psdGroupObj.mask.top === undefined) throw new Error('psdGroupObj.mask.top undefined');
                        innerCtx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
                    }
                    if (groupCanvas) {
                        if (groupCtx === undefined) throw new Error('groupCtx undefined');
                        groupCtx.globalCompositeOperation = innerItem.mixModeStr;
                        groupCtx.globalAlpha = innerItem.opacity;
                        groupCtx.drawImage(innerItem.image, 0, 0);
                    } else {
                        innerItem.opacity = innerItem.opacity * groupOpacity;
                        resultArr.push(innerItem);
                    }
                }
                continue;
            }
            const canvas = (0, _createCanvas.createCanvas)(result.width, result.height);
            const ctx = (0, _bb.BB).ctx(canvas);
            if (item.canvas) {
                // if a layer is empty it has no canvas
                if (item.top === undefined) throw new Error('item.top undefined');
                if (item.left === undefined) throw new Error('item.left undefined');
                ctx.drawImage(item.canvas, item.left, item.top);
            }
            // effects
            if (item.effects) addWarning('layer-effect');
            // mask
            if (item.mask) {
                addWarning('mask');
                if (item.mask.canvas === undefined) throw new Error('item.mask.canvas undefined');
                if (item.mask.defaultColor === undefined) throw new Error('item.mask.defaultColor undefined');
                if (item.mask.left === undefined) throw new Error('item.mask.left undefined');
                if (item.mask.top === undefined) throw new Error('item.mask.top undefined');
                prepareMask(item.mask.canvas, item.mask.defaultColor);
                ctx.globalCompositeOperation = item.mask.defaultColor === 0 ? 'destination-in' : 'destination-out';
                ctx.drawImage(item.mask.canvas, item.mask.left, item.mask.top);
            }
            // clipping
            if (hasClipping) {
                if (item.right === undefined) throw new Error('item.right undefined');
                if (item.left === undefined) throw new Error('item.left undefined');
                if (item.bottom === undefined) throw new Error('item.bottom undefined');
                if (item.top === undefined) throw new Error('item.top undefined');
                if (item.canvas === undefined) throw new Error('item.canvas undefined');
                const clippingCanvas = (0, _createCanvas.createCanvas)(item.right - item.left, item.bottom - item.top);
                const clippingCtx = (0, _bb.BB).ctx(clippingCanvas);
                clippingCtx.drawImage(item.canvas, 0, 0);
                for(let e = i + 1; e < psdGroupObj.children.length && psdGroupObj.children[e].clipping; e++){
                    const clippingItem = psdGroupObj.children[e];
                    if (clippingItem.opacity === 0 || clippingItem.hidden) continue;
                    if (clippingItem.blendMode === undefined) throw new Error('clippingItem.blendMode undefined');
                    if (clippingItem.opacity === undefined) throw new Error('clippingItem.opacity undefined');
                    if (clippingItem.canvas === undefined) throw new Error('clippingItem.canvas undefined');
                    if (clippingItem.left === undefined) throw new Error('clippingItem.left undefined');
                    if (clippingItem.top === undefined) throw new Error('clippingItem.top undefined');
                    clippingCtx.globalCompositeOperation = getMixModeStr(clippingItem.blendMode);
                    clippingCtx.globalAlpha = clippingItem.opacity;
                    clippingCtx.drawImage(clippingItem.canvas, clippingItem.left - item.left, clippingItem.top - item.top);
                }
                ctx.globalCompositeOperation = 'source-atop';
                ctx.drawImage(clippingCanvas, item.left, item.top);
            }
            // group mask
            if (psdGroupObj.mask) {
                ctx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? 'destination-in' : 'destination-out';
                if (psdGroupObj.mask.canvas === undefined) throw new Error('psdGroupObj.mask.canvas undefined');
                if (psdGroupObj.mask.left === undefined) throw new Error('psdGroupObj.mask.left undefined');
                if (psdGroupObj.mask.top === undefined) throw new Error('psdGroupObj.mask.top undefined');
                ctx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
            }
            if (item.blendMode === undefined) throw new Error('item.blendMode undefined');
            if (item.hidden === undefined) throw new Error('item.hidden  undefined');
            if (item.opacity === undefined) throw new Error('item.opacity undefined');
            if (groupCanvas && groupCtx) {
                if (groupOpacity > 0) {
                    groupCtx.globalCompositeOperation = getMixModeStr(item.blendMode);
                    groupCtx.globalAlpha = item.hidden ? 0 : item.opacity;
                    groupCtx.drawImage(canvas, 0, 0);
                }
            } else {
                if (item.name === undefined) throw new Error('item.name undefined');
                resultArr.push({
                    name: item.name,
                    isVisible: !item.hidden && groupIsVisible,
                    opacity: item.opacity * groupOpacity,
                    mixModeStr: getMixModeStr(item.blendMode),
                    image: canvas
                });
            }
        }
        if (groupCanvas) {
            if (psdGroupObj.name === undefined) throw new Error('psdGroupObj.name undefined');
            resultArr = [
                {
                    name: psdGroupObj.name,
                    isVisible: groupIsVisible,
                    opacity: groupOpacity,
                    mixModeStr: groupMixModeStr,
                    image: groupCanvas
                }
            ];
        }
        return resultArr;
    }
    result.layers = convertGroup({
        name: 'root',
        opacity: 1,
        blendMode: 'normal',
        children: psdObj.children
    });
    return result;
}
function klPsdToKlProject(klPsd) {
    // only share references to Canvas elements
    const result = {
        projectId: (0, _base.randomUuid)(),
        width: klPsd.width,
        height: klPsd.height,
        layers: []
    };
    if (klPsd.layers) result.layers = klPsd.layers.map((item)=>{
        return {
            name: item.name,
            isVisible: item.isVisible,
            opacity: item.opacity,
            mixModeStr: item.mixModeStr,
            image: item.image
        };
    });
    else // flattened
    result.layers = [
        {
            name: (0, _language.LANG)('background'),
            isVisible: true,
            opacity: 1,
            mixModeStr: 'source-over',
            image: klPsd.canvas
        }
    ];
    return result;
}

},{"../../bb/base/create-canvas":"5vnin","../../language/language":"mcywn","../canvas/kl-canvas":"aumh6","../../bb/bb":"3zOvT","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g0YSX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FILTER_LIB_STATUS", ()=>FILTER_LIB_STATUS);
parcelHelpers.export(exports, "FILTER_LIB", ()=>FILTER_LIB);
var _editBrightnessContrastSvg = require("url:/src/app/img/ui/edit-brightness-contrast.svg");
var _editBrightnessContrastSvgDefault = parcelHelpers.interopDefault(_editBrightnessContrastSvg);
var _editCropSvg = require("url:/src/app/img/ui/edit-crop.svg");
var _editCropSvgDefault = parcelHelpers.interopDefault(_editCropSvg);
var _editCurvesSvg = require("url:/src/app/img/ui/edit-curves.svg");
var _editCurvesSvgDefault = parcelHelpers.interopDefault(_editCurvesSvg);
var _editFlipSvg = require("url:/src/app/img/ui/edit-flip.svg");
var _editFlipSvgDefault = parcelHelpers.interopDefault(_editFlipSvg);
var _editHueSaturationSvg = require("url:/src/app/img/ui/edit-hue-saturation.svg");
var _editHueSaturationSvgDefault = parcelHelpers.interopDefault(_editHueSaturationSvg);
var _editInvertPng = require("url:/src/app/img/ui/edit-invert.png");
var _editInvertPngDefault = parcelHelpers.interopDefault(_editInvertPng);
var _editPerspectiveSvg = require("url:/src/app/img/ui/edit-perspective.svg");
var _editPerspectiveSvgDefault = parcelHelpers.interopDefault(_editPerspectiveSvg);
var _editResizeSvg = require("url:/src/app/img/ui/edit-resize.svg");
var _editResizeSvgDefault = parcelHelpers.interopDefault(_editResizeSvg);
var _editRotateSvg = require("url:/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
var _editTiltShiftPng = require("url:/src/app/img/ui/edit-tilt-shift.png");
var _editTiltShiftPngDefault = parcelHelpers.interopDefault(_editTiltShiftPng);
var _editToAlphaSvg = require("url:/src/app/img/ui/edit-to-alpha.svg");
var _editToAlphaSvgDefault = parcelHelpers.interopDefault(_editToAlphaSvg);
var _editTransformSvg = require("url:/src/app/img/ui/edit-transform.svg");
var _editTransformSvgDefault = parcelHelpers.interopDefault(_editTransformSvg);
var _editTriangleBlurPng = require("url:/src/app/img/ui/edit-triangle-blur.png");
var _editTriangleBlurPngDefault = parcelHelpers.interopDefault(_editTriangleBlurPng);
var _editUnsharpMaskPng = require("url:/src/app/img/ui/edit-unsharp-mask.png");
var _editUnsharpMaskPngDefault = parcelHelpers.interopDefault(_editUnsharpMaskPng);
var _editGridSvg = require("url:/src/app/img/ui/edit-grid.svg");
var _editGridSvgDefault = parcelHelpers.interopDefault(_editGridSvg);
var _editNoiseSvg = require("url:/src/app/img/ui/edit-noise.svg");
var _editNoiseSvgDefault = parcelHelpers.interopDefault(_editNoiseSvg);
var _editPatternSvg = require("url:/src/app/img/ui/edit-pattern.svg");
var _editPatternSvgDefault = parcelHelpers.interopDefault(_editPatternSvg);
var _editVanishPointSvg = require("url:/src/app/img/ui/edit-vanish-point.svg");
var _editVanishPointSvgDefault = parcelHelpers.interopDefault(_editVanishPointSvg);
var _editDistortSvg = require("url:/src/app/img/ui/edit-distort.svg");
var _editDistortSvgDefault = parcelHelpers.interopDefault(_editDistortSvg);
const FILTER_LIB_STATUS = {
    isLoaded: false
};
const FILTER_LIB = {
    brightnessContrast: {
        lang: {
            name: 'filter-bright-contrast-title',
            button: 'filter-bright-contrast',
            description: 'filter-bright-contrast-description'
        },
        icon: (0, _editBrightnessContrastSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    cropExtend: {
        lang: {
            name: 'filter-crop-title',
            button: 'filter-crop-extend',
            description: 'filter-crop-description'
        },
        icon: (0, _editCropSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    curves: {
        lang: {
            name: 'filter-curves-title',
            button: 'filter-curves',
            description: 'filter-curves-description'
        },
        icon: (0, _editCurvesSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    distort: {
        lang: {
            name: 'filter-distort',
            button: 'filter-distort',
            description: 'filter-distort-description'
        },
        icon: (0, _editDistortSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    flip: {
        lang: {
            name: 'filter-flip-title',
            button: 'filter-flip',
            description: 'filter-flip-description'
        },
        icon: (0, _editFlipSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    hueSaturation: {
        lang: {
            name: 'filter-hue-sat-title',
            button: 'filter-hue-sat',
            description: 'filter-hue-sat-description'
        },
        icon: (0, _editHueSaturationSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    invert: {
        lang: {
            name: 'filter-invert',
            button: 'filter-invert'
        },
        icon: (0, _editInvertPngDefault.default),
        updatePos: false,
        isInstant: true,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    perspective: {
        lang: {
            name: 'filter-perspective-title',
            button: 'filter-perspective',
            description: 'filter-perspective-description'
        },
        icon: (0, _editPerspectiveSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    resize: {
        lang: {
            name: 'filter-resize-title',
            button: 'filter-resize',
            description: 'filter-resize-description'
        },
        icon: (0, _editResizeSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    rotate: {
        lang: {
            name: 'filter-rotate-title',
            button: 'filter-rotate',
            description: 'filter-rotate-description'
        },
        icon: (0, _editRotateSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    tiltShift: {
        lang: {
            name: 'filter-tilt-shift-title',
            button: 'filter-tilt-shift',
            description: 'filter-tilt-shift-description'
        },
        icon: (0, _editTiltShiftPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    toAlpha: {
        lang: {
            name: 'filter-to-alpha-title',
            button: 'filter-to-alpha',
            description: 'filter-to-alpha-description'
        },
        icon: (0, _editToAlphaSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    transform: {
        lang: {
            name: 'filter-transform-title',
            button: 'filter-transform',
            description: 'filter-transform-description'
        },
        icon: (0, _editTransformSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    blur: {
        lang: {
            name: 'filter-triangle-blur-title',
            button: 'filter-triangle-blur',
            description: 'filter-triangle-blur-description'
        },
        icon: (0, _editTriangleBlurPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    unsharpMask: {
        lang: {
            name: 'filter-unsharp-mask-title',
            button: 'filter-unsharp-mask',
            description: 'filter-unsharp-mask-description'
        },
        icon: (0, _editUnsharpMaskPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    grid: {
        lang: {
            name: 'filter-grid',
            button: 'filter-grid',
            description: 'filter-grid-description'
        },
        icon: (0, _editGridSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    noise: {
        lang: {
            name: 'filter-noise',
            button: 'filter-noise',
            description: 'filter-noise-description'
        },
        icon: (0, _editNoiseSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    pattern: {
        lang: {
            name: 'filter-pattern',
            button: 'filter-pattern',
            description: 'filter-pattern-description'
        },
        icon: (0, _editPatternSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    vanishPoint: {
        lang: {
            name: 'filter-vanish-point-title',
            button: 'filter-vanish-point',
            description: 'filter-vanish-point-description'
        },
        icon: (0, _editVanishPointSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    }
};

},{"url:/src/app/img/ui/edit-brightness-contrast.svg":"fGV1h","url:/src/app/img/ui/edit-crop.svg":"7YZBQ","url:/src/app/img/ui/edit-curves.svg":"EPqrf","url:/src/app/img/ui/edit-flip.svg":"8P4CE","url:/src/app/img/ui/edit-hue-saturation.svg":"8b5hd","url:/src/app/img/ui/edit-invert.png":"k3o84","url:/src/app/img/ui/edit-perspective.svg":"54Ty3","url:/src/app/img/ui/edit-resize.svg":"9m2Yr","url:/src/app/img/ui/edit-rotate.svg":"hKhwU","url:/src/app/img/ui/edit-tilt-shift.png":"9zvFt","url:/src/app/img/ui/edit-to-alpha.svg":"j1hlf","url:/src/app/img/ui/edit-transform.svg":"3cuJX","url:/src/app/img/ui/edit-triangle-blur.png":"6MQOt","url:/src/app/img/ui/edit-unsharp-mask.png":"63Ukj","url:/src/app/img/ui/edit-grid.svg":"lUGDV","url:/src/app/img/ui/edit-noise.svg":"7nd6Y","url:/src/app/img/ui/edit-pattern.svg":"gly6R","url:/src/app/img/ui/edit-vanish-point.svg":"iSm1F","url:/src/app/img/ui/edit-distort.svg":"6VAq1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fGV1h":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-brightness-contrast.801e17db.svg") + "?" + Date.now();

},{}],"EPqrf":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-curves.f11acb76.svg") + "?" + Date.now();

},{}],"8P4CE":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-flip.41de8f5f.svg") + "?" + Date.now();

},{}],"8b5hd":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-hue-saturation.bd5ac257.svg") + "?" + Date.now();

},{}],"k3o84":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-invert.8023d182.png") + "?" + Date.now();

},{}],"54Ty3":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-perspective.4fe3a845.svg") + "?" + Date.now();

},{}],"9m2Yr":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-resize.9bfddd2a.svg") + "?" + Date.now();

},{}],"9zvFt":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-tilt-shift.a1cb8c2a.png") + "?" + Date.now();

},{}],"j1hlf":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-to-alpha.70fac010.svg") + "?" + Date.now();

},{}],"3cuJX":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-transform.fcc11c6b.svg") + "?" + Date.now();

},{}],"6MQOt":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-triangle-blur.e071772f.png") + "?" + Date.now();

},{}],"63Ukj":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-unsharp-mask.6ffa0a5a.png") + "?" + Date.now();

},{}],"lUGDV":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-grid.bd32cfc5.svg") + "?" + Date.now();

},{}],"7nd6Y":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-noise.c4c69290.svg") + "?" + Date.now();

},{}],"gly6R":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-pattern.c2a47275.svg") + "?" + Date.now();

},{}],"iSm1F":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-vanish-point.91c076dd.svg") + "?" + Date.now();

},{}],"6VAq1":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("edit-distort.ff66b3d2.svg") + "?" + Date.now();

},{}],"11wyk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BRUSHES", ()=>BRUSHES);
var _penBrush = require("./pen-brush");
var _blendBrush = require("./blend-brush");
var _sketchyBrush = require("./sketchy-brush");
var _pixelBrush = require("./pixel-brush");
var _eraserBrush = require("./eraser-brush");
var _smudgeBrush = require("./smudge-brush");
var _chemyBrush = require("./chemy-brush");
const BRUSHES = {
    PenBrush: (0, _penBrush.PenBrush),
    BlendBrush: (0, _blendBrush.BlendBrush),
    SketchyBrush: (0, _sketchyBrush.SketchyBrush),
    PixelBrush: (0, _pixelBrush.PixelBrush),
    ChemyBrush: (0, _chemyBrush.ChemyBrush),
    SmudgeBrush: (0, _smudgeBrush.SmudgeBrush),
    EraserBrush: (0, _eraserBrush.EraserBrush)
};

},{"./pen-brush":"fERfO","./blend-brush":"b5Ud8","./sketchy-brush":"2T8q9","./pixel-brush":"j2aAa","./eraser-brush":"K5lZc","./smudge-brush":"j9hUM","./chemy-brush":"h7JRV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fERfO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PenBrush", ()=>PenBrush);
var _bb = require("../../bb/bb");
var _brushesCommon = require("./brushes-common");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _changedTiles = require("../history/push-helpers/changed-tiles");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
const ALPHA_CIRCLE = 0;
const ALPHA_CHALK = 1;
const ALPHA_CAL = 2; // calligraphy
const ALPHA_SQUARE = 3;
const TWO_PI = 2 * Math.PI;
class PenBrush {
    updateChangedTiles(bounds) {
        const boundsWithinSelection = (0, _math.boundsOverlap)(bounds, this.selectionBounds);
        if (!boundsWithinSelection) return;
        this.changedTiles = (0, _changedTiles.updateChangedTiles)(this.changedTiles, (0, _changedTiles.getChangedTiles)(boundsWithinSelection, this.context.canvas.width, this.context.canvas.height));
    }
    updateAlphaCanvas() {
        if (this.settingAlphaId === ALPHA_CIRCLE || this.settingAlphaId === ALPHA_SQUARE) return;
        const instructionArr = [
            [
                this.alphaCanvas128,
                128
            ],
            [
                this.alphaCanvas64,
                64
            ],
            [
                this.alphaCanvas32,
                32
            ]
        ];
        let ctx;
        for(let i = 0; i < instructionArr.length; i++){
            ctx = (0, _bb.BB).ctx(instructionArr[i][0]);
            ctx.save();
            ctx.clearRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.fillStyle = 'rgba(' + this.settingColor.r + ', ' + this.settingColor.g + ', ' + this.settingColor.b + ', ' + this.alphaOpacityArr[this.settingAlphaId] + ')';
            ctx.fillRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.globalCompositeOperation = 'destination-in';
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage((0, _brushesCommon.ALPHA_IM_ARR)[this.settingAlphaId], 0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.restore();
        }
    }
    calcOpacity(pressure) {
        return this.settingOpacity * (this.settingHasOpacityPressure ? pressure * pressure : 1);
    }
    calcScatter(pressure) {
        return this.settingScatter * this.settingSize * (this.settingHasScatterPressure ? pressure : 1);
    }
    /**
     * @param x
     * @param y
     * @param size
     * @param opacity
     * @param scatter
     * @param angle
     * @param before - [x, y, size, opacity, angle] the drawDot call before
     */ drawDot(x, y, size, opacity, scatter, angle, before) {
        if (size <= 0) return;
        if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = 'source-atop';
        if (!before || before[3] !== opacity) this.context.globalAlpha = opacity;
        if (!before && (this.settingAlphaId === ALPHA_CIRCLE || this.settingAlphaId === ALPHA_SQUARE)) this.context.fillStyle = this.settingColorStr;
        if (scatter > 0) {
            // scatter equally distributed over area of a circle
            const scatterAngleRad = Math.random() * 2 * Math.PI;
            const distance = Math.sqrt(Math.random()) * scatter;
            x += Math.cos(scatterAngleRad) * distance;
            y += Math.sin(scatterAngleRad) * distance;
        }
        const boundsSize = this.settingAlphaId === ALPHA_CIRCLE || this.settingAlphaId === ALPHA_CAL ? size : size * Math.sqrt(2);
        this.updateChangedTiles({
            x1: Math.floor(x - boundsSize),
            y1: Math.floor(y - boundsSize),
            x2: Math.ceil(x + boundsSize),
            y2: Math.ceil(y + boundsSize)
        });
        if (this.settingAlphaId === ALPHA_CIRCLE) {
            this.context.beginPath();
            this.context.arc(x, y, size, 0, TWO_PI);
            this.context.closePath();
            this.context.fill();
            this.hasDrawnDot = true;
        } else if (this.settingAlphaId === ALPHA_SQUARE) {
            if (angle !== undefined) {
                this.context.save();
                this.context.translate(x, y);
                this.context.rotate(angle / 180 * Math.PI);
                this.context.fillRect(-size, -size, size * 2, size * 2);
                this.context.restore();
                this.hasDrawnDot = true;
            }
        } else {
            // other brush alphas
            this.context.save();
            this.context.translate(x, y);
            let targetMipmap = this.alphaCanvas128;
            if (size <= 32 && size > 16) targetMipmap = this.alphaCanvas64;
            else if (size <= 16) targetMipmap = this.alphaCanvas32;
            this.context.scale(size, size);
            if (this.settingAlphaId === ALPHA_CHALK) this.context.rotate((x + y) * 53123 % TWO_PI); // without mod it sometimes looks different
            this.context.drawImage(targetMipmap, -1, -1, 2, 2);
            this.context.restore();
            this.hasDrawnDot = true;
        }
    }
    // continueLine
    continueLine(x, y, size, pressure) {
        if (this.bezierLine === null) {
            this.bezierLine = new (0, _bb.BB).BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, ()=>{});
        }
        const drawArr = []; //draw instructions. will be all drawn at once
        const dotCallback = (val)=>{
            const localPressure = (0, _bb.BB).mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.calcOpacity(localPressure);
            const localSize = Math.max(0.1, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            const localScatter = this.calcScatter(localPressure);
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity,
                localScatter,
                val.angle
            ]);
        };
        const localSpacing = size * this.settingSpacing;
        if (x === null || y === null) this.bezierLine.addFinal(localSpacing, dotCallback);
        else this.bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        this.context.save();
        let before = undefined;
        for(let i = 0; i < drawArr.length; i++){
            const item = drawArr[i];
            this.drawDot(item[0], item[1], item[2], item[3], item[4], item[5], before);
            before = item;
        }
        this.context.restore();
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.context = {};
        this.klHistory = {};
        this.settingHasOpacityPressure = false;
        this.settingHasScatterPressure = false;
        this.settingHasSizePressure = true;
        this.settingSize = 2;
        this.settingSpacing = 0.8489;
        this.settingOpacity = 1;
        this.settingScatter = 0;
        this.settingColor = {};
        this.settingColorStr = '';
        this.settingAlphaId = ALPHA_CIRCLE;
        this.settingLockLayerAlpha = false;
        this.hasDrawnDot = false;
        this.lineToolLastDot = 0;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.inputArr = [];
        this.inputIsDrawing = false;
        this.bezierLine = null;
        // mipmapping
        this.alphaCanvas128 = (0, _bb.BB).canvas(128, 128);
        this.alphaCanvas64 = (0, _bb.BB).canvas(64, 64);
        this.alphaCanvas32 = (0, _bb.BB).canvas(32, 32);
        this.alphaOpacityArr = [
            1,
            0.9,
            1,
            1
        ];
        this.changedTiles = [];
    }
    // ---- interface ----
    startLine(x, y, p) {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.changedTiles = [];
        p = (0, _bb.BB).clamp(p, 0, 1);
        const localOpacity = this.calcOpacity(p);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, p * this.settingSize) : Math.max(0.1, this.settingSize);
        const localScatter = this.calcScatter(p);
        this.hasDrawnDot = false;
        this.inputIsDrawing = true;
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        this.drawDot(x, y, localSize, localOpacity, localScatter);
        this.context.restore();
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2.pressure = p;
        this.inputArr = [
            {
                x,
                y,
                pressure: p
            }
        ];
    }
    goLine(x, y, p) {
        if (!this.inputIsDrawing) return;
        const pressure = (0, _bb.BB).clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        /*context.fillStyle = 'red';
        context.fillRect(Math.floor(x), Math.floor(y - 10), 1, 20);
        context.fillRect(Math.floor(x - 10), Math.floor(y), 20, 1);*/ this.context.restore();
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput2.pressure = this.lastInput.pressure;
        this.lastInput.pressure = pressure;
        this.inputArr.push({
            x,
            y,
            pressure: p
        });
    }
    endLine() {
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        this.continueLine(null, null, localSize, this.lastInput.pressure);
        this.context.restore();
        this.inputIsDrawing = false;
        if (this.settingAlphaId === ALPHA_SQUARE && !this.hasDrawnDot) {
            // find max pressure input, use that one
            let maxInput = this.inputArr[0];
            this.inputArr.forEach((item)=>{
                if (item.pressure > maxInput.pressure) maxInput = item;
            });
            this.context.save();
            this.selectionPath && this.context.clip(this.selectionPath);
            const p = (0, _bb.BB).clamp(maxInput.pressure, 0, 1);
            const localOpacity = this.calcOpacity(p);
            const localScatter = this.calcScatter(p);
            this.drawDot(maxInput.x, maxInput.y, localSize, localOpacity, localScatter, 0);
            this.context.restore();
        }
        this.bezierLine = null;
        if (this.changedTiles.some((item)=>item)) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), (0, _canvasToLayerTiles.canvasAndChangedTilesToLayerTiles)(this.context.canvas, this.changedTiles)));
        this.hasDrawnDot = false;
        this.inputArr = [];
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.changedTiles = [];
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        this.lastInput.pressure = 1;
        if (this.inputIsDrawing || x1 === undefined) return;
        const angle = (0, _bb.BB).pointsToAngleDeg({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        });
        const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        const eX = (x2 - x1) / mouseDist;
        const eY = (y2 - y1) / mouseDist;
        let loopDist;
        const bdist = this.settingSize * this.settingSpacing;
        this.lineToolLastDot = this.settingSize * this.settingSpacing;
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        const localScatter = this.calcScatter(1);
        for(loopDist = this.lineToolLastDot; loopDist <= mouseDist; loopDist += bdist)this.drawDot(x1 + eX * loopDist, y1 + eY * loopDist, this.settingSize, this.settingOpacity, localScatter, angle);
        this.context.restore();
        if (this.changedTiles.some((item)=>item)) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), (0, _canvasToLayerTiles.canvasAndChangedTilesToLayerTiles)(this.context.canvas, this.changedTiles)));
    }
    //IS
    isDrawing() {
        return this.inputIsDrawing;
    }
    //SET
    setAlpha(a) {
        if (this.settingAlphaId === a) return;
        this.settingAlphaId = a;
        this.updateAlphaCanvas();
    }
    setColor(c) {
        if (this.settingColor === c) return;
        this.settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
        this.settingColorStr = 'rgb(' + this.settingColor.r + ',' + this.settingColor.g + ',' + this.settingColor.b + ')';
        this.updateAlphaCanvas();
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(klHistory) {
        this.klHistory = klHistory;
    }
    setSize(s) {
        this.settingSize = s;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setScatter(o) {
        this.settingScatter = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = b;
    }
    scatterPressure(b) {
        this.settingHasScatterPressure = b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    //GET
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getScatter() {
        return this.settingScatter;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
}

},{"../../bb/bb":"3zOvT","./brushes-common":"8rZAX","../history/push-helpers/get-pushable-layer-change":"cpxKS","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../history/push-helpers/changed-tiles":"fEQ1q","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8rZAX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ALPHA_IM_ARR", ()=>ALPHA_IM_ARR);
var _brushAlphas = require("./alphas/brush-alphas");
const ALPHA_IM_ARR = []; // used by default brush
ALPHA_IM_ARR[1] = (0, _brushAlphas.genBrushAlpha01)(128);
ALPHA_IM_ARR[2] = (0, _brushAlphas.genBrushAlpha02)(128);

},{"./alphas/brush-alphas":"7vzMQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7vzMQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// chalk
parcelHelpers.export(exports, "genBrushAlpha01", ()=>genBrushAlpha01);
// calligraphy
parcelHelpers.export(exports, "genBrushAlpha02", ()=>genBrushAlpha02);
var _bb = require("../../../bb/bb");
var _perlin = require("../../../bb/math/perlin");
function genBrushAlpha01(w) {
    const scaleFac = w / 500;
    const h = w;
    const canvas = (0, _bb.BB).canvas(w, h);
    const ctx = (0, _bb.BB).ctx(canvas);
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        const i = (y * w + x) * 4;
        // base noise
        const sFac2 = scaleFac + (0, _perlin.noise).simplex2(x / 50 / scaleFac, y / 50 / scaleFac) * 0.04;
        let noisePattern = 100 + ((0, _perlin.noise).simplex2(x / 50 / sFac2, y / 50 / sFac2) + 1) / 2 * 100;
        noisePattern -= ((0, _perlin.noise).simplex2(x / 10 / scaleFac, y / 10 / scaleFac) + 1) / 2 * 100;
        // fade out in circular shape
        const centerDist = (0, _bb.BB).dist(w / 2, h / 2, x, y);
        const falloff = (0, _bb.BB).clamp(1 - ((centerDist - w / 2.5) / (w / 14) + (0, _perlin.noise).simplex2(x / 22 / sFac2, y / 22 / sFac2)), 0, 1);
        noisePattern = noisePattern * falloff;
        // make the middle darker
        const falloff2 = (0, _bb.BB).clamp(1 - centerDist / w, 0, 1) * 2;
        noisePattern = noisePattern * falloff2;
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = (0, _bb.BB).clamp(noisePattern, 0, 255);
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}
// https://www.shadertoy.com/view/3tdSDj
function udSegment(p, a, b) {
    const ba = (0, _bb.BB).Vec2.sub(b, a);
    const pa = (0, _bb.BB).Vec2.sub(p, a);
    const h = (0, _bb.BB).clamp((0, _bb.BB).Vec2.dot(pa, ba) / (0, _bb.BB).Vec2.dot(ba, ba), 0.0, 1.0);
    return (0, _bb.BB).Vec2.len((0, _bb.BB).Vec2.sub(pa, (0, _bb.BB).Vec2.mul(ba, h)));
}
function genBrushAlpha02(w) {
    const pDist = 1 / 4;
    let centerSize = 2 / 3;
    let transitionSize = 1 / 3;
    centerSize *= pDist;
    transitionSize *= pDist;
    const p1 = {
        x: pDist * w,
        y: w - w * pDist
    };
    const p2 = {
        x: w - w * pDist,
        y: pDist * w
    };
    const h = w;
    const canvas = (0, _bb.BB).canvas(w, h);
    const ctx = (0, _bb.BB).ctx(canvas);
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        const i = (y * w + x) * 4;
        let col = udSegment({
            x: x,
            y: y
        }, p1, p2);
        col = (0, _bb.BB).clamp(255 - (col - w * centerSize) / (w * transitionSize) * 255, 0, 255);
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = col;
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}

},{"../../../bb/bb":"3zOvT","../../../bb/math/perlin":"g0qoq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g0qoq":[function(require,module,exports,__globalThis) {
/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noise", ()=>noise);
const myModule = {};
class Grad {
    constructor(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    dot2(x, y) {
        return this.x * x + this.y * y;
    }
}
/*
Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
};*/ const grad3 = [
    new Grad(1, 1, 0),
    new Grad(-1, 1, 0),
    new Grad(1, -1, 0),
    new Grad(-1, -1, 0),
    new Grad(1, 0, 1),
    new Grad(-1, 0, 1),
    new Grad(1, 0, -1),
    new Grad(-1, 0, -1),
    new Grad(0, 1, 1),
    new Grad(0, -1, 1),
    new Grad(0, 1, -1),
    new Grad(0, -1, -1)
];
const p = [
    151,
    160,
    137,
    91,
    90,
    15,
    131,
    13,
    201,
    95,
    96,
    53,
    194,
    233,
    7,
    225,
    140,
    36,
    103,
    30,
    69,
    142,
    8,
    99,
    37,
    240,
    21,
    10,
    23,
    190,
    6,
    148,
    247,
    120,
    234,
    75,
    0,
    26,
    197,
    62,
    94,
    252,
    219,
    203,
    117,
    35,
    11,
    32,
    57,
    177,
    33,
    88,
    237,
    149,
    56,
    87,
    174,
    20,
    125,
    136,
    171,
    168,
    68,
    175,
    74,
    165,
    71,
    134,
    139,
    48,
    27,
    166,
    77,
    146,
    158,
    231,
    83,
    111,
    229,
    122,
    60,
    211,
    133,
    230,
    220,
    105,
    92,
    41,
    55,
    46,
    245,
    40,
    244,
    102,
    143,
    54,
    65,
    25,
    63,
    161,
    1,
    216,
    80,
    73,
    209,
    76,
    132,
    187,
    208,
    89,
    18,
    169,
    200,
    196,
    135,
    130,
    116,
    188,
    159,
    86,
    164,
    100,
    109,
    198,
    173,
    186,
    3,
    64,
    52,
    217,
    226,
    250,
    124,
    123,
    5,
    202,
    38,
    147,
    118,
    126,
    255,
    82,
    85,
    212,
    207,
    206,
    59,
    227,
    47,
    16,
    58,
    17,
    182,
    189,
    28,
    42,
    223,
    183,
    170,
    213,
    119,
    248,
    152,
    2,
    44,
    154,
    163,
    70,
    221,
    153,
    101,
    155,
    167,
    43,
    172,
    9,
    129,
    22,
    39,
    253,
    19,
    98,
    108,
    110,
    79,
    113,
    224,
    232,
    178,
    185,
    112,
    104,
    218,
    246,
    97,
    228,
    251,
    34,
    242,
    193,
    238,
    210,
    144,
    12,
    191,
    179,
    162,
    241,
    81,
    51,
    145,
    235,
    249,
    14,
    239,
    107,
    49,
    192,
    214,
    31,
    181,
    199,
    106,
    157,
    184,
    84,
    204,
    176,
    115,
    121,
    50,
    45,
    127,
    4,
    150,
    254,
    138,
    236,
    205,
    93,
    222,
    114,
    67,
    29,
    24,
    72,
    243,
    141,
    128,
    195,
    78,
    66,
    215,
    61,
    156,
    180
];
// To remove the need for index wrapping, double the permutation table length
const perm = new Array(512);
const gradP = new Array(512);
// This isn't a very good seeding function, but it works ok. It supports 2^16
// different seed values. Write something better if you need more seeds.
myModule.seed = function(seed) {
    if (seed > 0 && seed < 1) // Scale the seed out
    seed *= 65536;
    seed = Math.floor(seed);
    if (seed < 256) seed |= seed << 8;
    for(let i = 0; i < 256; i++){
        let v;
        if (i & 1) v = p[i] ^ seed & 255;
        else v = p[i] ^ seed >> 8 & 255;
        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
};
myModule.seed(0);
/*
for (let i=0; i<256; i++) {
  perm[i] = perm[i + 256] = p[i];
  gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
}*/ // Skewing and unskewing factors for 2, 3, and 4 dimensions
const F2 = 0.5 * (Math.sqrt(3) - 1);
const G2 = (3 - Math.sqrt(3)) / 6;
/*let F3 = 1/3;
let G3 = 1/6;*/ // 2D simplex noise
myModule.simplex2 = function(xin, yin) {
    let n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    const s = (xin + yin) * F2; // Hairy factor for 2D
    let i = Math.floor(xin + s);
    let j = Math.floor(yin + s);
    const t = (i + j) * G2;
    const x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
    const y0 = yin - j + t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if (x0 > y0) {
        // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        i1 = 1;
        j1 = 0;
    } else {
        // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        i1 = 0;
        j1 = 1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    const y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    const y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    const gi0 = gradP[i + perm[j]];
    const gi1 = gradP[i + i1 + perm[j + j1]];
    const gi2 = gradP[i + 1 + perm[j + 1]];
    // Calculate the contribution from the three corners
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) n0 = 0;
    else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) n1 = 0;
    else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 < 0) n2 = 0;
    else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
};
const noise = myModule;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cpxKS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// create a history entry where the currently active layer changes its tiles
parcelHelpers.export(exports, "getPushableLayerChange", ()=>getPushableLayerChange);
var _canvasToLayerTiles = require("./canvas-to-layer-tiles");
function getPushableLayerChange(composed, imageOrTiles) {
    const activeLayerId = composed.activeLayerId;
    const layerMap = Object.fromEntries(Object.entries(composed.layerMap).map(([layerId, layerItem])=>{
        if (layerId === activeLayerId) return [
            layerId,
            {
                tiles: imageOrTiles instanceof HTMLCanvasElement ? (0, _canvasToLayerTiles.canvasToLayerTiles)(imageOrTiles) : [
                    ...imageOrTiles
                ]
            }
        ];
        return [
            layerId,
            {}
        ];
    }));
    return {
        layerMap
    };
}

},{"./canvas-to-layer-tiles":"byCWA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b5Ud8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlendBrush", ()=>BlendBrush);
var _bb = require("../../bb/bb");
var _klTypes = require("../kl-types");
var _math = require("../../bb/math/math");
var _klHistory = require("../history/kl-history");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _copyImageData = require("../utils/copy-image-data");
var _base = require("../../bb/base/base");
var _imageDataTile = require("../history/image-data-tile");
var _getBinaryMask = require("../select-tool/get-binary-mask");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
var _changedTiles = require("../history/push-helpers/changed-tiles");
class BlendBrush {
    updateRedrawBounds(bounds) {
        const boundsWithinSelection = (0, _math.boundsOverlap)(bounds, this.selectionBounds);
        if (!boundsWithinSelection) return;
        this.redrawBounds = (0, _bb.BB).updateBounds(this.redrawBounds, boundsWithinSelection);
    }
    getCellsWidth() {
        return Math.ceil(this.context.canvas.width / (0, _klHistory.HISTORY_TILE_SIZE));
    }
    /**
     * draw cells onto context
     * @param cells
     */ drawCells(cells) {
        const cellsW = this.getCellsWidth();
        cells.forEach((imageData, index)=>{
            if (!imageData) return;
            const cellOffsetX = index % cellsW * (0, _klHistory.HISTORY_TILE_SIZE);
            const cellOffsetY = Math.floor(index / cellsW) * (0, _klHistory.HISTORY_TILE_SIZE);
            this.context.putImageData(imageData, cellOffsetX, cellOffsetY);
        });
    }
    /**
     * draw changed cells (changed by brushstroke) onto context
     * @private
     */ drawChangedCells() {
        if (!this.redrawBounds) return;
        const cells = this.cells.map(()=>undefined);
        const touchedCells = this.getTouchedCells(this.redrawBounds);
        touchedCells.forEach((isTouched, index)=>{
            if (isTouched) cells[index] = this.cells[index];
        });
        this.drawCells(cells);
        this.redrawBounds = undefined;
    }
    getTouchedCells(bounds) {
        const touchedCells = this.cells.map(()=>false);
        const cellsW = this.getCellsWidth();
        bounds = {
            x1: Math.floor(bounds.x1 / (0, _klHistory.HISTORY_TILE_SIZE)),
            y1: Math.floor(bounds.y1 / (0, _klHistory.HISTORY_TILE_SIZE)),
            x2: Math.floor(bounds.x2 / (0, _klHistory.HISTORY_TILE_SIZE)),
            y2: Math.floor(bounds.y2 / (0, _klHistory.HISTORY_TILE_SIZE))
        };
        for(let i = bounds.x1; i <= bounds.x2; i++)for(let e = bounds.y1; e <= bounds.y2; e++)touchedCells[e * cellsW + i] = true;
        return touchedCells;
    }
    /**
     * Slice up bounds according to cells
     * @param bounds
     * @private
     */ sliceBounds(bounds) {
        const boundsWithinSelection = (0, _math.boundsOverlap)(bounds, this.selectionBounds);
        if (!boundsWithinSelection) return [];
        const cellsW = this.getCellsWidth();
        const result = [];
        const touchedCells = this.getTouchedCells(boundsWithinSelection);
        touchedCells.forEach((cell, i)=>{
            if (!cell) return;
            const cellOffsetX = i % cellsW * (0, _klHistory.HISTORY_TILE_SIZE);
            const cellOffsetY = Math.floor(i / cellsW) * (0, _klHistory.HISTORY_TILE_SIZE);
            const cellWidth = this.cells[i].width;
            const cellHeight = this.cells[i].height;
            const inCellBounds = {
                x1: Math.max(0, boundsWithinSelection.x1 - cellOffsetX),
                y1: Math.max(0, boundsWithinSelection.y1 - cellOffsetY),
                x2: Math.min(cellWidth - 1, boundsWithinSelection.x2 - cellOffsetX),
                y2: Math.min(cellHeight - 1, boundsWithinSelection.y2 - cellOffsetY)
            };
            if (inCellBounds.x1 > inCellBounds.x2 || inCellBounds.y1 > inCellBounds.y2) return;
            result.push({
                index: i,
                bounds: inCellBounds
            });
        });
        return result;
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas(bounds) {
        if (!bounds) return;
        const touchedCells = this.getTouchedCells(bounds);
        const composedLayer = this.klHistory.getComposed().layerMap[this.layerId];
        touchedCells.forEach((item, i)=>{
            if (!item || this.cells[i]) // not touched, or already copied
            return;
            const composedTile = composedLayer.tiles[i];
            if ((0, _klTypes.isLayerFill)(composedTile)) {
                const canvas = (0, _bb.BB).canvas((0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
                const ctx = (0, _bb.BB).ctx(canvas);
                ctx.fillStyle = composedTile.fill;
                ctx.fillRect(0, 0, (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
                this.cells[i] = ctx.getImageData(0, 0, (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
            } else this.cells[i] = (0, _copyImageData.copyImageData)(composedTile.data);
        });
    }
    getAverage(x, y, size) {
        size = Math.max(0.5, size * 0.75);
        const x1 = Math.max(0, Math.floor(x - size));
        const y1 = Math.max(0, Math.floor(y - size));
        const x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        const y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        let ar = 0, ag = 0, ab = 0, aa = 0;
        const slicedBounds = this.sliceBounds({
            x1,
            y1,
            x2,
            y2
        });
        const cellsW = this.getCellsWidth();
        slicedBounds.forEach((slice)=>{
            const cellOffsetX = slice.index % cellsW * (0, _klHistory.HISTORY_TILE_SIZE);
            const cellOffsetY = Math.floor(slice.index / cellsW) * (0, _klHistory.HISTORY_TILE_SIZE);
            const width = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            const bounds = slice.bounds;
            for(let i = bounds.y1, globalY = i + cellOffsetY; i <= bounds.y2; i++, globalY++)for(let e = bounds.x1, globalX = e + cellOffsetX, e2 = (i * width + bounds.x1) * 4; e <= bounds.x2; e++, globalX++, e2 += 4){
                if (this.mask && this.mask[globalY * this.context.canvas.width + globalX] === 0) continue;
                const alpha = data[e2 + 3] / 255;
                if (alpha === 0) continue;
                ar += data[e2] * alpha;
                ag += data[e2 + 1] * alpha;
                ab += data[e2 + 2] * alpha;
                aa += alpha;
            }
        });
        if (aa !== 0) {
            ar /= aa;
            ag /= aa;
            ab /= aa;
            aa = Math.min(1, aa);
        }
        return {
            r: ar,
            g: ag,
            b: ab,
            a: aa
        };
    }
    getDotBounds(x, y, size) {
        size = Math.max(0.5, size);
        const x1 = Math.max(0, Math.floor(x - size));
        const y1 = Math.max(0, Math.floor(y - size));
        const x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        const y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return undefined;
        return {
            x1,
            y1,
            x2,
            y2
        };
    }
    drawDot(params) {
        // array with random numbers. faster than Math.random()
        let randI = 0;
        const randLen = params.size > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
        const randArr = [];
        for(let i = 0; i < randLen; i++)randArr[i] = (Math.random() - 0.5) / 1.001 + 0.5;
        // thin lines take more than just 1 sample
        const sampleArr = [
            8,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2
        ]; // <0.5, 0.5, 1, 1.5, etc.
        const samples = sampleArr[Math.floor(params.size * 2)];
        const samplesSquared = samples ? samples * samples : 0;
        const sampleOffsets = [];
        if (samples) {
            let i = 0;
            for(let n = 0; n < samples; n++)for(let m = 0; m < samples; m++, i += 2){
                sampleOffsets[i] = (n + 1) / samples; // x offset
                sampleOffsets[i + 1] = (m + 1) / samples; // y offset
            }
        }
        const sharpness = Math.pow(params.opacity, 2) * 0.8;
        // to optimize calculations
        const invSharpness = 1 - sharpness;
        const sharpnessSubtrahend = sharpness / invSharpness;
        const sizeSquared = params.size * params.size;
        const distDivisor = sizeSquared * invSharpness / params.opacity;
        const alphaMinuend = (1 + sharpnessSubtrahend) * params.opacity;
        const slicedBounds = this.sliceBounds({
            x1: params.x1,
            y1: params.y1,
            x2: params.x2,
            y2: params.y2
        });
        const cellsW = this.getCellsWidth();
        slicedBounds.forEach((slice)=>{
            const cellOffsetX = slice.index % cellsW * (0, _klHistory.HISTORY_TILE_SIZE);
            const cellOffsetY = Math.floor(slice.index / cellsW) * (0, _klHistory.HISTORY_TILE_SIZE);
            const cellWidth = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            // i - y index within cell
            // e - x index within cell
            // e2 - index in image data (a tile)
            // mi - index in mask (one mask for the entire image)
            // ri - y index within image relative to dot-center
            // re - x index within image relative to dot-center
            for(let i = slice.bounds.y1, ri = i + cellOffsetY - params.y; i <= slice.bounds.y2; i++, ri++)for(let e = slice.bounds.x1, mi = (i + cellOffsetY) * this.context.canvas.width + (slice.bounds.x1 + cellOffsetX), e2 = (i * cellWidth + slice.bounds.x1) * 4, re = e + cellOffsetX - params.x; e <= slice.bounds.x2; e++, mi++, e2 += 4, re++){
                if (this.mask && this.mask[mi] === 0) continue;
                // O = over -> brush-dot
                // U = under -> image
                let alphaO = 0;
                if (samplesSquared) {
                    for(let f = 0; f < sampleOffsets.length; f += 2){
                        const dist = (0, _bb.BB).lenSquared(re + sampleOffsets[f], ri + sampleOffsets[f + 1]);
                        if (dist >= sizeSquared) continue;
                        alphaO += (0, _math.clamp)(alphaMinuend - dist / distDivisor, 0, params.opacity);
                    }
                    if (!alphaO) continue;
                    alphaO /= samplesSquared;
                } else {
                    // technically needs + 0.5 offset, but not noticeable with large brush
                    const dist = Math.pow(re, 2) + Math.pow(ri, 2);
                    if (dist >= sizeSquared) continue;
                    alphaO = (0, _math.clamp)(alphaMinuend - dist / distDivisor, 0, params.opacity);
                }
                const invAlphaO = 1 - alphaO;
                const alphaU = data[e2 + 3] / 255;
                if (this.settingLockLayerAlpha) {
                    const underR = params.r * alphaO + data[e2] * invAlphaO;
                    const underG = params.g * alphaO + data[e2 + 1] * invAlphaO;
                    const underB = params.b * alphaO + data[e2 + 2] * invAlphaO;
                    if (alphaU) {
                        data[e2] = Math.floor(underR + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB + randArr[randI]);
                    }
                } else {
                    const underR = params.r * alphaO + data[e2] * alphaU * invAlphaO;
                    const underG = params.g * alphaO + data[e2 + 1] * alphaU * invAlphaO;
                    const underB = params.b * alphaO + data[e2 + 2] * alphaU * invAlphaO;
                    const newAlpha = 1 - invAlphaO * (1 - alphaU);
                    data[e2 + 3] = Math.floor(Math.min(255, newAlpha * 255) + 0.5);
                    if (newAlpha) {
                        data[e2] = Math.floor(underR / newAlpha + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG / newAlpha + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB / newAlpha + randArr[randI]);
                    }
                }
                randI = (randI + 1) % randLen;
            }
        });
    }
    calcSpacing(size) {
        return (0, _bb.BB).mix(size * 2 / 2, size * 2 / 9, (0, _math.clamp)((size - 2.7) / 9.3, 0, 1));
    }
    continueLine(x, y, p, isCoalesced) {
        this.drawBuffer = [];
        let localPressure;
        let localOpacity;
        let localSize = this.settingSizePressure ? Math.max(1, p * this.size) : Math.max(1, this.size);
        const bDist = this.calcSpacing(localSize);
        const avgX = x === undefined ? this.lastInput.x : x;
        const avgY = y === undefined ? this.lastInput.y : y;
        let localColNew;
        if (this.blending === 0) {
            this.mixCol.r = this.color.r;
            this.mixCol.g = this.color.g;
            this.mixCol.b = this.color.b;
        } else {
            let average;
            if (isCoalesced) average = {
                r: this.localColOld.r,
                g: this.localColOld.g,
                b: this.localColOld.b,
                a: 0
            };
            else {
                const avgParams = [
                    avgX,
                    avgY,
                    this.settingSizePressure ? Math.max(0.5, p * this.size) : Math.max(0.5, this.size)
                ];
                const bounds = this.getDotBounds(avgParams[0], avgParams[1], avgParams[2]);
                if (bounds) this.copyFromCanvas(bounds);
                average = this.getAverage(avgParams[0], avgParams[1], avgParams[2]);
            }
            localColNew = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            if (average.a > 0 && this.blendCol.a === 0) {
                this.blendCol.r = average.r;
                this.blendCol.g = average.g;
                this.blendCol.b = average.b;
                this.blendCol.a = average.a;
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            } else {
                if (average.a === 0) {
                    average.r = this.color.r;
                    average.g = this.color.g;
                    average.b = this.color.b;
                    average.a = 1 - this.blending;
                }
                this.blendCol.r = (0, _bb.BB).mix(this.blendCol.r, (0, _bb.BB).mix(this.blendCol.r, average.r, this.blendMix), average.a);
                this.blendCol.g = (0, _bb.BB).mix(this.blendCol.g, (0, _bb.BB).mix(this.blendCol.g, average.g, this.blendMix), average.a);
                this.blendCol.b = (0, _bb.BB).mix(this.blendCol.b, (0, _bb.BB).mix(this.blendCol.b, average.b, this.blendMix), average.a);
                this.blendCol.a = Math.min(1, this.blendCol.a + average.a);
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            }
        }
        const bezierCallback = (val)=>{
            if (this.blending >= 1 && this.blendCol.a <= 0) return;
            const factor = val.t;
            localPressure = this.lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = this.settingOpacityPressure ? this.opacity * localPressure * localPressure : this.opacity;
            localSize = this.settingSizePressure ? Math.max(0.1, localPressure * this.size) : Math.max(0.1, this.size);
            if (this.blending != 0) {
                this.mixCol.r = (0, _bb.BB).mix(this.localColOld.r, localColNew.r, factor);
                this.mixCol.g = (0, _bb.BB).mix(this.localColOld.g, localColNew.g, factor);
                this.mixCol.b = (0, _bb.BB).mix(this.localColOld.b, localColNew.b, factor);
            }
            if (this.blending === 1 && this.localColOld.a === 0) {
                this.mixCol.r = localColNew.r;
                this.mixCol.g = localColNew.g;
                this.mixCol.b = localColNew.b;
            }
            const bounds = this.getDotBounds(val.x, val.y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: val.x,
                    y: val.y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixCol.r, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixCol.g, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixCol.b, this.blending)
                });
            }
        };
        if (x === undefined || y === undefined) this.bezierLine.addFinal(bDist, bezierCallback);
        else this.bezierLine.add(x, y, bDist, bezierCallback);
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.localColOld = localColNew;
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        // testing mode - context only gets updated when line is finished
        this.isTesting = false;
        this.context = {};
        this.layerId = 'NOT_SET';
        this.color = {};
        this.size = 29 // radius - 0.5 - 99999
        ;
        this.opacity = 0.6 // 0-1
        ;
        this.blending = 0.65 // 0-1
        ;
        this.settingLockLayerAlpha = false;
        this.settingSizePressure = true;
        this.settingOpacityPressure = false;
        this.blendCol = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        } // todo docs
        ;
        this.blendMix = 0.45 // todo docs
        ;
        this.mixCol = {
            r: 0,
            g: 0,
            b: 0
        } // todo docs
        ;
        this.localColOld = {} // todo docs
        ;
        this.isDrawing = false;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        } // todo docs
        ;
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        } // todo docs
        ;
        this.klHistory = {};
        this.cells = [];
        this.drawBuffer = [];
    }
    setHistory(klHistory) {
        this.klHistory = klHistory;
    }
    getSize() {
        return this.size;
    }
    setSize(s) {
        this.size = s;
    }
    getOpacity() {
        return this.opacity;
    }
    setOpacity(o) {
        this.opacity = o;
    }
    getBlending() {
        return this.blending;
    }
    setBlending(b) {
        this.blending = b;
    }
    setColor(c) {
        this.color = (0, _bb.BB).copyObj(c);
    }
    setContext(c, id) {
        this.context = c;
        this.layerId = id;
    }
    setSizePressure(b) {
        this.settingSizePressure = b;
    }
    setOpacityPressure(b) {
        this.settingOpacityPressure = b;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    setIsTesting(b) {
        this.isTesting = b;
    }
    startLine(x, y, p) {
        const selection = this.klHistory.getComposed().selection.value;
        this.selectionBounds = selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(selection)) : undefined;
        this.mask = selection ? (0, _getBinaryMask.getBinaryMask)(selection, this.context.canvas.width, this.context.canvas.height) : undefined;
        const totalCells = Math.ceil(this.context.canvas.width / (0, _klHistory.HISTORY_TILE_SIZE)) * Math.ceil(this.context.canvas.height / (0, _klHistory.HISTORY_TILE_SIZE));
        this.cells = (0, _base.createArray)(totalCells, undefined);
        this.isDrawing = true;
        p = Math.max(0, Math.min(1, p));
        const localOpacity = this.settingOpacityPressure ? this.opacity * p * p : this.opacity;
        const localSize = this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        if (this.blending === 0) {
            this.mixCol.r = this.color.r;
            this.mixCol.g = this.color.g;
            this.mixCol.b = this.color.b;
        } else {
            this.copyFromCanvas(this.getDotBounds(x, y, localSize));
            const average = this.getAverage(x, y, this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size));
            if (average.a === 0) this.blendCol = {
                r: this.color.r,
                g: this.color.g,
                b: this.color.b,
                a: 1 - this.blending
            };
            else this.blendCol = {
                r: average.r,
                g: average.g,
                b: average.b,
                a: average.a
            };
            this.mixCol.r = this.blendCol.r;
            this.mixCol.g = this.blendCol.g;
            this.mixCol.b = this.blendCol.b;
        }
        this.localColOld = {
            r: this.mixCol.r,
            g: this.mixCol.g,
            b: this.mixCol.b,
            a: this.blendCol.a
        };
        this.redrawBounds = undefined;
        this.drawBuffer = [];
        if (this.blending < 1 || this.blendCol.a > 0) {
            const bounds = this.getDotBounds(x, y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: x,
                    y: y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixCol.r, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixCol.g, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixCol.b, this.blending)
                });
            }
        }
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.bezierLine = new (0, _bb.BB).BezierLine();
        this.bezierLine.add(x, y, 0, function() {});
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        if (!this.isTesting) this.drawChangedCells();
    }
    goLine(x, y, p, isCoalesced) {
        if (!this.isDrawing) return;
        this.continueLine(x, y, this.lastInput.pressure, isCoalesced);
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        if (!this.isTesting) this.drawChangedCells();
    }
    endLine() {
        if (this.bezierLine) this.continueLine(undefined, undefined, this.lastInput.pressure, false);
        this.isDrawing = false;
        this.bezierLine = undefined;
        this.drawChangedCells();
        if (this.cells.some((item)=>item)) {
            let cells = this.cells;
            if (this.selectionBounds) {
                const tilesInSelection = (0, _changedTiles.getChangedTiles)(this.selectionBounds, this.context.canvas.width, this.context.canvas.height);
                cells = cells.map((cell, index)=>{
                    return tilesInSelection[index] ? cell : undefined;
                });
            }
            this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), cells.map((cell)=>{
                return cell ? (0, _imageDataTile.createImageDataTile)(cell) : undefined;
            })));
        }
        this.cells = [];
    }
    drawLineSegment(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.ceil(distance / 10);
        this.startLine(x1, y1, 1);
        for(let i = 1; i <= steps; i++){
            const t = i / steps;
            const xi = x1 + dx * t;
            const yi = y1 + dy * t;
            this.goLine(xi, yi, 1, false);
        }
        this.endLine();
    }
}

},{"../../bb/bb":"3zOvT","../kl-types":"E0RUG","../../bb/math/math":"7x9Fp","../history/kl-history":"l5YQK","../history/push-helpers/get-pushable-layer-change":"cpxKS","../utils/copy-image-data":"ceH2z","../../bb/base/base":"it3mQ","../history/image-data-tile":"gpqSK","../select-tool/get-binary-mask":"iRxtk","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","../history/push-helpers/changed-tiles":"fEQ1q","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2T8q9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SketchyBrush", ()=>SketchyBrush);
var _bb = require("../../bb/bb");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
const sampleCanvas = (0, _bb.BB).canvas(32, 32);
const sampleCtx = (0, _bb.BB).ctx(sampleCanvas);
class SketchyBrush {
    rand() {
        this.sketchySeed++;
        return Math.sin(6324634.2345 * Math.cos(this.sketchySeed * 5342.3423)) * 0.5 + 0.5;
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.context = {};
        this.settingColor = {};
        this.settingSize = 1;
        this.settingOpacity = 0.2;
        this.settingBlending = 0.5;
        this.settingScale = 1;
        this.lastX = 0;
        this.lastY = 0;
        this.inputIsDrawing = false;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.klHistory = {};
        this.sketchySeed = 0;
        this.points = [] // x y
        ;
        this.count = 0;
        this.mixMode = [
            (c1)=>{
                return c1;
            },
            (c1, c2)=>{
                // why
                const result = new (0, _bb.BB).RGB(c1.r, c1.g, c1.b);
                result.r *= c2.r / 255;
                result.g *= c2.g / 255;
                result.b *= c2.b / 255;
                return result;
            }
        ];
    }
    // ---- interface ----
    setHistory(klHistory) {
        this.klHistory = klHistory;
    }
    setSeed(s) {
        this.sketchySeed = parseInt('' + s);
    }
    getSeed() {
        return parseInt('' + this.sketchySeed);
    }
    getSize() {
        return this.settingSize / 2;
    }
    setColor(c) {
        this.settingColor = c;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    getBlending() {
        return this.settingBlending;
    }
    setBlending(b) {
        this.settingBlending = b;
    }
    setSize(s) {
        this.settingSize = s * 2;
    }
    getScale() {
        return this.settingScale;
    }
    setScale(s) {
        this.settingScale = s;
    }
    setContext(c) {
        this.context = c;
    }
    startLine(x, y, pressure, shift) {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.changedBounds = undefined;
        if (shift && this.lastInput.x) {
            this.inputIsDrawing = true;
            this.endLine();
        } else {
            this.inputIsDrawing = true;
            this.lastX = x;
            this.lastY = y;
            this.lastInput.x = x;
            this.lastInput.y = y;
        }
    }
    goLine(p_x, p_y, pressure, preMixedColor) {
        if (!this.inputIsDrawing || p_x === this.lastInput.x && p_y === this.lastInput.y) return;
        let e, b, a, g;
        const x = parseInt('' + p_x);
        const y = parseInt('' + p_y);
        this.points.push([
            x,
            y
        ]);
        let mixr = this.settingColor.r;
        let mixg = this.settingColor.g;
        let mixb = this.settingColor.b;
        if (preMixedColor) {
            mixr = preMixedColor.r;
            mixg = preMixedColor.g;
            mixb = preMixedColor.b;
        } else {
            if (this.settingBlending !== 0) {
                if (x + 5 >= 0 && y + 5 >= 0 && x - 5 < this.context.canvas.width - 1 && y - 5 < this.context.canvas.height - 1) {
                    mixr = 0;
                    mixg = 0;
                    mixb = 0;
                    const mixX = Math.min(this.context.canvas.width - 1, Math.max(0, x - 5));
                    const mixY = Math.min(this.context.canvas.height - 1, Math.max(0, y - 5));
                    let mixW = Math.min(this.context.canvas.width - 1, Math.max(0, x + 5));
                    let mixH = Math.min(this.context.canvas.height - 1, Math.max(0, y + 5));
                    mixW -= mixX;
                    mixH -= mixY;
                    if (mixW > 0 && mixH > 0) {
                        const imDat = this.context.getImageData(mixX, mixY, mixW, mixH);
                        let countMix = 0;
                        for(let i = 0; i < imDat.data.length; i += 4){
                            mixr += imDat.data[i + 0];
                            mixg += imDat.data[i + 1];
                            mixb += imDat.data[i + 2];
                            countMix++;
                        }
                        mixr /= countMix;
                        mixg /= countMix;
                        mixb /= countMix;
                    }
                    const mixed = this.mixMode[0](new (0, _bb.BB).RGB(mixr, mixg, mixb), this.settingColor);
                    mixr = parseInt('' + (0, _bb.BB).mix(this.settingColor.r, mixed.r, this.settingBlending));
                    mixg = parseInt('' + (0, _bb.BB).mix(this.settingColor.g, mixed.g, this.settingBlending));
                    mixb = parseInt('' + (0, _bb.BB).mix(this.settingColor.b, mixed.b, this.settingBlending));
                }
            }
        }
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        this.context.strokeStyle = 'rgba(' + mixr + ', ' + mixg + ', ' + mixb + ', ' + this.settingOpacity + ')';
        this.context.lineWidth = this.settingSize;
        this.context.beginPath();
        this.context.moveTo(this.lastX, this.lastY);
        this.context.lineTo(x, y);
        for(e = 0; e < this.points.length; e++){
            b = this.points[e][0] - this.points[this.count][0];
            a = this.points[e][1] - this.points[this.count][1];
            g = b * b + a * a;
            if (g < 4000 * this.settingScale * this.settingScale && this.rand() > g / 2000 / this.settingScale / this.settingScale) {
                this.context.moveTo(this.points[this.count][0] + b * 0.3, this.points[this.count][1] + a * 0.3);
                this.context.lineTo(this.points[e][0] - b * 0.3, this.points[e][1] - a * 0.3);
            }
        }
        this.context.stroke();
        this.context.restore();
        this.count++;
        this.lastX = x;
        this.lastY = y;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.changedBounds = (0, _bb.BB).updateBounds(this.changedBounds, {
            x1: Math.floor(x - this.settingSize / 2),
            y1: Math.floor(y - this.settingSize / 2),
            x2: Math.ceil(x + this.settingSize / 2),
            y2: Math.ceil(y + this.settingSize / 2)
        });
    }
    endLine() {
        this.inputIsDrawing = false;
        this.count = 0;
        this.points = [];
        if (this.changedBounds) {
            const boundsWithinSelection = (0, _math.boundsOverlap)(this.changedBounds, this.selectionBounds);
            const layerData = (0, _canvasToLayerTiles.canvasToLayerTiles)(this.context.canvas, boundsWithinSelection);
            if (layerData.some((item)=>item)) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), layerData));
        }
    }
    //cheap 'n' ugly
    drawLineSegment(x1, y1, x2, y2) {
        this.changedBounds = undefined;
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        if (this.inputIsDrawing || x1 === undefined) return;
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        this.context.lineWidth = this.settingSize;
        const mixCol = {
            r: this.settingColor.r,
            g: this.settingColor.g,
            b: this.settingColor.b
        };
        if (x1 + 5 >= 0 && y1 + 5 >= 0 && x1 - 5 < this.context.canvas.width - 1 && y1 - 5 < this.context.canvas.height - 1) {
            mixCol.r = 0;
            mixCol.g = 0;
            mixCol.b = 0;
            const mixX = Math.min(this.context.canvas.width - 1, Math.max(0, x1 - 5));
            const mixY = Math.min(this.context.canvas.height - 1, Math.max(0, y1 - 5));
            let mixW = Math.min(this.context.canvas.width - 1, Math.max(0, x1 + 5));
            let mixH = Math.min(this.context.canvas.height - 1, Math.max(0, y1 + 5));
            mixW -= mixX;
            mixH -= mixY;
            if (mixW > 0 && mixH > 0) {
                const w = Math.min(sampleCanvas.width, mixW);
                const h = Math.min(sampleCanvas.height, mixH);
                sampleCtx.save();
                sampleCtx.globalCompositeOperation = 'copy';
                sampleCtx.drawImage(this.context.canvas, mixX, mixY, mixW, mixH, 0, 0, w, h);
                sampleCtx.restore();
                const imDat = sampleCtx.getImageData(mixX, mixY, mixW, mixH);
                let countMix = 0;
                for(let i = 0; i < imDat.data.length; i += 4){
                    mixCol.r += imDat.data[i + 0];
                    mixCol.g += imDat.data[i + 1];
                    mixCol.b += imDat.data[i + 2];
                    countMix++;
                }
                mixCol.r /= countMix;
                mixCol.g /= countMix;
                mixCol.b /= countMix;
            }
        }
        const mixed = this.mixMode[0](new (0, _bb.BB).RGB(mixCol.r, mixCol.g, mixCol.b), this.settingColor);
        mixCol.r = parseInt('' + (this.settingBlending * mixed.r + this.settingColor.r * (1 - this.settingBlending)));
        mixCol.g = parseInt('' + (this.settingBlending * mixed.g + this.settingColor.g * (1 - this.settingBlending)));
        mixCol.b = parseInt('' + (this.settingBlending * mixed.b + this.settingColor.b * (1 - this.settingBlending)));
        this.context.strokeStyle = 'rgba(' + mixCol.r + ', ' + mixCol.g + ', ' + mixCol.b + ', ' + this.settingOpacity + ')';
        this.context.beginPath();
        this.context.moveTo(x1, y1);
        this.context.lineTo(x2, y2);
        this.context.stroke();
        this.context.strokeStyle = 'rgba(' + mixCol.r + ', ' + mixCol.g + ', ' + mixCol.b + ', ' + this.settingOpacity + ')';
        this.context.restore();
        this.changedBounds = (0, _bb.BB).updateBounds(this.changedBounds, {
            x1: Math.floor(x1 - this.settingSize / 2),
            y1: Math.floor(y1 - this.settingSize / 2),
            x2: Math.ceil(x1 + this.settingSize / 2),
            y2: Math.ceil(y1 + this.settingSize / 2)
        });
        this.changedBounds = (0, _bb.BB).updateBounds(this.changedBounds, {
            x1: Math.floor(x2 - this.settingSize / 2),
            y1: Math.floor(y2 - this.settingSize / 2),
            x2: Math.ceil(x2 + this.settingSize / 2),
            y2: Math.ceil(y2 + this.settingSize / 2)
        });
        if (this.changedBounds) {
            const boundsWithinSelection = (0, _math.boundsOverlap)(this.changedBounds, this.selectionBounds);
            const layerData = (0, _canvasToLayerTiles.canvasToLayerTiles)(this.context.canvas, boundsWithinSelection);
            if (layerData.some((item)=>item)) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), layerData));
        }
    }
    isDrawing() {
        return this.inputIsDrawing;
    }
}

},{"../../bb/bb":"3zOvT","../history/push-helpers/get-pushable-layer-change":"cpxKS","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j2aAa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PixelBrush", ()=>PixelBrush);
var _bb = require("../../bb/bb");
var _eraseColor = require("./erase-color");
var _base = require("../../bb/base/base");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _changedTiles = require("../history/push-helpers/changed-tiles");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
class PixelBrush {
    updateChangedTiles(bounds) {
        // fix bounds
        bounds = {
            x1: Math.min(bounds.x1, bounds.x2),
            y1: Math.min(bounds.y1, bounds.y2),
            x2: Math.max(bounds.x1, bounds.x2),
            y2: Math.max(bounds.y1, bounds.y2)
        };
        const boundsWithinSelection = (0, _math.boundsOverlap)(bounds, this.selectionBounds);
        if (!boundsWithinSelection) return;
        const changedTiles = (0, _changedTiles.getChangedTiles)(boundsWithinSelection, this.context.canvas.width, this.context.canvas.height);
        this.redrawBounds = this.redrawBounds ? (0, _math.updateBounds)(this.redrawBounds, boundsWithinSelection) : boundsWithinSelection;
        this.historyTiles = (0, _changedTiles.updateChangedTiles)(this.historyTiles, changedTiles);
    }
    initClone() {
        this.canvasClone = (0, _bb.BB).canvas(this.context.canvas.width, this.context.canvas.height);
        this.ctxClone = (0, _bb.BB).ctx(this.canvasClone);
        this.ctxClone.drawImage(this.context.canvas, 0, 0);
    }
    freeClone() {
        (0, _bb.BB).freeCanvas(this.canvasClone);
        this.ctxClone = {};
    }
    redrawToCanvas() {
        if (!this.redrawBounds) return;
        const boundsRect = (0, _math.boundsToRect)(this.redrawBounds, true);
        this.context.save();
        this.context.clearRect(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
        this.context.drawImage(this.canvasClone, boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height, boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
        this.context.restore();
        this.redrawBounds = undefined;
    }
    updateDither() {
        this.ditherCtx.clearRect(0, 0, 4, 4);
        this.ditherCtx.fillStyle = this.settingIsEraser ? `rgb(${0, _eraseColor.ERASE_COLOR},${0, _eraseColor.ERASE_COLOR},${0, _eraseColor.ERASE_COLOR})` : this.settingColorStr;
        for(let i = 0; i < Math.max(1, Math.round(this.settingOpacity * this.ditherArr.length)); i++)this.ditherCtx.fillRect(this.ditherArr[i][0], this.ditherArr[i][1], 1, 1);
        this.ditherPattern = (0, _base.throwIfNull)(this.context.createPattern(this.ditherCanvas, 'repeat'));
    }
    /**
     * Tests p1->p2 or p3->p4 deviate in their direction more than max, compared to p1->p4
     */ cubicCurveOverThreshold(p1, p2, p3, p4, maxAngleRad) {
        const d = (0, _bb.BB).Vec2.nor({
            x: p4.x - p1.x,
            y: p4.y - p1.y
        });
        const d2 = (0, _bb.BB).Vec2.nor({
            x: p2.x - p1.x,
            y: p2.y - p1.y
        });
        const d3 = (0, _bb.BB).Vec2.nor({
            x: p4.x - p3.x,
            y: p4.y - p3.y
        });
        // const a2 = Math.abs(BB.Vec2.angle(d, d2) % Math.PI) / Math.PI * 180;
        // const a3 = Math.abs(BB.Vec2.angle(d, d3) % Math.PI) / Math.PI * 180;
        return Math.max((0, _bb.BB).Vec2.dist(d, d2), (0, _bb.BB).Vec2.dist(d, d3)) > maxAngleRad;
    }
    plotCubicBezierLine(p1, p2, p3, p4) {
        const isOverThreshold = this.cubicCurveOverThreshold(p1, p2, p3, p4, 0.1);
        p1.x = Math.floor(p1.x);
        p1.y = Math.floor(p1.y);
        p4.x = Math.floor(p4.x);
        p4.y = Math.floor(p4.y);
        const dist = (0, _bb.BB).dist(p1.x, p1.y, p4.x, p4.y);
        if (!isOverThreshold || dist < 7) {
            this.updateChangedTiles({
                x1: p1.x,
                y1: p1.y,
                x2: p4.x,
                y2: p4.y
            });
            this.plotLine(p1.x, p1.y, p4.x, p4.y, true);
            return;
        }
        const n = Math.max(2, Math.round(dist / 4));
        const pointArr = [];
        for(let i = 0; i <= n; i++){
            const t = i / n;
            const a = Math.pow(1 - t, 3);
            const b = 3 * t * Math.pow(1 - t, 2);
            const c = 3 * Math.pow(t, 2) * (1 - t);
            const d = Math.pow(t, 3);
            pointArr.push({
                x: a * p1.x + b * p2.x + c * p3.x + d * p4.x,
                y: a * p1.y + b * p2.y + c * p3.y + d * p4.y
            });
        }
        for(let i = 0; i < n; i++){
            this.updateChangedTiles({
                x1: Math.round(pointArr[i].x),
                y1: Math.round(pointArr[i].y),
                x2: Math.round(pointArr[i + 1].x),
                y2: Math.round(pointArr[i + 1].y)
            });
            this.plotLine(Math.round(pointArr[i].x), Math.round(pointArr[i].y), Math.round(pointArr[i + 1].x), Math.round(pointArr[i + 1].y), true);
        }
    }
    drawDot(x, y, size, opacity) {
        const rect = {
            x: Math.round(x + -size),
            y: Math.round(y + -size),
            width: Math.round(size * 2),
            height: Math.round(size * 2)
        };
        this.updateChangedTiles({
            x1: rect.x,
            y1: rect.y,
            x2: rect.x + rect.width,
            y2: rect.y + rect.height
        });
        this.ctxClone.save();
        if (this.settingIsEraser) {
            this.ctxClone.fillStyle = this.settingUseDither ? this.ditherPattern : '#fff';
            if (this.settingLockLayerAlpha) this.ctxClone.globalCompositeOperation = 'source-atop';
            else this.ctxClone.globalCompositeOperation = 'destination-out';
        } else {
            this.ctxClone.fillStyle = this.settingUseDither ? this.ditherPattern : this.settingColorStr;
            if (this.settingLockLayerAlpha) this.ctxClone.globalCompositeOperation = 'source-atop';
        }
        this.ctxClone.globalAlpha = this.settingUseDither ? 1 : opacity;
        this.ctxClone.fillRect(rect.x, rect.y, rect.width, rect.height);
        this.ctxClone.restore();
    }
    continueLine(x, y, size, pressure) {
        if (this.bezierLine === null) {
            this.bezierLine = new (0, _bb.BB).BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, ()=>{});
        }
        this.ctxClone.save();
        this.selectionPath && this.ctxClone.clip(this.selectionPath);
        const dotCallback = (val)=>{
            const localPressure = (0, _bb.BB).mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.settingOpacity * (this.settingHasOpacityPressure ? localPressure * localPressure : 1);
            const localSize = Math.max(0.5, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            this.drawDot(val.x, val.y, localSize, localOpacity);
        };
        const controlCallback = (controlObj)=>{
            this.plotCubicBezierLine(controlObj.p1, controlObj.p2, controlObj.p3, controlObj.p4);
        };
        if (Math.round(this.settingSize * 2) === 1) {
            this.bresenheimPath = new Path2D();
            if (x === null || y === null) this.bezierLine.addFinal(4, undefined, controlCallback);
            else this.bezierLine.add(x, y, 4, undefined, controlCallback);
            if (this.settingIsEraser) {
                this.ctxClone.fillStyle = this.settingUseDither ? this.ditherPattern : '#fff';
                if (this.settingLockLayerAlpha) this.ctxClone.globalCompositeOperation = 'source-atop';
                else this.ctxClone.globalCompositeOperation = 'destination-out';
            } else {
                this.ctxClone.fillStyle = this.settingUseDither ? this.ditherPattern : this.settingColorStr;
                if (this.settingLockLayerAlpha) this.ctxClone.globalCompositeOperation = 'source-atop';
            }
            this.ctxClone.globalAlpha = this.settingUseDither ? 1 : this.settingOpacity;
            this.ctxClone.fill(this.bresenheimPath);
            this.bresenheimPath = undefined;
        } else {
            const localSpacing = size * this.settingSpacing;
            if (x === null || y === null) this.bezierLine.addFinal(localSpacing, dotCallback);
            else this.bezierLine.add(x, y, localSpacing, dotCallback);
        }
        this.ctxClone.restore();
    }
    /**
     * bresenheim line drawing
     */ plotLine(x0, y0, x1, y1, skipFirst) {
        x0 = Math.floor(x0);
        y0 = Math.floor(y0);
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        const dX = Math.abs(x1 - x0);
        const sX = x0 < x1 ? 1 : -1;
        const dY = -Math.abs(y1 - y0);
        const sY = y0 < y1 ? 1 : -1;
        let err = dX + dY;
        while(true){
            if (skipFirst) skipFirst = false;
            else this.bresenheimPath?.rect(x0, y0, 1, 1);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 >= dY) {
                err += dY;
                x0 += sX;
            }
            if (e2 <= dX) {
                err += dX;
                y0 += sY;
            }
        }
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.klHistory = {};
        this.context = {};
        this.settingHasSizePressure = true;
        this.settingHasOpacityPressure = false;
        this.settingSize = 0.5;
        this.settingSpacing = 0.9;
        this.settingOpacity = 1;
        this.settingColor = {};
        this.settingColorStr = '';
        this.settingLockLayerAlpha = false;
        this.settingIsEraser = false;
        this.settingUseDither = true;
        this.inputIsDrawing = false;
        this.lineToolLastDot = 0;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.bezierLine = null;
        this.ditherArr = [
            [
                3,
                2
            ],
            [
                1,
                0
            ],
            [
                3,
                0
            ],
            [
                1,
                2
            ],
            [
                2,
                1
            ],
            [
                0,
                3
            ],
            [
                0,
                1
            ],
            [
                2,
                3
            ],
            [
                2,
                0
            ],
            [
                0,
                2
            ],
            [
                0,
                0
            ],
            [
                2,
                2
            ],
            [
                1,
                1
            ],
            [
                3,
                3
            ],
            [
                3,
                1
            ],
            [
                1,
                3
            ]
        ];
        this.ditherPattern = {};
        /*
        Draw brush into fresh canvas for each line,
        because otherwise chrome slows the main canvas down.
        Multiple reads on a canvas -> canvas moved to CPU. (my guess)
     */ this.canvasClone = {};
        this.ctxClone = {};
        // changed tiles that will be pushed to history
        this.historyTiles = [];
        this.ditherCanvas = (0, _bb.BB).canvas(4, 4);
        this.ditherCtx = (0, _bb.BB).ctx(this.ditherCanvas);
    }
    // ---- interface ----
    startLine(x, y, p) {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.historyTiles = [];
        this.redrawBounds = undefined;
        if (this.settingUseDither) this.updateDither();
        this.initClone();
        p = Math.max(0, Math.min(1, p));
        const localOpacity = this.settingHasOpacityPressure ? this.settingOpacity * p * p : this.settingOpacity;
        const localSize = this.settingHasSizePressure ? Math.max(0.5, p * this.settingSize) : Math.max(0.5, this.settingSize);
        this.inputIsDrawing = true;
        this.ctxClone.save();
        this.selectionPath && this.ctxClone.clip(this.selectionPath);
        this.drawDot(x, y, localSize, localOpacity);
        this.ctxClone.restore();
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.redrawToCanvas();
    }
    goLine(x, y, p) {
        if (!this.inputIsDrawing) return;
        //debug
        //drawDot(x, y, 1, 0.5);
        const pressure = (0, _bb.BB).clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = pressure;
        this.redrawToCanvas();
    }
    endLine() {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(null, null, localSize, this.lastInput.pressure);
        //debug
        //drawDot(lastInput.x, lastInput.y, 3, 1);
        //drawDot(x, y, 10, 0.1);
        this.inputIsDrawing = false;
        this.bezierLine = null;
        this.redrawToCanvas();
        if (this.historyTiles.some((item)=>item)) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), (0, _canvasToLayerTiles.canvasAndChangedTilesToLayerTiles)(this.canvasClone, this.historyTiles)));
        this.freeClone();
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.startLine(x1, y1, 1);
        this.goLine(x2, y2, 1);
        this.endLine();
    }
    //IS
    isDrawing() {
        return this.inputIsDrawing;
    }
    //SET
    setColor(c) {
        if (this.settingColor === c) return;
        this.settingColor = c;
        this.settingColorStr = 'rgb(' + this.settingColor.r + ',' + this.settingColor.g + ',' + this.settingColor.b + ')';
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(klHistory) {
        this.klHistory = klHistory;
    }
    setSize(s) {
        this.settingSize = Math.round(s * 2) / 2;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    setIsEraser(b) {
        this.settingIsEraser = b;
    }
    setUseDither(b) {
        this.settingUseDither = b;
    }
    //GET
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    getIsEraser() {
        return this.settingIsEraser;
    }
    getUseDither() {
        return this.settingUseDither;
    }
}

},{"../../bb/bb":"3zOvT","./erase-color":"4wlOt","../../bb/base/base":"it3mQ","../history/push-helpers/get-pushable-layer-change":"cpxKS","../history/push-helpers/changed-tiles":"fEQ1q","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"K5lZc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EraserBrush", ()=>EraserBrush);
var _bb = require("../../bb/bb");
var _eraseColor = require("./erase-color");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _changedTiles = require("../history/push-helpers/changed-tiles");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
class EraserBrush {
    updateChangedTiles(bounds) {
        const boundsWithinSelection = (0, _math.boundsOverlap)(bounds, this.selectionBounds);
        if (!boundsWithinSelection) return;
        this.changedTiles = (0, _changedTiles.updateChangedTiles)(this.changedTiles, (0, _changedTiles.getChangedTiles)(bounds, this.context.canvas.width, this.context.canvas.height));
    }
    drawDot(x, y, size, opacity) {
        this.context.save();
        if (this.isBaseLayer) {
            if (this.isTransparentBG) this.context.globalCompositeOperation = 'destination-out';
            else this.context.globalCompositeOperation = 'source-atop';
        } else this.context.globalCompositeOperation = 'destination-out';
        const radgrad = this.context.createRadialGradient(size, size, 0, size, size, size);
        let sharpness = Math.pow(opacity, 2);
        sharpness = Math.max(0, Math.min((size - 1) / size, sharpness));
        const oFac = Math.max(0, Math.min(1, opacity));
        const localOpacity = 2 * oFac - oFac * oFac;
        radgrad.addColorStop(sharpness, `rgba(${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, ` + localOpacity + ')');
        radgrad.addColorStop(1, `rgba(${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, 0)`);
        this.context.fillStyle = radgrad;
        this.context.translate(x - size, y - size);
        this.context.fillRect(0, 0, size * 2, size * 2);
        this.context.restore();
        this.updateChangedTiles({
            x1: Math.floor(x - size),
            y1: Math.floor(y - size),
            x2: Math.ceil(x + size),
            y2: Math.ceil(y + size)
        });
    }
    continueLine(x, y, p) {
        p = Math.max(0, Math.min(1, p));
        let localPressure;
        let localOpacity;
        let localSize = this.useSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        const bdist = Math.max(1, Math.max(0.5, 1 - this.opacity) * localSize * this.spacing);
        const bezierCallback = (val)=>{
            const factor = val.t;
            localPressure = this.lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = this.useOpacityPressure ? this.opacity * localPressure * localPressure : this.opacity;
            localSize = this.useSizePressure ? Math.max(0.1, localPressure * this.size) : Math.max(0.1, this.size);
            this.drawDot(val.x, val.y, localSize, localOpacity);
        };
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        if (x === undefined || y === undefined) this.bezierLine.addFinal(bdist, bezierCallback);
        else this.bezierLine.add(x, y, bdist, bezierCallback);
        this.context.restore();
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.size = 30;
        this.spacing = 0.4;
        this.opacity = 1;
        this.useSizePressure = true;
        this.useOpacityPressure = false;
        this.isTransparentBG = false;
        this.klHistory = {};
        this.isBaseLayer = false;
        this.layer = {};
        this.context = {};
        this.started = false;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.changedTiles = [];
    }
    // ---- interface ----
    startLine(x, y, p) {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.changedTiles = [];
        this.isBaseLayer = 0 === this.layer.index;
        p = Math.max(0, Math.min(1, p));
        const localOpacity = this.useOpacityPressure ? this.opacity * p * p : this.opacity;
        const localSize = this.useSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        this.started = true;
        if (localSize > 1) {
            this.context.save();
            this.selectionPath && this.context.clip(this.selectionPath);
            this.drawDot(x, y, localSize, localOpacity);
            this.context.restore();
        }
        this.lastDot = localSize * this.spacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.bezierLine = new (0, _bb.BB).BezierLine();
        this.bezierLine.add(x, y, 0, ()=>undefined);
    }
    goLine(x, y, p) {
        if (!this.started) return;
        this.continueLine(x, y, this.lastInput.pressure);
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
    }
    endLine() {
        if (this.bezierLine) this.continueLine(undefined, undefined, this.lastInput.pressure);
        this.started = false;
        this.bezierLine = undefined;
        if (this.changedTiles.some((item)=>item)) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), (0, _canvasToLayerTiles.canvasAndChangedTilesToLayerTiles)(this.context.canvas, this.changedTiles)));
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.changedTiles = [];
        this.isBaseLayer = 0 === this.layer.index;
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        if (this.started || x1 === undefined) return;
        const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        const eX = (x2 - x1) / mouseDist;
        const eY = (y2 - y1) / mouseDist;
        let loopDist;
        const bdist = Math.max(1, Math.max(0.5, 1 - this.opacity) * this.size * this.spacing);
        this.lastDot = 0;
        this.context.save();
        this.selectionPath && this.context.clip(this.selectionPath);
        for(loopDist = this.lastDot; loopDist <= mouseDist; loopDist += bdist)this.drawDot(x1 + eX * loopDist, y1 + eY * loopDist, this.size, this.opacity);
        this.context.restore();
        if (this.changedTiles.some((item)=>item)) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), (0, _canvasToLayerTiles.canvasAndChangedTilesToLayerTiles)(this.context.canvas, this.changedTiles)));
    }
    //IS
    isDrawing() {
        return this.started;
    }
    //SET
    setLayer(layer) {
        this.layer = layer;
        this.context = layer.context;
    }
    setHistory(klHistory) {
        this.klHistory = klHistory;
    }
    setSize(s) {
        this.size = s;
    }
    setOpacity(o) {
        this.opacity = o;
    }
    sizePressure(b) {
        this.useSizePressure = b;
    }
    opacityPressure(b) {
        this.useOpacityPressure = b;
    }
    setTransparentBG(b) {
        this.isTransparentBG = b;
    }
    //GET
    getSize() {
        return this.size;
    }
    getOpacity() {
        return this.opacity;
    }
}

},{"../../bb/bb":"3zOvT","./erase-color":"4wlOt","../history/push-helpers/get-pushable-layer-change":"cpxKS","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../history/push-helpers/changed-tiles":"fEQ1q","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j9hUM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SmudgeBrush", ()=>SmudgeBrush);
var _bb = require("../../bb/bb");
var _math = require("../../bb/math/math");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _base = require("../../bb/base/base");
var _getBinaryMask = require("../select-tool/get-binary-mask");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
// let statCount = 1;
// let statAcc = 0;
// stats on win10, chrome, size 100, opacity 80, smudge()
// unoptimized: 1 ms
// minimal: 0.09 ms
// minimal + circle: 0.5ms
// minimal + circle + ix, iy: 0.23ms
// unoptimized + ix, iy: 0.64 ms
// unoptimized + ix, iy + sans rounding: 0.61 ms
// ix, iy + sans rounding + sans random: 0.32ms
// ix, iy + sans rounding + fast random: 0.46 ms
// ix, iy + sans rounding + fast random + offset const: 0.48 ms
const CELL_SIZE = 256;
/**
 * determine bounds of smudge
 * @param imWidth
 * @param imHeight
 * @param aP
 * @param bP
 * @param size
 */ function prepSmudge(imWidth, imHeight, aP, bP, size) {
    if (aP.x === bP.x && aP.y === bP.y) return null;
    aP = (0, _bb.BB).copyObj(aP);
    bP = (0, _bb.BB).copyObj(bP);
    size = (0, _bb.BB).copyObj(size);
    // corner behavior
    // cut down rectangles, if a or b go outside
    // i.e. if user drags partially or fully outside the canvas
    {
        let top = 0;
        let right = 0;
        let bottom = 0;
        let left = 0;
        if (aP.x < 0) left = -aP.x;
        if (aP.y < 0) top = -aP.y;
        if (bP.x < 0) left = Math.max(left, -bP.x);
        if (bP.y < 0) top = Math.max(top, -bP.y);
        if (aP.x + size.w > imWidth) right = aP.x + size.w - imWidth;
        if (aP.y + size.h > imHeight) bottom = aP.y + size.h - imHeight;
        if (bP.x + size.w > imWidth) right = Math.max(right, bP.x + size.w - imWidth);
        if (bP.y + size.h > imHeight) bottom = Math.max(bottom, bP.y + size.h - imHeight);
        aP.x += left;
        bP.x += left;
        aP.y += top;
        bP.y += top;
        size.w = size.w - left - right;
        size.h = size.h - top - bottom;
        if (size.w <= 0 || size.h <= 0) return null;
    }
    return {
        aP: {
            x: aP.x,
            y: aP.y
        },
        bP: {
            x: bP.x,
            y: bP.y
        },
        size: {
            w: size.w,
            h: size.h
        }
    };
}
/**
 * Pixel operations that do the smudging via ImageData
 * @param imageData
 * @param p
 */ function smudge(imageData, mask, p) {
    p = (0, _bb.BB).copyObj(p);
    const cSize = p.brush.size;
    const cX = p.brush.center.x;
    const cY = p.brush.center.y;
    /*if (statCount % 1000 === 0) {
        console.log(statAcc / 1000);
        statAcc = 0;
    }
    let start = performance.now();*/ // determine offset
    const aIndex = p.aP.y * imageData.width + p.aP.x;
    const bIndex = p.bP.y * imageData.width + p.bP.x;
    const offset = (bIndex - aIndex) * 4;
    // array with random numbers. faster than Math.random()
    let randI = 0;
    const randLen = cSize > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
    const randArr = [];
    for(let i = 0; i < randLen; i++)randArr[i] = (Math.random() - 0.5) / 1.001 + 0.5;
    const softnessPx = Math.max(3, Math.min(8, p.brush.size - 8));
    const pixel = (ai, bi, ix, iy)=>{
        const dist = (0, _bb.BB).dist(cX, cY, ix, iy);
        const fac = 1 - p.brush.opacity * (1 - (0, _math.clamp)((dist - (cSize - softnessPx)) / softnessPx, 0, 1));
        if (fac === 1) return;
        if (mask && (mask[ai / 4] === 0 || mask[bi / 4] === 0)) return;
        if (!imageData.data[ai + 3]) ;
        else if (!imageData.data[bi + 3]) {
            // don't mix if target fully transparent. pixel might have a strange color.
            imageData.data[bi] = imageData.data[ai];
            imageData.data[bi + 1] = imageData.data[ai + 1];
            imageData.data[bi + 2] = imageData.data[ai + 2];
        } else {
            // consider alpha ratio. If a has lower alpha than b, then b should be stronger, and vice versa
            // not totally accurate. TODO same compositing as blend brush
            let fac2;
            if (imageData.data[ai + 3] < imageData.data[bi + 3]) fac2 = 1 - imageData.data[ai + 3] / imageData.data[bi + 3] * (1 - fac);
            else fac2 = imageData.data[bi + 3] / imageData.data[ai + 3] * fac;
            // ImageData's Uint8ClampedArray rounds -> 0.5 becomes 1. But not in Safari, so needs to be done manually
            // Offset mixed color by random number noise (-0.5, 0.5), so it doesn't get stuck while mixing.
            // No +0.5, because it cancels out with rand.
            imageData.data[bi] = Math.floor((0, _bb.BB).mix(imageData.data[ai], imageData.data[bi + 0], fac2) + randArr[randI]);
            imageData.data[bi + 1] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 1], imageData.data[bi + 1], fac2) + randArr[randI]);
            imageData.data[bi + 2] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 2], imageData.data[bi + 2], fac2) + randArr[randI]);
            randI = (randI + 1) % randLen;
        }
        // Always mix alpha. unless alpha lock
        if (!p.brush.alphaLock) imageData.data[bi + 3] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 3], imageData.data[bi + 3], fac) + 0.5);
    };
    const bx1 = p.bP.x * 4;
    const bx2 = bx1 + (p.size.w - 1) * 4;
    // transfer of pixels depends on direction of smudging if there is overlap
    if (p.aP.y < p.bP.y) for(let y = p.size.h - 1, iy = p.bP.y + p.size.h - 1; y >= 0; y--, iy--){
        const yStart = (y + p.bP.y) * imageData.width * 4;
        for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
    }
    else if (p.aP.y > p.bP.y) for(let y = 0, iy = p.bP.y; y < p.size.h; y++, iy++){
        const yStart = (y + p.bP.y) * imageData.width * 4;
        for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
    }
    else {
        if (p.aP.x < p.bP.x) for(let y = p.size.h - 1, iy = p.bP.y + p.size.h - 1; y >= 0; y--, iy--){
            const yStart = (y + p.bP.y) * imageData.width * 4;
            for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
        }
        else for(let y = 0, iy = p.bP.y; y < p.size.h; y++, iy++){
            const yStart = (y + p.bP.y) * imageData.width * 4;
            for(let x = bx1 + yStart, x2 = bx1 + yStart - offset, ix = p.bP.x; x < bx2 + yStart; x += 4, x2 += 4, ix++)pixel(x2, x, ix, iy);
        }
    }
//statCount++;
//statAcc += performance.now() - start;
}
class SmudgeBrush {
    // workaround for https://github.com/microsoft/TypeScript/issues/41654
    resetRedrawBounds() {
        this.redrawBounds = undefined;
    }
    updateRedrawBounds(bounds) {
        const boundsWithinSelection = (0, _math.boundsOverlap)(bounds, this.selectionBounds);
        if (!boundsWithinSelection) return;
        this.redrawBounds = (0, _bb.BB).updateBounds(this.redrawBounds, boundsWithinSelection);
    }
    updateCompleteRedrawBounds(x1, y1, x2, y2) {
        this.completeRedrawBounds = (0, _bb.BB).updateBounds(this.completeRedrawBounds, {
            x1,
            y1,
            x2,
            y2
        });
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas() {
        const touchedCells = this.copiedCells.map(()=>false);
        const bounds = [];
        const cellsW = Math.ceil(this.copyImageData.width / CELL_SIZE);
        if (!this.redrawBounds) return;
        bounds.push({
            x1: Math.floor(this.redrawBounds.x1 / CELL_SIZE),
            y1: Math.floor(this.redrawBounds.y1 / CELL_SIZE),
            x2: Math.floor(this.redrawBounds.x2 / CELL_SIZE),
            y2: Math.floor(this.redrawBounds.y2 / CELL_SIZE)
        });
        bounds.forEach((item)=>{
            for(let i = item.x1; i <= item.x2; i++)for(let e = item.y1; e <= item.y2; e++)touchedCells[e * cellsW + i] = true;
        });
        touchedCells.forEach((item, i)=>{
            if (!item || this.copiedCells[i]) // not touched, or already copied
            return;
            this.copiedCells[i] = true;
            const x = i % cellsW;
            const y = Math.floor(i / cellsW);
            const w = (Math.min(x * CELL_SIZE + CELL_SIZE, this.copyImageData.width) - 1) % CELL_SIZE + 1;
            const h = (Math.min(y * CELL_SIZE + CELL_SIZE, this.copyImageData.height) - 1) % CELL_SIZE + 1;
            // temp canvas to prevent main canvas from getting slowed down in chrome
            const tmpCanvas = (0, _bb.BB).canvas(w, h);
            const tmpCtx = (0, _bb.BB).ctx(tmpCanvas);
            tmpCtx.drawImage(this.context.canvas, -x * CELL_SIZE, -y * CELL_SIZE);
            const data = tmpCtx.getImageData(0, 0, w, h);
            for(let i = 0; i < h; i++)for(let e = 0, e2 = i * w * 4, e3 = ((y * CELL_SIZE + i) * this.copyImageData.width + x * CELL_SIZE) * 4; e < w; e++, e2 += 4, e3 += 4){
                this.copyImageData.data[e3] = data.data[e2];
                this.copyImageData.data[e3 + 1] = data.data[e2 + 1];
                this.copyImageData.data[e3 + 2] = data.data[e2 + 2];
                this.copyImageData.data[e3 + 3] = data.data[e2 + 3];
            }
        });
    }
    /**
     * fill drawBuffer with params about to be drawn
     * @param x
     * @param y
     * @param size
     * @param opacity
     */ prepDot(x, y, size, opacity) {
        if (!this.lastDot) {
            this.lastDot = {
                x: x,
                y: y
            };
            return;
        }
        size = Math.round(size);
        const w = Math.round(size * 2);
        const h = Math.round(size * 2);
        const bounds = prepSmudge(this.copyImageData.width, this.copyImageData.height, {
            x: Math.round(this.lastDot.x - size),
            y: Math.round(this.lastDot.y - size)
        }, {
            x: Math.round(x - size),
            y: Math.round(y - size)
        }, {
            w,
            h
        });
        if (bounds) {
            const params = {
                aP: bounds.aP,
                bP: bounds.bP,
                size: bounds.size,
                brush: {
                    center: {
                        x,
                        y
                    },
                    size,
                    opacity,
                    alphaLock: this.settingLockLayerAlpha
                }
            };
            this.updateRedrawBounds({
                x1: params.bP.x,
                y1: params.bP.y,
                x2: params.bP.x + params.brush.size * 2,
                y2: params.bP.y + params.brush.size * 2
            });
            this.drawBuffer.push(params);
        }
        this.lastDot = {
            x: x,
            y: y
        };
    }
    continueLine(x, y, size, pressure) {
        this.drawBuffer = [];
        if (!this.bezierLine) {
            this.bezierLine = new (0, _bb.BB).BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, function() {});
        }
        const drawArr = []; //draw instructions. will be all drawn at once
        const dotCallback = (val)=>{
            const localPressure = (0, _bb.BB).mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.settingOpacity * (this.settingHasOpacityPressure ? localPressure * localPressure : 1);
            const localSize = Math.max(0.1, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity
            ]); //, val.angle]);
        };
        const localSpacing = size * this.settingSpacing / 3;
        if (x === undefined || y === undefined) this.bezierLine.addFinal(localSpacing, dotCallback);
        else this.bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        for(let i = 0; i < drawArr.length; i++){
            const item = drawArr[i];
            this.prepDot(item[0], item[1], item[2], item[3]);
        }
        this.copyFromCanvas();
        for(let i = 0; i < this.drawBuffer.length; i++)smudge(this.copyImageData, this.mask, this.drawBuffer[i]);
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.context = {};
        this.klHistory = {};
        this.settingColor = {
            r: 0,
            g: 0,
            b: 0
        };
        this.settingSize = 35;
        this.settingSpacing = 0.20446882736951905;
        this.settingOpacity = 0.8;
        this.settingHasSizePressure = false;
        this.settingHasOpacityPressure = false;
        this.settingLockLayerAlpha = false;
        this.lineToolLastDot = 0;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.isDrawing = false;
        this.copyImageData = {};
        this.drawBuffer = [];
        this.copiedCells = [];
    }
    startLine(x, y, p) {
        const selection = this.klHistory.getComposed().selection.value;
        this.selectionBounds = selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(selection)) : undefined;
        this.mask = selection ? (0, _getBinaryMask.getBinaryMask)(selection, this.context.canvas.width, this.context.canvas.height) : undefined;
        p = (0, _bb.BB).clamp(p, 0, 1);
        const localOpacity = this.settingHasOpacityPressure ? this.settingOpacity * p * p : this.settingOpacity;
        const localSize = this.settingHasSizePressure ? Math.max(0.1, p * this.settingSize) : Math.max(0.1, this.settingSize);
        this.lastDot = undefined;
        this.isDrawing = true;
        this.copyImageData = new ImageData(this.context.canvas.width, this.context.canvas.height);
        const totalCells = Math.ceil(this.context.canvas.width / CELL_SIZE) * Math.ceil(this.context.canvas.height / CELL_SIZE);
        this.copiedCells = (0, _base.createArray)(totalCells, false);
        this.prepDot(x, y, localSize, localOpacity);
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2.pressure = p;
        this.completeRedrawBounds = undefined;
    }
    goLine(x, y, p) {
        if (!this.isDrawing) return;
        this.resetRedrawBounds();
        const pressure = (0, _bb.BB).clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1, this.redrawBounds.y2 - this.redrawBounds.y1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput2.pressure = this.lastInput.pressure;
        this.lastInput.pressure = pressure;
    }
    endLine() {
        this.resetRedrawBounds();
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.continueLine(undefined, undefined, localSize, this.lastInput.pressure);
        this.context.restore();
        this.isDrawing = false;
        this.bezierLine = undefined;
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1, this.redrawBounds.y2 - this.redrawBounds.y1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        if (this.completeRedrawBounds) this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), (0, _canvasToLayerTiles.canvasToLayerTiles)(this.context.canvas, this.completeRedrawBounds)));
        this.copyImageData = {};
    }
    drawImage(im, x, y) {
        if (im instanceof ImageData) this.context.putImageData(im, x, y);
        else {
            this.context.clearRect(x, y, im.width, im.height);
            this.context.drawImage(im, x, y);
        }
    }
    drawLineSegment(x1, y1, x2, y2) {
        return;
    /*
        // todo
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;

        if (isDrawing || x1 === undefined) {
            return;
        }

        let angle = BB.pointsToAngleDeg({x:x1, y:y1}, {x:x2, y:y2});
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = settingSize * settingSpacing;
        lineToolLastDot = settingSize * settingSpacing;
        for (loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist) {
            drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity);
        }


        let historyEntry = {
            tool: ["brush", "SmudgeBrush"],
            actions: []
        };
        // todo
        history.add(historyEntry);*/ }
    getIsDrawing() {
        return this.isDrawing;
    }
    setColor(c) {
        if (this.settingColor.r === c.r && this.settingColor.g === c.g && this.settingColor.b === c.b) return;
        this.settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(klHistory) {
        this.klHistory = klHistory;
    }
    setSize(s) {
        this.settingSize = s;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
}

},{"../../bb/bb":"3zOvT","../../bb/math/math":"7x9Fp","../history/push-helpers/get-pushable-layer-change":"cpxKS","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../../bb/base/base":"it3mQ","../select-tool/get-binary-mask":"iRxtk","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h7JRV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChemyBrush", ()=>ChemyBrush);
var _bb = require("../../bb/bb");
var _eraseColor = require("./erase-color");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
class ChemyBrush {
    updateCompleteRedrawBounds(x, y) {
        let bounds = {
            x1: x,
            y1: y,
            x2: x,
            y2: y
        };
        if (this.settingXSymmetry) bounds = (0, _bb.BB).updateBounds(bounds, {
            x1: -x + this.copyCanvas.width,
            y1: y,
            x2: -x + this.copyCanvas.width,
            y2: y
        });
        if (this.settingYSymmetry) bounds = (0, _bb.BB).updateBounds(bounds, {
            x1: x,
            y1: -y + this.copyCanvas.height,
            x2: x,
            y2: -y + this.copyCanvas.height
        });
        const buffer = this.settingMode === 'stroke' ? this.settingSize + 1 : 1;
        bounds.x1 = Math.floor(bounds.x1 - buffer);
        bounds.y1 = Math.floor(bounds.y1 - buffer);
        bounds.x2 = Math.ceil(bounds.x2 + buffer);
        bounds.y2 = Math.ceil(bounds.y2 + buffer);
        const boundsWithinSelection = this.selectionBounds ? (0, _math.boundsOverlap)(bounds, this.selectionBounds) : bounds;
        if (!boundsWithinSelection) return;
        this.completeRedrawBounds = (0, _bb.BB).updateBounds(this.completeRedrawBounds, boundsWithinSelection);
    }
    drawShape() {
        this.context.save();
        this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
        this.context.drawImage(this.copyCanvas, 0, 0);
        this.selectionPath && this.context.clip(this.selectionPath);
        const color = {
            ...this.settingColor
        };
        if (this.settingIsEraser) {
            color.r = (0, _eraseColor.ERASE_COLOR);
            color.g = (0, _eraseColor.ERASE_COLOR);
            color.b = (0, _eraseColor.ERASE_COLOR);
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = 'source-atop';
            else this.context.globalCompositeOperation = 'destination-out';
        } else if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = 'source-atop';
        if (this.path.length > 1) {
            // path
            const path = new Path2D();
            this.path.forEach((item, index)=>{
                if (index === 0) path.moveTo(item.x, item.y);
                else path.lineTo(item.x, item.y);
            });
            let style = (0, _bb.BB).ColorConverter.toRgbaStr({
                r: color.r,
                g: color.g,
                b: color.b,
                a: this.settingOpacity
            });
            if (this.settingGradient) {
                const startAtTop = this.path[0].x > this.path[this.path.length - 1].x;
                const gradient = this.context.createLinearGradient(0, startAtTop ? this.minY : this.maxY, 0, startAtTop ? this.maxY : this.minY);
                gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: this.settingOpacity
                }));
                gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: 0
                }));
                style = gradient;
            }
            // setup params
            if (this.settingMode === 'fill') this.context.fillStyle = style;
            else {
                this.context.lineWidth = this.settingSize * 2;
                this.context.lineJoin = 'bevel';
                this.context.strokeStyle = style;
            }
            // draw
            const draw = ()=>{
                if (this.settingMode === 'fill') this.context.fill(path);
                else this.context.stroke(path);
            };
            draw();
            if (this.settingXSymmetry) {
                this.context.save();
                this.context.translate(this.context.canvas.width / 2, 0);
                this.context.scale(-1, 1);
                this.context.translate(-this.context.canvas.width / 2, 0);
                draw();
                this.context.restore();
            }
            if (this.settingYSymmetry) {
                this.context.save();
                this.context.translate(0, this.context.canvas.height / 2);
                this.context.scale(1, -1);
                this.context.translate(0, -this.context.canvas.height / 2);
                draw();
                this.context.restore();
                if (this.settingXSymmetry) {
                    this.context.save();
                    this.context.translate(this.context.canvas.width / 2, this.context.canvas.height / 2);
                    this.context.scale(-1, -1);
                    this.context.translate(-this.context.canvas.width / 2, -this.context.canvas.height / 2);
                    draw();
                    this.context.restore();
                }
            }
        }
        this.context.restore();
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.context = {};
        this.settingColor = {};
        this.settingSize = 0.25 // radius - 0.5 - 99999
        ;
        this.settingOpacity = 1 // 0-1
        ;
        this.settingLockLayerAlpha = false;
        this.settingIsEraser = false;
        this.settingMode = 'fill';
        this.settingDistort = 0 // 0 - 1
        ;
        this.settingXSymmetry = false;
        this.settingYSymmetry = false;
        this.settingGradient = false;
        this.isDrawing = false;
        this.klHistory = {};
        this.copyCanvas = {};
        this.path = [];
        this.minY = 0;
        this.maxY = 0;
    }
    setHistory(klHistory) {
        this.klHistory = klHistory;
    }
    getSize() {
        return this.settingMode === 'stroke' ? this.settingSize : 0;
    }
    setSize(s) {
        this.settingSize = s;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setColor(c) {
        this.settingColor = (0, _bb.BB).copyObj(c);
    }
    setContext(c) {
        this.context = c;
    }
    setMode(mode) {
        this.settingMode = mode;
    }
    getMode() {
        return this.settingMode;
    }
    setDistort(distort) {
        this.settingDistort = (0, _bb.BB).clamp(distort, 0, 1);
    }
    getDistort() {
        return this.settingDistort;
    }
    setXSymmetry(b) {
        this.settingXSymmetry = b;
    }
    getXSymmetry() {
        return this.settingXSymmetry;
    }
    setYSymmetry(b) {
        this.settingYSymmetry = b;
    }
    getYSymmetry() {
        return this.settingYSymmetry;
    }
    setGradient(b) {
        this.settingGradient = b;
    }
    getGradient() {
        return this.settingGradient;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    getIsEraser() {
        return this.settingIsEraser;
    }
    setIsEraser(b) {
        this.settingIsEraser = b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    startLine(x, y) {
        this.selection = this.klHistory.getComposed().selection.value;
        this.selectionPath = this.selection ? (0, _getSelectionPath2D.getSelectionPath2d)(this.selection) : undefined;
        this.selectionBounds = this.selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)) : undefined;
        this.isDrawing = true;
        this.path = [
            {
                x,
                y
            }
        ];
        this.minY = y;
        this.maxY = y;
        this.copyCanvas = (0, _bb.BB).canvas(this.context.canvas.width, this.context.canvas.height);
        (0, _bb.BB).ctx(this.copyCanvas).drawImage(this.context.canvas, 0, 0);
        this.completeRedrawBounds = undefined;
        this.updateCompleteRedrawBounds(x, y);
    }
    goLine(x, y) {
        if (!this.isDrawing) return;
        const pos = {
            x,
            y
        };
        if (this.settingDistort > 0) {
            pos.x += (Math.random() - 0.5) * this.settingDistort * 80;
            pos.y += (Math.random() - 0.5) * this.settingDistort * 80;
        }
        this.minY = Math.min(this.minY, pos.y);
        this.maxY = Math.max(this.maxY, pos.y);
        this.path.push(pos);
        this.updateCompleteRedrawBounds(x, y);
        this.drawShape();
    }
    endLine() {
        this.isDrawing = false;
        this.completeRedrawBounds = (0, _bb.BB).boundsInArea(this.completeRedrawBounds, this.copyCanvas.width, this.copyCanvas.height);
        if (this.path.length > 1 && this.completeRedrawBounds) {
            const layerData = (0, _canvasToLayerTiles.canvasToLayerTiles)(this.context.canvas, this.completeRedrawBounds);
            this.klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(this.klHistory.getComposed(), layerData));
        }
        this.path = [];
        this.copyCanvas = {};
    }
    drawLineSegment(x1, y1, x2, y2) {
    // might make sense for stroke
    }
}

},{"../../bb/bb":"3zOvT","./erase-color":"4wlOt","../history/push-helpers/get-pushable-layer-change":"cpxKS","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6ZP5I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BRUSHES_UI", ()=>BRUSHES_UI);
var _penBrushUi = require("./pen-brush-ui");
var _blendBrushUi = require("./blend-brush-ui");
var _sketchyBrushUi = require("./sketchy-brush-ui");
var _pixelBrushUi = require("./pixel-brush-ui");
var _eraserBrushUi = require("./eraser-brush-ui");
var _smudgeBrushUi = require("./smudge-brush-ui");
var _chemyBrushUi = require("./chemy-brush-ui");
const BRUSHES_UI = {
    penBrush: (0, _penBrushUi.penBrushUi),
    blendBrush: (0, _blendBrushUi.blendBrushUi),
    sketchyBrush: (0, _sketchyBrushUi.sketchyBrushUi),
    pixelBrush: (0, _pixelBrushUi.pixelBrushUi),
    chemyBrush: (0, _chemyBrushUi.chemyBrushUi),
    smudgeBrush: (0, _smudgeBrushUi.smudgeBrushUi),
    eraserBrush: (0, _eraserBrushUi.eraserBrushUi)
};

},{"./pen-brush-ui":"kl9tA","./blend-brush-ui":"1gIDV","./sketchy-brush-ui":"638lt","./pixel-brush-ui":"lMhDT","./eraser-brush-ui":"bmfNB","./smudge-brush-ui":"6Lyeq","./chemy-brush-ui":"7xweO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kl9tA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "penBrushUi", ()=>penBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/components/checkbox");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushPenSvg = require("url:/src/app/img/ui/brush-pen.svg");
var _brushPenSvgDefault = parcelHelpers.interopDefault(_brushPenSvg);
var _brushAlphas = require("../brushes/alphas/brush-alphas");
var _language = require("../../language/language");
var _options = require("../ui/components/options");
const penBrushUi = function() {
    const brushInterface = {
        image: (0, _brushPenSvgDefault.default),
        tooltip: (0, _language.LANG)('brush-pen'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).powerSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        },
        scatterSlider: {
            min: 0,
            max: 100,
            curve: (0, _bb.BB).powerSplineInput(0, 100, 0.1, 2.5)
        }
    };
    let alphaNames = [
        (0, _language.LANG)('brush-pen-circle'),
        (0, _language.LANG)('brush-pen-chalk'),
        (0, _language.LANG)('brush-pen-calligraphy'),
        (0, _language.LANG)('brush-pen-square')
    ];
    (0, _language.LANGUAGE_STRINGS).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)('brush-pen');
        alphaNames = [
            (0, _language.LANG)('brush-pen-circle'),
            (0, _language.LANG)('brush-pen-chalk'),
            (0, _language.LANG)('brush-pen-calligraphy'),
            (0, _language.LANG)('brush-pen-square')
        ];
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement('div'); // the gui
        const brush = new (0, _brushes.BRUSHES).PenBrush();
        brush.setHistory(p.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let scatterSlider;
        const alphaOptions = new (0, _options.Options)({
            optionArr: [
                0,
                1,
                2,
                3
            ].map((id)=>{
                const alpha = (0, _bb.BB).el({
                    className: 'dark-invert',
                    css: {
                        width: '31px',
                        height: '31px',
                        backgroundSize: 'contain',
                        margin: '2px'
                    }
                });
                const canvas = (0, _bb.BB).canvas(70, 70);
                const ctx = (0, _bb.BB).ctx(canvas);
                if (id === 0 || id === 3) {
                    if (id === 0) {
                        ctx.beginPath();
                        ctx.arc(35, 35, 30, 0, 2 * Math.PI);
                        ctx.closePath();
                        ctx.fill();
                    } else ctx.fillRect(5, 5, 60, 60);
                } else if (id === 1) ctx.drawImage((0, _brushAlphas.genBrushAlpha01)(60), 5, 5);
                else if (id === 2) ctx.drawImage((0, _brushAlphas.genBrushAlpha02)(60), 5, 5);
                alpha.style.backgroundImage = 'url(' + canvas.toDataURL('image/png') + ')';
                return {
                    id: id,
                    label: alpha,
                    title: alphaNames[id]
                };
            }),
            initId: 0,
            onChange: (id)=>{
                brush.setAlpha(id);
            }
        });
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)('lock-alpha'),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)('lock-alpha-title'),
            css: {
                display: 'inline-block'
            },
            name: 'lock-alpha-toggle'
        });
        const spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            scatterSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('scatter'),
                width: 225,
                height: 30,
                min: brushInterface.scatterSlider.min,
                max: brushInterface.scatterSlider.max,
                value: brushInterface.scatterSlider.min,
                curve: brushInterface.scatterSlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                onChange: (val)=>{
                    brush.setScatter(val);
                    p.onScatterChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            const pressureScatterToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.scatterPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), (0, _bb.BB).el({
                content: [
                    scatterSlider.getElement(),
                    pressureScatterToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }), (0, _bb.BB).el({
                content: alphaOptions.getElement(),
                css: {
                    marginTop: '10px'
                }
            }), (0, _bb.BB).el({
                content: lockAlphaToggle.getElement(),
                css: {
                    marginTop: '10px'
                }
            }));
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.getScatter = function() {
            return brush.getScatter();
        };
        this.setScatter = function(scatter) {
            brush.setScatter(scatter);
            scatterSlider.setValue(scatter);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setLayer = function(layer) {
            brush.setContext(layer.context);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"3zOvT","../brushes/brushes":"11wyk","./brushes-consts":"7wwZp","../ui/components/checkbox":"9bXL6","../ui/components/kl-slider":"fQOKQ","../ui/components/create-pen-pressure-toggle":"drOTJ","url:/src/app/img/ui/brush-pen.svg":"4lfyT","../brushes/alphas/brush-alphas":"7vzMQ","../../language/language":"mcywn","../ui/components/options":"7kiPU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7wwZp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EVENT_RES_MS", ()=>EVENT_RES_MS);
const EVENT_RES_MS = 20;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4lfyT":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-pen.3d165b19.svg") + "?" + Date.now();

},{}],"1gIDV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendBrushUi", ()=>blendBrushUi);
var _bb = require("../../bb/bb");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/components/checkbox");
var _brushes = require("../brushes/brushes");
var _klSlider = require("../ui/components/kl-slider");
var _brushBlendSvg = require("url:/src/app/img/ui/brush-blend.svg");
var _brushBlendSvgDefault = parcelHelpers.interopDefault(_brushBlendSvg);
var _language = require("../../language/language");
const blendBrushUi = function() {
    const brushInterface = {
        image: (0, _brushBlendSvgDefault.default),
        tooltip: (0, _language.LANG)('brush-blend'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).powerSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.LANGUAGE_STRINGS).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)('brush-blend');
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement('div'); // the gui
        const brush = new (0, _brushes.BRUSHES).BlendBrush();
        brush.setHistory(p.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: 58,
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                }
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const blendingSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-blending'),
                width: 225,
                height: 30,
                min: 0,
                max: 1,
                value: brush.getBlending(),
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: function(val) {
                    brush.setBlending(val);
                }
            });
            blendingSlider.getElement().style.marginTop = '10px';
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.setSizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.setOpacityPressure(b);
            });
            const lockAlphaToggle = new (0, _checkbox.Checkbox)({
                init: brush.getLockAlpha(),
                label: (0, _language.LANG)('lock-alpha'),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: (0, _language.LANG)('lock-alpha-title'),
                css: {
                    marginTop: '10px',
                    display: 'inline-block'
                },
                name: 'lock-alpha'
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }), blendingSlider.getElement(), lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setLayer = function(layer) {
            brush.setContext(layer.context, layer.id);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y, p, false); // looks weird with isCoalesced
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"3zOvT","../ui/components/create-pen-pressure-toggle":"drOTJ","./brushes-consts":"7wwZp","../ui/components/checkbox":"9bXL6","../brushes/brushes":"11wyk","../ui/components/kl-slider":"fQOKQ","url:/src/app/img/ui/brush-blend.svg":"iV2a4","../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iV2a4":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-blend.4bf2ab02.svg") + "?" + Date.now();

},{}],"638lt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sketchyBrushUi", ()=>sketchyBrushUi);
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klSlider = require("../ui/components/kl-slider");
var _brushSketchyPng = require("url:/src/app/img/ui/brush-sketchy.png");
var _brushSketchyPngDefault = parcelHelpers.interopDefault(_brushSketchyPng);
var _language = require("../../language/language");
var _bb = require("../../bb/bb");
const sketchyBrushUi = function() {
    const brushInterface = {
        image: (0, _brushSketchyPngDefault.default),
        tooltip: (0, _language.LANG)('brush-sketchy'),
        sizeSlider: {
            min: 0.5,
            max: 10
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.LANGUAGE_STRINGS).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)('brush-sketchy');
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement('div'); // the gui
        const brush = new (0, _brushes.BRUSHES).SketchyBrush();
        brush.setHistory(p.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-size'),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize() * 2,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: function(val) {
                    brush.setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('opacity'),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const blendSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-blending'),
                width: 250,
                height: 30,
                min: 0,
                max: 1,
                value: brush.getBlending(),
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: function(val) {
                    brush.setBlending(val);
                }
            });
            const scaleSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-sketchy-scale'),
                width: 250,
                height: 30,
                min: 1,
                max: 20,
                value: brush.getScale(),
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                onChange: function(val) {
                    brush.setScale(val);
                }
            });
            opacitySlider.getElement().style.marginTop = '10px';
            blendSlider.getElement().style.marginTop = '10px';
            scaleSlider.getElement().style.marginTop = '10px';
            div.append(sizeSlider.getElement(), opacitySlider.getElement(), blendSlider.getElement(), scaleSlider.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setLayer = function(layer) {
            brush.setContext(layer.context);
        };
        this.startLine = function(x, y, pressure) {
            brush.startLine(x, y, pressure);
        };
        this.goLine = function(x, y, pressure) {
            brush.goLine(x, y, pressure, undefined);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getSeed = function() {
            return parseInt('' + brush.getSeed());
        };
        this.setSeed = function(s) {
            brush.setSeed(parseInt('' + s));
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../brushes/brushes":"11wyk","./brushes-consts":"7wwZp","../ui/components/kl-slider":"fQOKQ","url:/src/app/img/ui/brush-sketchy.png":"9An1U","../../language/language":"mcywn","../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9An1U":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-sketchy.c262a660.png") + "?" + Date.now();

},{}],"lMhDT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pixelBrushUi", ()=>pixelBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/components/checkbox");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushPixelSvg = require("url:/src/app/img/ui/brush-pixel.svg");
var _brushPixelSvgDefault = parcelHelpers.interopDefault(_brushPixelSvg);
var _language = require("../../language/language");
const pixelBrushUi = function() {
    const brushInterface = {
        image: (0, _brushPixelSvgDefault.default),
        tooltip: (0, _language.LANG)('brush-pixel'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).powerSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        }
    };
    (0, _language.LANGUAGE_STRINGS).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)('brush-pixel');
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement('div'); // the gui
        const brush = new (0, _brushes.BRUSHES).PixelBrush();
        brush.setHistory(p.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)('lock-alpha'),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)('lock-alpha-title'),
            name: 'lock-alpha-toggle'
        });
        const eraserToggle = new (0, _checkbox.Checkbox)({
            init: brush.getIsEraser(),
            label: (0, _language.LANG)('eraser'),
            callback: function(b) {
                brush.setIsEraser(b);
            },
            name: 'eraser-toggle'
        });
        const ditherToggle = new (0, _checkbox.Checkbox)({
            init: brush.getUseDither(),
            label: (0, _language.LANG)('brush-pixel-dither'),
            callback: function(b) {
                brush.setUseDither(b);
            },
            name: 'dither-toggle'
        });
        const spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0.5,
                0.45
            ],
            [
                100,
                4
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(spacingSpline.interpolate(size) / size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                }
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), opacitySlider.getElement());
            const toggleRow = (0, _bb.BB).el({
                parent: div,
                css: {
                    display: 'flex',
                    marginTop: '10px',
                    gap: '10px',
                    flexWrap: 'wrap'
                }
            });
            toggleRow.append(lockAlphaToggle.getElement(), eraserToggle.getElement(), ditherToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size * 2);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity * 100);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setLayer = function(layer) {
            brush.setContext(layer.context);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.toggleEraser = ()=>{
            eraserToggle.setValue(!eraserToggle.getValue());
            brush.setIsEraser(eraserToggle.getValue());
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"3zOvT","../brushes/brushes":"11wyk","./brushes-consts":"7wwZp","../ui/components/checkbox":"9bXL6","../ui/components/kl-slider":"fQOKQ","../ui/components/create-pen-pressure-toggle":"drOTJ","url:/src/app/img/ui/brush-pixel.svg":"hnEQg","../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hnEQg":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-pixel.2db493a1.svg") + "?" + Date.now();

},{}],"bmfNB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eraserBrushUi", ()=>eraserBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _checkbox = require("../ui/components/checkbox");
var _brushEraserSvg = require("url:/src/app/img/ui/brush-eraser.svg");
var _brushEraserSvgDefault = parcelHelpers.interopDefault(_brushEraserSvg);
var _language = require("../../language/language");
const eraserBrushUi = function() {
    const brushInterface = {
        image: (0, _brushEraserSvgDefault.default),
        tooltip: (0, _language.LANG)('eraser') + ' [E]',
        sizeSlider: {
            min: 0.5,
            max: 200,
            curve: (0, _bb.BB).powerSplineInput(0.5, 200, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.LANGUAGE_STRINGS).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)('eraser') + ' [E]';
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement('div'); // the gui
        const brush = new (0, _brushes.BRUSHES).EraserBrush();
        brush.setHistory(p.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let isTransparentBg = false;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: 30,
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }));
            const transparencyToggle = new (0, _checkbox.Checkbox)({
                init: false,
                label: (0, _language.LANG)('brush-eraser-transparent-bg'),
                callback: function(b) {
                    isTransparentBg = b;
                    brush.setTransparentBG(b);
                },
                css: {
                    marginTop: '10px'
                },
                name: 'transparency-toggle'
            });
            div.append(transparencyToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function() {};
        this.setLayer = function(layer) {
            brush.setLayer(layer);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.getIsTransparentBg = function() {
            return isTransparentBg;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"3zOvT","../brushes/brushes":"11wyk","./brushes-consts":"7wwZp","../ui/components/kl-slider":"fQOKQ","../ui/components/create-pen-pressure-toggle":"drOTJ","../ui/components/checkbox":"9bXL6","url:/src/app/img/ui/brush-eraser.svg":"5aXt2","../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5aXt2":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-eraser.f54a9f13.svg") + "?" + Date.now();

},{}],"6Lyeq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smudgeBrushUi", ()=>smudgeBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/components/checkbox");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushSmudgeSvg = require("url:/src/app/img/ui/brush-smudge.svg");
var _brushSmudgeSvgDefault = parcelHelpers.interopDefault(_brushSmudgeSvg);
var _language = require("../../language/language");
const smudgeBrushUi = function() {
    const brushInterface = {
        image: (0, _brushSmudgeSvgDefault.default),
        tooltip: (0, _language.LANG)('brush-smudge'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).powerSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        }
    };
    (0, _language.LANGUAGE_STRINGS).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)('brush-smudge');
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement('div'); // the gui
        const brush = new (0, _brushes.BRUSHES).SmudgeBrush();
        brush.setHistory(p.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)('lock-alpha'),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)('lock-alpha-title'),
            css: {
                display: 'inline-block'
            },
            name: 'lock-alpha-toggle'
        });
        const spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.sizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }));
            const bottomRow = (0, _bb.BB).el({
                parent: div,
                css: {
                    marginTop: '10px'
                }
            });
            bottomRow.append(lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setLayer = function(layer) {
            brush.setContext(layer.context);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"3zOvT","../brushes/brushes":"11wyk","./brushes-consts":"7wwZp","../ui/components/checkbox":"9bXL6","../ui/components/kl-slider":"fQOKQ","../ui/components/create-pen-pressure-toggle":"drOTJ","url:/src/app/img/ui/brush-smudge.svg":"enKu4","../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"enKu4":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-smudge.e7d43e2c.svg") + "?" + Date.now();

},{}],"7xweO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "chemyBrushUi", ()=>chemyBrushUi);
var _bb = require("../../bb/bb");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/components/checkbox");
var _brushes = require("../brushes/brushes");
var _klSlider = require("../ui/components/kl-slider");
var _brushChemySvg = require("url:/src/app/img/ui/brush-chemy.svg");
var _brushChemySvgDefault = parcelHelpers.interopDefault(_brushChemySvg);
var _options = require("../ui/components/options");
var _boxToggle = require("../ui/components/box-toggle");
var _language = require("../../language/language");
var _base = require("../../bb/base/base");
const chemyBrushUi = function() {
    const brushInterface = {
        image: (0, _brushChemySvgDefault.default),
        tooltip: (0, _language.LANG)('brush-chemy'),
        sizeSlider: {
            min: 0.25,
            max: 25,
            curve: (0, _bb.BB).powerSplineInput(0.25, 25, 0.1),
            isDisabled: true
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.LANGUAGE_STRINGS).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)('brush-chemy');
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement('div'); // the gui
        const brush = new (0, _brushes.BRUSHES).ChemyBrush();
        brush.setHistory(p.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        let eraserToggle;
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('brush-size'),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                isEnabled: brush.getMode() === 'stroke',
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 5) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('opacity'),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                eventResMs: (0, _brushesConsts.EVENT_RES_MS),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            (0, _base.css)(opacitySlider.getElement(), {
                marginTop: '10px'
            });
            eraserToggle = new (0, _checkbox.Checkbox)({
                init: brush.getIsEraser(),
                label: (0, _language.LANG)('eraser'),
                callback: function(b) {
                    brush.setIsEraser(b);
                },
                css: {
                    marginTop: '10px',
                    marginLeft: '10px'
                },
                name: 'eraser-toggle'
            });
            const lockAlphaToggle = new (0, _checkbox.Checkbox)({
                init: brush.getLockAlpha(),
                label: (0, _language.LANG)('lock-alpha'),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: (0, _language.LANG)('lock-alpha-title'),
                css: {
                    marginTop: '10px'
                },
                name: 'lock-alpha-toggle'
            });
            const toggleRow = (0, _bb.BB).el({
                css: {
                    display: 'flex',
                    marginTop: '10px'
                }
            });
            const iconSize = 35;
            const padding = 8;
            const actualIconSize = iconSize - padding * 2;
            const halfSize = actualIconSize / 2;
            const modeOptions = new (0, _options.Options)({
                optionArr: [
                    {
                        id: 'fill',
                        label: (0, _bb.BB).createSvg({
                            class: 'dark-invert',
                            elementType: 'svg',
                            width: iconSize + '',
                            height: iconSize + '',
                            childrenArr: [
                                {
                                    elementType: 'path',
                                    fill: '#000',
                                    css: {
                                        transformOrigin: '0 0',
                                        transform: `translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`
                                    },
                                    d: 'M 0,0 C 1.5,0 -0.5,1 1,1'
                                }
                            ]
                        }),
                        title: (0, _language.LANG)('brush-chemy-fill')
                    },
                    {
                        id: 'stroke',
                        label: (0, _bb.BB).createSvg({
                            class: 'dark-invert',
                            elementType: 'svg',
                            width: iconSize + '',
                            height: iconSize + '',
                            childrenArr: [
                                {
                                    elementType: 'path',
                                    fill: 'none',
                                    stroke: '#000',
                                    css: {
                                        strokeWidth: '0.12px',
                                        transformOrigin: '0 0',
                                        transform: `translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`
                                    },
                                    d: 'M 0,0 C 1.5,0 -0.5,1 1,1'
                                }
                            ]
                        }),
                        title: (0, _language.LANG)('brush-chemy-stroke')
                    }
                ],
                initId: brush.getMode(),
                onChange: (id)=>{
                    brush.setMode(id);
                    brushInterface.sizeSlider.isDisabled = brush.getMode() === 'fill';
                    sizeSlider.setIsEnabled(!brushInterface.sizeSlider.isDisabled);
                    const brushSize = brush.getSize();
                    sizeSlider.setValue(brushSize);
                    p.onSizeChange(brushSize);
                    p.onConfigChange();
                }
            });
            const mirrorXToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    class: 'dark-invert',
                    elementType: 'svg',
                    width: iconSize + '',
                    height: iconSize + '',
                    childrenArr: [
                        {
                            elementType: 'path',
                            fill: 'none',
                            stroke: '#000',
                            css: {
                                strokeWidth: '1px'
                            },
                            d: `M ${halfSize + padding},${padding} ${halfSize + padding},${actualIconSize + padding}`
                        }
                    ]
                }),
                title: (0, _language.LANG)('brush-chemy-mirror-x'),
                init: brush.getXSymmetry(),
                onChange: (b)=>{
                    brush.setXSymmetry(b);
                }
            });
            const mirrorYToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    class: 'dark-invert',
                    elementType: 'svg',
                    width: iconSize + '',
                    height: iconSize + '',
                    childrenArr: [
                        {
                            elementType: 'path',
                            fill: 'none',
                            stroke: '#000',
                            css: {
                                strokeWidth: '1px'
                            },
                            d: `M ${padding},${halfSize + padding} ${actualIconSize + padding},${halfSize + padding}`
                        }
                    ]
                }),
                title: (0, _language.LANG)('brush-chemy-mirror-y'),
                init: brush.getYSymmetry(),
                onChange: (b)=>{
                    brush.setYSymmetry(b);
                }
            });
            const gradientToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    class: 'dark-invert',
                    elementType: 'svg',
                    width: iconSize + '',
                    height: iconSize + '',
                    childrenArr: [
                        {
                            elementType: 'defs',
                            childrenArr: [
                                {
                                    elementType: 'linearGradient',
                                    id: 'gradient',
                                    x1: '0',
                                    y1: '0',
                                    x2: '0',
                                    y2: '1',
                                    childrenArr: [
                                        {
                                            elementType: 'stop',
                                            offset: '0%',
                                            'stop-color': 'rgba(0,0,0,0)'
                                        },
                                        {
                                            elementType: 'stop',
                                            offset: '100%',
                                            'stop-color': 'rgba(0,0,0,1)'
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            elementType: 'rect',
                            fill: "url('#gradient')",
                            x: '' + padding,
                            y: '' + padding,
                            width: '' + actualIconSize,
                            height: '' + actualIconSize
                        }
                    ]
                }),
                title: (0, _language.LANG)('brush-chemy-gradient'),
                init: brush.getGradient(),
                onChange: (b)=>{
                    brush.setGradient(b);
                }
            });
            (0, _base.css)(mirrorXToggle.getElement(), {
                marginLeft: '10px'
            });
            {
                const margin = {
                    marginLeft: '4px'
                };
                (0, _base.css)(mirrorYToggle.getElement(), margin);
                (0, _base.css)(gradientToggle.getElement(), margin);
            }
            toggleRow.append(modeOptions.getElement(), mirrorXToggle.getElement(), mirrorYToggle.getElement(), gradientToggle.getElement());
            div.append(sizeSlider.getElement(), opacitySlider.getElement(), toggleRow, (0, _bb.BB).el({
                content: [
                    lockAlphaToggle.getElement(),
                    eraserToggle.getElement()
                ],
                css: {
                    display: 'flex'
                }
            }));
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === 'stroke') sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === 'stroke') sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setLayer = function(layer) {
            brush.setContext(layer.context);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.toggleEraser = ()=>{
            eraserToggle.setValue(!eraserToggle.getValue());
            brush.setIsEraser(eraserToggle.getValue());
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"3zOvT","./brushes-consts":"7wwZp","../ui/components/checkbox":"9bXL6","../brushes/brushes":"11wyk","../ui/components/kl-slider":"fQOKQ","url:/src/app/img/ui/brush-chemy.svg":"eNbn8","../ui/components/options":"7kiPU","../ui/components/box-toggle":"1YB1o","../../language/language":"mcywn","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eNbn8":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("brush-chemy.cc5e3952.svg") + "?" + Date.now();

},{}],"e3aiU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showIframeModal", ()=>showIframeModal);
var _bb = require("../../../bb/bb");
var _dynamicModal = require("./base/dynamic-modal");
var _language = require("../../../language/language");
function showIframeModal(url, isEmbed) {
    // window very small, modal might look bad
    if (!isEmbed && (window.innerHeight < 500 || window.innerWidth < 700)) {
        window.open(url);
        return;
    }
    const iframe = (0, _bb.BB).el({
        tagName: 'iframe',
        custom: {
            src: url
        },
        css: {
            width: '100%',
            height: '100%',
            opacity: '0'
        }
    });
    setTimeout(()=>{
        iframe.style.opacity = ''; // fallback
    }, 500);
    const titleEl = (0, _bb.BB).el();
    let linkEl;
    if (!isEmbed) {
        linkEl = (0, _bb.BB).el({
            tagName: 'a',
            parent: titleEl,
            content: (0, _language.LANG)('modal-new-tab'),
            custom: {
                href: 'help',
                target: '_blank'
            },
            onClick: function() {
                popup.close();
            }
        });
        iframe.onload = ()=>{
            if (linkEl && iframe.contentWindow) try {
                (0, _bb.BB).setAttributes(linkEl, {
                    href: '' + iframe.contentWindow.location
                });
            } catch (e) {
            // might not have access
            }
            iframe.style.opacity = '';
        };
    }
    const popup = new (0, _dynamicModal.DynamicModal)({
        title: titleEl,
        content: iframe,
        width: 880,
        isMaxHeight: true,
        onClose: ()=>{
            if (linkEl) {
                iframe.src = 'about:blank';
                (0, _bb.BB).destroyEl(linkEl);
                linkEl = undefined;
            }
        }
    });
}

},{"../../../bb/bb":"3zOvT","./base/dynamic-modal":"3DApo","../../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1MvSQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RadioList", ()=>RadioList);
var _bb = require("../../../bb/bb");
class RadioList {
    constructor({ name, init, items, ignoreFocus }){
        this.inputs = [];
        this.el = (0, _bb.BB).el({
            className: 'kl-radio'
        });
        items.forEach((item)=>{
            const label = (0, _bb.BB).el({
                tagName: 'label'
            });
            const input = (0, _bb.BB).el({
                tagName: 'input',
                parent: label,
                custom: {
                    name: name,
                    value: item.value,
                    type: 'radio'
                }
            });
            if (ignoreFocus) input.setAttribute('data-ignore-focus', 'true');
            if (init === item.value) input.checked = true;
            label.append(item.label);
            this.el.append(label);
            this.inputs.push(input);
        });
    }
    getValue() {
        for(let i = 0; i < this.inputs.length; i++){
            if (this.inputs[i].checked) return this.inputs[i].value;
        }
        return null;
    }
    getElement() {
        return this.el;
    }
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jEHd9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrowserStorageUi", ()=>BrowserStorageUi);
var _bb = require("../../../bb/bb");
var _removeLayerSvg = require("url:/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _kl = require("../../kl");
var _language = require("../../../language/language");
var _showModal = require("../modals/base/showModal");
var _timestampToAge = require("../utils/timestamp-to-age");
var _browserStorageHeaderUi = require("./browser-storage-header-ui");
var _browserStorageUiModuleScss = require("./browser-storage-ui.module.scss");
var _ui = require("../../../bb/base/ui");
var _requestPersistentStorage = require("../../storage/request-persistent-storage");
var _canvas = require("../../../bb/base/canvas");
class BrowserStorageUi {
    updateAge() {
        if (!this.timestamp) return;
        this.ageEl.textContent = (0, _timestampToAge.timestampToAge)(this.timestamp);
    }
    resetButtons() {
        this.previewEl.classList.remove('kl-storage-preview--disabled');
        if (this.timestamp) {
            if (this.openButtonEl) this.openButtonEl.disabled = false;
            this.storeButtonEl.textContent = (0, _language.LANG)('file-storage-overwrite');
            this.storeButtonEl.disabled = false;
            this.clearButtonEl.disabled = false;
        } else {
            if (this.openButtonEl) this.openButtonEl.disabled = true;
            this.storeButtonEl.textContent = (0, _language.LANG)('file-storage-store');
            this.storeButtonEl.disabled = false;
            this.clearButtonEl.disabled = true;
        }
    }
    updateThumb(timestamp, thumbnail) {
        this.timestamp = timestamp;
        this.thumbnail?.remove();
        this.thumbnail = thumbnail ? (0, _canvas.copyCanvas)(thumbnail) : undefined;
        const thumbnailCanvas = this.thumbnail; // typescript being weird
        if (thumbnailCanvas && timestamp) {
            thumbnailCanvas.classList.add('kl-storage-preview__im');
            this.ageEl.remove();
            this.emptyEl.remove();
            this.updateAge();
            this.previewEl.append(thumbnailCanvas, this.ageEl);
            this.previewEl.style.pointerEvents = this.onOpen ? '' : 'none';
            if (typeof performance !== 'undefined' && timestamp > performance.timeOrigin) {
                const animEl = (0, _bb.BB).el({
                    parent: this.previewEl,
                    className: _browserStorageUiModuleScss.animEl
                });
                setTimeout(()=>{
                    animEl.remove();
                }, 500);
            }
        } else {
            this.ageEl.remove();
            this.previewEl.append(this.emptyEl);
            this.previewEl.style.pointerEvents = 'none'; // prevent title
        }
        this.resetButtons();
    }
    async store() {
        const meta = this.projectStore.getCurrentMeta();
        const project = this.getProject();
        if (meta && meta.projectId !== project.projectId) {
            const doOverwrite = await new Promise((resolve, reject)=>{
                (0, _showModal.showModal)({
                    target: document.body,
                    type: 'warning',
                    message: (0, _language.LANG)('file-storage-overwrite-confirm'),
                    buttons: [
                        (0, _language.LANG)('file-storage-overwrite'),
                        'Cancel'
                    ],
                    callback: async (result)=>{
                        if (result === 'Cancel') {
                            resolve(false);
                            return;
                        }
                        resolve(true);
                    }
                });
            });
            if (!doOverwrite) return;
        }
        this.applyUncommitted();
        await (0, _requestPersistentStorage.requestPersistentStorage)();
        if (this.openButtonEl) this.openButtonEl.disabled = true;
        this.storeButtonEl.textContent = (0, _language.LANG)('file-storage-storing');
        this.storeButtonEl.disabled = true;
        this.clearButtonEl.disabled = true;
        this.previewEl.classList.add('kl-storage-preview--disabled');
        await new Promise((resolve)=>{
            setTimeout(()=>resolve(null), 20);
        });
        try {
            await this.projectStore.store(project);
            this.onStored();
        } catch (e) {
            this.resetButtons();
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: 'error',
                message: [
                    `${(0, _language.LANG)('file-storage-failed-1')}<ul>`,
                    `<li>${(0, _language.LANG)('file-storage-failed-2')}</li>`,
                    `<li>${(0, _language.LANG)('file-storage-failed-3')}</li>`,
                    `<li>${(0, _language.LANG)('file-storage-failed-4')}</li>`,
                    '</ul>'
                ].join(''),
                buttons: [
                    'Ok'
                ]
            });
            setTimeout(()=>{
                throw new Error('storage-ui: failed to store browser storage, ' + e);
            }, 0);
        }
    }
    async clear() {
        (0, _showModal.showModal)({
            target: document.body,
            type: 'warning',
            message: (0, _language.LANG)('file-storage-clear-prompt'),
            buttons: [
                (0, _language.LANG)('file-storage-clear'),
                'Cancel'
            ],
            deleteButtonName: (0, _language.LANG)('file-storage-clear'),
            callback: async (result)=>{
                if (result === 'Cancel') return;
                if (this.openButtonEl) this.openButtonEl.disabled = true;
                this.storeButtonEl.disabled = true;
                this.clearButtonEl.disabled = true;
                try {
                    await this.projectStore.clear();
                } catch (e) {
                    this.resetButtons();
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        type: 'error',
                        message: (0, _language.LANG)('file-storage-failed-clear'),
                        buttons: [
                            'Ok'
                        ]
                    });
                    setTimeout(()=>{
                        throw new Error('storage-ui: failed to clear browser storage, ' + e);
                    }, 0);
                }
            }
        });
    }
    showError() {
        this.contentEl.innerHTML = '';
        (0, _bb.BB).el({
            parent: this.contentEl,
            content: "\uD83D\uDD34 " + (0, _language.LANG)('file-storage-cant-access'),
            css: {
                marginTop: '10px'
            }
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.previewEl = {};
        this.ageEl = {};
        this.emptyEl = {};
        this.storeButtonEl = {};
        this.clearButtonEl = {};
        this.storeListener = {};
        this.isFirst = true;
        this.updateAgeInterval = setInterval(()=>this.updateAge(), 60000);
        this.projectStore = p.projectStore;
        this.getProject = p.getProject;
        this.onStored = p.onStored;
        this.klRootEl = p.klRootEl;
        this.applyUncommitted = p.applyUncommitted;
        this.options = p.options;
        this.onOpen = p.onOpen;
        this.rootEl = (0, _bb.BB).el({});
        this.header = new (0, _browserStorageHeaderUi.BrowserStorageHeaderUi)();
        this.rootEl.append(this.header.getElement());
        this.contentEl = (0, _bb.BB).el({
            parent: this.rootEl
        });
        if (!this.projectStore.getIsAvailable()) {
            this.showError();
            return;
        }
        this.previewEl = (0, _bb.BB).el({
            className: 'kl-storage-preview',
            onClick: ()=>this.onOpen?.(),
            title: (0, _language.LANG)('file-storage-open'),
            noRef: true
        });
        this.emptyEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('file-storage-empty')
        });
        this.ageEl = (0, _bb.BB).el({
            css: {
                position: 'absolute',
                right: '0',
                bottom: '0',
                width: '100%',
                textAlign: 'center',
                background: 'rgba(0,0,0,0.7)',
                color: '#fff',
                fontSize: '13px'
            }
        });
        if (this.onOpen) this.openButtonEl = (0, _bb.BB).el({
            tagName: 'button',
            className: 'grid-button',
            content: (0, _language.LANG)('file-storage-open'),
            css: {
                margin: '0'
            },
            onClick: ()=>this.onOpen?.(),
            noRef: true
        });
        this.storeButtonEl = (0, _bb.BB).el({
            tagName: 'button',
            className: 'grid-button',
            content: (0, _language.LANG)('file-storage-store'),
            css: {
                margin: '0'
            },
            onClick: ()=>this.store(),
            noRef: true
        });
        this.clearButtonEl = (0, _bb.BB).el({
            tagName: 'button',
            className: 'grid-button kl-button-delete',
            content: '<img src="' + (0, _removeLayerSvgDefault.default) + '" height="20"/> ' + (0, _language.LANG)('file-storage-clear'),
            css: {
                margin: '0'
            },
            onClick: ()=>this.clear(),
            noRef: true
        });
        if (!this.options?.isFocusable) {
            this.openButtonEl && (0, _ui.makeUnfocusable)(this.openButtonEl);
            (0, _ui.makeUnfocusable)(this.storeButtonEl);
            (0, _ui.makeUnfocusable)(this.clearButtonEl);
        }
        if (this.options?.hideClearButton) this.clearButtonEl.style.visibility = 'hidden';
        this.contentEl.append((0, _bb.BB).el({
            content: [
                (0, _bb.BB).el({
                    content: this.previewEl,
                    css: {
                        alignSelf: 'stretch',
                        flexGrow: '1'
                    }
                }),
                (0, _bb.BB).el({
                    content: [
                        this.openButtonEl,
                        this.storeButtonEl,
                        this.clearButtonEl
                    ],
                    css: {
                        display: 'flex',
                        gap: '10px',
                        flexDirection: 'column'
                    }
                })
            ],
            css: {
                marginTop: '10px',
                display: 'flex',
                gap: '10px'
            }
        }));
        this.storeListener = {
            onUpdate: (project)=>{
                this.updateThumb(project?.timestamp, project?.thumbnail);
            }
        };
        this.projectStore.subscribe(this.storeListener);
        this.updateThumb();
    }
    getElement() {
        return this.rootEl;
    }
    show() {
        if (this.isFirst) {
            this.isFirst = false;
            if (!this.projectStore.getIsAvailable()) this.showError();
            else (async ()=>{
                try {
                    await this.projectStore.update();
                    const meta = this.projectStore.getCurrentMeta();
                    if (meta) this.updateThumb(meta.timestamp, meta.thumbnail);
                    else this.updateThumb();
                } catch (e) {
                    this.showError();
                    throw new Error('browser-storage-ui: failed initial read browser storage, ' + e);
                }
            })();
        }
    }
    hide() {
    // ...
    }
    destroy() {
        this.header.destroy();
        (0, _bb.BB).destroyEl(this.storeButtonEl);
        (0, _bb.BB).destroyEl(this.clearButtonEl);
        clearInterval(this.updateAgeInterval);
        this.projectStore.unsubscribe(this.storeListener);
    }
}

},{"../../../bb/bb":"3zOvT","url:/src/app/img/ui/remove-layer.svg":"fV9n3","../../kl":"lHQKw","../../../language/language":"mcywn","../modals/base/showModal":"gy3iL","../utils/timestamp-to-age":"7KGHi","./browser-storage-header-ui":"a0QD5","./browser-storage-ui.module.scss":"6zZ4f","../../../bb/base/ui":"5dJJW","../../storage/request-persistent-storage":"gBKae","../../../bb/base/canvas":"86XNv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7KGHi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timestampToAge", ()=>timestampToAge);
var _language = require("../../../language/language");
function timestampToAge(timestamp) {
    let age = new Date().getTime() - timestamp;
    let ageStr;
    age = Math.floor(age / 1000 / 60);
    ageStr = (0, _language.LANG)('file-storage-min-ago').replace('{x}', '' + age);
    if (age > 60) {
        age = Math.floor(age / 60);
        ageStr = (0, _language.LANG)('file-storage-hours-ago').replace('{x}', '' + age);
        if (age > 24) {
            age = Math.floor(age / 24);
            ageStr = (0, _language.LANG)('file-storage-days-ago').replace('{x}', '' + age);
            if (age > 31) ageStr = (0, _language.LANG)('file-storage-month-ago');
        }
    }
    return ageStr;
}

},{"../../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a0QD5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrowserStorageHeaderUi", ()=>BrowserStorageHeaderUi);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _showIframeModal = require("../modals/show-iframe-modal");
class BrowserStorageHeaderUi {
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.infoButton = (0, _bb.BB).el({
            content: '?',
            className: 'kl-info-btn',
            title: (0, _language.LANG)('file-storage-about'),
            onClick: ()=>{
                (0, _showIframeModal.showIframeModal)('./help/#help-browser-storage', false);
            }
        });
        this.rootEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('file-storage'),
            css: {
                display: 'flex',
                margin: '-5px 0',
                gap: '6px'
            }
        });
        this.rootEl.append(this.infoButton);
    }
    getElement() {
        return this.rootEl;
    }
    show() {}
    destroy() {
        (0, _bb.BB).destroyEl(this.infoButton);
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","../modals/show-iframe-modal":"e3aiU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6zZ4f":[function(require,module,exports,__globalThis) {
module.exports["anim"] = `a9LdEW_anim`;
module.exports["anim"];
module.exports["animEl"] = `a9LdEW_animEl`;

},{}],"gBKae":[function(require,module,exports,__globalThis) {
/**
 * https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/persist
 * Might reduce deletions of indexedDB data by browser.
 *
 * "The best time to request your storage be marked as persistent is when you save critical user
 * data, and the request should ideally be **wrapped in a user gesture**."
 * from https://web.dev/articles/persistent-storage
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "requestPersistentStorage", ()=>requestPersistentStorage);
async function requestPersistentStorage() {
    if ('storage' in navigator && 'persist' in navigator.storage) await navigator.storage.persist();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Zcnn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTImageDataReference", ()=>isTImageDataReference);
/**
 * simplified interface for storing projects into browser storage
 */ parcelHelpers.export(exports, "ProjectStore", ()=>ProjectStore);
var _projectConverter = require("./project-converter");
var _localStorage = require("../../bb/base/local-storage");
var _klIndexedDb = require("./kl-indexed-db");
var _base = require("../../bb/base/base");
var _bb = require("../../bb/bb");
var _canvas = require("../../bb/base/canvas");
function isTImageDataReference(input) {
    return typeof input === 'object' && input !== null && 'id' in input && typeof input.id === 'string';
}
async function createFallbackThumbnail() {
    // very basic fallback. only affects data stored before version 0.5.1 (2022)
    return await (0, _canvas.canvasToBlob)((0, _bb.BB).canvas((0, _projectConverter.PROJECT_STORE_THUMBNAIL_SIZE_PX), (0, _projectConverter.PROJECT_STORE_THUMBNAIL_SIZE_PX)), 'image/png');
}
class ProjectStore {
    async lowLevelStore(project) {
        // get image data ids
        const rawOld = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.BROWSER_STORAGE_STORE), 1);
        const deleteIds = [];
        if (rawOld) {
            if (isTImageDataReference(rawOld.thumbnail)) deleteIds.push(rawOld.thumbnail.id);
            for (const layer of rawOld.layers)if (isTImageDataReference(layer.blob)) deleteIds.push(layer.blob.id);
        }
        // prepare for storing
        const imageDataList = [];
        const thumbnail = {
            id: (0, _base.randomUuid)()
        };
        imageDataList.push({
            id: thumbnail.id,
            data: project.thumbnail
        });
        const layers = [];
        for (const layer of project.layers){
            const blob = {
                id: (0, _base.randomUuid)()
            };
            imageDataList.push({
                id: blob.id,
                data: layer.blob
            });
            layers.push({
                ...layer,
                blob
            });
        }
        const raw = {
            ...project,
            thumbnail,
            layers
        };
        // store first. so nothing will be lost if something goes wrong
        for (const imageData of imageDataList)await (0, _klIndexedDb.KL_INDEXED_DB).set((0, _klIndexedDb.IMAGE_DATA_STORE), imageData.id, imageData.data);
        await (0, _klIndexedDb.KL_INDEXED_DB).set((0, _klIndexedDb.BROWSER_STORAGE_STORE), undefined, raw);
        // remove obsolete imageData
        for (const id of deleteIds)await (0, _klIndexedDb.KL_INDEXED_DB).remove((0, _klIndexedDb.IMAGE_DATA_STORE), id);
    }
    async lowLevelReadMeta() {
        const raw = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.BROWSER_STORAGE_STORE), 1);
        if (!raw) return undefined;
        let thumbnail;
        if (isTImageDataReference(raw.thumbnail)) {
            const thumbnailReadResult = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.IMAGE_DATA_STORE), raw.thumbnail.id);
            if ((0, _base.isBlob)(thumbnailReadResult)) thumbnail = thumbnailReadResult;
        } else thumbnail = raw.thumbnail;
        thumbnail = thumbnail ?? await createFallbackThumbnail();
        return {
            projectId: raw.projectId ?? (0, _base.randomUuid)(),
            timestamp: raw.timestamp,
            thumbnail
        };
    }
    async lowLevelRead() {
        const raw = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.BROWSER_STORAGE_STORE), 1);
        if (!raw) return undefined;
        let thumbnail;
        if (isTImageDataReference(raw.thumbnail)) {
            const thumbnailReadResult = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.IMAGE_DATA_STORE), raw.thumbnail.id);
            if ((0, _base.isBlob)(thumbnailReadResult)) thumbnail = thumbnailReadResult;
        } else thumbnail = raw.thumbnail;
        thumbnail = thumbnail ?? await createFallbackThumbnail();
        const layers = [];
        for (const layer of raw.layers){
            let blob;
            if (isTImageDataReference(layer.blob)) {
                const readResult = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.IMAGE_DATA_STORE), layer.blob.id);
                if ((0, _base.isBlob)(readResult)) blob = readResult;
            } else blob = layer.blob;
            layers.push({
                ...layer,
                isVisible: layer.isVisible ?? true,
                mixModeStr: layer.mixModeStr ?? 'source-over',
                blob
            });
        }
        return {
            ...raw,
            projectId: raw.projectId ?? (0, _base.randomUuid)(),
            thumbnail,
            layers
        };
    }
    async lowLevelClear() {
        // get image data ids
        const rawOld = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.BROWSER_STORAGE_STORE), 1);
        const deleteIds = [];
        if (rawOld) {
            if (isTImageDataReference(rawOld.thumbnail)) deleteIds.push(rawOld.thumbnail.id);
            for (const layer of rawOld.layers)if (isTImageDataReference(layer.blob)) deleteIds.push(layer.blob.id);
        }
        await (0, _klIndexedDb.KL_INDEXED_DB).remove((0, _klIndexedDb.BROWSER_STORAGE_STORE), 1);
        for (const id of deleteIds)await (0, _klIndexedDb.KL_INDEXED_DB).remove((0, _klIndexedDb.IMAGE_DATA_STORE), id);
    }
    emit(meta) {
        this.currentMeta = meta ? {
            ...meta
        } : undefined;
        this.listeners.forEach((item)=>{
            item.onUpdate(meta);
        });
    }
    updateTimestamp() {
        (0, _localStorage.LocalStorage).setItem('indexedDbUpdatedAt', '' + new Date().getTime());
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.listeners = [];
        this.isAvailable = true;
        if (!(0, _klIndexedDb.KL_INDEXED_DB).getIsAvailable()) {
            this.isAvailable = false;
            return;
        }
        window.addEventListener('storage', async (e)=>{
            if (e.key !== 'indexedDbUpdatedAt' || this.listeners.length === 0) return;
            await this.update();
        });
    }
    async update() {
        try {
            this.emit(await this.readMeta());
        } catch (e) {
            if (e instanceof Error && e.message.indexOf('db-error') === 0) this.isAvailable = false;
        }
    }
    async read() {
        let storageProject;
        try {
            storageProject = await this.lowLevelRead();
        } catch (e) {
            this.isAvailable = false;
            throw new Error('db-error: ' + e);
        }
        if (!storageProject) return undefined;
        let result;
        try {
            result = await (0, _projectConverter.ProjectConverter).readStorageProject(storageProject);
        } catch (e) {
            throw new Error('format-error: ' + e);
        }
        return result;
    }
    async readMeta() {
        let blobMeta;
        try {
            blobMeta = await this.lowLevelReadMeta();
        } catch (e) {
            this.isAvailable = false;
            throw new Error('db-error: ' + e);
        }
        if (!blobMeta) return undefined;
        let result;
        try {
            result = await (0, _projectConverter.ProjectConverter).readStorageMeta(blobMeta);
        } catch (e) {
            throw new Error('format-error: ' + e);
        }
        return result;
    }
    async store(project) {
        try {
            const storageProject = await (0, _projectConverter.ProjectConverter).createStorageProject(project);
            await this.lowLevelStore(storageProject);
        } catch (e) {
            this.isAvailable = false;
            throw new Error('db-error: ' + e);
        }
        this.updateTimestamp();
        setTimeout(async ()=>{
            const meta = await this.readMeta();
            this.emit(meta);
        });
    }
    async clear() {
        await this.lowLevelClear();
        this.updateTimestamp();
        setTimeout(()=>this.emit(), 0);
    }
    subscribe(listener) {
        if (this.listeners.includes(listener)) return;
        this.listeners.push(listener);
    }
    unsubscribe(listener) {
        for(let i = 0; i < this.listeners.length; i++)if (listener === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
    getIsAvailable() {
        this.isAvailable = this.isAvailable && (0, _klIndexedDb.KL_INDEXED_DB).getIsAvailable();
        return this.isAvailable;
    }
    getCurrentMeta() {
        return this.currentMeta;
    }
}

},{"./project-converter":"8SgmT","../../bb/base/local-storage":"itqB1","./kl-indexed-db":"iz3yu","../../bb/base/base":"it3mQ","../../bb/bb":"3zOvT","../../bb/base/canvas":"86XNv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8SgmT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PROJECT_STORE_THUMBNAIL_SIZE_PX", ()=>PROJECT_STORE_THUMBNAIL_SIZE_PX);
parcelHelpers.export(exports, "loadImage", ()=>loadImage);
/**
 * for:
 * - preparing project to be stored in ProjectStore
 * - reading a project that came out of the ProjectStore
 */ parcelHelpers.export(exports, "ProjectConverter", ()=>ProjectConverter);
var _bb = require("../../bb/bb");
var _drawProject = require("../canvas/draw-project");
var _canvas = require("../../bb/base/canvas");
const PROJECT_STORE_THUMBNAIL_SIZE_PX = 240;
function loadImage(blob) {
    return new Promise((resolve, reject)=>{
        const im = new Image();
        try {
            im.src = (0, _bb.BB).imageBlobToUrl(blob);
        } catch (e) {
            reject('imageBlobToUrl, ' + (e instanceof Error ? e.message : ''));
            return;
        }
        im.onload = ()=>{
            URL.revokeObjectURL(im.src);
            resolve(im);
        };
        im.onabort = ()=>{
            URL.revokeObjectURL(im.src);
            reject('layer image failed loading (abort)');
        };
        // This does occur. Maybe decoder runs of memory or storage corruption.
        im.onerror = ()=>{
            URL.revokeObjectURL(im.src);
            reject('layer image failed loading (error)');
        };
    });
}
class ProjectConverter {
    static createThumbnail(project) {
        const size = (0, _bb.BB).fitInto(project.width, project.height, PROJECT_STORE_THUMBNAIL_SIZE_PX, PROJECT_STORE_THUMBNAIL_SIZE_PX);
        const factor = size.width / project.width;
        return (0, _drawProject.drawProject)(project, factor);
    }
    static async createStorageProject(project) {
        const layers = [];
        for (const item of project.layers){
            let blob;
            if (item.image instanceof HTMLCanvasElement) blob = await (0, _canvas.canvasToBlob)(item.image, 'image/png');
            else // todo image
            throw new Error('Not implemented');
            layers.push({
                name: item.name,
                isVisible: item.isVisible,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr ?? 'source-over',
                blob
            });
        }
        return {
            id: 1,
            projectId: project.projectId,
            timestamp: new Date().getTime(),
            thumbnail: await (0, _canvas.canvasToBlob)(ProjectConverter.createThumbnail(project), 'image/png'),
            width: project.width,
            height: project.height,
            layers
        };
    }
    static async readStorageProject(storageProject) {
        if (!storageProject.width || !storageProject.height || isNaN(storageProject.width) || isNaN(storageProject.height) || storageProject.width < 1 || storageProject.height < 1) throw new Error('readStorageProject invalid canvas size: ' + storageProject.width + ', ' + storageProject.height);
        const project = {
            projectId: storageProject.projectId,
            width: storageProject.width,
            height: storageProject.height,
            layers: (await Promise.all(storageProject.layers.map((layer)=>{
                if (layer.blob) return loadImage(layer.blob).catch(()=>new Image(storageProject.width, storageProject.height));
                return new Image(storageProject.width, storageProject.height);
            }))).map((image, i)=>{
                const storageLayer = storageProject.layers[i];
                return {
                    name: storageLayer.name,
                    isVisible: storageLayer.isVisible,
                    opacity: storageLayer.opacity,
                    mixModeStr: storageLayer.mixModeStr,
                    image
                };
            })
        };
        return {
            project: project,
            timestamp: storageProject.timestamp,
            thumbnail: await loadImage(storageProject.thumbnail).catch(()=>new Image(PROJECT_STORE_THUMBNAIL_SIZE_PX, PROJECT_STORE_THUMBNAIL_SIZE_PX))
        };
    }
    static async readStorageMeta(rawMeta) {
        return {
            projectId: rawMeta.projectId,
            timestamp: rawMeta.timestamp,
            thumbnail: rawMeta.thumbnail ? await loadImage(rawMeta.thumbnail).catch(()=>new Image(PROJECT_STORE_THUMBNAIL_SIZE_PX, PROJECT_STORE_THUMBNAIL_SIZE_PX)) : (0, _bb.BB).canvas(10, 10)
        };
    }
}

},{"../../bb/bb":"3zOvT","../canvas/draw-project":"8dpes","../../bb/base/canvas":"86XNv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iz3yu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setKlIndexedDbName", ()=>setKlIndexedDbName);
parcelHelpers.export(exports, "getKlIndexedDbName", ()=>getKlIndexedDbName);
parcelHelpers.export(exports, "RECOVERY_STORE", ()=>RECOVERY_STORE);
parcelHelpers.export(exports, "IMAGE_DATA_STORE", ()=>IMAGE_DATA_STORE);
parcelHelpers.export(exports, "BROWSER_STORAGE_STORE", ()=>BROWSER_STORAGE_STORE);
parcelHelpers.export(exports, "KL_INDEXED_DB_STORES", ()=>KL_INDEXED_DB_STORES);
parcelHelpers.export(exports, "KL_INDEXED_DB_VERSION", ()=>KL_INDEXED_DB_VERSION);
parcelHelpers.export(exports, "KL_INDEXED_DB_UPGRADER", ()=>KL_INDEXED_DB_UPGRADER);
parcelHelpers.export(exports, "KL_INDEXED_DB", ()=>KL_INDEXED_DB);
var _indexedDb = require("../../bb/base/indexed-db");
let dbName = 'Klecks';
function setKlIndexedDbName(name) {
    dbName = name;
}
function getKlIndexedDbName() {
    return dbName;
}
const RECOVERY_STORE = 'RecoveryStore'; // key is string
const IMAGE_DATA_STORE = 'ImageDataStore'; // key is string
const BROWSER_STORAGE_STORE = 'ProjectStore'; // key is number
const KL_INDEXED_DB_STORES = [
    RECOVERY_STORE,
    IMAGE_DATA_STORE,
    BROWSER_STORAGE_STORE
];
const KL_INDEXED_DB_VERSION = 2;
const KL_INDEXED_DB_UPGRADER = (event)=>{
    const oldVersion = event.oldVersion;
    const db = event.target.result;
    if (oldVersion < 1) {
        const store = db.createObjectStore(BROWSER_STORAGE_STORE, {
            keyPath: 'id'
        });
        store.createIndex('id', 'id', {
            unique: true
        });
    }
    if (oldVersion < 2) {
        db.createObjectStore(IMAGE_DATA_STORE);
        db.createObjectStore(RECOVERY_STORE);
    }
};
const KL_INDEXED_DB = new (0, _indexedDb.IndexedDb)({});

},{"../../bb/base/indexed-db":"21x0D","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"21x0D":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IndexedDb", ()=>IndexedDb);
var _base = require("./base");
// 2025-05-20
// Blobs not supported on iPad in private tabs.
// Blobs are required for indexed db to be useful. Data urls would be wasteful.
const areBlobUrlsSupported = async function() {
    let result = true;
    const dbName = 'kl-blob-url-test';
    try {
        const blob = new Blob([
            'test'
        ], {
            type: 'text/plain'
        });
        const db = await (0, _base.timeoutWrapper)(new Promise((resolve, reject)=>{
            const request = indexedDB.open(dbName, 1);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve(request.result);
            request.onupgradeneeded = (event)=>{
                const db = event.target.result;
                db.createObjectStore('testStore');
            };
        }), 'areBlobUrlsSupported.createDb');
        await (0, _base.timeoutWrapper)(new Promise((resolve, reject)=>{
            const transaction = db.transaction('testStore', 'readwrite');
            const store = transaction.objectStore('testStore');
            const request = store.put(blob, 'testStore');
            transaction.onabort = ()=>resolve();
            request.onsuccess = ()=>resolve();
            request.onerror = ()=>reject(request.error);
        }), 'areBlobUrlsSupported.storeBlob');
        db.close();
    } catch (e) {
        result = false;
    }
    try {
        indexedDB.deleteDatabase(dbName);
    } catch (e) {
    // IDBFactory.deleteDatabase() called in an invalid security context
    }
    return result;
};
class IndexedDb {
    disconnect() {
        this.db?.close();
        this.db = undefined;
    }
    async autoDisconnectWrapper(activity) {
        try {
            this.openTransactionCount++;
            clearTimeout(this.disconnectTimeout);
            return await activity();
        } finally{
            this.openTransactionCount--;
            if (this.openTransactionCount === 0) {
                // When a new version of the app upgrades the DB, old tabs holding open connections would
                // block the upgrade.
                // -> Close DB connections when inactive.
                clearTimeout(this.disconnectTimeout);
                this.disconnectTimeout = setTimeout(()=>this.disconnect(), 1000);
            }
        }
    }
    async openDb() {
        if (this.db) return;
        return new Promise((resolve, reject)=>{
            const request = indexedDB.open(this.dbName, this.dbVersion);
            request.onupgradeneeded = (event)=>{
                this.upgrader(event);
            };
            request.onsuccess = (event)=>{
                this.db = event.target.result;
                this.db.onversionchange = ()=>{
                    this.isAvailable = false;
                    this.disconnect();
                    throw new Error('idb onversionchange');
                };
                resolve();
            };
            request.onerror = (event)=>{
                this.isAvailable = false;
                reject(event.target.error);
            };
        });
    }
    getTransaction(storeName, mode) {
        if (!this.storeNames.includes(storeName)) throw new Error(`indexedDb store "${storeName}" not found in "${this.dbName}"`);
        const transaction = this.db.transaction(storeName, mode);
        return {
            transaction,
            objectStore: transaction.objectStore(storeName)
        };
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.dbVersion = -1;
        this.dbName = '';
        this.storeNames = [];
        this.upgrader = ()=>{};
        this.isAvailable = true;
        this.openTransactionCount = 0;
    }
    init(dbName, objectStoreNames, version, upgrader) {
        if (this.dbName !== '') throw new Error('IndexedDb already initialized');
        this.dbName = dbName;
        this.storeNames = [
            ...objectStoreNames
        ];
        this.dbVersion = version;
        this.upgrader = upgrader;
    }
    async testConnection() {
        this.isAvailable = this.isAvailable && await areBlobUrlsSupported();
        if (!this.isAvailable) return this.isAvailable;
        try {
            for (const name of this.storeNames){
                await (0, _base.timeoutWrapper)(this.openDb(), 'indexed-db.testConnection.openDb');
                const { transaction } = this.getTransaction(name, 'readonly');
                transaction.abort();
            }
        } catch (e) {
            this.isAvailable = false;
        }
        return this.isAvailable;
    }
    async set(store, key, value) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return await new Promise((resolve, reject)=>{
                const { transaction, objectStore } = this.getTransaction(store, 'readwrite');
                transaction.onabort = ()=>reject(transaction.error);
                const request = objectStore.put(value, key);
                request.onsuccess = ()=>{
                    resolve();
                };
                request.onerror = ()=>reject(request.error);
            });
        });
    }
    async get(store, key) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return await new Promise((resolve, reject)=>{
                const { transaction, objectStore } = this.getTransaction(store, 'readonly');
                transaction.onabort = ()=>reject(transaction.error);
                const request = objectStore.get(key);
                request.onsuccess = ()=>resolve(request.result);
                request.onerror = ()=>reject(request.error);
            });
        });
    }
    async has(store, key) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return await new Promise((resolve, reject)=>{
                const { transaction, objectStore } = this.getTransaction(store, 'readonly');
                transaction.onabort = ()=>reject(transaction.error);
                const request = objectStore.getKey(key);
                request.onsuccess = ()=>resolve(!!request.result);
                request.onerror = ()=>reject(request.error);
            });
        });
    }
    async getKeys(store) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return await new Promise((resolve, reject)=>{
                const { transaction, objectStore } = this.getTransaction(store, 'readonly');
                transaction.onabort = ()=>reject(transaction.error);
                const request = objectStore.getAllKeys();
                request.onsuccess = ()=>resolve(request.result.map((key)=>key.toString()));
                request.onerror = ()=>reject(request.error);
            });
        });
    }
    async remove(store, key) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return await new Promise((resolve, reject)=>{
                const { transaction, objectStore } = this.getTransaction(store, 'readwrite');
                transaction.onabort = ()=>reject(transaction.error);
                const request = objectStore.delete(key);
                request.onsuccess = ()=>{
                    resolve();
                };
                request.onerror = ()=>reject(request.error);
            });
        });
    }
    async bulkSet(store, entries) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return new Promise((resolve, reject)=>{
                const { transaction, objectStore } = this.getTransaction(store, 'readwrite');
                transaction.onabort = ()=>reject(transaction.error);
                transaction.onerror = ()=>reject(transaction.error);
                transaction.oncomplete = ()=>resolve();
                for (const { key, value } of entries){
                    const request = objectStore.put(value, key);
                    request.onerror = ()=>reject(request.error);
                }
            });
        });
    }
    async bulkGet(store, keys) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return new Promise((resolve, reject)=>{
                const results = {};
                const { transaction, objectStore } = this.getTransaction(store, 'readonly');
                transaction.onabort = ()=>reject(transaction.error);
                transaction.onerror = ()=>reject(transaction.error);
                transaction.oncomplete = ()=>resolve(results);
                keys.forEach((key, idx)=>{
                    const request = objectStore.get(key);
                    request.onsuccess = ()=>results['' + key] = request.result;
                    request.onerror = ()=>reject(request.error);
                });
            });
        });
    }
    async bulkRemove(store, keys) {
        return this.autoDisconnectWrapper(async ()=>{
            await this.openDb();
            return new Promise((resolve, reject)=>{
                const { transaction, objectStore } = this.getTransaction(store, 'readwrite');
                transaction.onabort = ()=>reject(transaction.error);
                transaction.onerror = ()=>reject(transaction.error);
                transaction.oncomplete = ()=>resolve();
                for (const key of keys){
                    const request = objectStore.delete(key);
                    request.onerror = ()=>reject(request.error);
                }
            });
        });
    }
    getIsAvailable() {
        return this.isAvailable;
    }
    destroy() {
        this.disconnect();
    }
}

},{"./base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lkbRA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FileUi", ()=>FileUi);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _browserStorageUi = require("../components/browser-storage-ui");
var _language = require("../../../language/language");
var _newImageSvg = require("url:/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
var _exportSvg = require("url:/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
var _shareSvg = require("url:/src/app/img/ui/share.svg");
var _shareSvgDefault = parcelHelpers.interopDefault(_shareSvg);
var _uploadSvg = require("url:/src/app/img/ui/upload.svg");
var _uploadSvgDefault = parcelHelpers.interopDefault(_uploadSvg);
var _importSvg = require("url:/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
var _checkbox = require("../components/checkbox");
var _localStorage = require("../../../bb/base/local-storage");
var _showRecoveryManagerPanel = require("../modals/recovery-manager-panel/show-recovery-manager-panel");
var _fileUiModuleScss = require("./file-ui.module.scss");
var _browserStorageHeaderUi = require("../components/browser-storage-header-ui");
var _base = require("../../../bb/base/base");
const LS_SHOW_SAVE_DIALOG = 'kl-save-dialog';
const createSpacer = ()=>{
    const el = document.createElement('div');
    const clearer = document.createElement('div');
    const line = (0, _bb.BB).el({
        className: 'grid-hr'
    });
    el.append(clearer, line);
    (0, _base.css)(clearer, {
        clear: 'both'
    });
    return el;
};
const createButtonContent = (text, icon, noInvert)=>{
    return `<img ${noInvert ? 'class="dark-no-invert"' : ''} src='${icon}' alt='icon' height='20'/>${text}`;
};
class FileUi {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.recoveryListener = (metas)=>{
            if (!this.recoveryCountBubble) return;
            const count = metas.length;
            if (count === 0) this.recoveryCountBubble.style.display = 'none';
            else {
                this.recoveryCountBubble.textContent = '' + count;
                this.recoveryCountBubble.style.display = 'inline-block';
            }
        };
        this.exportType = p.exportType;
        this.applyUncommitted = p.applyUncommitted;
        this.rootEl = document.createElement('div');
        const asyncCreation = ()=>{
            // --- hint ---
            const saveNote = (0, _bb.BB).el({
                className: 'kl-toolspace-note',
                textContent: (0, _language.LANG)('file-no-autosave'),
                css: {
                    margin: '10px 10px 0 10px'
                }
            });
            // --- new, import, save ---
            const newButton = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button',
                content: createButtonContent((0, _language.LANG)('file-new'), (0, _newImageSvgDefault.default), true),
                custom: {
                    tabIndex: '-1'
                },
                css: {
                    cssFloat: 'left'
                },
                onClick: ()=>p.onNewImage()
            });
            const importButton = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button',
                content: createButtonContent((0, _language.LANG)('file-import'), (0, _importSvgDefault.default), true),
                css: {
                    position: 'relative',
                    cursor: 'pointer',
                    cssFloat: 'left'
                },
                custom: {
                    tabIndex: '-1'
                },
                onClick: ()=>this.importInput.click()
            });
            this.importInput = (0, _bb.BB).el({
                tagName: 'input',
                css: {
                    display: 'none'
                },
                onChange: ()=>{
                    this.applyUncommitted();
                    this.importInput.files && p.onFileSelect(this.importInput.files, 'default');
                    this.importInput.value = '';
                },
                custom: {
                    tabIndex: '-1'
                }
            });
            this.importInput.type = 'file';
            this.importInput.multiple = true;
            this.importInput.accept = 'image/*,.psd'; // .psd needed for chrome, although it's image/vnd.adobe.photoshop
            const saveButton = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button grid-button--filter',
                content: createButtonContent((0, _language.LANG)('file-save'), (0, _exportSvgDefault.default)),
                custom: {
                    tabIndex: '-1'
                },
                css: {
                    cssFloat: 'left',
                    flex: '1 0 0',
                    margin: '0'
                },
                onClick: ()=>p.onSaveImageToComputer()
            });
            const canShowSaveDialog = 'showSaveFilePicker' in window;
            const showSaveDialogRaw = (0, _localStorage.LocalStorage).getItem(LS_SHOW_SAVE_DIALOG);
            const initialShowSaveDialog = showSaveDialogRaw === null ? false : showSaveDialogRaw === 'true';
            const saveDialogCheckbox = new (0, _checkbox.Checkbox)({
                init: initialShowSaveDialog,
                label: (0, _language.LANG)('file-show-save-dialog'),
                callback: (value)=>{
                    if (value) (0, _localStorage.LocalStorage).setItem(LS_SHOW_SAVE_DIALOG, 'true');
                    else (0, _localStorage.LocalStorage).removeItem(LS_SHOW_SAVE_DIALOG); // default is false
                    p.onChangeShowSaveDialog(value);
                },
                css: {
                    maxWidth: 'fit-content'
                },
                name: 'show-save-dialog'
            });
            p.onChangeShowSaveDialog(initialShowSaveDialog);
            // export filetype dropdown
            const exportTypeSelect = new (0, _kl.KL).Select({
                optionArr: [
                    [
                        'png',
                        'PNG'
                    ],
                    [
                        'psd',
                        'PSD'
                    ],
                    [
                        'layers',
                        (0, _language.LANG)('layers') + ' (PNG)'
                    ]
                ],
                initValue: this.exportType,
                onChange: (val)=>{
                    this.exportType = val;
                    p.onExportTypeChange(this.exportType);
                    p.onSaveImageToComputer();
                },
                title: (0, _language.LANG)('file-format'),
                name: 'export-type'
            });
            (0, _base.css)(exportTypeSelect.getElement(), {
                height: '30px',
                width: 'calc(50% - 10px)',
                flex: '1 0 0'
            });
            // --- browser storage ---
            let browserStorageFallbackEl;
            if (p.projectStore) {
                this.browserStorageUi = new (0, _browserStorageUi.BrowserStorageUi)({
                    projectStore: p.projectStore,
                    getProject: p.getProject,
                    klRootEl: p.klRootEl,
                    applyUncommitted: this.applyUncommitted,
                    onOpen: p.onOpenBrowserStorage,
                    onStored: ()=>p.onStoredToBrowserStorage()
                });
                (0, _base.css)(this.browserStorageUi.getElement(), {
                    margin: '10px'
                });
            } else {
                const header = new (0, _browserStorageHeaderUi.BrowserStorageHeaderUi)();
                browserStorageFallbackEl = (0, _bb.BB).el({
                    content: [
                        header.getElement(),
                        (0, _bb.BB).el({
                            content: "\uD83D\uDD34 " + (0, _language.LANG)('file-storage-cant-access'),
                            css: {
                                marginTop: '10px'
                            }
                        })
                    ],
                    css: {
                        margin: '10px 10px 0 10px'
                    }
                });
            }
            const saveRow = (0, _bb.BB).el({
                content: [
                    (0, _bb.BB).el({
                        content: [
                            saveButton,
                            exportTypeSelect.getElement()
                        ],
                        css: {
                            display: 'flex',
                            gap: '10px'
                        }
                    }),
                    ...canShowSaveDialog ? [
                        saveDialogCheckbox.getElement()
                    ] : []
                ],
                css: {
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '10px',
                    margin: '10px 10px 0 10px'
                }
            });
            // --- recovery ---
            this.klRecoveryManager = p.klRecoveryManager;
            const recoveryWrapper = (0, _bb.BB).el({});
            this.recoveryCountBubble = (0, _bb.BB).el({
                className: _fileUiModuleScss.recoveryBubble
            });
            const recoveryBrowserButton = (0, _bb.BB).el({
                tagName: 'button',
                content: [
                    (0, _language.LANG)('tab-recovery-recover-tabs'),
                    this.recoveryCountBubble
                ],
                onClick: ()=>(0, _showRecoveryManagerPanel.showRecoveryManagerPanel)(this.klRecoveryManager),
                custom: {
                    tabIndex: '-1'
                },
                css: {
                    margin: '10px 0 0 10px',
                    width: 'calc(100% - 20px)'
                }
            });
            recoveryWrapper.append(recoveryBrowserButton, createSpacer());
            (async ()=>{
                if (!this.klRecoveryManager) return;
                this.klRecoveryManager.subscribe(this.recoveryListener);
                await this.klRecoveryManager.update();
                this.klRecoveryManager.unsubscribe(this.recoveryListener);
            })();
            // --- upload, share ---
            const shareButton = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button',
                content: createButtonContent((0, _language.LANG)('file-share'), (0, _shareSvgDefault.default)),
                custom: {
                    tabIndex: '-1'
                },
                css: {
                    cssFloat: 'left'
                },
                onClick: ()=>{
                    shareButton.disabled = true;
                    p.onShareImage(()=>{
                        shareButton.disabled = false;
                    });
                }
            });
            const uploadImgurButton = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button',
                content: createButtonContent((0, _language.LANG)('file-upload'), (0, _uploadSvgDefault.default)),
                custom: {
                    tabIndex: '-1'
                },
                css: {
                    cssFloat: 'left'
                },
                onClick: ()=>{
                    p.onUpload();
                }
            });
            (0, _bb.BB).append(this.rootEl, [
                saveNote,
                newButton,
                importButton,
                (0, _bb.BB).el({
                    css: {
                        clear: 'both'
                    }
                }),
                saveRow,
                createSpacer(),
                this.browserStorageUi?.getElement(),
                browserStorageFallbackEl,
                createSpacer(),
                recoveryWrapper,
                uploadImgurButton,
                (0, _bb.BB).canShareFiles() ? shareButton : undefined,
                (0, _bb.BB).el({
                    css: {
                        clear: 'both'
                    }
                })
            ]);
        };
        setTimeout(asyncCreation, 1);
    }
    refresh() {}
    getElement() {
        return this.rootEl;
    }
    setIsVisible(isVisible) {
        if (isVisible) {
            this.refresh();
            this.browserStorageUi?.show();
            if (this.klRecoveryManager) {
                this.klRecoveryManager.subscribe(this.recoveryListener);
                this.klRecoveryManager.update();
            }
        } else if (this.klRecoveryManager) this.klRecoveryManager.unsubscribe(this.recoveryListener);
    }
    triggerImport() {
        this.importInput && this.importInput.click();
    }
}

},{"../../../bb/bb":"3zOvT","../../kl":"lHQKw","../components/browser-storage-ui":"jEHd9","../../../language/language":"mcywn","url:/src/app/img/ui/new-image.svg":"1y5Oa","url:/src/app/img/ui/export.svg":"imwXl","url:/src/app/img/ui/share.svg":"6LMSL","url:/src/app/img/ui/upload.svg":"cz0a2","url:/src/app/img/ui/import.svg":"fa9CT","../components/checkbox":"9bXL6","../../../bb/base/local-storage":"itqB1","../modals/recovery-manager-panel/show-recovery-manager-panel":"iCUhn","./file-ui.module.scss":"4Ybt5","../components/browser-storage-header-ui":"a0QD5","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cz0a2":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("upload.9cba70c2.svg") + "?" + Date.now();

},{}],"iCUhn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showRecoveryManagerPanel", ()=>showRecoveryManagerPanel);
var _showModal = require("../base/showModal");
var _bb = require("../../../../bb/bb");
var _recoveryManagerPanel = require("./recovery-manager-panel");
var _klIndexedDb = require("../../../storage/kl-indexed-db");
var _kl = require("../../../kl");
var _language = require("../../../../language/language");
function showRecoveryManagerPanel(klRecoveryManager) {
    if (!klRecoveryManager || !(0, _klIndexedDb.KL_INDEXED_DB).getIsAvailable()) {
        (0, _kl.KL).popup({
            target: document.body,
            type: 'error',
            message: (0, _language.LANG)('file-storage-cant-access'),
            buttons: [
                'Ok'
            ]
        });
        return;
    }
    const recoveryManager = new (0, _recoveryManagerPanel.RecoveryManagerPanel)({
        klRecoveryManager
    });
    const rootEl = (0, _bb.BB).el({
        content: [
            recoveryManager.getElement()
        ]
    });
    const onModalExit = (val)=>{
        recoveryManager.destroy();
    };
    const modal = (0, _showModal.showModal)({
        target: document.body,
        message: `<b>${(0, _language.LANG)('tab-recovery-recover-tabs')}</b>`,
        div: rootEl,
        buttons: [
            (0, _language.LANG)('modal-close')
        ],
        callback: onModalExit,
        style: {
            width: 'calc(100% - 50px)',
            maxWidth: '1000px',
            minWidth: '300px',
            boxSizing: 'border-box'
        },
        clickOnEnter: 'Ok'
    });
}

},{"../base/showModal":"gy3iL","../../../../bb/bb":"3zOvT","./recovery-manager-panel":"8Wuqz","../../../storage/kl-indexed-db":"iz3yu","../../../kl":"lHQKw","../../../../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Wuqz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RecoveryManagerPanel", ()=>RecoveryManagerPanel);
var _bb = require("../../../../bb/bb");
var _klRecoveryManager = require("../../../storage/kl-recovery-manager");
var _timestampToAge = require("../../utils/timestamp-to-age");
var _showModal = require("../base/showModal");
var _canvas = require("../../../../bb/base/canvas");
var _recoveryManagerPanelModuleScss = require("./recovery-manager-panel.module.scss");
var _language = require("../../../../language/language");
var _removeLayerSvg = require("url:/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _base = require("../../../../bb/base/base");
class RecoveryManagerPanel {
    async update(metas, totalMemoryUsedBytes) {
        const elements = [];
        metas.sort((a, b)=>{
            if (a.timestamp > b.timestamp) return -1;
            if (a.timestamp < b.timestamp) return 1;
            return 0;
        }).forEach((meta)=>{
            const recoverBtn = (0, _bb.BB).el({
                tagName: 'a',
                className: 'kl-button kl-button-link',
                content: (0, _language.LANG)('tab-recovery-recover'),
                custom: {
                    href: '#' + meta.id,
                    target: '_blank'
                }
            });
            const deleteBtn = (0, _bb.BB).el({
                tagName: 'button',
                className: 'kl-button-delete',
                content: `<img src="${(0, _removeLayerSvgDefault.default)}" height="20"/>${(0, _language.LANG)('tab-recovery-delete')}`,
                onClick: ()=>{
                    deleteBtn.blur();
                    const thumbnail2 = (0, _canvas.copyCanvas)(meta.thumbnail);
                    (0, _base.css)(thumbnail2, {
                        alignSelf: 'start',
                        background: 'var(--kl-checkerboard-background)',
                        maxWidth: '100%'
                    });
                    (0, _showModal.showModal)({
                        target: document.body,
                        type: 'warning',
                        message: (0, _bb.BB).el({
                            content: [
                                (0, _language.LANG)('tab-recovery-delete-confirmation'),
                                thumbnail2
                            ],
                            css: {
                                display: 'flex',
                                flexDirection: 'column',
                                gap: '10px'
                            }
                        }),
                        buttons: [
                            (0, _language.LANG)('tab-recovery-delete'),
                            'Cancel'
                        ],
                        deleteButtonName: (0, _language.LANG)('tab-recovery-delete'),
                        callback: async (result)=>{
                            if (result === 'Cancel') return;
                            await this.klRecoveryManager.remove(+meta.id);
                        }
                    });
                },
                noRef: true
            });
            const preview = meta.thumbnail;
            const previewWrapper = (0, _bb.BB).el({
                tagName: 'a',
                content: preview,
                className: _recoveryManagerPanelModuleScss.preview,
                title: (0, _language.LANG)('tab-recovery-recover'),
                css: {
                    minHeight: (0, _klRecoveryManager.RECOVERY_THUMB_HEIGHT_PX) + 'px'
                },
                custom: {
                    href: '#' + meta.id,
                    target: '_blank'
                }
            });
            const infoEl = (0, _bb.BB).el({
                content: [
                    (0, _timestampToAge.timestampToAge)(meta.timestamp),
                    ', ' + (0, _bb.BB).round(meta.memoryEstimateBytes / 1000000, 1) + ' MB'
                ],
                css: {
                    textAlign: 'center'
                }
            });
            elements.push((0, _bb.BB).el({
                content: [
                    previewWrapper,
                    infoEl,
                    recoverBtn,
                    deleteBtn
                ],
                css: {
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '5px',
                    maxWidth: '100%'
                }
            }));
        });
        this.rootEl.innerHTML = '';
        if (0, _klRecoveryManager.DEBUG_RETURN_ALL_RECOVERIES) this.rootEl.append((0, _bb.BB).el({
            content: 'Debug On - SHOWING ALL TABS',
            css: {
                background: 'red'
            }
        }));
        this.rootEl.append((0, _bb.BB).el({
            content: (0, _language.LANG)('tab-recovery-explanation'),
            className: 'kl-toolspace-note'
        }), (0, _bb.BB).el({
            content: (0, _language.LANG)('tab-recovery-total-quota-label') + ' ' + (0, _bb.BB).round(totalMemoryUsedBytes / 1000000, 1) + ' MB / ' + (0, _bb.BB).round((0, _klRecoveryManager.RECOVERY_MEMORY_LIMIT_BYTES) / 1000000, 1) + ' MB',
            css: {
                margin: '10px 0'
            }
        }), (0, _bb.BB).el({
            content: [
                ...elements
            ],
            css: {
                display: 'flex',
                flexWrap: 'wrap',
                gap: '20px 10px',
                justifyContent: 'space-evenly'
            }
        }));
        if (elements.length === 0) this.rootEl.append((0, _language.LANG)('tab-recovery-empty'));
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.recoveryListener = (metas, totalMemoryUsedBytes)=>{
            this.update(metas, totalMemoryUsedBytes);
        };
        this.klRecoveryManager = p.klRecoveryManager;
        this.rootEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('loading')
        });
        this.klRecoveryManager.subscribe(this.recoveryListener);
        setTimeout(async ()=>{
            try {
                await this.klRecoveryManager.update();
            } catch (e) {
                setTimeout(()=>{
                    throw e;
                });
                this.rootEl.innerHTML = 'error';
            }
        });
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.klRecoveryManager.unsubscribe(this.recoveryListener);
    }
}

},{"../../../../bb/bb":"3zOvT","../../../storage/kl-recovery-manager":"htaZX","../../utils/timestamp-to-age":"7KGHi","../base/showModal":"gy3iL","../../../../bb/base/canvas":"86XNv","./recovery-manager-panel.module.scss":"5s8aN","../../../../language/language":"mcywn","url:/src/app/img/ui/remove-layer.svg":"fV9n3","../../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"htaZX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RECOVERY_THUMB_WIDTH_PX", ()=>RECOVERY_THUMB_WIDTH_PX);
parcelHelpers.export(exports, "RECOVERY_THUMB_HEIGHT_PX", ()=>RECOVERY_THUMB_HEIGHT_PX);
parcelHelpers.export(exports, "RECOVERY_AGE_LIMIT_MS", ()=>RECOVERY_AGE_LIMIT_MS);
parcelHelpers.export(exports, "RECOVERY_MEMORY_LIMIT_BYTES", ()=>RECOVERY_MEMORY_LIMIT_BYTES);
parcelHelpers.export(exports, "FIRST_RECOVERY_AFTER_CHANGES", ()=>FIRST_RECOVERY_AFTER_CHANGES);
parcelHelpers.export(exports, "DEBUG_RETURN_ALL_RECOVERIES", ()=>DEBUG_RETURN_ALL_RECOVERIES);
parcelHelpers.export(exports, "DEBUG_INSTANT_RECOVERY", ()=>DEBUG_INSTANT_RECOVERY);
parcelHelpers.export(exports, "setHash", ()=>setHash);
/**
 * handles all recovery logic.
 * - determines the tabId
 * - stores and updates the recovery automatically
 * - updates the hash in the url
 * - does cleanup (orphans, old drawings, exceeding memory)
 */ parcelHelpers.export(exports, "KlRecoveryManager", ()=>KlRecoveryManager);
var _klRecoveryStorage = require("./kl-recovery-storage");
var _base = require("../../bb/base/base");
var _crossTabChannel = require("../../bb/base/cross-tab-channel");
var _klIndexedDb = require("./kl-indexed-db");
const RECOVERY_THUMB_WIDTH_PX = 300;
const RECOVERY_THUMB_HEIGHT_PX = 180;
const RECOVERY_AGE_LIMIT_MS = 604800000; // 1 week
const RECOVERY_MEMORY_LIMIT_BYTES = 1e9;
const FIRST_RECOVERY_AFTER_MS = 300000;
const FIRST_RECOVERY_AFTER_CHANGES = 8;
const SUBSEQUENT_RECOVERY_AFTER_MS = 60000;
const SUBSEQUENT_RECOVERY_AFTER_CHANGES = 4;
const DEBUG_RETURN_ALL_RECOVERIES = false;
const DEBUG_INSTANT_RECOVERY = false;
function setHash(value) {
    if (value === undefined) {
        history.replaceState(null, '', ' ');
        return;
    }
    // avoid creating a new history state
    history.replaceState(null, '', window.location.origin + window.location.pathname + window.location.search + '#' + value);
}
function getHash() {
    // returns without the "#"
    return window.location.hash ? window.location.hash.substring(1) : undefined;
}
const ignoredHashes = [
    'licenses'
];
function hashToTabId(rawHash) {
    if (rawHash === undefined || ignoredHashes.includes(rawHash)) return undefined;
    const num = +rawHash;
    if (isNaN(num) || num < 0 || num % 1 !== 0) return undefined;
    return num;
}
function genNewId(takenIds) {
    const limit = 1000;
    if (takenIds.length >= limit) throw new Error('No available IDs');
    const idSet = new Set(takenIds);
    const pool = (0, _base.createArray)(limit, 0).map((_, index)=>index).filter((id)=>!idSet.has(id));
    const index = Math.floor(Math.random() * pool.length);
    if (pool[index] === undefined) throw new Error('No available IDs');
    return pool[index];
}
class KlRecoveryManager {
    announceTabId() {
        this.crossTabChannel.postMessage({
            type: 'new-tab'
        });
    }
    initListeners() {
        document.addEventListener('visibilitychange', ()=>{
            if (document.hidden) return;
            // changes may have happened since tab last visible
            // might not register a tab is closed without timeout
            setTimeout(()=>{
                this.update();
            }, 500);
        });
        window.addEventListener('focus', ()=>{
            setTimeout(()=>{
                this.update();
            }, 500);
        });
        this.crossTabChannel.subscribe((message)=>{
            if (message.type === 'new-tab') {
                if (document.hidden) // we'll update when tab visible. noop.
                return;
                setTimeout(()=>{
                    this.update();
                }, 500);
            }
            if (message.type === 'request-ids') {
                if (this.tabId !== undefined) this.crossTabChannel.postMessage({
                    type: 'response-ids',
                    id: this.tabId
                });
            }
        });
        // I think this is not needed
        let debounceTimeout;
    /*KL_INDEXED_DB.addListener(async () => {
            if (document.hidden) {
                return;
            }
            console.log('indexed db change!');
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(async () => {
                this.update();
            }, 100);
        });*/ }
    async emitUpdate() {
        if (!(0, _klIndexedDb.KL_INDEXED_DB).getIsAvailable()) return;
        const ids = await (0, _klRecoveryStorage.getIdsFromRecoveryStore)();
        const otherTabIds = await this.getIdsFromTabs();
        const tabIds = DEBUG_RETURN_ALL_RECOVERIES ? ids : ids.filter((id)=>!otherTabIds.includes(id) && id !== this.tabId);
        const drawings = await Promise.all(tabIds.map((id)=>{
            return (0, _klRecoveryStorage.getMetadata)('' + id, true);
        }));
        const totalMemoryUsedBytes = await this.getTotalMemoryUsedBytes();
        this.listeners.forEach((listener)=>{
            listener(drawings, totalMemoryUsedBytes);
        });
    }
    setHash(id) {
        setHash(id === undefined ? undefined : '' + id);
        this.announceTabId();
    }
    async getIdsFromTabs() {
        this.crossTabChannel.postMessage({
            type: 'request-ids'
        });
        const result = [];
        const onMessage = (message)=>{
            if (message.type === 'response-ids') result.push(+message.id);
        };
        this.crossTabChannel.subscribe(onMessage);
        await (0, _base.sleep)(100);
        this.crossTabChannel.unsubscribe(onMessage);
        return result;
    }
    async getTotalMemoryUsedBytes() {
        const ids = await (0, _klRecoveryStorage.getIdsFromRecoveryStore)();
        let result = 0;
        for (const id of ids){
            const meta = await (0, _klRecoveryStorage.getMetadata)('' + id);
            result += meta.memoryEstimateBytes;
        }
        return result;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.klHistory = {};
        this.isStoring = false;
        this.listeners = new Set();
        this.crossTabChannel = new (0, _crossTabChannel.CrossTabChannel)('kl-tab-communication');
        this.initListeners();
    }
    async getRecovery() {
        // is there a tabId?
        const initialTabId = hashToTabId(getHash());
        if (initialTabId === undefined) {
            this.noRecoveryReason = 'noTabIdHash';
            // we get a tabId later
            return undefined;
        }
        // is there another tab with the same tabId?
        const openTabIds = await this.getIdsFromTabs();
        if (openTabIds.includes(initialTabId)) {
            this.noRecoveryReason = 'alreadyOpened';
            // Already exists -> unset tabId. Nothing to load.
            this.setHash(undefined);
            return undefined;
        }
        // is id in storage?
        const storedIds = await (0, _klRecoveryStorage.getIdsFromRecoveryStore)();
        if (!storedIds.includes(initialTabId)) {
            this.noRecoveryReason = 'idNotFound';
            // not found -> unset tabId and abort
            this.setHash(undefined);
            return undefined;
        }
        // change id of drawing and tab
        const newId = genNewId(storedIds);
        if (!await (0, _klRecoveryStorage.changeRecoveryId)(initialTabId, newId)) {
            this.noRecoveryReason = 'idChangeFailed';
            this.setHash(undefined);
            return undefined;
        }
        this.setHash(newId); // update hash
        const result = await (0, _klRecoveryStorage.getRecovery)(newId);
        if (result) this.tabId = newId;
        setTimeout(()=>{
            // don't disrupt loading
            (0, _klRecoveryStorage.removeOrphans)();
        });
        return result;
    }
    setKlHistory(klHistory) {
        this.klHistory = klHistory;
        let startTime = new Date().getTime();
        let lastStoredChangeCount = 0;
        this.klHistory.addListener(async ()=>{
            if (this.isStoring) return;
            const changeCount = this.klHistory.getChangeCount();
            if (!DEBUG_INSTANT_RECOVERY) {
                const deltaMs = new Date().getTime() - startTime;
                // initial store after 5 minutes
                if (this.tabId === undefined && (deltaMs < FIRST_RECOVERY_AFTER_MS || changeCount < FIRST_RECOVERY_AFTER_CHANGES)) return;
                // subsequent store after 1 minutes
                if (this.tabId !== undefined && (deltaMs < SUBSEQUENT_RECOVERY_AFTER_MS || changeCount - lastStoredChangeCount < SUBSEQUENT_RECOVERY_AFTER_CHANGES)) return;
            }
            let isFreshDrawing = false;
            if (!this.tabId) {
                const storedIds = await (0, _base.timeoutWrapper)((0, _klRecoveryStorage.getIdsFromRecoveryStore)(), 'setKlHistory.getIdsFromStore');
                this.tabId = genNewId(storedIds);
                isFreshDrawing = true;
            }
            this.isStoring = true;
            try {
                await (0, _klRecoveryStorage.storeRecovery)(this.tabId, this.klHistory.getComposed(), this.getThumbnail);
                startTime = new Date().getTime();
            } catch (e) {
                setTimeout(()=>{
                    throw e;
                });
            }
            if (isFreshDrawing) {
                this.setHash(this.tabId);
                await (0, _klRecoveryStorage.clearOldRecoveries)();
            }
            startTime = new Date().getTime();
            lastStoredChangeCount = changeCount;
            this.isStoring = false;
        });
    }
    setGetThumbnail(getThumbnail) {
        this.getThumbnail = getThumbnail;
    }
    /**
     * Listener will be informed about recoveries in closed tabs.
     * totalMemoryUsesBytes includes recoveries in open tabs
     */ subscribe(listener) {
        this.listeners.add(listener);
    }
    unsubscribe(listener) {
        this.listeners.delete(listener);
    }
    // re-checks what recoveries exist
    async update() {
        if (this.listeners.size > 0) await this.emitUpdate();
    }
    async remove(recoveryId) {
        await (0, _klRecoveryStorage.deleteRecovery)('' + recoveryId);
        this.update();
    }
    getTabId() {
        return this.tabId;
    }
    getNoRecoveryReason() {
        return this.noRecoveryReason;
    }
    destroy() {
    // todo
    }
}

},{"./kl-recovery-storage":"aRAOz","../../bb/base/base":"it3mQ","../../bb/base/cross-tab-channel":"czgd6","./kl-indexed-db":"iz3yu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aRAOz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getIdsFromRecoveryStore", ()=>getIdsFromRecoveryStore);
parcelHelpers.export(exports, "getImageDataIdsFromStorage", ()=>getImageDataIdsFromStorage);
parcelHelpers.export(exports, "clearOldRecoveries", ()=>clearOldRecoveries);
/**
 * Removes orphaned tiles. Doesn't delete those still referenced.
 */ parcelHelpers.export(exports, "removeOrphans", ()=>removeOrphans);
parcelHelpers.export(exports, "getRecovery", ()=>getRecovery);
// returns false if recovery doesn't exist
parcelHelpers.export(exports, "changeRecoveryId", ()=>changeRecoveryId);
parcelHelpers.export(exports, "storeRecovery", ()=>storeRecovery);
parcelHelpers.export(exports, "deleteRecovery", ()=>deleteRecovery);
parcelHelpers.export(exports, "getMetadata", ()=>getMetadata);
var _klIndexedDb = require("./kl-indexed-db");
var _projectConverter = require("./project-converter");
var _klTypes = require("../kl-types");
var _bb = require("../../bb/bb");
var _klHistory = require("../history/kl-history");
var _sortLayerMap = require("../history/sort-layer-map");
var _base = require("../../bb/base/base");
var _klRecoveryManager = require("./kl-recovery-manager");
var _projectStore = require("./project-store");
async function getIdsFromRecoveryStore() {
    const keys = await (0, _klIndexedDb.KL_INDEXED_DB).getKeys((0, _klIndexedDb.RECOVERY_STORE));
    return keys.map((item)=>+item);
}
async function getImageDataIdsFromStorage() {
    return await (0, _klIndexedDb.KL_INDEXED_DB).getKeys((0, _klIndexedDb.IMAGE_DATA_STORE));
}
async function clearOldRecoveries() {
    const ids = await (0, _klIndexedDb.KL_INDEXED_DB).getKeys((0, _klIndexedDb.RECOVERY_STORE));
    const recoveries = await Promise.all(ids.map((id)=>{
        return (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.RECOVERY_STORE), id);
    }));
    await Promise.all(recoveries.map((recovery, index)=>{
        if (recovery.timestamp < new Date().getTime() - (0, _klRecoveryManager.RECOVERY_AGE_LIMIT_MS)) return deleteRecovery(ids[index]);
        return Promise.resolve();
    }));
}
async function loadFromImageDataStore(id, commonCtx) {
    const result = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.IMAGE_DATA_STORE), id);
    if (!result) {
        commonCtx.clearRect(0, 0, (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
        return commonCtx.getImageData(0, 0, (0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
    }
    if ((0, _base.isBlob)(result)) {
        let image;
        try {
            image = await (0, _projectConverter.loadImage)(result);
        } catch (e) {
        // someday maybe pass error with result, to show user something went wrong
        }
        commonCtx.canvas.width = image?.width ?? commonCtx.canvas.width;
        commonCtx.canvas.height = image?.height ?? commonCtx.canvas.height;
        // no clear needed, because size was set
        image && commonCtx.drawImage(image, 0, 0);
        return commonCtx.getImageData(0, 0, commonCtx.canvas.width, commonCtx.canvas.height);
    }
    return result;
}
async function getRawRecoveryProject(id) {
    return await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.RECOVERY_STORE), '' + id);
}
async function removeOrphans(candidateIds) {
    const imageDataIds = candidateIds ?? await getImageDataIdsFromStorage();
    const usedIds = new Set();
    const recoveryIds = await getIdsFromRecoveryStore();
    for (const id of recoveryIds){
        const raw = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.RECOVERY_STORE), '' + id);
        if (!raw) continue;
        for (const layer of raw.layers){
            for (const tile of layer.image)if (!(0, _klTypes.isLayerFill)(tile)) usedIds.add(tile.id);
        }
        usedIds.add(raw.thumbnail);
    }
    // also have to check browser storage store
    const browserStorageRaw = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.BROWSER_STORAGE_STORE), 1);
    if (browserStorageRaw) {
        if ((0, _projectStore.isTImageDataReference)(browserStorageRaw.thumbnail)) usedIds.add(browserStorageRaw.thumbnail.id);
        for (const layer of browserStorageRaw.layers)if ((0, _projectStore.isTImageDataReference)(layer.blob)) usedIds.add(layer.blob.id);
    }
    // remove entries
    await (0, _klIndexedDb.KL_INDEXED_DB).bulkRemove((0, _klIndexedDb.IMAGE_DATA_STORE), imageDataIds.filter((id)=>!usedIds.has(id)));
}
async function getRecovery(tabId) {
    const raw = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.RECOVERY_STORE), '' + tabId);
    if (raw === undefined) return undefined;
    // shared canvas to load tiles
    const canvas = (0, _bb.BB).canvas((0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
    const ctx = (0, _bb.BB).ctx(canvas);
    // speed up by loading in parallel
    const layers = [];
    await Promise.all(raw.layers.map(async (layerSerialized, index)=>{
        const tiles = [];
        for(let index = 0; index < layerSerialized.image.length; index++){
            const tile = layerSerialized.image[index];
            if ((0, _klTypes.isLayerFill)(tile)) tiles.push(tile);
            else tiles.push({
                id: tile.id,
                data: await loadFromImageDataStore(tile.id, ctx)
            });
        }
        layers[index] = {
            ...layerSerialized,
            image: tiles
        };
    }));
    return {
        project: {
            projectId: raw.projectId ?? (0, _base.randomUuid)(),
            width: raw.width,
            height: raw.height,
            layers
        },
        timestamp: 0,
        thumbnail: await getThumbnail(raw.thumbnail)
    };
}
async function getThumbnail(id) {
    const canvas = (0, _bb.BB).canvas((0, _klHistory.HISTORY_TILE_SIZE), (0, _klHistory.HISTORY_TILE_SIZE));
    const ctx = (0, _bb.BB).ctx(canvas);
    const imageData = await loadFromImageDataStore(id, ctx);
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    ctx.putImageData(imageData, 0, 0);
    return canvas;
}
async function changeRecoveryId(oldId, newId) {
    const storedProjectSerialized = await getRawRecoveryProject(oldId);
    if (!storedProjectSerialized) // nothing to do
    return false;
    storedProjectSerialized.timestamp = new Date().getTime();
    await (0, _klIndexedDb.KL_INDEXED_DB).set((0, _klIndexedDb.RECOVERY_STORE), '' + newId, storedProjectSerialized);
    await (0, _klIndexedDb.KL_INDEXED_DB).remove((0, _klIndexedDb.RECOVERY_STORE), '' + oldId);
    return true;
}
async function storeRecovery(tabId, composed, getThumbnail) {
    let orphanCandidates;
    try {
        // get thumbnail early to be accurate
        const fit = (0, _base.fitInto)(composed.size.width, composed.size.height, (0, _klRecoveryManager.RECOVERY_THUMB_WIDTH_PX), (0, _klRecoveryManager.RECOVERY_THUMB_HEIGHT_PX));
        const thumbCanvas = getThumbnail(fit.width / composed.size.width);
        const sortedComposedLayers = Object.values(composed.layerMap).sort((0, _sortLayerMap.sortLayerMap));
        // make a list of existing imageData ids in A (stored project)
        const storedProjectSerialized = await (0, _base.timeoutWrapper)(getRawRecoveryProject(tabId), 'storeRecovery.getRawRecoveryProject');
        const storedImageDataIds = new Set(storedProjectSerialized?.layers.flatMap((layer)=>{
            return layer.image.map((tile)=>!(0, _klTypes.isLayerFill)(tile) ? tile.id : undefined).filter((id)=>id !== undefined);
        }));
        storedProjectSerialized && storedImageDataIds.add(storedProjectSerialized.thumbnail);
        // to help calculate updated memoryEstimateBytes
        const storedImageDataSizes = {};
        storedProjectSerialized && storedProjectSerialized.layers.forEach((layer)=>{
            layer.image.forEach((tile)=>{
                if (!(0, _klTypes.isLayerFill)(tile)) storedImageDataSizes[tile.id] = tile.sizeBytes || 0;
            });
        });
        // make a list of imageData ids in B (to be stored)
        const idsFromProject = new Set(sortedComposedLayers.flatMap((layer)=>{
            return layer.tiles.flatMap((tile)=>{
                return (0, _klTypes.isLayerFill)(tile) ? [] : [
                    tile.id
                ];
            });
        }));
        // the to delete list: not in B (aka no longer stored)
        orphanCandidates = [
            ...storedImageDataIds
        ].filter((id)=>{
            return !idsFromProject.has(id);
        });
        const layers = [];
        const imageDataList = [];
        // estimate memory
        let memoryEstimateBytes = 0;
        for (const composedLayer of sortedComposedLayers)layers.push({
            name: composedLayer.name,
            isVisible: composedLayer.isVisible,
            opacity: composedLayer.opacity,
            mixModeStr: composedLayer.mixModeStr,
            image: await (async ()=>{
                const result = [];
                for (const tile of composedLayer.tiles)if ((0, _klTypes.isLayerFill)(tile)) {
                    result.push(tile);
                    memoryEstimateBytes += tile.fill.length;
                } else {
                    let size = 0;
                    if (storedImageDataIds.has(tile.id)) size = storedImageDataSizes[tile.id];
                    else {
                        imageDataList.push({
                            id: tile.id,
                            data: tile.data
                        });
                        size = tile.data.width * tile.data.height * 4; // 4 channels, each 1 byte
                    }
                    memoryEstimateBytes += size;
                    result.push({
                        id: tile.id,
                        sizeBytes: size
                    });
                }
                return result;
            })()
        });
        const thumbImageData = {
            id: (0, _base.randomUuid)(),
            data: (()=>{
                const thumbCtx = (0, _bb.BB).ctx(thumbCanvas);
                return thumbCtx.getImageData(0, 0, thumbCanvas.width, thumbCanvas.height);
            })()
        };
        imageDataList.push(thumbImageData);
        memoryEstimateBytes += thumbImageData.data.width * thumbImageData.data.height * 4; // 4 channels, each 1 byte
        const serialized = {
            projectId: composed.projectId.value,
            width: composed.size.width,
            height: composed.size.height,
            timestamp: new Date().getTime(),
            thumbnail: thumbImageData.id,
            layers,
            memoryEstimateBytes
        };
        // check will we be over the memory limit - if so, removed oldest drawings until we won't.
        const totalExceptDrawingBytes = await (0, _base.timeoutWrapper)(getTotalMemoryExceptCurrentDrawing(tabId), 'storeRecovery.getTotalMemory');
        if (totalExceptDrawingBytes + memoryEstimateBytes > (0, _klRecoveryManager.RECOVERY_MEMORY_LIMIT_BYTES)) {
            const overLimitByBytes = totalExceptDrawingBytes + memoryEstimateBytes - (0, _klRecoveryManager.RECOVERY_MEMORY_LIMIT_BYTES);
            let toBeRemovedBytes = 0;
            const idsToRemove = [];
            const metas = (await getAllMeta()).sort((a, b)=>{
                if (a.timestamp > b.timestamp) return 1;
                if (a.timestamp < b.timestamp) return -1;
                return 0;
            });
            metas.forEach((meta)=>{
                if (toBeRemovedBytes >= overLimitByBytes) // removed enough
                return;
                idsToRemove.push(meta.id);
                toBeRemovedBytes += meta.memoryEstimateBytes;
            });
            // also make sure to remove the imagedata
            for (const id of idsToRemove)await deleteRecovery(id);
        }
        // store first. so nothing will be lost if something goes wrong
        await (0, _base.timeoutWrapper)((0, _klIndexedDb.KL_INDEXED_DB).bulkSet((0, _klIndexedDb.IMAGE_DATA_STORE), imageDataList.map((item)=>{
            return {
                key: item.id,
                value: item.data
            };
        })), 'storeRecovery.storeTile', 30000);
        await (0, _base.timeoutWrapper)((0, _klIndexedDb.KL_INDEXED_DB).set((0, _klIndexedDb.RECOVERY_STORE), '' + tabId, serialized), 'storeRecovery.storeRecovery');
    } finally{
        /*
        Orphaned tiles are possible and must be cleaned up, even if there's a timeout or other exception.
         */ await (0, _base.timeoutWrapper)(removeOrphans(orphanCandidates), 'storeRecovery.removeOrphans', 8000);
    }
}
async function deleteRecovery(id) {
    const recovery = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.RECOVERY_STORE), id);
    if (!recovery) return;
    await (0, _klIndexedDb.KL_INDEXED_DB).remove((0, _klIndexedDb.RECOVERY_STORE), id);
    const orphanCandidates = [
        recovery.thumbnail
    ];
    for (const layer of recovery.layers){
        for (const tile of layer.image)if (!(0, _klTypes.isLayerFill)(tile)) orphanCandidates.push(tile.id);
    }
    // prevent deletion of tiles referenced by multiple recoveries.
    await removeOrphans(orphanCandidates);
}
async function getAllMeta() {
    const ids = await getIdsFromRecoveryStore();
    const result = [];
    for (const id of ids)result.push(await getMetadata('' + id));
    return result;
}
async function getTotalMemoryExceptCurrentDrawing(tabId) {
    const ids = await getIdsFromRecoveryStore();
    let result = 0;
    for (const id of ids){
        if (id === tabId) continue;
        const meta = await getMetadata('' + id);
        result += meta.memoryEstimateBytes;
    }
    return result;
}
async function getMetadata(drawingId, includeThumbnail) {
    const raw = await (0, _klIndexedDb.KL_INDEXED_DB).get((0, _klIndexedDb.RECOVERY_STORE), drawingId);
    if (raw === undefined) throw new Error('drawing not found');
    const parsed = raw;
    return {
        id: drawingId,
        width: parsed.width,
        height: parsed.height,
        thumbnail: includeThumbnail ? await getThumbnail(parsed.thumbnail) : undefined,
        timestamp: parsed.timestamp,
        memoryEstimateBytes: parsed.memoryEstimateBytes
    };
}

},{"./kl-indexed-db":"iz3yu","./project-converter":"8SgmT","../kl-types":"E0RUG","../../bb/bb":"3zOvT","../history/kl-history":"l5YQK","../history/sort-layer-map":"cIR0B","../../bb/base/base":"it3mQ","./kl-recovery-manager":"htaZX","./project-store":"6Zcnn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"czgd6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * broadcast channel with local storage fallback
 */ parcelHelpers.export(exports, "CrossTabChannel", ()=>CrossTabChannel);
var _localStorage = require("./local-storage");
var _base = require("./base");
const originId = (0, _base.randomUuid)();
class CrossTabChannel {
    getLsKey() {
        return this.localStoragePrefix + this.name;
    }
    // ----------------------------------- public ----------------------------------
    constructor(name){
        this.name = name;
        this.broadcastChannelListeners = [];
        this.lastReadTimestamp = new Date().getTime();
        this.maxAgeMs = 10000;
        this.localStoragePrefix = 'cross-tab-channel--';
        this.localStorageListeners = new Set();
        this.onLocalStorageChange = (e)=>{
            if (e.key !== this.getLsKey() || e.newValue === null) // case 1: irrelevant key changed
            // case 2: null means no new message
            // -> noop
            return;
            try {
                const entries = JSON.parse(e.newValue);
                entries.forEach((entry)=>{
                    if (entry.originId === originId || entry.timestamp <= this.lastReadTimestamp) // ignore messages from our own tab, or that aren't new
                    return;
                    this.lastReadTimestamp = entry.timestamp;
                    this.localStorageListeners.forEach((listener)=>listener(entry.message));
                });
            } catch (error) {
                // probably invalid value -> reset
                (0, _localStorage.LocalStorage).removeItem(this.getLsKey());
            }
        };
        if (typeof BroadcastChannel !== 'undefined') this.broadcastChannel = new BroadcastChannel(name);
    }
    postMessage(message) {
        if (this.broadcastChannel) this.broadcastChannel.postMessage(message);
        else {
            const now = new Date().getTime();
            let raw = null;
            try {
                raw = (0, _localStorage.LocalStorage).getItem(this.getLsKey());
            } catch (error) {
            // probably invalid value -> reset
            }
            let entries = raw === null ? [] : JSON.parse(raw);
            entries = entries.filter((entry)=>{
                // delete old entries
                return entry.timestamp > now - this.maxAgeMs;
            });
            entries.push({
                timestamp: now,
                originId,
                message
            });
            (0, _localStorage.LocalStorage).setItem(this.getLsKey(), JSON.stringify(entries));
        }
    }
    subscribe(listener) {
        if (this.broadcastChannel) {
            const preListener = (message)=>listener(message.data);
            this.broadcastChannelListeners.push({
                preListener,
                listener
            });
            this.broadcastChannel.addEventListener('message', preListener);
        } else {
            if (this.localStorageListeners.size === 0) window.addEventListener('storage', this.onLocalStorageChange);
            this.localStorageListeners.add(listener);
        }
    }
    unsubscribe(listener) {
        if (this.broadcastChannel) {
            const match = this.broadcastChannelListeners.find((item)=>item.listener === listener);
            if (match) this.broadcastChannel.removeEventListener('message', match.preListener);
        } else {
            this.localStorageListeners.delete(listener);
            if (this.localStorageListeners.size === 0) window.removeEventListener('storage', this.onLocalStorageChange);
        }
    }
    close() {
        if (this.broadcastChannel) this.broadcastChannel.close();
    }
}

},{"./local-storage":"itqB1","./base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5s8aN":[function(require,module,exports,__globalThis) {
module.exports["preview"] = `-c3MRW_preview`;

},{}],"4Ybt5":[function(require,module,exports,__globalThis) {
module.exports["recoveryBubble"] = `Tt6aiG_recoveryBubble`;

},{}],"deEWV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EditUi", ()=>EditUi);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _language = require("../../../language/language");
var _sharedFx = require("../../../fx-canvas/shared-fx");
var _c = require("../../../bb/base/c");
var _copySvg = require("url:/src/app/img/ui/copy.svg");
var _copySvgDefault = parcelHelpers.interopDefault(_copySvg);
var _ui = require("../../../bb/base/ui");
class EditUi {
    testHasWebGL() {
        return !!(0, _sharedFx.getSharedFx)();
    }
    init() {
        const filters = (0, _kl.KL).FILTER_LIB;
        const buttons = [];
        if (!(0, _kl.KL).FILTER_LIB_STATUS.isLoaded) throw new Error('filters not loaded');
        const hasWebGL = this.testHasWebGL();
        if (!hasWebGL) {
            const note = (0, _bb.BB).el({
                parent: this.rootEl,
                className: 'kl-toolspace-note',
                content: 'Features disabled because WebGL is failing.',
                css: {
                    margin: '10px',
                    marginBottom: '0'
                }
            });
            const noteButton = (0, _bb.BB).el({
                parent: note,
                tagName: 'button',
                textContent: 'Learn More',
                css: {
                    marginLeft: '5px'
                }
            });
            noteButton.onclick = ()=>{
                (0, _kl.KL).popup({
                    target: this.klRootEl,
                    message: '<b>WebGL is not working</b>',
                    div: (0, _bb.BB).el({
                        content: `
See if your browser supports WebGL and has it enabled: <a href="https://get.webgl.org" target="_blank" rel="noopener noreferrer">get.webgl.org</a><br>
<br>
Recently (2023-05) a number of Chrome users on Chrome OS reported that WebGL fails, although it is enabled & supported.
This has been reported to Google.
`
                    }),
                    buttons: [
                        'Ok'
                    ],
                    clickOnEnter: 'Ok'
                });
            };
        }
        const createButton = (filterKey)=>{
            const filter = filters[filterKey];
            const button = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button grid-button--filter',
                content: [
                    (0, _ui.createImage)({
                        alt: 'icon',
                        src: filter.icon,
                        width: 18,
                        height: 20,
                        className: filter.darkNoInvert ? 'dark-no-invert' : '',
                        css: {
                            marginRight: '3px'
                        }
                    }),
                    (0, _language.LANG)(filter.lang.button)
                ],
                css: {
                    lineHeight: '20px',
                    fontSize: '12px'
                },
                custom: {
                    tabIndex: '-1'
                }
            });
            const filterName = (0, _language.LANG)(filter.lang.name);
            let isEnabled = true;
            if (filter.webGL && !hasWebGL) isEnabled = false;
            if (isEnabled) button.onclick = ()=>{
                this.applyUncommitted();
                const dialogButtons = [
                    'Ok',
                    'Cancel'
                ];
                const finishedDialog = (result, filterDialog)=>{
                    if ('error' in filterDialog) return;
                    if (result == 'Cancel') {
                        if (filterDialog.destroy) filterDialog.destroy();
                        return;
                    }
                    let input;
                    try {
                        input = filterDialog.getInput(); // also destroys
                    } catch (e) {
                        if (e.message.indexOf('.getInput is not a function') !== -1) throw 'filterDialog.getInput is not a function, filter: ' + filterName;
                        else throw e;
                    }
                    applyFilter(input);
                };
                if (!('apply' in filters[filterKey])) {
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        message: 'Application not fully loaded',
                        type: 'error'
                    });
                    return;
                }
                const applyFilter = (input)=>{
                    const filterResult = filters[filterKey].apply({
                        layer: this.getCurrentLayer(),
                        klCanvas: this.klCanvas,
                        klHistory: this.klHistory,
                        input: input
                    });
                    if (!filterResult) (0, _kl.KL).popup({
                        target: this.klRootEl,
                        message: "Couldn't apply the edit action",
                        type: 'error'
                    });
                    filters[filterKey].updatePos && this.onCanvasChanged();
                    this.layersUi.update();
                };
                if (filters[filterKey].isInstant) {
                    button.blur();
                    applyFilter(null);
                    this.statusOverlay.out('"' + filterName + '" ' + (0, _language.LANG)('filter-applied'), true);
                } else {
                    const secondaryColorRGB = this.klColorSlider.getSecondaryRGB();
                    let filterDialog = undefined;
                    try {
                        filterDialog = filters[filterKey].getDialog({
                            context: this.getCurrentLayer().context,
                            klCanvas: this.klCanvas,
                            maxWidth: this.maxCanvasSize,
                            maxHeight: this.maxCanvasSize,
                            currentColorRgb: {
                                r: this.getCurrentColor().r,
                                g: this.getCurrentColor().g,
                                b: this.getCurrentColor().b
                            },
                            secondaryColorRgb: {
                                r: secondaryColorRGB.r,
                                g: secondaryColorRGB.g,
                                b: secondaryColorRGB.b
                            },
                            composed: this.klHistory.getComposed()
                        });
                    } catch (e) {
                        setTimeout(()=>{
                            throw e;
                        });
                    }
                    if (!filterDialog || 'error' in filterDialog) {
                        (0, _kl.KL).popup({
                            target: this.klRootEl,
                            message: filterDialog ? filterDialog.error : 'Error: Could not perform action.',
                            type: 'error'
                        });
                        return;
                    }
                    let closeFunc;
                    // Todo should move into getDialogParams
                    filterDialog.errorCallback = (e)=>{
                        (0, _kl.KL).popup({
                            target: this.klRootEl,
                            message: 'Error: Could not perform action.',
                            type: 'error'
                        });
                        setTimeout(()=>{
                            throw e;
                        }, 0);
                        closeFunc();
                    };
                    const style = {};
                    if ('width' in filterDialog) style.width = filterDialog.width + 'px';
                    let title;
                    {
                        const els = [
                            (0, _c.c)('b', filterName)
                        ];
                        if (filter.lang.description !== undefined) els.push((0, _c.c)({
                            className: 'kl-info-btn',
                            onClick: ()=>{
                                (0, _kl.KL).popup({
                                    target: this.klRootEl,
                                    message: (0, _language.LANG)(filter.lang.description)
                                });
                            },
                            title: (0, _language.LANG)(filter.lang.description),
                            noRef: true
                        }, '?'));
                        title = (0, _c.c)(',flex,gap-5', els);
                    }
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        message: title,
                        div: filterDialog.element,
                        style: style,
                        buttons: dialogButtons,
                        clickOnEnter: 'Ok',
                        callback: (result)=>{
                            finishedDialog(result, filterDialog);
                        },
                        closeFunc: (func)=>{
                            closeFunc = func;
                        }
                    });
                }
            };
            else button.disabled = true;
            buttons.push(button);
            return button;
        };
        const addGroup = (groupArr)=>{
            Object.entries(filters).forEach(([filterKey, filter])=>{
                if (!groupArr.includes(filterKey)) return;
                if (this.isEmbed && !filter.inEmbed) return;
                this.rootEl.append(createButton(filterKey));
            });
        };
        const groupA = [
            'cropExtend',
            'flip',
            'perspective',
            'resize',
            'rotate',
            'transform'
        ];
        const groupB = [
            'brightnessContrast',
            'curves',
            'distort',
            'hueSaturation',
            'invert',
            'tiltShift',
            'toAlpha',
            'blur',
            'unsharpMask'
        ];
        const groupC = [
            'grid',
            'noise',
            'pattern',
            'vanishPoint'
        ];
        if (!this.isEmbed) {
            const copyBtn = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button grid-button--filter',
                content: [
                    (0, _ui.createImage)({
                        alt: 'icon',
                        src: (0, _copySvgDefault.default),
                        width: 18,
                        height: 20,
                        css: {
                            marginRight: '3px'
                        }
                    }),
                    (0, _language.LANG)('file-copy')
                ],
                onClick: ()=>this.onCopyToClipboard(),
                title: (0, _language.LANG)('file-copy-title'),
                custom: {
                    tabIndex: '-1'
                },
                css: {
                    lineHeight: '20px'
                }
            });
            const pasteBtn = (0, _bb.BB).el({
                tagName: 'button',
                className: 'grid-button grid-button--filter',
                content: [
                    (0, _bb.BB).el({
                        css: {
                            height: '20px',
                            cssFloat: 'left'
                        }
                    }),
                    (0, _language.LANG)('file-paste')
                ],
                custom: {
                    tabIndex: '-1'
                },
                css: {
                    lineHeight: '20px'
                },
                onClick: ()=>this.onPaste()
            });
            this.rootEl.append(copyBtn, pasteBtn, (0, _bb.BB).el({
                className: 'grid-hr'
            }));
        }
        addGroup(groupA);
        this.rootEl.append((0, _bb.BB).el({
            className: 'grid-hr'
        }));
        addGroup(groupB);
        this.rootEl.append((0, _bb.BB).el({
            className: 'grid-hr'
        }));
        addGroup(groupC);
        this.isInit = true;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isInit = false;
        this.klRootEl = p.klRootEl;
        this.klColorSlider = p.klColorSlider;
        this.layersUi = p.layersUi;
        this.getCurrentColor = p.getCurrentColor;
        this.maxCanvasSize = p.maxCanvasSize;
        this.klCanvas = p.klCanvas;
        this.getCurrentLayer = p.getCurrentLayer;
        this.isEmbed = p.isEmbed;
        this.statusOverlay = p.statusOverlay;
        this.onCanvasChanged = p.onCanvasChanged;
        this.applyUncommitted = p.applyUncommitted;
        this.klHistory = p.klHistory;
        this.onCopyToClipboard = p.onCopyToClipboard;
        this.onPaste = p.onPaste;
        this.rootEl = (0, _bb.BB).el();
    }
    getElement() {
        return this.rootEl;
    }
    show() {
        if (!this.isInit) this.init();
        this.rootEl.style.display = 'block';
    }
    hide() {
        this.rootEl.style.display = 'none';
    }
}

},{"../../../bb/bb":"3zOvT","../../kl":"lHQKw","../../../language/language":"mcywn","../../../fx-canvas/shared-fx":"agFAL","../../../bb/base/c":"3KmDH","url:/src/app/img/ui/copy.svg":"9BQWG","../../../bb/base/ui":"5dJJW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"agFAL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSharedFx", ()=>getSharedFx);
var _fxCanvas = require("./fx-canvas");
let failed = false;
let fx = null;
function getSharedFx() {
    // failed previously, don't need to try again.
    if (failed) return fx;
    if (!fx || fx._.gl.isContextLost()) try {
        fx = (0, _fxCanvas.fxCanvas)();
    } catch (e) {
        failed = true;
        fx = null;
        setTimeout(()=>{
            throw e;
        });
    }
    return fx;
}

},{"./fx-canvas":"fJJDu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fJJDu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fxCanvas", ()=>fxCanvas);
var _brightnessContrast = require("./filters/brightness-contrast");
var _fxShader = require("./core/fx-shader");
var _gl = require("./core/gl");
var _fxTexture = require("./core/fx-texture");
var _curves = require("./filters/curves");
var _hueSaturation = require("./filters/hue-saturation");
var _noise = require("./filters/noise");
var _triangleBlur = require("./filters/triangle-blur");
var _tiltShift = require("./filters/tilt-shift");
var _matrixWarp = require("./filters/matrix-warp");
var _unsharpMask = require("./filters/unsharp-mask");
var _toAlpha = require("./filters/to-alpha");
var _invert = require("./filters/invert");
var _perspective = require("./filters/perspective");
var _unmultiplyAlpha = require("./filters/unmultiply-alpha");
var _distort = require("./filters/distort");
var _multiplyAlpha = require("./filters/multiply-alpha");
var _bb = require("../bb/bb");
var _mask = require("./filters/mask");
const fxCanvas = function() {
    function wrapTexture(texture) {
        return {
            _: texture,
            loadContentsOf: function(element) {
                // Make sure that we're using the correct global WebGL context
                (0, _gl.setGl)(this._.gl);
                this._.loadContentsOf(element);
            },
            destroy: function() {
                // Make sure that we're using the correct global WebGL context
                (0, _gl.setGl)(this._.gl);
                this._.destroy();
            }
        };
    }
    function texture(element) {
        return wrapTexture((0, _fxTexture.FxTexture).fromElement(element));
    }
    function getTextureType() {
        let textureType = (0, _gl.gl).UNSIGNED_BYTE;
        // Go for floating point buffer textures if we can, it'll make the bokeh
        // filter look a lot better. Note that on Windows, ANGLE does not let you
        // render to a floating-point texture when linear filtering is enabled.
        // See http://crbug.com/172278 for more information.
        if ((0, _gl.gl).getExtension('WEBGL_color_buffer_float') && // firefox shows warning without this line
        (0, _gl.gl).getExtension('OES_texture_float') && (0, _gl.gl).getExtension('OES_texture_float_linear')) {
            const testTexture = new (0, _fxTexture.FxTexture)(100, 100, (0, _gl.gl).RGBA, (0, _gl.gl).FLOAT);
            try {
                // Only use gl.FLOAT if we can render to it
                testTexture.drawTo(function() {
                    textureType = (0, _gl.gl).FLOAT;
                });
            } catch (e) {
            /* empty */ }
            testTexture.destroy();
        }
        return textureType;
    }
    function initialize(width, height) {
        const textureType = getTextureType();
        if (this._.texture) this._.texture.destroy();
        if (this._.spareTexture) this._.spareTexture.destroy();
        this.width = width;
        this.height = height;
        this._.texture = new (0, _fxTexture.FxTexture)(width, height, (0, _gl.gl).RGBA, textureType);
        this._.spareTexture = new (0, _fxTexture.FxTexture)(width, height, (0, _gl.gl).RGBA, textureType);
        this._.extraTexture = this._.extraTexture || new (0, _fxTexture.FxTexture)(0, 0, (0, _gl.gl).RGBA, textureType);
        this._.flippedShader = this._.flippedShader || new (0, _fxShader.FxShader)(null, `
uniform sampler2D texture;
varying vec2 texCoord;
void main() {
    gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));
}
        `, 'flippedShader');
        this._.isInitialized = true;
    }
    function draw(texture, width, height) {
        if (!this._.isInitialized || texture._.width != this.width || texture._.height != this.height) initialize.call(this, width ? width : texture._.width, height ? height : texture._.height);
        texture._.use();
        this._.texture.drawTo(function() {
            (0, _fxShader.FxShader).getDefaultShader().drawRect();
        });
        return this;
    }
    function update() {
        this._.texture.use();
        this._.flippedShader.drawRect();
        return this;
    }
    function contents() {
        const texture = new (0, _fxTexture.FxTexture)(this._.texture.width, this._.texture.height, (0, _gl.gl).RGBA, (0, _gl.gl).UNSIGNED_BYTE);
        this._.texture.use();
        texture.drawTo(function() {
            (0, _fxShader.FxShader).getDefaultShader().drawRect();
        });
        return wrapTexture(texture);
    }
    /*
       Get a Uint8 array of pixel values: [r, g, b, a, r, g, b, a, ...]
       Length of the array will be width * height * 4.
    */ function getPixelArray() {
        const w = this._.texture.width;
        const h = this._.texture.height;
        const array = new Uint8Array(w * h * 4);
        this._.texture.drawTo(function() {
            (0, _gl.gl).readPixels(0, 0, w, h, (0, _gl.gl).RGBA, (0, _gl.gl).UNSIGNED_BYTE, array);
        });
        return array;
    }
    function wrap(fn) {
        return function(...args) {
            // Make sure that we're using the correct global WebGL context
            (0, _gl.setGl)(this._.gl);
            // Now that the context has been switched, we can call the wrapped function
            return fn.apply(this, args);
        };
    }
    function getWebGlContext(canvas, options) {
        const contextNames = [
            'webgl',
            'experimental-webgl',
            'webgl2'
        ];
        let context = null;
        contextNames.forEach((name)=>{
            if (context) return;
            // get.webgl.org does a try-catch
            try {
                context = canvas.getContext(name, options);
            } catch (e) {
            /* empty */ }
        });
        return context;
    }
    return ()=>{
        if (!window.WebGLRenderingContext) throw 'WebGLRenderingContext not set. Browser does not support WebGL.';
        const canvas = (0, _bb.BB).canvas(1, 1);
        const context = getWebGlContext(canvas, {
            premultipliedAlpha: false
        });
        if (!context) throw 'This browser does not support WebGL';
        (0, _gl.setGl)(context);
        canvas._ = {
            gl: (0, _gl.gl),
            isInitialized: false,
            texture: null,
            spareTexture: null,
            flippedShader: null
        };
        // Core methods
        canvas.texture = wrap(texture);
        canvas.initialize = wrap(initialize);
        canvas.draw = wrap(draw);
        canvas.update = wrap(update);
        canvas.contents = wrap(contents);
        canvas.getPixelArray = wrap(getPixelArray);
        // Filter methods
        canvas.brightnessContrast = wrap((0, _brightnessContrast.brightnessContrast));
        canvas.hueSaturation = wrap((0, _hueSaturation.hueSaturation));
        canvas.triangleBlur = wrap((0, _triangleBlur.triangleBlur));
        canvas.unsharpMask = wrap((0, _unsharpMask.unsharpMask));
        canvas.perspective = wrap((0, _perspective.perspective));
        canvas.matrixWarp = wrap((0, _matrixWarp.matrixWarp));
        canvas.tiltShift = wrap((0, _tiltShift.tiltShift));
        canvas.noise = wrap((0, _noise.noise));
        canvas.curves = wrap((0, _curves.curves));
        canvas.invert = wrap((0, _invert.invert));
        canvas.multiplyAlpha = wrap((0, _multiplyAlpha.multiplyAlpha));
        canvas.unmultiplyAlpha = wrap((0, _unmultiplyAlpha.unmultiplyAlpha));
        canvas.toAlpha = wrap((0, _toAlpha.toAlpha));
        canvas.distort = wrap((0, _distort.distort));
        canvas.mask = wrap((0, _mask.mask));
        return canvas;
    };
}();

},{"./filters/brightness-contrast":"87mGA","./core/fx-shader":"hwJnV","./core/gl":"g5PuJ","./core/fx-texture":"4Y51M","./filters/curves":"5dkDC","./filters/hue-saturation":"4mVdX","./filters/noise":"f8fKq","./filters/triangle-blur":"c8CNI","./filters/tilt-shift":"17AcX","./filters/matrix-warp":"bGzpO","./filters/unsharp-mask":"TYEfm","./filters/to-alpha":"65OZL","./filters/invert":"bg4OA","./filters/perspective":"5Tlry","./filters/unmultiply-alpha":"Udxwr","./filters/distort":"4JP4W","./filters/multiply-alpha":"butIc","../bb/bb":"3zOvT","./filters/mask":"gbuqp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"87mGA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brightnessContrast", ()=>brightnessContrast);
var _bb = require("../../bb/bb");
var _simpleShader = require("../core/simple-shader");
var _fxShader = require("../core/fx-shader");
var _gl = require("../core/gl");
const brightnessContrast = function(brightness, contrast) {
    (0, _gl.gl).brightnessContrast = (0, _gl.gl).brightnessContrast || new (0, _fxShader.FxShader)(null, '\
        uniform sampler2D texture;\
        uniform float brightness;\
        uniform float contrast;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color.rgb += brightness;\
            if (contrast > 0.0) {\
                color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\
            } else {\
                color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;\
            }\
            gl_FragColor = clamp(color, 0.0, 1.0);\
        }\
    ', 'brightnessContrast');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).brightnessContrast, {
        brightness: (0, _bb.BB).clamp(brightness, -1, 1),
        contrast: (0, _bb.BB).clamp(contrast, -1, 1)
    });
    return this;
};

},{"../../bb/bb":"3zOvT","../core/simple-shader":"nkbUU","../core/fx-shader":"hwJnV","../core/gl":"g5PuJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"nkbUU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "simpleShader", ()=>simpleShader);
function simpleShader(shader, uniforms, textureIn, textureOut) {
    (textureIn || this._.texture).use();
    this._.spareTexture.drawTo(function() {
        shader.uniforms(uniforms).drawRect();
    });
    this._.spareTexture.swapWith(textureOut || this._.texture);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hwJnV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FxShader", ()=>FxShader);
var _gl = require("./gl");
var _bb = require("../../bb/bb");
const defaultVertexSource = '\
    attribute vec2 vertex;\
    attribute vec2 _texCoord;\
    varying vec2 texCoord;\
    void main() {\
        texCoord = _texCoord;\
        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);\
    }';
const defaultFragmentSource = '\
    uniform sampler2D texture;\
    varying vec2 texCoord;\
    void main() {\
        gl_FragColor = texture2D(texture, texCoord);\
    }';
function isArray(obj) {
    return Object.prototype.toString.call(obj) == '[object Array]';
}
function isNumber(obj) {
    return Object.prototype.toString.call(obj) == '[object Number]';
}
let floatPrecision;
class FxShader {
    // ---- static ----
    static getDefaultShader() {
        (0, _gl.gl).defaultShader = (0, _gl.gl).defaultShader || new FxShader();
        return (0, _gl.gl).defaultShader;
    }
    // ---- private ----
    compileSource(type, source, nameStr) {
        const shader = (0, _bb.BB).throwIfNull((0, _gl.gl).createShader(type));
        (0, _gl.gl).shaderSource(shader, source.replace(/#define.*/, '')); // glslify adds a line add the beginning that breaks it
        (0, _gl.gl).compileShader(shader);
        if (!(0, _gl.gl).getShaderParameter(shader, (0, _gl.gl).COMPILE_STATUS)) throw 'compile error: ' + nameStr + ' - ' + (0, _gl.gl).getShaderInfoLog(shader);
        return shader;
    }
    /**
     * HIGH_FLOAT | MEDIUM_FLOAT
     */ testPrecisionSupport(precisionType) {
        const format = (0, _gl.gl).getShaderPrecisionFormat((0, _gl.gl).FRAGMENT_SHADER, precisionType);
        return format !== null && format.precision !== 0;
    }
    // ----------------------------------- public -----------------------------------
    constructor(vertexSource, fragmentSource, nameStr){
        this.vertexAttribute = null;
        this.texCoordAttribute = null;
        this.program = (0, _bb.BB).throwIfNull((0, _gl.gl).createProgram());
        vertexSource = vertexSource || defaultVertexSource;
        fragmentSource = fragmentSource || defaultFragmentSource;
        if (!floatPrecision) floatPrecision = this.testPrecisionSupport((0, _gl.gl).HIGH_FLOAT) ? 'highp' : this.testPrecisionSupport((0, _gl.gl).MEDIUM_FLOAT) ? 'mediump' : 'lowp';
        fragmentSource = 'precision ' + floatPrecision + ' float;' + fragmentSource; // annoying requirement is annoying
        (0, _gl.gl).attachShader(this.program, this.compileSource((0, _gl.gl).VERTEX_SHADER, vertexSource, nameStr + '(vertex)'));
        (0, _gl.gl).attachShader(this.program, this.compileSource((0, _gl.gl).FRAGMENT_SHADER, fragmentSource, nameStr + '(fragment)'));
        (0, _gl.gl).linkProgram(this.program);
        if (!(0, _gl.gl).getProgramParameter(this.program, (0, _gl.gl).LINK_STATUS)) throw 'link error: ' + (0, _gl.gl).getProgramInfoLog(this.program);
    }
    destroy() {
        (0, _gl.gl).deleteProgram(this.program);
        this.program = null;
    }
    uniforms(uniforms) {
        (0, _gl.gl).useProgram(this.program);
        Object.entries(uniforms).forEach(([name, value])=>{
            const location = (0, _gl.gl).getUniformLocation(this.program, name);
            if (location === null) // will be null if the uniform isn't used in the shader
            return;
            if (isArray(value)) switch(value.length){
                case 1:
                    (0, _gl.gl).uniform1fv(location, new Float32Array(value));
                    break;
                case 2:
                    (0, _gl.gl).uniform2fv(location, new Float32Array(value));
                    break;
                case 3:
                    (0, _gl.gl).uniform3fv(location, new Float32Array(value));
                    break;
                case 4:
                    (0, _gl.gl).uniform4fv(location, new Float32Array(value));
                    break;
                case 9:
                    (0, _gl.gl).uniformMatrix3fv(location, false, new Float32Array(value));
                    break;
                case 16:
                    (0, _gl.gl).uniformMatrix4fv(location, false, new Float32Array(value));
                    break;
                default:
                    throw 'dont\'t know how to load uniform "' + name + '" of length ' + value.length;
            }
            else if (isNumber(value)) (0, _gl.gl).uniform1f(location, value);
            else throw 'attempted to set uniform "' + name + '" to invalid value ' + (value || 'undefined').toString();
        });
        // allow chaining
        return this;
    }
    //
    /**
     * textures are uniforms too but for some reason can't be specified by gl.uniform1f,
     * even though floating point numbers represent the integers 0 through 7 exactly
     */ textures(textures) {
        (0, _gl.gl).useProgram(this.program);
        Object.entries(textures).forEach(([name, value])=>{
            (0, _gl.gl).uniform1i((0, _gl.gl).getUniformLocation(this.program, name), value);
        });
        // allow chaining
        return this;
    }
    drawRect(left, top, right, bottom) {
        let undefined;
        const viewport = (0, _gl.gl).getParameter((0, _gl.gl).VIEWPORT);
        top = top !== undefined ? (top - viewport[1]) / viewport[3] : 0;
        left = left !== undefined ? (left - viewport[0]) / viewport[2] : 0;
        right = right !== undefined ? (right - viewport[0]) / viewport[2] : 1;
        bottom = bottom !== undefined ? (bottom - viewport[1]) / viewport[3] : 1;
        if ((0, _gl.gl).vertexBuffer === undefined || (0, _gl.gl).vertexBuffer === null) (0, _gl.gl).vertexBuffer = (0, _bb.BB).throwIfNull((0, _gl.gl).createBuffer());
        (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).vertexBuffer);
        (0, _gl.gl).bufferData((0, _gl.gl).ARRAY_BUFFER, new Float32Array([
            left,
            top,
            left,
            bottom,
            right,
            top,
            right,
            bottom
        ]), (0, _gl.gl).STATIC_DRAW);
        if ((0, _gl.gl).texCoordBuffer == null) {
            (0, _gl.gl).texCoordBuffer = (0, _bb.BB).throwIfNull((0, _gl.gl).createBuffer());
            (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).texCoordBuffer);
            (0, _gl.gl).bufferData((0, _gl.gl).ARRAY_BUFFER, new Float32Array([
                0,
                0,
                0,
                1,
                1,
                0,
                1,
                1
            ]), (0, _gl.gl).STATIC_DRAW);
        }
        if (this.vertexAttribute == null) {
            this.vertexAttribute = (0, _gl.gl).getAttribLocation(this.program, 'vertex');
            (0, _gl.gl).enableVertexAttribArray(this.vertexAttribute);
        }
        if (this.texCoordAttribute == null) {
            this.texCoordAttribute = (0, _gl.gl).getAttribLocation(this.program, '_texCoord');
            (0, _gl.gl).enableVertexAttribArray(this.texCoordAttribute);
        }
        (0, _gl.gl).useProgram(this.program);
        (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).vertexBuffer);
        (0, _gl.gl).vertexAttribPointer(this.vertexAttribute, 2, (0, _gl.gl).FLOAT, false, 0, 0);
        (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).texCoordBuffer);
        (0, _gl.gl).vertexAttribPointer(this.texCoordAttribute, 2, (0, _gl.gl).FLOAT, false, 0, 0);
        (0, _gl.gl).drawArrays((0, _gl.gl).TRIANGLE_STRIP, 0, 4);
    }
}

},{"./gl":"g5PuJ","../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g5PuJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gl", ()=>gl);
parcelHelpers.export(exports, "setGl", ()=>setGl);
let gl;
function setGl(newGl) {
    // more problems setting type to null
    gl = newGl;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Y51M":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FxTexture", ()=>FxTexture);
var _gl = require("./gl");
var _bb = require("../../bb/bb");
class FxTexture {
    // ---- static ----
    static fromElement(element) {
        const texture = new FxTexture(0, 0, (0, _gl.gl).RGBA, (0, _gl.gl).UNSIGNED_BYTE);
        texture.loadContentsOf(element);
        return texture;
    }
    /*
    // never seen this being used
    private getCanvas(texture: Texture): CanvasRenderingContext2D {
        if (this.canvas == null) {
            this.canvas = BB.canvas(texture.width, texture.height);
        }
        this.canvas.width = texture.width;
        this.canvas.height = texture.height;
        const c = BB.ctx(this.canvas);
        c.clearRect(0, 0, this.canvas.width, this.canvas.height);
        return c;
    }*/ // ----------------------------------- public -----------------------------------
    constructor(width, height, format, type){
        this.gl = (0, _gl.gl);
        this.id = (0, _bb.BB).throwIfNull((0, _gl.gl).createTexture());
        this.width = width;
        this.height = height;
        this.format = format;
        this.type = type;
        this.canvas = null;
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_MAG_FILTER, (0, _gl.gl).LINEAR);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_MIN_FILTER, (0, _gl.gl).LINEAR);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_WRAP_S, (0, _gl.gl).CLAMP_TO_EDGE);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_WRAP_T, (0, _gl.gl).CLAMP_TO_EDGE);
        if (width && height) (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
    }
    loadContentsOf(element) {
        this.width = element.width || element.videoWidth;
        this.height = element.height || element.videoHeight;
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
        (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, this.format, this.format, this.type, element);
    }
    initFromBytes(width, height, data) {
        this.width = width;
        this.height = height;
        this.format = (0, _gl.gl).RGBA;
        this.type = (0, _gl.gl).UNSIGNED_BYTE;
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
        (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, (0, _gl.gl).RGBA, width, height, 0, (0, _gl.gl).RGBA, this.type, new Uint8Array(data));
    }
    destroy() {
        (0, _gl.gl).deleteTexture(this.id);
        this.id = null;
    }
    use(unit) {
        (0, _gl.gl).activeTexture((0, _gl.gl).TEXTURE0 + (unit || 0));
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
    }
    unuse(unit) {
        (0, _gl.gl).activeTexture((0, _gl.gl).TEXTURE0 + (unit || 0));
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, null);
    }
    ensureFormat(width, height, format, type) {
        // change the format only if required
        if (width != this.width || height != this.height || format != this.format || type != this.type) {
            this.width = width;
            this.height = height;
            this.format = format;
            this.type = type;
            (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
            (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
        }
    }
    ensureFormatViaTexture(texture) {
        this.ensureFormat(texture.width, texture.height, texture.format, texture.type);
    }
    drawTo(callback) {
        // start rendering to this texture
        (0, _gl.gl).framebuffer = (0, _gl.gl).framebuffer || (0, _gl.gl).createFramebuffer();
        (0, _gl.gl).bindFramebuffer((0, _gl.gl).FRAMEBUFFER, (0, _gl.gl).framebuffer);
        (0, _gl.gl).framebufferTexture2D((0, _gl.gl).FRAMEBUFFER, (0, _gl.gl).COLOR_ATTACHMENT0, (0, _gl.gl).TEXTURE_2D, this.id, 0);
        if ((0, _gl.gl).checkFramebufferStatus((0, _gl.gl).FRAMEBUFFER) !== (0, _gl.gl).FRAMEBUFFER_COMPLETE) throw new Error('incomplete framebuffer');
        (0, _gl.gl).viewport(0, 0, this.width, this.height);
        // do the drawing
        callback();
        // stop rendering to this texture
        (0, _gl.gl).bindFramebuffer((0, _gl.gl).FRAMEBUFFER, null);
    }
    /*
    // never seen this being used
    fillUsingCanvas (callback: (canvas: CanvasRenderingContext2D) => void): Texture {
        callback(this.getCanvas(this));
        this.format = gl.RGBA;
        this.type = gl.UNSIGNED_BYTE;
        gl.bindTexture(gl.TEXTURE_2D, this.id);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);
        return this;
    }

    // never seen this being used
    toImage (image: HTMLImageElement): void {
        this.use();
        Shader.getDefaultShader().drawRect();
        const size = this.width * this.height * 4;
        const pixels = new Uint8Array(size);
        const c = this.getCanvas(this);
        const data = c.createImageData(this.width, this.height);
        gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        for (let i = 0; i < size; i++) {
            data.data[i] = pixels[i];
        }
        c.putImageData(data, 0, 0);
        image.src = this.canvas.toDataURL();
    }
     */ swapWith(other) {
        let temp;
        temp = other.id;
        other.id = this.id;
        this.id = temp;
        temp = other.width;
        other.width = this.width;
        this.width = temp;
        temp = other.height;
        other.height = this.height;
        this.height = temp;
        temp = other.format;
        other.format = this.format;
        this.format = temp;
    // type?
    }
}

},{"./gl":"g5PuJ","../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5dkDC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "curves", ()=>curves);
var _splineInterpolate = require("../math/spline-interpolate");
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const curves = function(red, green, blue) {
    // Create the ramp texture
    const redRamp = (0, _splineInterpolate.splineInterpolate)(red);
    const greenRamp = (0, _splineInterpolate.splineInterpolate)(green);
    const blueRamp = (0, _splineInterpolate.splineInterpolate)(blue);
    const array = [];
    for(let i = 0; i < 256; i++)array.splice(array.length, 0, redRamp[i], greenRamp[i], blueRamp[i], 255);
    this._.extraTexture.initFromBytes(256, 1, array);
    this._.extraTexture.use(1);
    (0, _gl.gl).curves = (0, _gl.gl).curves || new (0, _fxShader.FxShader)(null, '\
        uniform sampler2D texture;\
        uniform sampler2D map;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color.r = texture2D(map, vec2(color.r)).r;\
            color.g = texture2D(map, vec2(color.g)).g;\
            color.b = texture2D(map, vec2(color.b)).b;\
            gl_FragColor = color;\
        }\
    ', 'curves');
    (0, _gl.gl).curves.textures({
        map: 1
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).curves, {});
    return this;
};

},{"../math/spline-interpolate":"amV6W","../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"amV6W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "splineInterpolate", ()=>splineInterpolate);
var _bb = require("../../bb/bb");
function splineInterpolate(points) {
    const interpolator = new (0, _bb.BB).SplineInterpolator(points);
    const array = [];
    for(let i = 0; i < 256; i++)array.push((0, _bb.BB).clamp(Math.floor(interpolator.interpolate(i / 255) * 256), 0, 255));
    return array;
}

},{"../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4mVdX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hueSaturation", ()=>hueSaturation);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
var _bb = require("../../bb/bb");
const hueSaturation = function(hue, saturation) {
    (0, _gl.gl).hueSaturation = (0, _gl.gl).hueSaturation || new (0, _fxShader.FxShader)(null, '\
        uniform sampler2D texture;\
        uniform float hue;\
        uniform float saturation;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            /* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */\
            float angle = hue * 3.14159265;\
            float s = sin(angle), c = cos(angle);\
            vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\
            float len = length(color.rgb);\
            color.rgb = vec3(\
                dot(color.rgb, weights.xyz),\
                dot(color.rgb, weights.zxy),\
                dot(color.rgb, weights.yzx)\
            );\
            \
            /* saturation adjustment */\
            float average = (color.r + color.g + color.b) / 3.0;\
            if (saturation > 0.0) {\
                color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));\
            } else {\
                color.rgb += (average - color.rgb) * (-saturation);\
            }\
            \
            gl_FragColor = color;\
        }\
    ', 'hueSaturation');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).hueSaturation, {
        hue: (0, _bb.BB).clamp(hue, -1, 1),
        saturation: (0, _bb.BB).clamp(saturation, -1, 1)
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f8fKq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noise", ()=>noise);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
var _shaderNoiseGlsl = require("../shaders/shader-noise.glsl");
var _shaderNoiseGlslDefault = parcelHelpers.interopDefault(_shaderNoiseGlsl);
const noise = function(seed, type, scale, offset, octaves, samples, peaks, brightness, contrast, isReversed, colA, colB, channels) {
    (0, _gl.gl).noise = (0, _gl.gl).noise || new (0, _fxShader.FxShader)(null, (0, _shaderNoiseGlslDefault.default).replace(/#define.*/, ''), 'noise');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).noise, {
        seed: seed || 0,
        type,
        scale: [
            scale[0],
            scale[1]
        ],
        offset,
        octaves,
        samples,
        texSize: [
            this.width,
            this.height
        ],
        peaks,
        brightness,
        contrast,
        isReversed: isReversed ? 1.0 : 0.0,
        colA: colA ? [
            colA.r / 255,
            colA.g / 255,
            colA.b / 255
        ] : [
            0,
            0,
            0
        ],
        colB: colB ? [
            colB.r / 255,
            colB.g / 255,
            colB.b / 255
        ] : [
            1,
            1,
            1
        ],
        channels: channels === 'rgb' ? 0 : 1
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","../shaders/shader-noise.glsl":"lBRCM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lBRCM":[function(require,module,exports,__globalThis) {
module.exports = "#define GLSLIFY 1\nuniform sampler2D texture;\nvarying vec2 texCoord;\nuniform vec2 texSize;\n\nuniform float seed;\nuniform float type;\nuniform vec2 scale;\nuniform vec2 offset;\nuniform float octaves;\nuniform float samples;\n\nuniform float peaks;\nuniform float contrast;\nuniform float brightness;\nuniform float isReversed;\n\nuniform vec3 colA;\nuniform vec3 colB;\n\nuniform float channels; // 0 - rgb, 1 - alpha\n\n// fbm, cellular_noise based on\n// https://github.com/Gonkee/Gonkees-Shaders\n// MIT, Copyright \xa9 Gonkee\n\n// hash & simplex based on\n// https://www.shadertoy.com/view/Msf3WH\n// MIT, Copyright \xa9 2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat value_noise(vec2 coord){\n    return rand(floor(coord) / 100.0);\n}\n\nfloat cellular_noise(vec2 coord) {\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n\n    float min_dist = 99999.0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            vec2 node = rand(i + vec2(x, y)) + vec2(x, y);\n            float dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n            min_dist = min(min_dist, dist);\n        }\n    }\n    return min_dist;\n}\n\n// ---------- Simplex Alternative ---------------------\n\nvec3 hash(vec3 p)\n{ p=vec3(dot(p, vec3(127.1, 311.7, 74.7))\n, dot(p, vec3(269.5, 183.3, 246.1))\n, dot(p, vec3(113.5, 271.9, 124.6)))\n;return fract(sin(p)*43758.5453123)*2.-1.; }\n\nmat3 hash(mat3 p)\n{ return mat3(hash(p[0]), hash(p[1]), hash(p[2])); }\n\nvec3 dots(mat3 a, vec3 w, mat3 b){ return vec3\n(dot(a[0], w-b[0]), dot(a[1], w-b[1]), dot(a[2], w-b[2])); }\n\n//return noiseGra13dx as .x, and its derivatives as .yzw\n// https://www.shadertoy.com/view/llByD1\nvec3 noiseGra13dx(in vec3 x) {\n    vec3 p=floor(x), w=fract(x)\n    #if 1\n    , u=w*w*w*(w*(w*6.-15.)+10.), v=30.*w*w*(w*(w-2.)+1.)//quintic hermite\n    #else\n    , u=w*w*(3.-2.*w), v=6.*w*(1.-w)//cubic hermite\n    #endif\n    //gradients\n    , G=hash(p+vec3(0)), F=hash(p+vec3(1))\n    ;mat3 D=hash(mat3(p, p, p)+mat3(1)), E=hash(mat3(p, p, p)+1.-mat3(1));\n    //projections\n    vec3 d=dots(D, w, mat3(1)), e=dots(E, w, 1.-mat3(1));\n    //interpolations\n    float g=dot(G, w), f=dot(F, w-vec3(1));\n    vec3 h=u.yzx*(g-d.xyx-d.yzz+e.zxy)+d-g, U=u*h, a=d-e;\n    mat3 S=D-mat3(G, G, G), W=D-E;\n    a.x=(a.x+a.y+a.z)+f-g;\n    ;float b=u.x*u.y*u.z;\n\n    vec4 result = vec4(g+U.x+U.y+U.z+a.x*b// value\n    , G*(1.-b)+b*(W[0]+W[1]+W[2]+F)//https://www.shadertoy.com/view/llByD1\n    +u.x*(S[0]+u.y*(G-D[0]-D[1]+E[2]))// derivatives\n    +u.y*(S[1]+u.z*(G-D[1]-D[2]+E[0]))\n    +u.z*(S[2]+u.x*(G-D[0]-D[2]+E[1]))\n    +v*(u.zxy*(g-d.xxy-d.zyz+e.yzx)+h+u.yzx*u.zxy*a.x));\n    return 0.5 + 0.5 * result.xxx;\n}\n\nfloat fbm(vec2 coord) {\n    float normalize_factor = 0.0;\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (float i = 0.0; i < 7.0; i++){\n        if (i < octaves) {\n            if (type == 0.0) {\n                value += value_noise(coord) * scale;\n            } else if (type == 1.0) {\n                value += noiseGra13dx(vec3(coord.x, coord.y, 0.0)).r * scale;\n            } else if (type == 2.0) {\n                value += cellular_noise(coord) * scale;\n            }\n            normalize_factor += scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n    }\n    return value / normalize_factor;\n}\n\nfloat render (vec2 pos) {\n    float result = fbm(pos);\n    //\n\n    if (peaks > 0.0) {\n        result = abs(mod(result * peaks - 0.5, 1.0) - 0.5) * 2.0;// triangle\n        //result = mod(result * (peaks + 1.0), 1.0); // sawtooth\n    }\n\n    result += brightness;\n    if (contrast > 0.0) {\n        result = clamp((result - 0.5) / (1.0 - contrast) + 0.5, 0.0, 1.0);\n    } else if (contrast < 0.0) {\n        result = clamp((result - 0.5) * (1.0 + contrast) + 0.5, 0.0, 1.0);\n    }\n\n    if (isReversed == 1.0) {\n        result = 1.0 - result;\n    }\n    return result;\n}\n\nvoid main() {\n    vec4 color;\n\n    vec2 seedOffset;\n    seedOffset.x = (rand(vec2(seed, 0.0)) * 100.0 - 50.0);\n    seedOffset.y = (rand(vec2(0.0, seed)) * 100.0 - 50.0);\n\n    float val = 0.0;\n    vec2 basePos = texCoord * texSize / scale - offset / scale + seedOffset;\n\n    if (samples == 1.0) {\n        val = render(basePos);\n\n    }/* else if (samples == 4.0) {\n        for (float i = 0.0; i < 2.0; i++) {\n            for (float e = 0.0; e < 2.0; e++) {\n                val += render(basePos + (vec2(i, e) - 0.5) * 0.5 / scale);\n            }\n        }\n        val /= 4.0;\n\n    }*/ else if (samples == 16.0) {\n        for (float i = 0.0; i < 4.0; i++) {\n            for (float e = 0.0; e < 4.0; e++) {\n                val += render(basePos + (vec2(i, e) - 0.25) * 0.25 / scale);\n            }\n        }\n        val /= 16.0;\n    }\n\n    if (channels == 0.0) {\n        gl_FragColor = vec4(vec3(mix(colA, colB, val)), 1.0);\n    } else {\n        gl_FragColor = vec4(vec3(1.0), val);\n    }\n}";

},{}],"c8CNI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "triangleBlur", ()=>triangleBlur);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _randomShaderFunc = require("../shaders/random-shader-func");
var _simpleShader = require("../core/simple-shader");
const triangleBlur = function(radius) {
    (0, _gl.gl).triangleBlur = (0, _gl.gl).triangleBlur || new (0, _fxShader.FxShader)(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        ' + (0, _randomShaderFunc.randomShaderFunc) + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec4 sample = texture2D(texture, texCoord + delta * percent);\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
        }\
    ', 'triangleBlur');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).triangleBlur, {
        delta: [
            radius / this.width,
            0
        ]
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).triangleBlur, {
        delta: [
            0,
            radius / this.height
        ]
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../shaders/random-shader-func":"eVnGI","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eVnGI":[function(require,module,exports,__globalThis) {
// returns a random number between 0 and 1
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomShaderFunc", ()=>randomShaderFunc);
const randomShaderFunc = '\
    float random(vec3 scale, float seed) {\
        /* use the fragment position for a different seed per-pixel */\
        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\
    }\
';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"17AcX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tiltShift", ()=>tiltShift);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _randomShaderFunc = require("../shaders/random-shader-func");
var _simpleShader = require("../core/simple-shader");
const tiltShift = function(startX, startY, endX, endY, blurRadius, gradientRadius) {
    (0, _gl.gl).tiltShift = (0, _gl.gl).tiltShift || new (0, _fxShader.FxShader)(null, '\
        uniform sampler2D texture;\
        uniform float blurRadius;\
        uniform float gradientRadius;\
        uniform vec2 start;\
        uniform vec2 end;\
        uniform vec2 delta;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        ' + (0, _randomShaderFunc.randomShaderFunc) + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\
            float radius = smoothstep(0.0, 1.0, abs(dot(texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;\
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec4 sample = texture2D(texture, texCoord + delta / texSize * percent * radius);\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
        }\
    ', 'tiltShift');
    const dx = endX - startX;
    const dy = endY - startY;
    const d = Math.sqrt(dx * dx + dy * dy);
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).tiltShift, {
        blurRadius: blurRadius,
        gradientRadius: gradientRadius,
        start: [
            startX,
            startY
        ],
        end: [
            endX,
            endY
        ],
        delta: [
            dx / d,
            dy / d
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).tiltShift, {
        blurRadius: blurRadius,
        gradientRadius: gradientRadius,
        start: [
            startX,
            startY
        ],
        end: [
            endX,
            endY
        ],
        delta: [
            -dy / d,
            dx / d
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../shaders/random-shader-func":"eVnGI","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bGzpO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "matrixWarp", ()=>matrixWarp);
var _gl = require("../core/gl");
var _warpShader = require("../shaders/warp-shader");
var _simpleShader = require("../core/simple-shader");
var _matrix = require("../math/matrix");
const matrixWarp = function(matrix, inverse, useTextureSpace) {
    (0, _gl.gl).matrixWarp = (0, _gl.gl).matrixWarp || (0, _warpShader.warpShader)('\
        uniform mat3 matrix;\
        uniform bool useTextureSpace;\
    ', '\
        if (useTextureSpace) coord = coord / texSize * 2.0 - 1.0;\
        vec3 warp = matrix * vec3(coord, 1.0);\
        coord = warp.xy / warp.z;\
        if (useTextureSpace) coord = (coord * 0.5 + 0.5) * texSize;\
    ');
    // Flatten all members of matrix into one big list
    matrix = matrix.flat();
    // Extract a 3x3 matrix out of the arguments
    if (matrix.length == 4) matrix = [
        matrix[0],
        matrix[1],
        0,
        matrix[2],
        matrix[3],
        0,
        0,
        0,
        1
    ];
    else if (matrix.length != 9) throw 'can only warp with 2x2 or 3x3 matrix';
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).matrixWarp, {
        matrix: inverse ? (0, _matrix.getInverse)(matrix) : matrix,
        texSize: [
            this.width,
            this.height
        ],
        useTextureSpace: useTextureSpace ? 1 : 0
    });
    return this;
};

},{"../core/gl":"g5PuJ","../shaders/warp-shader":"b0GDp","../core/simple-shader":"nkbUU","../math/matrix":"9vHue","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b0GDp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "warpShader", ()=>warpShader);
var _fxShader = require("../core/fx-shader");
function warpShader(uniformsStr, warpStr) {
    return new (0, _fxShader.FxShader)(null, uniformsStr + '\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    void main() {\
        vec2 coord = texCoord * texSize;\
        ' + warpStr + '\
        gl_FragColor = texture2D(texture, coord / texSize);\
        vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\
        if (coord != clampedCoord) {\
            /* fade to transparent if we are outside the image */\
            gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));\
        }\
    }', 'warp');
}

},{"../core/fx-shader":"hwJnV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9vHue":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// from javax.media.jai.PerspectiveTransform
/**
 * Creates a PerspectiveTransform that maps the unit square onto an arbitrary quadrilateral.
 */ parcelHelpers.export(exports, "getSquareToQuad", ()=>getSquareToQuad);
parcelHelpers.export(exports, "getInverse", ()=>getInverse);
parcelHelpers.export(exports, "multiply", ()=>multiply);
function getSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3) {
    const dx1 = x1 - x2;
    const dy1 = y1 - y2;
    const dx2 = x3 - x2;
    const dy2 = y3 - y2;
    const dx3 = x0 - x1 + x2 - x3;
    const dy3 = y0 - y1 + y2 - y3;
    const det = dx1 * dy2 - dx2 * dy1;
    const a = (dx3 * dy2 - dx2 * dy3) / det;
    const b = (dx1 * dy3 - dx3 * dy1) / det;
    return [
        x1 - x0 + a * x1,
        y1 - y0 + a * y1,
        a,
        x3 - x0 + b * x3,
        y3 - y0 + b * y3,
        b,
        x0,
        y0,
        1
    ];
}
function getInverse(m) {
    const a = m[0], b = m[1], c = m[2];
    const d = m[3], e = m[4], f = m[5];
    const g = m[6], h = m[7], i = m[8];
    const det = a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    return [
        (e * i - f * h) / det,
        (c * h - b * i) / det,
        (b * f - c * e) / det,
        (f * g - d * i) / det,
        (a * i - c * g) / det,
        (c * d - a * f) / det,
        (d * h - e * g) / det,
        (b * g - a * h) / det,
        (a * e - b * d) / det
    ];
}
function multiply(a, b) {
    return [
        a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
        a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
        a[0] * b[2] + a[1] * b[5] + a[2] * b[8],
        a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
        a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
        a[3] * b[2] + a[4] * b[5] + a[5] * b[8],
        a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
        a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
        a[6] * b[2] + a[7] * b[5] + a[8] * b[8]
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"TYEfm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsharpMask", ()=>unsharpMask);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const unsharpMask = function(radius, strength) {
    (0, _gl.gl).unsharpMask = (0, _gl.gl).unsharpMask || new (0, _fxShader.FxShader)(null, '\
        uniform sampler2D blurredTexture;\
        uniform sampler2D originalTexture;\
        uniform float strength;\
        uniform float threshold;\
        varying vec2 texCoord;\
        void main() {\
            vec4 blurred = texture2D(blurredTexture, texCoord);\
            vec4 original = texture2D(originalTexture, texCoord);\
            gl_FragColor = mix(blurred, original, 1.0 + strength);\
        }\
    ', 'unsharpMask');
    // Store a copy of the current texture in the second texture unit
    this._.extraTexture.ensureFormatViaTexture(this._.texture);
    this._.texture.use();
    this._.extraTexture.drawTo(function() {
        (0, _fxShader.FxShader).getDefaultShader().drawRect();
    });
    // Blur the current texture, then use the stored texture to detect edges
    this._.extraTexture.use(1);
    this.triangleBlur(radius);
    (0, _gl.gl).unsharpMask.textures({
        originalTexture: 1
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).unsharpMask, {
        strength: strength
    });
    this._.extraTexture.unuse(1);
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"65OZL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toAlpha", ()=>toAlpha);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const toAlpha = function(isInverted, replaceRGBA) {
    (0, _gl.gl).toAlpha = (0, _gl.gl).toAlpha || new (0, _fxShader.FxShader)(null, '\
    uniform bool isInverted;\
    uniform vec4 replace;\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    \
    void main() {\
        vec4 color = texture2D(texture, texCoord);\
        float alpha = (color.r + color.g + color.b) / 3.0;\
        if (isInverted) alpha = 1.0 - alpha;\
        alpha = min(color.a, alpha);\
        if (replace.a > 0.0) color = replace;\
        gl_FragColor = vec4(color.r, color.g, color.b, alpha);\
    }\
', 'toAlpha');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).toAlpha, {
        isInverted: isInverted ? 1 : 0,
        replace: replaceRGBA ? [
            replaceRGBA.r / 255,
            replaceRGBA.g / 255,
            replaceRGBA.b / 255,
            replaceRGBA.a
        ] : [
            0,
            0,
            0,
            0
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bg4OA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "invert", ()=>invert);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const invert = function() {
    (0, _gl.gl).invert = (0, _gl.gl).invert || new (0, _fxShader.FxShader)(null, '\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    \
    void main() {\
        vec4 color = texture2D(texture, texCoord);\
        color.rgb = 1.0 - color.rgb;\
        gl_FragColor = color;\
    }\
', 'invert');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).invert, {
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Tlry":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "perspective", ()=>perspective);
var _matrix = require("../math/matrix");
const perspective = function(before, after) {
    const a = (0, _matrix.getSquareToQuad)(...after);
    const b = (0, _matrix.getSquareToQuad)(...before);
    const c = (0, _matrix.multiply)((0, _matrix.getInverse)(a), b);
    return this.matrixWarp(c);
};

},{"../math/matrix":"9vHue","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"Udxwr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unmultiplyAlpha", ()=>unmultiplyAlpha);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const unmultiplyAlpha = function() {
    (0, _gl.gl).unmultiplyAlpha = (0, _gl.gl).unmultiplyAlpha || new (0, _fxShader.FxShader)(null, '\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    \
    void main() {\
        vec4 color = texture2D(texture, texCoord);\
        if(color.a > 0.0) {\
            color.rgb /= color.a;\
        }\
        gl_FragColor = color;\
    }\
', 'unmultiplyAlpha');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).unmultiplyAlpha, {
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4JP4W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distort", ()=>distort);
var _gl = require("../core/gl");
var _warpShader = require("../shaders/warp-shader");
var _simpleShader = require("../core/simple-shader");
const distort = function(settings) {
    (0, _gl.gl).distort = (0, _gl.gl).distort || (0, _warpShader.warpShader)(`
    uniform float stepSize;
    uniform vec2 scale;
    uniform vec2 strength;
    uniform vec2 phase;
    uniform float type;
    uniform vec2 offset;
`, `
    const float PI = 3.14159265;
    float x = coord.x + offset.x;
    float y = coord.y + offset.y;
    if (stepSize > 1.0) {
        x = floor(x / stepSize) * stepSize;
        y = floor(y / stepSize) * stepSize;
    }
    float distortX = sin((x/scale.x + phase.x) * PI * 2.0) * strength.x;
    float distortY = sin((y/scale.y + phase.y) * PI * 2.0) * strength.y;
    if (type == 0.0) {
        coord.y += distortX;
        coord.x += distortY;
    } else if (type == 1.0) {
        coord.x += distortX;
        coord.y += distortY;
    } else if (type == 2.0) {
        x -= offset.x;
        y -= offset.y;
        gl_FragColor = texture2D(texture, vec2(x, y) / texSize);
        coord.y += sin(gl_FragColor.r/scale.x*200.0 + phase.x * PI * 2.0) * strength.x;
        coord.x += cos(gl_FragColor.g/scale.y*200.0 + phase.y * PI * 2.0) * strength.y;
    }
    coord.x = mod(coord.x, texSize.x);
    coord.y = mod(coord.y, texSize.y);
`);
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).distort, {
        stepSize: settings.stepSize,
        type: settings.distortType,
        scale: [
            settings.scale.x,
            settings.scale.y
        ],
        strength: [
            settings.strength.x,
            settings.strength.y
        ],
        phase: [
            settings.phase.x,
            settings.phase.y
        ],
        offset: [
            settings.offset.x,
            settings.offset.y
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"g5PuJ","../shaders/warp-shader":"b0GDp","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"butIc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multiplyAlpha", ()=>multiplyAlpha);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const multiplyAlpha = function() {
    (0, _gl.gl).multiplyAlpha = (0, _gl.gl).multiplyAlpha || new (0, _fxShader.FxShader)(null, '\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    \
    void main() {\
        vec4 color = texture2D(texture, texCoord);\
        color.rgb *= color.a;\
        gl_FragColor = color;\
    }\
', 'multiplyAlpha');
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).multiplyAlpha, {
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gbuqp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mask", ()=>mask);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const mask = function(maskTexture, originalTexture) {
    maskTexture._.use(1);
    if (originalTexture) originalTexture._.use(2);
    else {
        // should be faster than introducing a conditional in the shader
        this._.extraTexture.use(2);
        this._.extraTexture.initFromBytes(1, 1, [
            0,
            0,
            0,
            0
        ]);
    }
    (0, _gl.gl).mask = (0, _gl.gl).mask || new (0, _fxShader.FxShader)(null, `
        uniform sampler2D texture;
        uniform sampler2D mask;
        uniform sampler2D original;
        varying vec2 texCoord;

        void main() {
            vec4 filteredCol = texture2D(texture, texCoord);
            vec4 originalCol = texture2D(original, texCoord);
            float maskStrength = texture2D(mask, texCoord).r;
            gl_FragColor = mix(originalCol, filteredCol, maskStrength);
        }
        `, 'mask');
    (0, _gl.gl).mask.textures({
        mask: 1,
        original: 2
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).mask, {});
    return this;
};

},{"../core/gl":"g5PuJ","../core/fx-shader":"hwJnV","../core/simple-shader":"nkbUU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dLyJt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imgurUpload", ()=>imgurUpload);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _language = require("../../../language/language");
var _loadingGif = require("url:/src/app/img/ui/loading.gif");
var _loadingGifDefault = parcelHelpers.interopDefault(_loadingGif);
var _canvas = require("../../../bb/base/canvas");
var _base = require("../../../bb/base/base");
/**
 * uploads canvas, opens new tab with the upload progress & then opens the image page.
 */ async function upload(canvas, title, description, type, imgurKey) {
    const imageBlob = await (0, _canvas.canvasToBlob)(canvas, 'image/' + type);
    const newTab = window.open();
    if (!newTab) throw new Error('could not create new tab');
    const label = newTab.document.createElement('div');
    const gif = newTab.document.createElement('img');
    gif.src = (0, _loadingGifDefault.default);
    label.append(gif);
    (0, _base.css)(gif, {
        filter: 'invert(1)'
    });
    (0, _base.css)(newTab.document.body, {
        backgroundColor: '#121211',
        backgroundImage: 'linear-gradient(#2b2b2b 0%, #121211 50%)',
        backgroundRepeat: 'no-repeat'
    });
    const labelText = newTab.document.createElement('div');
    labelText.style.marginTop = '10px';
    label.append(labelText);
    labelText.textContent = (0, _language.LANG)('upload-uploading');
    newTab.document.body.append(label);
    (0, _base.css)(label, {
        marginLeft: 'auto',
        marginRight: 'auto',
        marginTop: '100px',
        fontFamily: 'system-ui, sans-serif',
        fontSize: '20px',
        textAlign: 'center',
        transition: 'opacity 0.3s ease-in-out',
        opacity: '0',
        color: '#ccc'
    });
    setTimeout(function() {
        label.style.opacity = '1';
    }, 20);
    let response;
    try {
        const formData = new FormData();
        formData.append('title', title);
        formData.append('description', description);
        formData.append('image', imageBlob);
        response = await fetch('https://api.imgur.com/3/image', {
            method: 'POST',
            headers: {
                Authorization: 'Client-ID ' + imgurKey
            },
            body: formData
        });
    } catch (e) {
        newTab.close();
        throw e;
    }
    if (!response.ok) {
        newTab.close();
        throw new Error();
    }
    const data = (await response.json()).data;
    newTab.location.href = data.link.replace(/\.(jpg|png)/, '');
    return data;
}
function imgurUpload(klCanvas, klRootEl, imgurKey, onUploaded) {
    if (!imgurKey) throw new Error('imgur key missing');
    const inputTitle = (0, _bb.BB).el({
        tagName: 'input',
        custom: {
            name: 'image-title'
        }
    });
    inputTitle.type = 'text';
    inputTitle.value = (0, _language.LANG)('upload-title-untitled');
    const inputDescription = (0, _bb.BB).el({
        tagName: 'textarea',
        custom: {
            rows: '2',
            name: 'image-description'
        },
        css: {
            width: '100%',
            maxWidth: '100%'
        }
    });
    const labelTitle = (0, _bb.BB).el({
        textContent: (0, _language.LANG)('upload-name') + ':'
    });
    const labelDescription = (0, _bb.BB).el({
        textContent: (0, _language.LANG)('upload-caption') + ':',
        css: {
            marginTop: '10px'
        }
    });
    const tos = (0, _bb.BB).el({
        content: `<br/><a href="https://imgur.com/tos" target="_blank" rel="noopener noreferrer">${(0, _language.LANG)('terms-of-service')}</a>`
    });
    const typeRadio = new (0, _kl.KL).RadioList({
        name: 'filetype',
        init: 'jpeg',
        items: [
            {
                label: 'JPG',
                value: 'jpeg'
            },
            {
                label: 'PNG',
                value: 'png'
            }
        ],
        ignoreFocus: true
    });
    (0, _base.css)(typeRadio.getElement(), {
        marginBottom: '10px'
    });
    const outDiv = (0, _bb.BB).el();
    const infoHint = (0, _bb.BB).el({
        className: 'info-hint',
        textContent: (0, _language.LANG)('upload-link-notice')
    });
    outDiv.append(infoHint, typeRadio.getElement(), labelTitle, inputTitle, labelDescription, inputDescription, tos);
    (0, _kl.KL).popup({
        target: klRootEl,
        message: `<b>${(0, _language.LANG)('upload-title')}</b>`,
        type: 'upload',
        div: outDiv,
        buttons: [
            (0, _language.LANG)('upload-submit'),
            'Cancel'
        ],
        clickOnEnter: (0, _language.LANG)('upload-submit'),
        primaries: [
            (0, _language.LANG)('upload-submit')
        ],
        autoFocus: (0, _language.LANG)('upload-submit'),
        callback: async function(val) {
            if (val === (0, _language.LANG)('upload-submit') || val === 'Yes' || val === 'Ok') try {
                const result = await upload(klCanvas.getCompleteCanvas(1), inputTitle.value, inputDescription.value, typeRadio.getValue(), imgurKey);
                (0, _kl.KL).popup({
                    target: klRootEl,
                    type: 'ok',
                    message: `<h3>${(0, _language.LANG)('upload-success')}</h3><br>${(0, _language.LANG)('upload-delete')}<br><a target='_blank' rel="noopener noreferrer" href='https://imgur.com/delete/${result.deletehash}'>imgur.com/delete/${result.deletehash}</a><br><br>`,
                    buttons: [
                        'Ok'
                    ]
                });
                onUploaded();
            } catch (e) {
                (0, _kl.KL).popup({
                    target: klRootEl,
                    type: 'error',
                    message: (0, _language.LANG)('upload-failed'),
                    buttons: [
                        'Ok'
                    ]
                });
            }
        }
    });
}

},{"../../../bb/bb":"3zOvT","../../kl":"lHQKw","../../../language/language":"mcywn","url:/src/app/img/ui/loading.gif":"bTyF5","../../../bb/base/canvas":"86XNv","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bTyF5":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("loading.68659e0a.gif") + "?" + Date.now();

},{}],"ZuAcA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadAgPsd", ()=>loadAgPsd);
let agPsdLazy;
async function loadAgPsd() {
    if (!agPsdLazy) agPsdLazy = await require("9bdc000954b5ac76");
    return agPsdLazy;
}

},{"9bdc000954b5ac76":"21Q3g","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"21Q3g":[function(require,module,exports,__globalThis) {
module.exports = import("./dist.85077542.js").then(()=>module.bundle.root('lfV2S'));

},{"lfV2S":"lfV2S"}],"ge4nE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * remind user of saving, keep user aware of save state
 */ parcelHelpers.export(exports, "SaveReminder", ()=>SaveReminder);
var _kl = require("../../kl");
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _localStorage = require("../../../bb/base/local-storage");
var _saveReminderModuleScss = require("./save-reminder.module.scss");
var _browserStorageUi = require("./browser-storage-ui");
const DEBUG_TIME_LIMIT_MS = undefined;
const DEBUG_UNSAVED_ACTIONS_LIMIT = undefined;
// minimum number of actions required for reminder to show up (regardless of time limit)
const UNSAVED_ACTIONS_LIMIT = DEBUG_UNSAVED_ACTIONS_LIMIT ?? 100;
const LS_REMINDER_KEY = 'kl-save-reminder';
class SaveReminder {
    showPopup() {
        const min = Math.round((performance.now() - this.lastSavedAt) / 1000 / 60);
        const contentEl = (0, _bb.BB).el();
        contentEl.append((0, _bb.BB).el({
            content: (0, _language.LANG)('save-reminder-text', {
                a: '<strong>' + min,
                b: '</strong>'
            }),
            css: {
                marginBottom: '20px'
            }
        }));
        const psdWrapper = (0, _bb.BB).el({
            className: _saveReminderModuleScss.psdWrapper
        });
        const storageWrapper = (0, _bb.BB).el({
            css: {
                margin: '0 -20px',
                padding: '20px',
                paddingBottom: '0'
            }
        });
        contentEl.append(psdWrapper, storageWrapper);
        const psdBtn = (0, _bb.BB).el({
            tagName: 'button',
            className: 'kl-button kl-button-primary kl-button--extra-focus',
            content: (0, _language.LANG)('save-reminder-save-psd'),
            onClick: ()=>{
                this.applyUncommitted();
                this.onSaveAsPsd();
            },
            css: {
                padding: '14px'
            },
            noRef: true
        });
        psdWrapper.append(psdBtn, (0, _bb.BB).el({
            content: "\u2714 " + (0, _language.LANG)('save-reminder-psd-layers'),
            css: {
                marginTop: '10px'
            }
        }));
        const storageUi = new (0, _browserStorageUi.BrowserStorageUi)({
            projectStore: this.projectStore,
            getProject: this.getProject,
            klRootEl: document.body,
            applyUncommitted: this.applyUncommitted,
            options: {
                hideClearButton: true,
                isFocusable: true
            },
            onStored: ()=>this.onStored()
        });
        storageUi.show();
        storageWrapper.append(storageUi.getElement());
        (0, _kl.KL).popup({
            type: 'warning',
            target: document.body,
            message: `<b>${(0, _language.LANG)('save-reminder-title')}</b>`,
            div: contentEl,
            ignoreBackground: true,
            callback: ()=>{
                storageUi.destroy();
                (0, _bb.BB).destroyEl(psdBtn);
                this.closeFunc = undefined;
                this.lastReminderShownAt = performance.now();
            },
            closeFunc: (f)=>{
                this.closeFunc = f;
            }
        });
        setTimeout(()=>{
            psdBtn.focus();
        }, 40);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.klHistory = {};
        this.lastSavedAt = 0;
        this.lastReminderShownAt = 0;
        this.onSaveAsPsd = p.onSaveAsPsd;
        this.isDrawing = p.isDrawing;
        this.projectStore = p.projectStore;
        this.getProject = p.getProject;
        this.onStored = p.onStored;
        this.applyUncommitted = p.applyUncommitted;
        this.klHistory = p.klHistory;
        this.setting = (0, _localStorage.LocalStorage).getItem(LS_REMINDER_KEY) ?? '40min';
    }
    init() {
        if (this.lastSavedHistoryIndex !== undefined) // already initialized
        return;
        this.lastSavedHistoryIndex = this.klHistory.getTotalIndex();
        this.lastReminderShownAt = performance.now();
        this.lastSavedAt = performance.now();
        setInterval(()=>{
            if (document.visibilityState !== 'visible') return;
            const unsavedActions = Math.abs(this.klHistory.getTotalIndex() - this.lastSavedHistoryIndex);
            const timeLimitMs = DEBUG_TIME_LIMIT_MS ?? 60000 * ({
                '20min': 20,
                '40min': 40,
                disabled: 0
            })[this.setting];
            if (timeLimitMs > 0 && (0, _kl.KL).DIALOG_COUNTER.get() === 0 && !this.isDrawing() && this.lastReminderShownAt + timeLimitMs < performance.now() && unsavedActions >= UNSAVED_ACTIONS_LIMIT) this.showPopup();
        }, 5000);
    }
    reset() {
        if (this.lastSavedHistoryIndex === undefined) // not initialized
        return;
        this.lastSavedHistoryIndex = this.klHistory.getTotalIndex();
        this.lastReminderShownAt = performance.now();
        this.lastSavedAt = performance.now();
        window.onbeforeunload = null;
        if (this.closeFunc) this.closeFunc();
    }
    getSetting() {
        return this.setting;
    }
    setSetting(setting) {
        this.setting = setting;
        (0, _localStorage.LocalStorage).setItem(LS_REMINDER_KEY, this.setting);
    }
}

},{"../../kl":"lHQKw","../../../bb/bb":"3zOvT","../../../language/language":"mcywn","../../../bb/base/local-storage":"itqB1","./save-reminder.module.scss":"bMhmV","./browser-storage-ui":"jEHd9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bMhmV":[function(require,module,exports,__globalThis) {
module.exports["psdWrapper"] = `WKn-vG_psdWrapper`;

},{}],"fvvQk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SaveToComputer", ()=>SaveToComputer);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
var _saveAs = require("../../bb/base/save-as");
var _klConfig = require("../kl-config");
var _canvas = require("../../bb/base/canvas");
class SaveToComputer {
    async saveImage(canvas, filename, mimeType, showDialog = false) {
        const blob = await (0, _canvas.canvasToBlob)(canvas, mimeType);
        await (0, _saveAs.saveAs)(blob, filename, showDialog);
    }
    // ----------------------------------- public -----------------------------------
    constructor(getExportType, klCanvas, onSaved){
        this.getExportType = getExportType;
        this.klCanvas = klCanvas;
        this.onSaved = onSaved;
        this.showSaveDialog = true;
    }
    async save(format) {
        if (!format) format = this.getExportType();
        if (format === 'png') {
            const extension = 'png';
            const mimeType = 'image/png';
            const filename = (0, _bb.BB).getDate() + (0, _klConfig.KL_CONFIG).filenameBase + '.' + extension;
            const fullCanvas = this.klCanvas.getCompleteCanvas(1);
            try {
                await this.saveImage(fullCanvas, filename, mimeType, this.showSaveDialog);
            } catch (error) {
                //fallback for old browsers
                alert('could not save');
                throw new Error('failed png export');
            }
        } else if (format === 'layers') {
            const extension = 'png';
            const mimeType = 'image/png';
            const fileBase = (0, _bb.BB).getDate() + (0, _klConfig.KL_CONFIG).filenameBase;
            const layerArr = this.klCanvas.getLayersFast();
            for(let i = 0; i < layerArr.length; i++){
                const item = layerArr[i];
                const fnameArr = [
                    fileBase,
                    '_',
                    ('' + (i + 1)).padStart(2, '0'),
                    '_',
                    item.name,
                    '.',
                    extension
                ];
                await this.saveImage(item.canvas, fnameArr.join(''), mimeType);
            }
        } else if (format === 'psd') {
            const layerArr = this.klCanvas.getLayersFast();
            const psdConfig = {
                width: this.klCanvas.getWidth(),
                height: this.klCanvas.getHeight(),
                children: [],
                canvas: this.klCanvas.getCompleteCanvas(1)
            };
            for(let i = 0; i < layerArr.length; i++){
                const item = layerArr[i];
                psdConfig.children.push({
                    name: item.name,
                    hidden: !item.isVisible,
                    opacity: item.opacity,
                    canvas: item.canvas,
                    blendMode: (0, _kl.KL).PSD.blendKlToPsd(item.mixModeStr),
                    left: 0,
                    top: 0
                });
            }
            (0, _kl.KL).loadAgPsd().then((agPsdLazy)=>{
                const buffer = agPsdLazy.writePsdBuffer(psdConfig);
                const blob = new Blob([
                    buffer
                ], {
                    type: 'image/vnd.adobe.photoshop'
                });
                (0, _saveAs.saveAs)(blob, (0, _bb.BB).getDate() + (0, _klConfig.KL_CONFIG).filenameBase + '.psd', this.showSaveDialog);
            }).catch(()=>{
                alert('Error: failed to load PSD library');
            });
        }
        this.onSaved();
    }
    setShowSaveDialog(b) {
        this.showSaveDialog = b;
    }
}

},{"../../bb/bb":"3zOvT","../kl":"lHQKw","../../bb/base/save-as":"gABgn","../kl-config":"4KrR1","../../bb/base/canvas":"86XNv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gABgn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "saveAs", ()=>saveAs);
const types = {
    'image/png': {
        description: 'PNG Image',
        accept: {
            'image/png': [
                '.png'
            ]
        }
    },
    'image/vnd.adobe.photoshop': {
        description: 'Adobe Photoshop Document',
        accept: {
            'image/vnd.adobe.photoshop': [
                '.psd'
            ]
        }
    }
};
// resolves to true if it saves via file picker (or user aborted)
async function saveViaFilePicker(blob, fileName) {
    const mimeType = blob.type;
    if ('showSaveFilePicker' in window) {
        let fileHandle;
        if (!types[mimeType]) {
            console.error('unknown mime type:', mimeType);
            return false;
        }
        try {
            fileHandle = await window.showSaveFilePicker({
                suggestedName: fileName,
                types: [
                    types[mimeType]
                ]
            });
        } catch (e) {
            if (e instanceof Error && e.name === 'AbortError') // cancelled dialog
            return true;
            console.log('unpredicted error', e);
            return false;
        }
        if (!fileHandle) return false;
        const writableStream = await fileHandle.createWritable();
        await writableStream.write(blob);
        await writableStream.close();
        return true;
    } else return false;
}
async function saveAs(blob, fileName, showDialog = false) {
    if (showDialog && await saveViaFilePicker(blob, fileName)) return;
    // Namespace is used to prevent conflict w/ Chrome Poper Blocker extension (Issue https://github.com/eligrey/FileSaver.js/issues/561)
    const a = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
    a.download = fileName;
    a.rel = 'noopener';
    const objectUrl = URL.createObjectURL(blob);
    a.href = objectUrl;
    setTimeout(()=>URL.revokeObjectURL(objectUrl), 40000);
    setTimeout(()=>{
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }, 1);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4KrR1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KL_CONFIG", ()=>KL_CONFIG);
const KL_CONFIG = {
    filenameBase: 'Klecks'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c1CDV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Central place to update brush settings, and to subscribe to changes.
 */ parcelHelpers.export(exports, "BrushSettingService", ()=>BrushSettingService);
class BrushSettingService {
    emit(obj, skipSubscriber) {
        for(let i = 0; i < this.subscriberArr.length; i++){
            if (this.subscriberArr[i] === skipSubscriber) continue;
            this.subscriberArr[i](obj);
        }
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.subscriberArr = [];
        this.onSetColor = p.onSetColor;
        this.onSetSize = p.onSetSize;
        this.onSetOpacity = p.onSetOpacity;
        this.onSetScatter = p.onSetScatter;
        this.onGetColor = p.onGetColor;
        this.onGetSize = p.onGetSize;
        this.onGetOpacity = p.onGetOpacity;
        this.onGetScatter = p.onGetScatter;
        this.onGetSliderConfig = p.onGetSliderConfig;
        if (BrushSettingService.instance) throw new Error('BrushSettingService already instantiated');
        BrushSettingService.instance = this;
    }
    emitColor(color, skipSubscriber) {
        this.emit({
            type: 'color',
            value: color
        }, skipSubscriber);
    }
    emitSize(size, skipSubscriber) {
        this.emit({
            type: 'size',
            value: size
        }, skipSubscriber);
    }
    emitOpacity(opacity, skipSubscriber) {
        this.emit({
            type: 'opacity',
            value: opacity
        }, skipSubscriber);
    }
    emitScatter(scatter, skipSubscriber) {
        this.emit({
            type: 'scatter',
            value: scatter
        }, skipSubscriber);
    }
    emitSliderConfig(sliderConfig, skipSubscriber) {
        this.emit({
            type: 'sliderConfig',
            value: sliderConfig
        }, skipSubscriber);
    }
    /**
     * set current brush color
     * @param color
     * @param skipSubscriber
     */ setColor(color, skipSubscriber) {
        this.onSetColor(color);
        this.emitColor(color, skipSubscriber);
    }
    /**
     * set current brush size
     * @param size
     * @param skipSubscriber
     */ setSize(size, skipSubscriber) {
        this.onSetSize(size);
    // why not emitting?
    }
    /**
     * set current opacity
     * @param opacity
     * @param skipSubscriber
     */ setOpacity(opacity, skipSubscriber) {
        this.onSetOpacity(opacity);
    // why not emitting?
    }
    /**
     * set current scatter
     * @param scatter
     * @param skipSubscriber
     */ setScatter(scatter, skipSubscriber) {
        this.onSetScatter(scatter);
    // why not emitting?
    }
    /**
     * get current brush color
     */ getColor() {
        return this.onGetColor();
    }
    getSize() {
        return this.onGetSize();
    }
    getOpacity() {
        return this.onGetOpacity();
    }
    getScatter() {
        return this.onGetScatter();
    }
    getSliderConfig() {
        return this.onGetSliderConfig();
    }
    /**
     * subscribe to changes
     * @param func
     */ subscribe(func) {
        if (this.subscriberArr.includes(func)) return;
        this.subscriberArr.push(func);
    }
    unsubscribe(func) {
        for(let i = 0; i < this.subscriberArr.length; i++)if (func === this.subscriberArr[i]) {
            this.subscriberArr.splice(i, 1);
            i--;
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iO0QN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SettingsUi", ()=>SettingsUi);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _kl = require("../../kl");
var _languages = require("../../../../languages/languages");
var _bitbofLogoSvg = require("url:/src/app/img/bitbof-logo.svg");
var _bitbofLogoSvgDefault = parcelHelpers.interopDefault(_bitbofLogoSvg);
var _klecksLogoPng = require("url:/src/app/img/klecks-logo.png");
var _klecksLogoPngDefault = parcelHelpers.interopDefault(_klecksLogoPng);
var _uiSwapLrSvg = require("url:/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
var _localStorage = require("../../../bb/base/local-storage");
var _theme = require("../../../theme/theme");
var _base = require("../../../bb/base/base");
var _showLicensesDialog = require("../modals/licenses-dialog/show-licenses-dialog");
var _c = require("../../../bb/base/c");
var _showModal = require("../modals/base/showModal");
var _ui = require("../../../bb/base/ui");
class SettingsUi {
    // ----------------------------------- public -----------------------------------
    constructor({ onLeftRight, saveReminder, customAbout }){
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: '10px'
            }
        });
        // ---- language ----
        const autoLanguage = (0, _language.LANGUAGE_STRINGS).getAutoLanguage();
        const langWrapper = (0, _bb.BB).el({
            parent: this.rootEl,
            content: (0, _bb.BB).el({
                content: (0, _language.LANG)('settings-language') + ':',
                css: {
                    marginRight: '5px',
                    marginBottom: '2px'
                }
            }),
            css: {
                display: 'flex',
                alignItems: 'center',
                flexWrap: 'wrap'
            }
        });
        const options = [
            [
                'auto',
                (0, _language.LANG)('auto') + ` \u{2192} ${autoLanguage.name} (${autoLanguage.code})`
            ],
            ...(0, _languages.languages).map((item)=>{
                return [
                    item.code,
                    item.name + ` (${item.code})`
                ];
            })
        ];
        const languageSelect = new (0, _kl.KL).Select({
            initValue: (0, _base.nullToUndefined)((0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) ? (0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) : 'auto'),
            optionArr: options,
            onChange: (val)=>{
                if (val === 'auto') (0, _localStorage.LocalStorage).removeItem((0, _language.LS_LANGUAGE_KEY));
                else (0, _localStorage.LocalStorage).setItem((0, _language.LS_LANGUAGE_KEY), val);
                languageHint.style.display = 'block';
            },
            name: 'language'
        });
        (0, _base.css)(languageSelect.getElement(), {
            flexGrow: '1'
        });
        const languageHint = (0, _bb.BB).el({
            className: 'kl-toolspace-note',
            content: (0, _language.LANG)('settings-language-reload'),
            css: {
                display: 'none',
                marginTop: '5px',
                flexGrow: '1'
            }
        });
        langWrapper.append(languageSelect.getElement(), languageHint);
        // ---- theme ----
        function themeToLabel(theme) {
            return theme === 'dark' ? "\u2B1B " + (0, _language.LANG)('theme-dark') : "\u2B1C " + (0, _language.LANG)('theme-light');
        }
        const themeSelect = new (0, _kl.KL).Select({
            optionArr: [
                [
                    'auto',
                    (0, _language.LANG)('auto') + " \u2192 " + themeToLabel((0, _theme.THEME).getMediaQueryTheme())
                ],
                [
                    'light',
                    themeToLabel('light')
                ],
                [
                    'dark',
                    themeToLabel('dark')
                ]
            ],
            initValue: (0, _theme.THEME).getStoredTheme() || 'auto',
            onChange: (val)=>{
                (0, _theme.THEME).setStoredTheme(val === 'auto' ? undefined : val);
            },
            name: 'ui-theme'
        });
        (0, _base.css)(themeSelect.getElement(), {
            flexGrow: '1'
        });
        (0, _base.addIsDarkListener)(()=>{
            themeSelect.updateLabel('auto', (0, _language.LANG)('auto') + " \u2192 " + themeToLabel((0, _theme.THEME).getMediaQueryTheme()));
        });
        (0, _bb.BB).el({
            parent: this.rootEl,
            content: [
                (0, _bb.BB).el({
                    content: (0, _language.LANG)('settings-theme') + ':',
                    css: {
                        marginRight: '5px',
                        marginBottom: '2px'
                    }
                }),
                themeSelect.getElement()
            ],
            css: {
                marginTop: '15px',
                display: 'flex',
                alignItems: 'center',
                flexWrap: 'wrap'
            }
        });
        // ---- save reminder ----
        if (saveReminder) {
            const reminderSelect = new (0, _kl.KL).Select({
                optionArr: [
                    [
                        '20min',
                        (0, _language.LANG)('x-minutes', {
                            x: '20'
                        })
                    ],
                    [
                        '40min',
                        (0, _language.LANG)('x-minutes', {
                            x: '40'
                        })
                    ],
                    [
                        'disabled',
                        "\u26A0\uFE0F " + (0, _language.LANG)('settings-save-reminder-disabled')
                    ]
                ],
                initValue: saveReminder.getSetting(),
                onChange: (val)=>{
                    if (val !== 'disabled') {
                        saveReminder.setSetting(val);
                        return;
                    }
                    const disableStr = (0, _language.LANG)('settings-save-reminder-confirm-disable');
                    (0, _showModal.showModal)({
                        target: document.body,
                        message: "\u26A0\uFE0F" + (0, _language.LANG)('settings-save-reminder-confirm-title'),
                        div: (0, _c.c)('', [
                            (0, _c.c)('.info-hint', (0, _language.LANG)('settings-save-reminder-confirm-a')),
                            (0, _language.LANG)('settings-save-reminder-confirm-b')
                        ]),
                        buttons: [
                            disableStr,
                            'Cancel'
                        ],
                        callback: (result)=>{
                            if (result === disableStr) saveReminder.setSetting(val);
                            else reminderSelect.setValue(saveReminder.getSetting());
                        }
                    });
                },
                name: 'save-reminder-interval'
            });
            reminderSelect.getElement().style.flexGrow = '1';
            this.rootEl.append((0, _c.c)(',flex,items-center,gap-5,mt-15,flexWrap', [
                (0, _language.LANG)('settings-save-reminder-label') + ':',
                reminderSelect.getElement()
            ]));
        }
        // ---- flip ui ----
        (0, _bb.BB).el({
            tagName: 'button',
            parent: this.rootEl,
            content: [
                (0, _ui.createImage)({
                    alt: 'icon',
                    src: (0, _uiSwapLrSvgDefault.default),
                    width: 18,
                    height: 20,
                    css: {
                        marginRight: '5px'
                    }
                }),
                (0, _language.LANG)('switch-ui-left-right')
            ],
            onClick: ()=>onLeftRight(),
            css: {
                marginTop: '15px'
            },
            custom: {
                tabIndex: '-1'
            }
        });
        // ---- about ----
        this.rootEl.append((0, _bb.BB).el({
            className: 'grid-hr',
            css: {
                margin: '10px 0'
            }
        }));
        function makeLicenses() {
            return (0, _bb.BB).el({
                tagName: 'a',
                content: (0, _language.LANG)('licenses'),
                onClick: ()=>(0, _showLicensesDialog.showLicensesDialog)()
            });
        }
        if (customAbout) {
            this.rootEl.append(customAbout);
            if (!customAbout.innerHTML) {
                const minimalAbout = (0, _bb.BB).el({
                    parent: customAbout,
                    css: {
                        textAlign: 'center'
                    }
                });
                minimalAbout.append((0, _bb.BB).el({
                    content: [
                        (0, _ui.createImage)({
                            alt: 'icon',
                            height: 20,
                            src: (0, _bitbofLogoSvgDefault.default),
                            css: {
                                verticalAlign: 'middle'
                            }
                        }),
                        ' ',
                        (0, _bb.BB).el({
                            tagName: 'a',
                            content: 'bitbof',
                            custom: {
                                href: 'https://bitbof.com',
                                target: '_blank',
                                tabIndex: '-1'
                            }
                        }),
                        " \xa9 2025",
                        (0, _bb.BB).el({
                            tagName: 'br'
                        })
                    ]
                }), makeLicenses());
            }
        } else {
            const versionEl = (0, _bb.BB).el({
                parent: this.rootEl,
                css: {
                    textAlign: 'center'
                },
                content: [
                    (0, _ui.createImage)({
                        alt: 'Klecks',
                        className: 'dark-invert',
                        height: 25,
                        src: (0, _klecksLogoPngDefault.default)
                    }),
                    (0, _bb.BB).el({
                        tagName: 'br'
                    }),
                    (0, _ui.createImage)({
                        alt: 'icon',
                        height: 20,
                        src: (0, _bitbofLogoSvgDefault.default),
                        css: {
                            verticalAlign: 'middle'
                        }
                    }),
                    ' ',
                    (0, _bb.BB).el({
                        tagName: 'a',
                        content: 'bitbof',
                        custom: {
                            href: 'https://bitbof.com',
                            target: '_blank',
                            tabIndex: '-1'
                        }
                    }),
                    " \xa9 2025",
                    (0, _bb.BB).el({
                        tagName: 'br'
                    })
                ]
            });
            versionEl.append(makeLicenses(), document.createTextNode(' | '), (0, _bb.BB).el({
                tagName: 'a',
                content: (0, _language.LANG)('donate'),
                custom: {
                    href: 'https://kleki.com/donate/',
                    target: '_blank'
                }
            }), document.createTextNode(' | '), (0, _bb.BB).el({
                tagName: 'a',
                content: (0, _language.LANG)('source-code'),
                custom: {
                    href: 'https://klecks.org',
                    target: '_blank'
                }
            }));
        }
        window.addEventListener('storage', (e)=>{
            if (e.key !== (0, _language.LS_LANGUAGE_KEY)) return;
            languageSelect.setValue((0, _base.nullToUndefined)((0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) ? (0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) : 'auto'));
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","../../kl":"lHQKw","../../../../languages/languages":"e8OBh","url:/src/app/img/bitbof-logo.svg":"6EdOJ","url:/src/app/img/klecks-logo.png":"dpGLi","url:/src/app/img/ui/ui-swap-lr.svg":"5X8wZ","../../../bb/base/local-storage":"itqB1","../../../theme/theme":"cVh0j","../../../bb/base/base":"it3mQ","../modals/licenses-dialog/show-licenses-dialog":"hQXbH","../../../bb/base/c":"3KmDH","../modals/base/showModal":"gy3iL","../../../bb/base/ui":"5dJJW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6EdOJ":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("bitbof-logo.f3f958f4.svg") + "?" + Date.now();

},{}],"5X8wZ":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("ui-swap-lr.df4af825.svg") + "?" + Date.now();

},{}],"hQXbH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showLicensesDialog", ()=>showLicensesDialog);
var _c = require("../../../../bb/base/c");
var _showLicensesDialogModuleScss = require("./show-licenses-dialog.module.scss");
var _dynamicModal = require("../base/dynamic-modal");
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
function showLicensesDialog() {
    const libraries = (0, _c.c)('.' + _showLicensesDialogModuleScss.licenses, (0, _language.LANG)('loading'));
    const fonts = (0, _c.c)('.' + _showLicensesDialogModuleScss.licenses, (0, _language.LANG)('loading'));
    const content = (0, _c.c)(',flex,flexCol,gap-10', [
        libraries,
        fonts
    ]);
    new (0, _dynamicModal.DynamicModal)({
        title: (0, _bb.BB).el({
            content: (0, _language.LANG)('licenses')
        }),
        content: (0, _bb.BB).el({
            content,
            css: {
                height: '100%',
                overflowY: 'auto',
                padding: '10px',
                boxSizing: 'border-box'
            }
        }),
        width: 800,
        isMaxHeight: true,
        onClose: ()=>{
            if (window.location.hash === '#licenses') history.replaceState('', document.title, window.location.pathname + window.location.search);
        }
    });
    require("1724060f7208bfc0").then((result)=>{
        libraries.innerHTML = '';
        result.LICENSES.forEach((item)=>{
            libraries.append((0, _c.c)('details', [
                (0, _c.c)('summary', item.title),
                (0, _c.c)('', item.full.replace(/\n/g, '<br>'))
            ]));
        });
    });
    require("45a71af7bfe324b2").then((result)=>{
        fonts.innerHTML = '';
        result.FONT_LICENSES.forEach((item)=>{
            fonts.append((0, _c.c)('details', [
                (0, _c.c)('summary', 'Font: ' + item.title),
                (0, _c.c)('', item.full.replace(/\n/g, '<br>'))
            ]));
        });
    });
}

},{"../../../../bb/base/c":"3KmDH","./show-licenses-dialog.module.scss":"j67CW","../base/dynamic-modal":"3DApo","../../../../bb/bb":"3zOvT","../../../../language/language":"mcywn","1724060f7208bfc0":"7Zykb","45a71af7bfe324b2":"exgIi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j67CW":[function(require,module,exports,__globalThis) {
module.exports["licenses"] = `ttl1Ia_licenses`;

},{}],"7Zykb":[function(require,module,exports,__globalThis) {
module.exports = import("./licenses.70ce967d.js").then(()=>module.bundle.root('iZDwU'));

},{"iZDwU":"iZDwU"}],"exgIi":[function(require,module,exports,__globalThis) {
module.exports = import("./font-licenses.44a33bed.js").then(()=>module.bundle.root('02i01'));

},{"02i01":"02i01"}],"83fjv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Scroll buttons at the top and bottom of toolspace
 * Show up when window is very small.
 * Allow user to scroll up and down toolspace.
 */ parcelHelpers.export(exports, "ToolspaceScroller", ()=>ToolspaceScroller);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _modalCount = require("../modals/modal-count");
var _base = require("../../../bb/base/base");
class ToolspaceScroller {
    update() {
        let newUpDisplay = this.upBtn.style.display;
        let newDownDisplay = this.downBtn.style.display;
        if (this.toolspace.scrollHeight > this.toolspace.offsetHeight + 3) {
            // small buffer where it's not worth it
            if (!this.upInterval) newUpDisplay = this.toolspace.scrollTop === 0 ? 'none' : 'block';
            if (!this.downInterval) newDownDisplay = this.toolspace.scrollTop + this.toolspace.offsetHeight + 1 >= this.toolspace.scrollHeight ? 'none' : 'block';
        } else {
            newUpDisplay = 'none';
            newDownDisplay = 'none';
        }
        // check to prevent infinite MutationObserver loop in Pale Moon
        if (newUpDisplay !== this.upBtn.style.display) this.upBtn.style.display = newUpDisplay;
        if (newDownDisplay !== this.downBtn.style.display) this.downBtn.style.display = newDownDisplay;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.toolspace = p.toolspace;
        this.upBtn = (0, _bb.BB).el({
            parent: this.toolspace,
            title: (0, _language.LANG)('scroll'),
            className: 'kl-scroller',
            css: {
                top: '0',
                transform: 'rotate(180deg)'
            }
        });
        this.downBtn = (0, _bb.BB).el({
            parent: this.toolspace,
            title: (0, _language.LANG)('scroll'),
            className: 'kl-scroller',
            css: {
                bottom: '0'
            }
        });
        this.updateUiState(p.uiState);
        const upListener = new (0, _bb.BB).PointerListener({
            target: this.upBtn,
            onPointer: (e)=>{
                if (e.type === 'pointerdown') this.upInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, -13);
                    this.update();
                }, 20);
                if (e.type === 'pointerup') {
                    clearInterval(this.upInterval);
                    setTimeout(()=>{
                        // prevent ff pressing anything underneath
                        this.upInterval = null;
                        this.update();
                    }, 50);
                }
            }
        });
        const downListener = new (0, _bb.BB).PointerListener({
            target: this.downBtn,
            onPointer: (e)=>{
                if (e.type === 'pointerdown') this.downInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, 13);
                    this.update();
                }, 20);
                if (e.type === 'pointerup') {
                    clearInterval(this.downInterval);
                    setTimeout(()=>{
                        // prevent ff pressing anything underneath
                        this.downInterval = null;
                        this.update();
                    }, 50);
                }
            }
        });
        const wheelListener = (e)=>{
            this.toolspace.scrollBy(0, Math.round(0.7 * e.deltaY));
            this.update();
        };
        this.upBtn.addEventListener('wheel', wheelListener, {
            passive: false
        });
        this.downBtn.addEventListener('wheel', wheelListener, {
            passive: false
        });
        this.update();
        const observer = new MutationObserver(()=>this.update());
        observer.observe(this.toolspace, {
            attributes: true,
            childList: true,
            subtree: true
        });
        window.addEventListener('resize', ()=>this.update());
        // hide if in dialog because that can have its own scrollbar
        (0, _modalCount.DIALOG_COUNTER).subscribe((v)=>{
            // ignores the 0.5 by tool dropdown
            this.upBtn.style.opacity = v >= 1 ? '0' : '';
            this.downBtn.style.opacity = v >= 1 ? '0' : '';
        });
    }
    updateUiState(uiState) {
        (0, _base.css)(this.upBtn, {
            left: uiState === 'left' ? '0' : '',
            right: uiState === 'right' ? '0' : ''
        });
        (0, _base.css)(this.downBtn, {
            left: uiState === 'left' ? '0' : '',
            right: uiState === 'right' ? '0' : ''
        });
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","../modals/modal-count":"60MST","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ic2NK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gradient Tool tab contents
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "GradientUi", ()=>GradientUi);
var _bb = require("../../../bb/bb");
var _klSlider = require("../components/kl-slider");
var _language = require("../../../language/language");
var _checkbox = require("../components/checkbox");
var _options = require("../components/options");
var _base = require("../../../bb/base/base");
class GradientUi {
    updateIcons() {
        const col1 = this.settings.isReversed ? '#0000' : '#000';
        const col2 = this.settings.isReversed ? '#000' : '#0000';
        this.iconArr[0].style.background = `linear-gradient(${col1}, ${col2})`;
        this.iconArr[1].style.background = `linear-gradient(${col2}, ${col1}, ${col2})`;
        this.iconArr[2].style.background = `radial-gradient(${col1}, ${col2})`;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.settings = {
            opacity: 1,
            type: 'linear',
            doLockAlpha: false,
            doSnap: false,
            isReversed: false,
            isEraser: false
        };
        this.colorSlider = p.colorSlider;
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: '10px'
            }
        });
        this.isVisible = true;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: '10px'
            }
        });
        this.iconArr = [];
        {
            const size = 33;
            [
                0,
                1,
                2
            ].forEach(()=>{
                const el = (0, _bb.BB).el({
                    className: 'dark-invert',
                    css: {
                        width: size + 'px',
                        height: size + 'px',
                        borderRadius: '3px',
                        margin: '1px'
                    }
                });
                this.iconArr.push(el);
            });
        }
        this.updateIcons();
        const typeOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'linear',
                    label: this.iconArr[0],
                    title: (0, _language.LANG)('gradient-linear')
                },
                {
                    id: 'linear-mirror',
                    label: this.iconArr[1],
                    title: (0, _language.LANG)('gradient-linear-mirror')
                },
                {
                    id: 'radial',
                    label: this.iconArr[2],
                    title: (0, _language.LANG)('gradient-radial')
                }
            ],
            initId: 'linear',
            onChange: (id)=>{
                this.settings.type = id;
            }
        });
        this.rootEl.append(typeOptions.getElement());
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('opacity'),
            width: 250,
            height: 30,
            min: 0.01,
            max: 1,
            value: this.settings.opacity,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: (val)=>{
                this.settings.opacity = val;
            }
        });
        (0, _base.css)(opacitySlider.getElement(), {
            marginTop: '10px'
        });
        this.rootEl.append(opacitySlider.getElement());
        const row1 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: 'flex',
                alignItems: 'center',
                marginTop: '10px'
            }
        });
        const reverseToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('reverse'),
            callback: (b)=>{
                this.settings.isReversed = b;
                this.updateIcons();
            },
            css: {
                width: '50%'
            },
            name: 'reverse-gradient'
        });
        const doSnapToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('angle-snap'),
            title: (0, _language.LANG)('angle-snap-title'),
            callback: (b)=>{
                this.settings.doSnap = b;
            },
            css: {
                width: '50%'
            },
            name: 'enable-snapping'
        });
        row1.append(reverseToggle.getElement(), doSnapToggle.getElement());
        const row2 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: 'flex',
                alignItems: 'center',
                marginTop: '10px'
            }
        });
        const eraserToggle = new (0, _checkbox.Checkbox)({
            init: this.settings.isEraser,
            label: (0, _language.LANG)('eraser'),
            callback: (b)=>{
                this.settings.isEraser = b;
            },
            css: {
                width: '50%'
            },
            name: 'enable-eraser'
        });
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)('lock-alpha'),
            title: (0, _language.LANG)('lock-alpha-title'),
            callback: (b)=>{
                this.settings.doLockAlpha = b;
            },
            doHighlight: true,
            css: {
                width: '50%'
            },
            name: 'enable-alpha-lock'
        });
        row2.append(eraserToggle.getElement(), lockAlphaToggle.getElement());
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(isVisible) {
        this.isVisible = isVisible;
        this.rootEl.style.display = isVisible ? 'block' : 'none';
        if (isVisible) this.colorDiv.append(this.colorSlider.getElement(), this.colorSlider.getOutputElement());
    }
    getSettings() {
        return (0, _bb.BB).copyObj(this.settings);
    }
}

},{"../../../bb/bb":"3zOvT","../components/kl-slider":"fQOKQ","../../../language/language":"mcywn","../components/checkbox":"9bXL6","../components/options":"7kiPU","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fdJcF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Topmost row of buttons in toolspace. (embed)
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "EmbedToolspaceTopRow", ()=>EmbedToolspaceTopRow);
var _bb = require("../bb/bb");
var _uiSwapLrSvg = require("url:/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
var _helpSvg = require("url:/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../language/language");
class EmbedToolspaceTopRow {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-toolspace-row',
            css: {
                height: '36px',
                display: 'flex'
            }
        });
        function createButton(p) {
            const padding = 6 + (p.extraPadding ? p.extraPadding : 0);
            const el = (0, _bb.BB).el({
                className: 'toolspace-row-button nohighlight',
                title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.content ? '' : p.contain ? padding + 'px 0' : ''
                }
            });
            if (p.content) el.append(p.content);
            else {
                const im = (0, _bb.BB).el({
                    className: 'dark-invert',
                    css: {
                        backgroundImage: "url('" + p.image + "')",
                        backgroundRepeat: 'no-repeat',
                        backgroundPosition: 'center',
                        backgroundSize: p.contain ? 'contain' : '',
                        //filter: 'grayscale(1)',
                        height: '100%'
                    }
                });
                im.style.pointerEvents = 'none';
                el.append(im);
            }
            const pointerListener = new (0, _bb.BB).PointerListener({
                // because :hover causes problems w touch
                target: el,
                onEnterLeave: function(isOver) {
                    el.classList.toggle('toolspace-row-button-hover', isOver);
                }
            });
            return {
                el,
                pointerListener
            };
        }
        const submitButton = createButton({
            onClick: p.onSubmit,
            title: (0, _language.LANG)('submit-title'),
            content: (0, _bb.BB).el({
                content: (0, _language.LANG)('submit'),
                className: 'toolspace-row-button__submit',
                css: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    width: '100%',
                    height: '100%'
                }
            }),
            contain: true
        });
        submitButton.el.style.width = '45px';
        const helpButton = createButton({
            onClick: p.onHelp,
            title: (0, _language.LANG)('help'),
            image: (0, _helpSvgDefault.default),
            contain: true
        });
        const leftRightButton = createButton({
            onClick: p.onLeftRight,
            title: (0, _language.LANG)('switch-ui-left-right'),
            image: (0, _uiSwapLrSvgDefault.default),
            contain: true
        });
        this.rootEl.append(submitButton.el, leftRightButton.el, helpButton.el);
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../bb/bb":"3zOvT","url:/src/app/img/ui/ui-swap-lr.svg":"5X8wZ","url:/src/app/img/ui/help.svg":"4kIsD","../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1RciL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "importFilters", ()=>importFilters);
var _filters = require("./filters");
var _filterBrightnessContrast = require("./filter-brightness-contrast");
var _filterCropExtend = require("./filter-crop-extend");
var _filterCurves = require("./filter-curves");
var _filterFlip = require("./filter-flip");
var _filterHueSaturation = require("./filter-hue-saturation");
var _filterInvert = require("./filter-invert");
var _filterPerspective = require("./filter-perspective");
var _filterResize = require("./filter-resize");
var _filterRotate = require("./filter-rotate");
var _filterTiltShift = require("./filter-tilt-shift");
var _filterTransform = require("./filter-transform");
var _filterBlur = require("./filter-blur");
var _filterUnsharpMask = require("./filter-unsharp-mask");
var _filterToAlpha = require("./filter-to-alpha");
var _filterGrid = require("./filter-grid");
var _filterNoise = require("./filter-noise");
var _filterPattern = require("./filter-pattern");
var _filterDistort = require("./filter-distort");
var _filterVanishPoint = require("./filter-vanish-point");
function importFilter(libObj, moduleObj) {
    if (moduleObj.getDialog) libObj.getDialog = moduleObj.getDialog;
    libObj.apply = moduleObj.apply;
}
function importFilters() {
    if ((0, _filters.FILTER_LIB_STATUS).isLoaded) return;
    importFilter((0, _filters.FILTER_LIB).brightnessContrast, (0, _filterBrightnessContrast.filterBrightnessContrast));
    importFilter((0, _filters.FILTER_LIB).cropExtend, (0, _filterCropExtend.filterCropExtend));
    importFilter((0, _filters.FILTER_LIB).curves, (0, _filterCurves.filterCurves));
    importFilter((0, _filters.FILTER_LIB).flip, (0, _filterFlip.filterFlip));
    importFilter((0, _filters.FILTER_LIB).hueSaturation, (0, _filterHueSaturation.filterHueSaturation));
    importFilter((0, _filters.FILTER_LIB).invert, (0, _filterInvert.filterInvert));
    importFilter((0, _filters.FILTER_LIB).perspective, (0, _filterPerspective.filterPerspective));
    importFilter((0, _filters.FILTER_LIB).resize, (0, _filterResize.filterResize));
    importFilter((0, _filters.FILTER_LIB).rotate, (0, _filterRotate.filterRotate));
    importFilter((0, _filters.FILTER_LIB).tiltShift, (0, _filterTiltShift.filterTiltShift));
    importFilter((0, _filters.FILTER_LIB).transform, (0, _filterTransform.filterTransform));
    importFilter((0, _filters.FILTER_LIB).blur, (0, _filterBlur.filterBlur));
    importFilter((0, _filters.FILTER_LIB).unsharpMask, (0, _filterUnsharpMask.filterUnsharpMask));
    importFilter((0, _filters.FILTER_LIB).toAlpha, (0, _filterToAlpha.filterToAlpha));
    importFilter((0, _filters.FILTER_LIB).grid, (0, _filterGrid.filterGrid));
    importFilter((0, _filters.FILTER_LIB).noise, (0, _filterNoise.filterNoise));
    importFilter((0, _filters.FILTER_LIB).pattern, (0, _filterPattern.filterPattern));
    importFilter((0, _filters.FILTER_LIB).distort, (0, _filterDistort.filterDistort));
    importFilter((0, _filters.FILTER_LIB).vanishPoint, (0, _filterVanishPoint.filterVanishPoint));
    (0, _filters.FILTER_LIB_STATUS).isLoaded = true;
}

},{"./filters":"g0YSX","./filter-brightness-contrast":"kYsQU","./filter-crop-extend":"7zOac","./filter-curves":"6AKHC","./filter-flip":"6kJjO","./filter-hue-saturation":"bAqOF","./filter-invert":"8R1OQ","./filter-perspective":"c0zTv","./filter-resize":"1DDXZ","./filter-rotate":"lkJ03","./filter-tilt-shift":"8LMiw","./filter-transform":"jVUiJ","./filter-blur":"f8cQN","./filter-unsharp-mask":"6bRZw","./filter-to-alpha":"75hoV","./filter-grid":"ln3Cp","./filter-noise":"eN32i","./filter-pattern":"kvwLX","./filter-distort":"aZ3yq","./filter-vanish-point":"kggAL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kYsQU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterBrightnessContrast", ()=>filterBrightnessContrast);
var _klSlider = require("../ui/components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
var _base = require("../../bb/base/base");
const filterBrightnessContrast = {
    getDialog (params) {
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let brightness = 0, contrast = 0;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas)=>{
                return fxCanvas.brightnessContrast(brightness, contrast);
            },
            selection: klCanvas.getSelection()
        });
        const brightnessSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-bright-contrast-brightness'),
            width: 300,
            height: 30,
            min: 0,
            max: 100,
            value: (brightness + 1) * 50,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                brightness = val / 50 - 1;
                preview.render();
            }
        });
        const contrastSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-bright-contrast-contrast'),
            width: 300,
            height: 30,
            min: 0,
            max: 100,
            value: (contrast + 1) * 50,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                contrast = val / 50 - 1;
                preview.render();
            }
        });
        brightnessSlider.getElement().style.marginBottom = '10px';
        contrastSlider.getElement().style.marginBottom = '10px';
        rootEl.append(brightnessSlider.getElement(), contrastSlider.getElement());
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            brightnessSlider.destroy();
            contrastSlider.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                brightness: brightness,
                contrast: contrast
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const brightness = params.input.brightness;
        const contrast = params.input.contrast;
        const klHistory = params.klHistory;
        if (!context) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.brightnessContrast(brightness, contrast);
        }, klHistory);
    }
};

},{"../ui/components/kl-slider":"fQOKQ","./filters-consts":"gXypy","../../language/language":"mcywn","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../../bb/bb":"3zOvT","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gXypy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EVENT_RES_MS", ()=>EVENT_RES_MS);
const EVENT_RES_MS = 60;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dp0s7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FxPreviewRenderer", ()=>FxPreviewRenderer);
var _bb = require("../../../bb/bb");
var _sharedFx = require("../../../fx-canvas/shared-fx");
var _base = require("../../../bb/base/base");
var _transformationMatrix = require("transformation-matrix");
var _createMatrixFromTransform = require("../../../bb/transform/create-matrix-from-transform");
var _matrixToTuple = require("../../../bb/math/matrix-to-tuple");
var _canvas = require("../../../bb/base/canvas");
var _transformMultiPolygon = require("../../../bb/multi-polygon/transform-multi-polygon");
class FxPreviewRenderer {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.texture = undefined;
        this.maskCanvas = undefined // prevent destroying the mask repeatedly
        ;
        this.maskTexture = undefined;
        this.oldOnUpdateProps = {
            textureWidth: 0,
            textureHeight: 0,
            transform: {
                scaleX: 0,
                scaleY: 0,
                angleDeg: 0,
                x: 0,
                y: 0
            }
        };
        this.render = (viewportTransform, viewportWidth, viewportHeight)=>{
            const viewportMat = (0, _createMatrixFromTransform.createMatrixFromTransform)(viewportTransform);
            const padding = 0; // render more than visible with padding < 0
            let clippedViewportRect; // rect in viewport coordinates which contains the canvas
            let transformMatrix = (0, _transformationMatrix.identity)();
            {
                const topLeft = (0, _transformationMatrix.applyToPoint)(viewportMat, {
                    x: 0,
                    y: 0
                });
                const bottomRight = (0, _transformationMatrix.applyToPoint)(viewportMat, {
                    x: this.original.width,
                    y: this.original.height
                });
                bottomRight.x = Math.round(bottomRight.x);
                bottomRight.y = Math.round(bottomRight.y);
                const clippedTL = {
                    x: Math.max(padding, topLeft.x),
                    y: Math.max(padding, topLeft.y)
                };
                const clippedBR = {
                    x: Math.min(viewportWidth - padding, bottomRight.x),
                    y: Math.min(viewportHeight - padding, bottomRight.y)
                };
                clippedViewportRect = {
                    x: clippedTL.x,
                    y: clippedTL.y,
                    width: clippedBR.x - clippedTL.x,
                    height: clippedBR.y - clippedTL.y
                };
                if (clippedViewportRect.width <= 0 || clippedViewportRect.height <= 0) {
                    this.textureSource.width = 1;
                    this.textureSource.height = 1;
                    return this.textureSource;
                }
            }
            let resultTransform = (0, _transformationMatrix.compose)((0, _transformationMatrix.inverse)(viewportMat), (0, _transformationMatrix.translate)(padding, padding), (0, _transformationMatrix.translate)(clippedViewportRect.x - padding, clippedViewportRect.y - padding));
            const onUpdateProps = {
                textureWidth: Math.ceil(clippedViewportRect.width),
                textureHeight: Math.ceil(clippedViewportRect.height),
                transform: {
                    scaleX: viewportTransform.scaleX,
                    scaleY: viewportTransform.scaleY,
                    angleDeg: viewportTransform.angleDeg,
                    x: viewportTransform.x - clippedViewportRect.x,
                    y: viewportTransform.y - clippedViewportRect.y
                }
            };
            let tlOffsetX = 0;
            let tlOffsetY = 0;
            if (viewportTransform.scaleX > 1) {
                // what pixels of original canvas are actually visible
                const canvasTopLeft = (0, _transformationMatrix.applyToPoint)(resultTransform, {
                    x: 0,
                    y: 0
                });
                tlOffsetX = -canvasTopLeft.x;
                tlOffsetY = -canvasTopLeft.y;
                canvasTopLeft.x = Math.max(0, Math.floor(canvasTopLeft.x));
                canvasTopLeft.y = Math.max(0, Math.floor(canvasTopLeft.y));
                tlOffsetX += canvasTopLeft.x;
                tlOffsetY += canvasTopLeft.y;
                const canvasBottomRight = (0, _transformationMatrix.applyToPoint)(resultTransform, {
                    x: clippedViewportRect.width,
                    y: clippedViewportRect.height
                });
                canvasBottomRight.x = Math.min(this.original.width, Math.ceil(canvasBottomRight.x));
                canvasBottomRight.y = Math.min(this.original.height, Math.ceil(canvasBottomRight.y));
                const cw = canvasBottomRight.x - canvasTopLeft.x;
                const ch = canvasBottomRight.y - canvasTopLeft.y;
                onUpdateProps.textureWidth = cw;
                onUpdateProps.textureHeight = ch;
                onUpdateProps.transform = {
                    scaleX: 1,
                    scaleY: 1,
                    angleDeg: 0,
                    x: -canvasTopLeft.x,
                    y: -canvasTopLeft.y
                };
                resultTransform = (0, _transformationMatrix.compose)(resultTransform, (0, _transformationMatrix.scale)(viewportTransform.scaleX, viewportTransform.scaleY), (0, _transformationMatrix.translate)(tlOffsetX, tlOffsetY));
            }
            if (!this.texture || JSON.stringify(onUpdateProps) !== JSON.stringify(this.oldOnUpdateProps) || this.postMix) {
                // update texture
                this.textureSource.width = onUpdateProps.textureWidth;
                this.textureSource.height = onUpdateProps.textureHeight;
                // draw original canvas into temp
                this.ctx.save();
                this.ctx.imageSmoothingEnabled = false;
                if (viewportTransform.scaleX > 1) {
                    transformMatrix = (0, _createMatrixFromTransform.createMatrixFromTransform)(onUpdateProps.transform);
                    this.ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(transformMatrix));
                } else {
                    transformMatrix = (0, _transformationMatrix.inverse)(resultTransform);
                    this.ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(transformMatrix));
                }
                this.ctx.drawImage(this.original, 0, 0);
                this.ctx.restore();
                // debug
                /*BB.css(this.canvas, {
                position: 'absolute',
                left: '0',
                top: '0',
                zIndex: '1000',
                boxShadow: '0 0 0 1px #f00',
            });
            document.body.append(this.canvas);*/ const propsDidChange = JSON.stringify(onUpdateProps) !== JSON.stringify(this.oldOnUpdateProps);
                if (!this.texture || propsDidChange) {
                    if (this.texture) this.texture.loadContentsOf(this.textureSource);
                    else this.texture = this.fxCanvas.texture(this.textureSource);
                }
                if (this.selection && (!this.maskTexture || propsDidChange)) {
                    if (!this.maskCanvas) this.maskCanvas = (0, _bb.BB).canvas(onUpdateProps.textureWidth, onUpdateProps.textureHeight);
                    else {
                        this.maskCanvas.width = onUpdateProps.textureWidth;
                        this.maskCanvas.height = onUpdateProps.textureHeight;
                    }
                    const ctx = (0, _bb.BB).ctx(this.maskCanvas);
                    const transformedSelection = (0, _transformMultiPolygon.transformMultiPolygon)(this.selection, transformMatrix);
                    (0, _canvas.drawSelectionMask)(transformedSelection, ctx);
                    if (this.maskTexture) this.maskTexture.loadContentsOf(this.maskCanvas);
                    else this.maskTexture = this.fxCanvas.texture(this.maskCanvas);
                }
                if (!this.postMix) {
                    this.textureSource.width = 1;
                    this.textureSource.height = 1;
                }
            }
            this.oldOnUpdateProps = onUpdateProps;
            this.onUpdate(this.fxCanvas.draw(this.texture), onUpdateProps.transform);
            if (this.maskTexture) this.fxCanvas.multiplyAlpha().mask(this.maskTexture, this.isMaskingWithEmptyOriginal ? undefined : this.texture).unmultiplyAlpha();
            this.fxCanvas.update();
            if (this.postMix) {
                this.ctx.save();
                this.ctx.globalAlpha = this.postMix.opacity;
                this.ctx.globalCompositeOperation = this.postMix.operation;
                this.ctx.drawImage(this.fxCanvas, 0, 0);
                this.ctx.restore();
                return {
                    image: this.textureSource,
                    transform: resultTransform
                };
            }
            return {
                image: this.fxCanvas,
                transform: resultTransform
            };
        };
        this.original = p.original;
        this.onUpdate = p.onUpdate;
        this.textureSource = (0, _bb.BB).canvas(1, 1);
        this.ctx = (0, _bb.BB).ctx(this.textureSource);
        this.fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
        this.postMix = p.postMix;
        this.selection = p.selection;
        this.isMaskingWithEmptyOriginal = !!p.isMaskingWithEmptyOriginal;
    }
    setPostMix(postMix) {
        this.postMix = postMix;
    }
    destroy() {
        (0, _bb.BB).freeCanvas(this.textureSource);
        this.maskCanvas && (0, _bb.BB).freeCanvas(this.maskCanvas);
        if (this.texture) {
            this.texture = this.fxCanvas.texture(this.textureSource);
            this.fxCanvas.draw(this.texture).update();
            this.texture && this.texture.destroy();
        }
        // I don't remember why the other texture is destroyed differently.
        this.maskTexture?.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","../../../fx-canvas/shared-fx":"agFAL","../../../bb/base/base":"it3mQ","transformation-matrix":"70QDB","../../../bb/transform/create-matrix-from-transform":"6kvhU","../../../bb/math/matrix-to-tuple":"8BP1P","../../../bb/base/canvas":"86XNv","../../../bb/multi-polygon/transform-multi-polygon":"54b2I","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9sGVx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyFxFilter", ()=>applyFxFilter);
var _bb = require("../../bb/bb");
var _canvas = require("../../bb/base/canvas");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
var _sharedFx = require("../../fx-canvas/shared-fx");
function applyFxFilter(context, selection, applyFn, klHistory) {
    const fxCanvas = (0, _sharedFx.getSharedFx)();
    if (!fxCanvas) return false; // todo more specific error?
    let maskTexture;
    if (selection) {
        const maskCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
        const maskContext = (0, _bb.BB).ctx(maskCanvas);
        (0, _canvas.drawSelectionMask)(selection, maskContext);
        maskTexture = fxCanvas.texture(maskCanvas);
        (0, _bb.BB).freeCanvas(maskCanvas);
    }
    const originalTexture = fxCanvas.texture(context.canvas);
    fxCanvas.draw(originalTexture);
    applyFn(fxCanvas);
    if (maskTexture) {
        fxCanvas.multiplyAlpha().mask(maskTexture, originalTexture).unmultiplyAlpha();
        maskTexture.destroy();
    }
    originalTexture.destroy();
    fxCanvas.update();
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    context.drawImage(fxCanvas, 0, 0);
    klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(klHistory.getComposed(), (0, _canvasToLayerTiles.canvasToLayerTiles)(context.canvas, selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(selection)) : undefined)));
    return true;
}

},{"../../bb/bb":"3zOvT","../../bb/base/canvas":"86XNv","../history/push-helpers/get-pushable-layer-change":"cpxKS","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","../../fx-canvas/shared-fx":"agFAL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7zOac":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterCropExtend", ()=>filterCropExtend);
var _bb = require("../../bb/bb");
var _input = require("../ui/components/input");
var _checkbox = require("../ui/components/checkbox");
var _colorOptions = require("../ui/components/color-options");
var _cropper = require("../ui/components/cropper");
var _language = require("../../language/language");
var _previewSize = require("../ui/utils/preview-size");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
const filterCropExtend = {
    getDialog (params) {
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        const tempCanvas = (0, _bb.BB).canvas();
        {
            const fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 560, 400, 1);
            const w = parseInt('' + fit.width), h = parseInt('' + fit.height);
            const previewFactor = w / klCanvas.getWidth();
            tempCanvas.width = w;
            tempCanvas.height = h;
            tempCanvas.style.display = 'block';
            (0, _bb.BB).ctx(tempCanvas).drawImage(klCanvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        }
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let left = 0, right = 0, top = 0, bottom = 0;
        let leftChanged = false, rightChanged = false, topChanged = false, bottomChanged = false;
        const maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        let scale = 1;
        const selection = klCanvas.getSelection();
        let selectionBounds = selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(selection)) : undefined;
        if (selectionBounds) {
            const boundsWidth = selectionBounds.x2 - selectionBounds.x1;
            const boundsHeight = selectionBounds.y2 - selectionBounds.y1;
            if (boundsWidth <= maxWidth && boundsHeight <= maxHeight) {
                top = selectionBounds.y1;
                right = selectionBounds.x2 - klCanvas.getWidth();
                bottom = selectionBounds.y2 - klCanvas.getHeight();
                left = selectionBounds.x1;
            } else selectionBounds = undefined;
        }
        // --- input elements ---
        const leftInput = (0, _input.input)({
            init: left,
            type: 'number',
            min: -klCanvas.getWidth(),
            max: maxWidth,
            css: {
                width: '75px'
            },
            callback: function() {
                leftChanged = true;
                updateInput();
            }
        });
        const rightInput = (0, _input.input)({
            init: right,
            type: 'number',
            min: -klCanvas.getWidth(),
            max: maxWidth,
            css: {
                width: '75px'
            },
            callback: function() {
                rightChanged = true;
                updateInput();
            }
        });
        const topInput = (0, _input.input)({
            init: top,
            type: 'number',
            min: -klCanvas.getHeight(),
            max: maxHeight,
            css: {
                width: '75px'
            },
            callback: function() {
                topChanged = true;
                updateInput();
            }
        });
        const bottomInput = (0, _input.input)({
            init: bottom,
            type: 'number',
            min: -klCanvas.getHeight(),
            max: maxHeight,
            css: {
                width: '75px'
            },
            callback: function() {
                bottomChanged = true;
                updateInput();
            }
        });
        const sharedCss = {
            display: 'flex',
            flexDirection: 'column',
            width: 'calc(50% - 5px)',
            gap: '3px'
        };
        const leftWrapper = (0, _bb.BB).el({
            content: [
                (0, _language.LANG)('filter-crop-left') + ':',
                leftInput
            ],
            css: sharedCss
        });
        const rightWrapper = (0, _bb.BB).el({
            content: [
                (0, _language.LANG)('filter-crop-right') + ':',
                rightInput
            ],
            css: sharedCss
        });
        const topWrapper = (0, _bb.BB).el({
            content: [
                (0, _language.LANG)('filter-crop-top') + ':',
                topInput
            ],
            css: sharedCss
        });
        const bottomWrapper = (0, _bb.BB).el({
            content: [
                (0, _language.LANG)('filter-crop-bottom') + ':',
                bottomInput
            ],
            css: sharedCss
        });
        const wrapWrapper = (0, _bb.BB).el({
            css: {
                display: 'flex',
                flexWrap: 'wrap',
                gap: '10px'
            }
        });
        wrapWrapper.append(leftWrapper, rightWrapper, topWrapper, bottomWrapper);
        rootEl.append(wrapWrapper);
        function updateInput() {
            left = parseInt(leftInput.value);
            right = parseInt(rightInput.value);
            top = parseInt(topInput.value);
            bottom = parseInt(bottomInput.value);
            let newWidth = klCanvas.getWidth() + left + right;
            let newHeight = klCanvas.getHeight() + top + bottom;
            if (newWidth <= 0) {
                if (leftChanged) {
                    left = -klCanvas.getWidth() - right + 1;
                    leftInput.value = '' + left;
                }
                if (rightChanged) {
                    right = -klCanvas.getWidth() - left + 1;
                    rightInput.value = '' + right;
                }
                newWidth = 1;
            }
            if (newWidth > maxWidth) {
                if (leftChanged) {
                    left = -klCanvas.getWidth() - right + maxWidth;
                    leftInput.value = '' + left;
                }
                if (rightChanged) {
                    right = -klCanvas.getWidth() - left + maxWidth;
                    rightInput.value = '' + right;
                }
                newWidth = maxWidth;
            }
            if (newHeight <= 0) {
                if (topChanged) {
                    top = -klCanvas.getHeight() - bottom + 1;
                    topInput.value = '' + top;
                }
                if (bottomChanged) {
                    bottom = -klCanvas.getHeight() - top + 1;
                    bottomInput.value = '' + bottom;
                }
                newHeight = 1;
            }
            if (newHeight > maxHeight) {
                if (topChanged) {
                    top = -klCanvas.getHeight() - bottom + maxHeight;
                    topInput.value = '' + top;
                }
                if (bottomChanged) {
                    bottom = -klCanvas.getHeight() - top + maxHeight;
                    bottomInput.value = '' + bottom;
                }
                newHeight = maxHeight;
            }
            cropper.setTransform({
                x: -left,
                y: -top,
                width: newWidth,
                height: newHeight
            });
            leftChanged = false;
            rightChanged = false;
            topChanged = false;
            bottomChanged = false;
        }
        let useRuleOfThirds = true;
        const ruleOThirdsCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)('filter-crop-rule-thirds'),
            allowTab: true,
            callback: function(b) {
                useRuleOfThirds = b;
                cropper.showThirds(useRuleOfThirds);
            },
            name: 'rule-of-thirds'
        });
        rootEl.append((0, _bb.BB).el({
            css: {
                clear: 'both'
            }
        }));
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)('filter-crop-fill'),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                updateBg();
            }
        });
        const flexRow = (0, _bb.BB).el({
            css: {
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginTop: '10px'
            }
        });
        rootEl.append(flexRow);
        flexRow.append(ruleOThirdsCheckbox.getElement(), colorOptions.getElement());
        // when input field changed, or dragging in preview finished
        // adjusts the zoom
        function update(transform) {
            const fit = (0, _bb.BB).fitInto(transform.width, transform.height, 260, 180, 1);
            scale = fit.width / transform.width;
            const offset = (0, _bb.BB).centerWithin((0, _previewSize.SMALL_PREVIEW).width, previewHeight, fit.width, fit.height);
            tempCanvas.style.width = klCanvas.getWidth() * scale + 'px';
            tempCanvas.style.height = klCanvas.getHeight() * scale + 'px';
            offsetWrapper.style.left = offset.x - transform.x * scale + 'px';
            offsetWrapper.style.top = offset.y - transform.y * scale + 'px';
            left = parseInt('' + -transform.x);
            top = parseInt('' + -transform.y);
            right = parseInt('' + (transform.x + transform.width - klCanvas.getWidth()));
            bottom = parseInt('' + (transform.y + transform.height - klCanvas.getHeight()));
            leftInput.value = '' + left;
            topInput.value = '' + top;
            rightInput.value = '' + right;
            bottomInput.value = '' + bottom;
            if (selectedRgbaObj.a !== 0) {
                tempCanvas.style.background = 'var(--kl-checkerboard-background)';
                tempCanvas.style.backgroundSize = 100 * scale + 'px';
            }
            previewWrapper.style.backgroundPosition = offset.x + 'px ' + offset.y + 'px';
            previewWrapper.style.backgroundSize = 100 * scale + 'px';
            cropper.setScale(scale);
        }
        const previewHeight = (0, _previewSize.SMALL_PREVIEW).height - 2; // two less because of border
        const previewWrapper = (0, _bb.BB).el({
            className: 'kl-edit-crop-preview',
            css: {
                width: (0, _previewSize.SMALL_PREVIEW).width + 'px',
                marginTop: '10px',
                marginLeft: '-20px',
                height: previewHeight + 'px',
                backgroundColor: '#9e9e9e',
                position: 'relative',
                borderTop: '1px solid rgb(144,144,144)',
                borderBottom: '1px solid rgb(144,144,144)',
                overflow: 'hidden',
                userSelect: 'none',
                touchAction: 'none',
                background: 'var(--kl-checkerboard-background)'
            }
        });
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        const bgColorOverlay = (0, _bb.BB).el({
            css: {
                position: 'absolute',
                left: '0',
                top: '0',
                bottom: '0',
                right: '0'
            }
        });
        previewWrapper.append(bgColorOverlay);
        const offsetWrapper = (0, _bb.BB).el({
            parent: previewWrapper,
            css: {
                position: 'absolute',
                left: '0',
                top: '0'
            }
        });
        (0, _bb.BB).el({
            parent: offsetWrapper,
            content: tempCanvas,
            css: {
                boxShadow: '0 0 0px 1px rgb(130,130,130)',
                position: 'absolute',
                left: '0px',
                top: '0px'
            }
        });
        rootEl.append(previewWrapper);
        const cropper = new (0, _cropper.Cropper)({
            x: 0,
            y: 0,
            width: klCanvas.getWidth(),
            height: klCanvas.getHeight(),
            scale: scale,
            callback: update,
            maxW: maxWidth,
            maxH: maxHeight,
            init: selectionBounds
        });
        update(cropper.getTransform());
        offsetWrapper.append(cropper.getElement());
        function updateBg() {
            if (selectedRgbaObj.a === 0) {
                bgColorOverlay.style.background = '';
                tempCanvas.style.background = '';
            } else {
                bgColorOverlay.style.background = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
                tempCanvas.style.background = 'var(--kl-checkerboard-background)';
                tempCanvas.style.backgroundSize = 100 * scale + 'px';
            }
        }
        result.destroy = ()=>{
            cropper.destroy();
            ruleOThirdsCheckbox.destroy();
            colorOptions.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                left: left,
                right: right,
                top: top,
                bottom: bottom,
                fillColor: selectedRgbaObj.a === 0 ? undefined : selectedRgbaObj
            };
        };
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        if (!klCanvas || isNaN(params.input.left) || isNaN(params.input.right) || isNaN(params.input.top) || isNaN(params.input.bottom)) return false;
        klCanvas.resizeCanvas(params.input);
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../ui/components/input":"e8FQP","../ui/components/checkbox":"9bXL6","../ui/components/color-options":"1nMl0","../ui/components/cropper":"dNjUU","../../language/language":"mcywn","../ui/utils/preview-size":"eOdff","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6AKHC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterCurves", ()=>filterCurves);
var _bb = require("../../bb/bb");
var _curvesInput = require("./filter-curves/curves-input");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
var _base = require("../../bb/base/base");
const filterCurves = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let curves = (0, _curvesInput.getDefaultCurvesInput)();
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas)=>{
                return fxCanvas.curves(curves.r, curves.g, curves.b);
            },
            selection: klCanvas.getSelection()
        });
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        const input = new (0, _curvesInput.CurvesInput)({
            curves,
            callback: function(val) {
                curves = val;
                preview.render();
            }
        });
        const modeButtons = input.getModeButtons();
        rootEl.append(input.getElement(), preview.getElement());
        result.destroy = ()=>{
            input.destroy();
            modeButtons.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                curves: curves
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const curves = params.input.curves;
        const klHistory = params.klHistory;
        if (!context) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.curves(curves.r, curves.g, curves.b);
        }, klHistory);
    }
};

},{"../../bb/bb":"3zOvT","./filter-curves/curves-input":"1S8H2","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1S8H2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDefaultCurvesInput", ()=>getDefaultCurvesInput);
parcelHelpers.export(exports, "CurvesInput", ()=>CurvesInput);
var _options = require("../../ui/components/options");
var _language = require("../../../language/language");
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
function getDefaultCurvesInput() {
    return (0, _bb.BB).copyObj({
        r: [
            [
                0,
                0
            ],
            [
                1 / 3,
                1 / 3
            ],
            [
                2 / 3,
                2 / 3
            ],
            [
                1,
                1
            ]
        ],
        g: [
            [
                0,
                0
            ],
            [
                1 / 3,
                1 / 3
            ],
            [
                2 / 3,
                2 / 3
            ],
            [
                1,
                1
            ]
        ],
        b: [
            [
                0,
                0
            ],
            [
                1 / 3,
                1 / 3
            ],
            [
                2 / 3,
                2 / 3
            ],
            [
                1,
                1
            ]
        ]
    });
}
class CurvesInput {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: 'relative',
                marginBottom: '10px'
            }
        });
        this.rootEl.oncontextmenu = ()=>false;
        let mode = 'All';
        let curves = p.curves;
        this.modeButtons = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'All',
                    label: (0, _language.LANG)('filter-curves-all')
                },
                {
                    id: 'Red',
                    label: (0, _language.LANG)('red')
                },
                {
                    id: 'Green',
                    label: (0, _language.LANG)('green')
                },
                {
                    id: 'Blue',
                    label: (0, _language.LANG)('blue')
                }
            ],
            initId: 'All',
            onChange: (id)=>{
                mode = id;
                if (mode === 'All') curves = getDefaultCurvesInput();
                let curve = curves.r;
                if (mode === 'Green') curve = curves.g;
                if (mode === 'Blue') curve = curves.b;
                this.p0.setPos(0, areaH - curve[0][1] * areaH);
                this.p1.setPos(curve[1][0] * areaW, areaH - curve[1][1] * areaH);
                this.p2.setPos(curve[2][0] * areaW, areaH - curve[2][1] * areaH);
                this.p3.setPos(areaW, areaH - curve[3][1] * areaH);
                update();
            }
        });
        this.rootEl.append(this.modeButtons.getElement());
        const curveArea = (0, _bb.BB).el({
            parent: this.rootEl,
            className: 'kl-curves-graph',
            css: {
                position: 'relative',
                marginTop: '10px'
            }
        });
        const areaW = 300, areaH = 100;
        const canvas = (0, _bb.BB).canvas(areaW, areaH);
        let ctx = (0, _bb.BB).ctx(canvas);
        curveArea.append(canvas);
        const fit = (v)=>{
            return Math.max(0, Math.min(1, v));
        };
        const createPoint = (x, y, callback, lock)=>{
            const gripSize = 14;
            let internalY = y, internalX = x;
            const pointEl = (0, _bb.BB).el({
                className: 'kl-curves-graph__grip',
                css: {
                    left: x - gripSize / 2 + 'px',
                    top: y - gripSize / 2 + 'px',
                    width: gripSize + 'px',
                    height: gripSize + 'px',
                    borderRadius: gripSize + 'px'
                }
            });
            const update = ()=>{
                (0, _base.css)(pointEl, {
                    left: x - gripSize / 2 + 'px',
                    top: y - gripSize / 2 + 'px'
                });
            };
            const pointerListener = new (0, _bb.BB).PointerListener({
                target: pointEl,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === 'pointerdown') {
                        internalX = x;
                        internalY = y;
                    }
                    if (event.button === 'left' && event.type === 'pointermove') {
                        if (!lock) internalX += event.dX;
                        x = Math.max(0, Math.min(areaW, internalX));
                        internalY += event.dY;
                        y = Math.max(0, Math.min(areaH, internalY));
                        update();
                        callback({
                            x: x,
                            y: y
                        });
                    }
                }
            });
            curveArea.append(pointEl);
            const setPos = (newX, newY)=>{
                x = newX;
                y = newY;
                internalY = y;
                internalX = x;
                (0, _base.css)(pointEl, {
                    left: x - gripSize / 2 + 'px',
                    top: y - gripSize / 2 + 'px'
                });
            };
            return {
                el: pointEl,
                setPos,
                pointerListener
            };
        };
        const updateControl = (i, x, y)=>{
            if (mode === 'All') {
                curves.r[i] = [
                    fit(x / areaW),
                    fit(1 - y / areaH)
                ];
                curves.g[i] = [
                    fit(x / areaW),
                    fit(1 - y / areaH)
                ];
                curves.b[i] = [
                    fit(x / areaW),
                    fit(1 - y / areaH)
                ];
            }
            if (mode === 'Red') curves.r[i] = [
                fit(x / areaW),
                fit(1 - y / areaH)
            ];
            if (mode === 'Green') curves.g[i] = [
                fit(x / areaW),
                fit(1 - y / areaH)
            ];
            if (mode === 'Blue') curves.b[i] = [
                fit(x / areaW),
                fit(1 - y / areaH)
            ];
        };
        this.p0 = createPoint(0, areaH, (val)=>{
            updateControl(0, val.x, val.y);
            update();
        }, true);
        this.p1 = createPoint(areaW / 3, areaH / 3 * 2, (val)=>{
            updateControl(1, val.x, val.y);
            update();
        });
        this.p2 = createPoint(areaW / 3 * 2, areaH / 3, (val)=>{
            updateControl(2, val.x, val.y);
            update();
        });
        this.p3 = createPoint(areaW, 0, (val)=>{
            updateControl(3, val.x, val.y);
            update();
        }, true);
        const update = ()=>{
            ctx = (0, _bb.BB).ctx(canvas);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const outCurves = {
                r: [],
                g: [],
                b: []
            };
            for(let i = 0; i < curves.r.length; i++){
                outCurves.r.push(curves.r[i]);
                outCurves.g.push(curves.g[i]);
                outCurves.b.push(curves.b[i]);
            }
            const drawCurve = (curve)=>{
                ctx.beginPath();
                const spline = new (0, _bb.BB).SplineInterpolator(curve);
                for(let i = 0; i < 100; i++){
                    let y = spline.interpolate(i / 100);
                    y = Math.max(0, Math.min(1, y));
                    if (i === 0) ctx.moveTo(i / 100 * areaW, areaH - y * areaH);
                    else ctx.lineTo(i / 100 * areaW, areaH - y * areaH);
                }
                ctx.stroke();
            };
            ctx.save();
            if (mode === 'All') {
                ctx.strokeStyle = 'black';
                drawCurve(outCurves.r);
            } else {
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = 'red';
                drawCurve(outCurves.r);
                ctx.strokeStyle = 'green';
                drawCurve(outCurves.g);
                ctx.strokeStyle = 'blue';
                drawCurve(outCurves.b);
            }
            ctx.restore();
            p.callback(outCurves);
        };
        update();
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    getModeButtons() {
        return this.modeButtons;
    }
    destroy() {
        this.p0.pointerListener.destroy();
        this.p1.pointerListener.destroy();
        this.p2.pointerListener.destroy();
        this.p3.pointerListener.destroy();
    }
}

},{"../../ui/components/options":"7kiPU","../../../language/language":"mcywn","../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6kJjO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterFlip", ()=>filterFlip);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/components/checkbox");
var _klCanvasPreview = require("../ui/project-viewport/kl-canvas-preview");
var _language = require("../../language/language");
var _base = require("../../bb/base/base");
var _options = require("../ui/components/options");
var _previewSize = require("../ui/utils/preview-size");
const filterFlip = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        const w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let isHorizontal = true;
        let isVertical = false;
        let doFlipCanvas = true;
        const horizontalCheckbox = new (0, _checkbox.Checkbox)({
            init: isHorizontal,
            label: (0, _language.LANG)('filter-flip-horizontal') + " \u27F7",
            allowTab: true,
            callback: function(v) {
                isHorizontal = v;
                updatePreview();
            },
            css: {
                marginBottom: '10px'
            },
            name: 'flip-horizontal'
        });
        const verticalCheckbox = new (0, _checkbox.Checkbox)({
            init: isVertical,
            label: (0, _language.LANG)('filter-flip-vertical') + " \u2195",
            allowTab: true,
            callback: function(v) {
                isVertical = v;
                updatePreview();
            },
            css: {
                marginBottom: '10px'
            },
            name: 'flip-vertical'
        });
        rootEl.append(horizontalCheckbox.getElement());
        rootEl.append(verticalCheckbox.getElement());
        const targetOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: true,
                    label: (0, _language.LANG)('filter-flip-image')
                },
                {
                    id: false,
                    label: (0, _language.LANG)('filter-flip-layer')
                }
            ],
            onChange: (val)=>{
                doFlipCanvas = val;
                updatePreview();
            }
        });
        rootEl.append(targetOptions.getElement());
        const previewWrapper = (0, _bb.BB).el({
            className: 'kl-preview-wrapper',
            css: {
                width: (0, _previewSize.SMALL_PREVIEW).width + 'px',
                height: (0, _previewSize.SMALL_PREVIEW).height + 'px'
            }
        });
        const previewLayer = {
            image: (0, _bb.BB).canvas(Math.round(w), Math.round(h)),
            isVisible: true,
            opacity: 1,
            mixModeStr: 'source-over'
        };
        const klCanvasPreview = new (0, _klCanvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: [
                previewLayer
            ]
        });
        const previewInnerWrapper = (0, _bb.BB).el({
            className: 'kl-preview-wrapper__canvas',
            css: {
                width: parseInt('' + w) + 'px',
                height: parseInt('' + h) + 'px'
            }
        });
        previewInnerWrapper.append(klCanvasPreview.getElement());
        previewWrapper.append(previewInnerWrapper);
        function updatePreview() {
            const ctx = (0, _bb.BB).ctx(previewLayer.image);
            ctx.save();
            ctx.clearRect(0, 0, previewLayer.image.width, previewLayer.image.height);
            if (doFlipCanvas) {
                if (isHorizontal) {
                    ctx.translate(previewLayer.image.width, 0);
                    ctx.scale(-1, 1);
                }
                if (isVertical) {
                    ctx.translate(0, previewLayer.image.height);
                    ctx.scale(1, -1);
                }
            }
            for(let i = 0; i < layers.length; i++){
                if (!layers[i].isVisible) continue;
                ctx.save();
                if (!doFlipCanvas && selectedLayerIndex === i) {
                    if (isHorizontal) {
                        ctx.translate(previewLayer.image.width, 0);
                        ctx.scale(-1, 1);
                    }
                    if (isVertical) {
                        ctx.translate(0, previewLayer.image.height);
                        ctx.scale(1, -1);
                    }
                }
                if (ctx.canvas.width > layers[i].context.canvas.width) ctx.imageSmoothingEnabled = false;
                ctx.globalAlpha = layers[i].opacity;
                ctx.globalCompositeOperation = layers[i].mixModeStr;
                ctx.drawImage(layers[i].context.canvas, 0, 0, previewLayer.image.width, previewLayer.image.height);
                ctx.restore();
            }
            klCanvasPreview.render();
            ctx.restore();
        }
        setTimeout(updatePreview, 0);
        rootEl.append(previewWrapper);
        result.destroy = ()=>{
            horizontalCheckbox.destroy();
            verticalCheckbox.destroy();
            targetOptions.destroy();
            klCanvasPreview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                horizontal: isHorizontal,
                vertical: isVertical,
                flipCanvas: doFlipCanvas
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klCanvas = params.klCanvas;
        const horizontal = params.input.horizontal;
        const vertical = params.input.vertical;
        const flipCanvas = params.input.flipCanvas;
        if (!context || !klCanvas) return false;
        klCanvas.flip(horizontal, vertical, flipCanvas ? undefined : (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas)));
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../ui/components/checkbox":"9bXL6","../ui/project-viewport/kl-canvas-preview":"2vGJF","../../language/language":"mcywn","../../bb/base/base":"it3mQ","../ui/components/options":"7kiPU","../ui/utils/preview-size":"eOdff","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bAqOF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterHueSaturation", ()=>filterHueSaturation);
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/components/kl-slider");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
var _base = require("../../bb/base/base");
const filterHueSaturation = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let hue = 0, saturation = 0;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas)=>{
                return fxCanvas.hueSaturation(hue, saturation);
            },
            selection: klCanvas.getSelection()
        });
        const hueSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-hue-sat-hue'),
            width: 300,
            height: 30,
            min: -100,
            max: 100,
            value: hue * 100,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                hue = val / 100;
                preview.render();
            }
        });
        const saturationSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-hue-sat-saturation'),
            width: 300,
            height: 30,
            min: 0,
            max: 100,
            value: (saturation + 1) * 50,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                saturation = val / 50 - 1;
                preview.render();
            }
        });
        hueSlider.getElement().style.marginBottom = '10px';
        saturationSlider.getElement().style.marginBottom = '10px';
        rootEl.append(hueSlider.getElement(), saturationSlider.getElement());
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            hueSlider.destroy();
            saturationSlider.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                hue: hue,
                saturation: saturation
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const hue = params.input.hue;
        const klHistory = params.klHistory;
        const saturation = params.input.saturation;
        if (!context || hue === null || saturation === null) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.hueSaturation(hue, saturation);
        }, klHistory);
    }
};

},{"./filters-consts":"gXypy","../ui/components/kl-slider":"fQOKQ","../../language/language":"mcywn","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../../bb/bb":"3zOvT","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8R1OQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterInvert", ()=>filterInvert);
var _applyFxFilter = require("./apply-fx-filter");
const filterInvert = {
    apply (params) {
        const context = params.layer.context;
        const klHistory = params.klHistory;
        if (!context) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.invert();
        }, klHistory);
    }
};

},{"./apply-fx-filter":"9sGVx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c0zTv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterPerspective", ()=>filterPerspective);
var _bb = require("../../bb/bb");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _twoTabs = require("../ui/components/two-tabs");
var _transformationMatrix = require("transformation-matrix");
var _preview = require("../ui/project-viewport/preview");
var _base = require("../../bb/base/base");
var _draggableInput = require("../ui/components/draggable-input");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
const filterPerspective = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        if (!isSmall) result.width = (0, _previewSize.MEDIUM_PREVIEW).width;
        const fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
        const texture = (0, _base.throwIfUndefined)(fxCanvas?.texture(context.canvas));
        function update() {
            if (isBefore) fxCanvas.draw(texture).update();
            else fxCanvas.draw(texture).perspective(getFlatArr(beforeInputs), getFlatArr(afterInputs)).update();
            preview.render();
        }
        const rectPoints = [
            {
                x: 0,
                y: 0
            },
            {
                x: context.canvas.width,
                y: 0
            },
            {
                x: context.canvas.width,
                y: context.canvas.height
            },
            {
                x: 0,
                y: context.canvas.height
            }
        ];
        const beforeInputs = rectPoints.map((point)=>{
            return new (0, _draggableInput.DraggableInput)({
                value: point,
                onChange: ()=>{
                    update();
                }
            });
        });
        beforeInputs.forEach((item)=>item.getElement().style.display = 'none');
        const afterInputs = rectPoints.map((point)=>{
            return new (0, _draggableInput.DraggableInput)({
                value: point,
                onChange: ()=>{
                    update();
                }
            });
        });
        function getFlatArr(inputs, matrix) {
            return inputs.flatMap((item)=>{
                let value = item.getValue();
                if (matrix) value = (0, _transformationMatrix.applyToPoint)(matrix, value);
                return [
                    value.x,
                    value.y
                ];
            });
        }
        let isBefore = false;
        const beforeAfterTabs = new (0, _twoTabs.TwoTabs)({
            left: (0, _language.LANG)('compare-before'),
            right: (0, _language.LANG)('compare-after'),
            init: 1,
            onChange: (val)=>{
                isBefore = val === 0;
                if (isBefore) {
                    beforeInputs.forEach((item)=>item.getElement().style.display = 'block');
                    afterInputs.forEach((item)=>item.getElement().style.display = 'none');
                } else {
                    beforeInputs.forEach((item, index)=>{
                        afterInputs[index].setValue(item.getValue());
                    });
                    beforeInputs.forEach((item)=>item.getElement().style.display = 'none');
                    afterInputs.forEach((item)=>item.getElement().style.display = 'block');
                }
                update();
            }
        });
        rootEl.append(beforeAfterTabs.getElement());
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxCanvas : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            onTransformChange: (transform)=>{
                beforeInputs.forEach((item)=>item.setTransform(transform));
                afterInputs.forEach((item)=>item.setTransform(transform));
            }
        });
        (0, _base.css)(preview.getElement(), {
            overflow: 'hidden',
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        preview.getElement().append(...beforeInputs.map((item)=>item.getElement()), ...afterInputs.map((item)=>item.getElement()));
        rootEl.append(preview.getElement());
        update();
        result.destroy = ()=>{
            preview.destroy();
            texture.destroy();
            beforeInputs.forEach((item)=>item.destroy());
            afterInputs.forEach((item)=>item.destroy());
        };
        result.getInput = ()=>{
            result.destroy();
            return {
                before: getFlatArr(beforeInputs),
                after: getFlatArr(afterInputs)
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klHistory = params.klHistory;
        const before = params.input.before;
        const after = params.input.after;
        if (!context || !before || !after) return false;
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).multiplyAlpha().perspective(before, after).unmultiplyAlpha().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        {
            const layerMap = Object.fromEntries(params.klCanvas.getLayers().map((layerItem)=>{
                if (layerItem.id === params.layer.id) return [
                    layerItem.id,
                    {
                        tiles: (0, _canvasToLayerTiles.canvasToLayerTiles)(params.layer.canvas)
                    }
                ];
                return [
                    layerItem.id,
                    {}
                ];
            }));
            klHistory.push({
                layerMap
            });
        }
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../../fx-canvas/shared-fx":"agFAL","../../language/language":"mcywn","../ui/components/two-tabs":"6neWo","transformation-matrix":"70QDB","../ui/project-viewport/preview":"j8zOr","../../bb/base/base":"it3mQ","../ui/components/draggable-input":"kvq3O","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","../history/push-helpers/canvas-to-layer-tiles":"byCWA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6neWo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Two buttons next to each other, each representing a tab. one at a time can be active.
 */ parcelHelpers.export(exports, "TwoTabs", ()=>TwoTabs);
var _bb = require("../../../bb/bb");
class TwoTabs {
    update() {
        this.leftTab.classList.toggle('kl-2-tabs--active', this.value === 0);
        this.rightTab.classList.toggle('kl-2-tabs--active', this.value === 1);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.value = p.init;
        this.rootEl = (0, _bb.BB).el({
            className: 'kl-2-tabs'
        });
        this.leftTab = (0, _bb.BB).el({
            parent: this.rootEl,
            content: p.left,
            className: 'kl-2-tabs__left'
        });
        this.leftTab.onpointerdown = ()=>false;
        this.rightTab = (0, _bb.BB).el({
            parent: this.rootEl,
            content: p.right,
            className: 'kl-2-tabs__right'
        });
        this.rightTab.onpointerdown = ()=>false;
        this.update();
        this.leftTab.onclick = ()=>{
            if (this.value === 0) return;
            this.value = 0;
            this.update();
            p.onChange(this.value);
        };
        this.rightTab.onclick = ()=>{
            if (this.value === 1) return;
            this.value = 1;
            this.update();
            p.onChange(this.value);
        };
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kvq3O":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DraggableInput", ()=>DraggableInput);
var _bb = require("../../../bb/bb");
var _transformationMatrix = require("transformation-matrix");
var _createMatrixFromTransform = require("../../../bb/transform/create-matrix-from-transform");
var _base = require("../../../bb/base/base");
const SIZE = 16;
class DraggableInput {
    update() {
        const p = (0, _transformationMatrix.applyToPoint)((0, _createMatrixFromTransform.createMatrixFromTransform)(this.transform), this.value);
        (0, _base.css)(this.rootEl, {
            left: p.x - SIZE / 2 + 'px',
            top: p.y - SIZE / 2 + 'px'
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.value = {
            ...p.value
        };
        this.transform = {
            x: 0,
            y: 0,
            scale: 1,
            angleDeg: 0
        };
        this.rootEl = (0, _bb.BB).el({
            css: {
                width: SIZE + 'px',
                height: SIZE + 'px',
                backgroundColor: '#fff',
                border: '2px solid #000',
                borderRadius: SIZE + 'px',
                position: 'absolute',
                cursor: 'move',
                userSelect: 'none',
                touchAction: 'none'
            }
        });
        this.pointerListener = new (0, _bb.BB).PointerListener({
            target: this.rootEl,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.button === 'left' && event.type === 'pointermove') {
                    this.value.x += event.dX / this.transform.scale;
                    this.value.y += event.dY / this.transform.scale;
                    this.update();
                    p.onChange(this.value);
                }
            }
        });
    }
    setTransform(transform) {
        if (JSON.stringify(this.transform) === JSON.stringify(transform)) return;
        this.transform = transform;
        this.update();
    }
    getValue() {
        return this.value;
    }
    setValue(p) {
        this.value = {
            ...p
        };
        this.update();
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.rootEl.remove();
        this.pointerListener.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","transformation-matrix":"70QDB","../../../bb/transform/create-matrix-from-transform":"6kvhU","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1DDXZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterResize", ()=>filterResize);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/components/checkbox");
var _select = require("../ui/components/select");
var _constrainSvg = require("url:/src/app/img/ui/constrain.svg");
var _constrainSvgDefault = parcelHelpers.interopDefault(_constrainSvg);
var _language = require("../../language/language");
var _table = require("../ui/components/table");
var _previewSize = require("../ui/utils/preview-size");
var _base = require("../../bb/base/base");
const filterResize = {
    getDialog (params) {
        //BB.centerWithin
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        const fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 280, 200, 1);
        const w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        let previewFactor = w / klCanvas.getWidth();
        const tempCanvas = klCanvas.getCompleteCanvas(1);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let newWidth = klCanvas.getWidth(), newHeight = klCanvas.getHeight();
        const maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        const widthWrapper = (0, _bb.BB).el({
            css: {
                width: '150px',
                height: '35px',
                lineHeight: '30px'
            }
        });
        const heightWrapper = (0, _bb.BB).el({
            css: {
                width: '150px',
                height: '35px',
                lineHeight: '30px'
            }
        });
        const widthInput = (0, _bb.BB).el({
            tagName: 'input',
            css: {
                cssFloat: 'right',
                width: '90px'
            },
            custom: {
                type: 'number',
                min: '1',
                max: '' + maxWidth,
                value: '' + klCanvas.getWidth()
            }
        });
        const heightInput = (0, _bb.BB).el({
            tagName: 'input',
            css: {
                cssFloat: 'right',
                width: '90px'
            },
            custom: {
                type: 'number',
                min: '1',
                max: '' + maxHeight,
                value: '' + klCanvas.getHeight()
            }
        });
        widthInput.onclick = function() {
            this.focus();
            widthChanged = true;
            update();
        };
        heightInput.onclick = function() {
            this.focus();
            heightChanged = true;
            update();
        };
        widthInput.onchange = function() {
            widthChanged = true;
            update();
        };
        heightInput.onchange = function() {
            heightChanged = true;
            update();
        };
        widthWrapper.append((0, _language.LANG)('width') + ': ', widthInput);
        heightWrapper.append((0, _language.LANG)('height') + ': ', heightInput);
        const inputWrapper = (0, _bb.BB).el({
            css: {
                background: 'url(' + (0, _constrainSvgDefault.default) + ') no-repeat 140px 5px',
                backgroundSize: '50px 52px'
            }
        });
        inputWrapper.append(widthWrapper, heightWrapper);
        const constrainIm = new Image();
        constrainIm.src = (0, _constrainSvgDefault.default);
        constrainIm.height = 40;
        const sizeTable = (0, _table.table)([
            [
                (0, _language.LANG)('width') + ':&nbsp;',
                widthInput,
                constrainIm
            ],
            [
                (0, _bb.BB).el({
                    css: {
                        height: '5px'
                    }
                }),
                '',
                ''
            ],
            [
                (0, _language.LANG)('height') + ':&nbsp;',
                heightInput
            ]
        ], {
            '0.2': {
                rowspan: 3
            }
        });
        (0, _base.css)(sizeTable, {
            marginBottom: '10px'
        });
        rootEl.append(sizeTable);
        //contrain checkbox
        let heightChanged = false, widthChanged = false;
        const ratio = klCanvas.getWidth() / klCanvas.getHeight();
        function updateConstrain() {
            constrainIm.style.display = isConstrained ? '' : 'none';
            if (isConstrained) {
                widthInput.value = '' + klCanvas.getWidth();
                heightInput.value = '' + klCanvas.getHeight();
                update();
            }
        }
        let isConstrained = true;
        const constrainCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)('constrain-proportions'),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                updateConstrain();
            },
            name: 'constrain-proportions'
        });
        rootEl.append((0, _bb.BB).el({
            css: {
                clear: 'both'
            }
        }));
        const algorithmSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: [
                [
                    'smooth',
                    (0, _language.LANG)('algorithm-smooth')
                ],
                [
                    'pixelated',
                    (0, _language.LANG)('algorithm-pixelated')
                ]
            ],
            title: (0, _language.LANG)('scaling-algorithm'),
            initValue: 'smooth',
            onChange: ()=>{
                update();
            },
            name: 'interpolation-algorithm'
        });
        const secondRowElement = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
            }
        });
        secondRowElement.append(constrainCheckbox.getElement(), algorithmSelect.getElement());
        const previewCanvas = (0, _bb.BB).canvas(w, h);
        previewCanvas.style.imageRendering = 'pixelated';
        const previewCtx = (0, _bb.BB).ctx(previewCanvas);
        function draw() {
            if (algorithmSelect.getValue() === 'smooth') {
                previewCanvas.style.imageRendering = previewFactor > 1 ? 'pixelated' : '';
                previewCanvas.width = klCanvas.getWidth();
                previewCanvas.height = klCanvas.getHeight();
                previewCtx.save();
                previewCtx.imageSmoothingQuality = 'high';
                previewCtx.drawImage(tempCanvas, 0, 0);
                (0, _bb.BB).resizeCanvas(previewCanvas, newWidth, newHeight);
                previewCtx.restore();
            } else {
                previewCanvas.style.imageRendering = 'pixelated';
                previewCanvas.width = newWidth;
                previewCanvas.height = newHeight;
                previewCtx.save();
                previewCtx.imageSmoothingEnabled = false;
                previewCtx.drawImage(tempCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.restore();
            }
        }
        function update() {
            if (widthInput.value.length === 0 && widthChanged || heightInput.value.length === 0 && heightChanged) {
                heightChanged = false;
                widthChanged = false;
                return;
            }
            widthInput.value = '' + Math.max(1, parseInt(widthInput.value));
            heightInput.value = '' + Math.max(1, parseInt(heightInput.value));
            if (isConstrained) {
                if (heightChanged) widthInput.value = '' + parseInt('' + parseInt(heightInput.value) * ratio);
                if (widthChanged) heightInput.value = '' + parseInt('' + parseInt(widthInput.value) / ratio);
                if (parseInt(widthInput.value) > maxWidth || parseInt(heightInput.value) > maxHeight) {
                    const fit = (0, _bb.BB).fitInto(parseInt(widthInput.value), parseInt(heightInput.value), maxWidth, maxHeight, 1);
                    widthInput.value = '' + parseInt('' + fit.width);
                    heightInput.value = '' + parseInt('' + fit.height);
                }
            }
            if (parseInt(widthInput.value) > maxWidth) widthInput.value = '' + maxWidth;
            if (parseInt(heightInput.value) > maxHeight) heightInput.value = '' + maxHeight;
            heightChanged = false;
            widthChanged = false;
            newWidth = parseInt(widthInput.value);
            newHeight = parseInt(heightInput.value);
            const preview = (0, _bb.BB).fitInto(newWidth, newHeight, 280, 200, 1);
            const previewW = parseInt('' + preview.width), previewH = parseInt('' + preview.height);
            previewFactor = previewW / newWidth;
            const offset = (0, _bb.BB).centerWithin((0, _previewSize.SMALL_PREVIEW).width, (0, _previewSize.SMALL_PREVIEW).height, previewW, previewH);
            draw();
            previewCanvas.style.width = Math.max(1, previewW) + 'px';
            previewCanvas.style.height = Math.max(1, previewH) + 'px';
            canvasWrapper.style.left = offset.x + 'px';
            canvasWrapper.style.top = offset.y + 'px';
            canvasWrapper.style.width = Math.max(1, previewW) + 'px';
            canvasWrapper.style.height = Math.max(1, previewH) + 'px';
        }
        const previewWrapper = (0, _bb.BB).el({
            className: 'kl-transparent-preview',
            css: {
                width: (0, _previewSize.SMALL_PREVIEW).width + 'px',
                height: (0, _previewSize.SMALL_PREVIEW).height + 'px',
                marginLeft: '-20px',
                display: 'table',
                marginTop: '10px',
                position: 'relative',
                userSelect: 'none',
                background: 'var(--kl-checkerboard-background)',
                backgroundSize: '16px'
            }
        });
        const canvasWrapper = (0, _bb.BB).el({
            parent: previewWrapper,
            content: previewCanvas,
            className: 'kl-transparent-preview__canvas',
            css: {
                width: w + 'px',
                height: h + 'px',
                position: 'absolute',
                overflow: 'hidden'
            }
        });
        rootEl.append(previewWrapper);
        update();
        result.destroy = ()=>{
            constrainCheckbox.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                width: newWidth,
                height: newHeight,
                algorithm: algorithmSelect.getValue()
            };
        };
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const width = params.input.width;
        const height = params.input.height;
        const algorithm = params.input.algorithm;
        if (!klCanvas) return false;
        klCanvas.resize(width, height, algorithm);
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../ui/components/checkbox":"9bXL6","../ui/components/select":"iuUFh","url:/src/app/img/ui/constrain.svg":"2xeyp","../../language/language":"mcywn","../ui/components/table":"lM08M","../ui/utils/preview-size":"eOdff","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2xeyp":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("constrain.ee8deb1c.svg") + "?" + Date.now();

},{}],"lkJ03":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterRotate", ()=>filterRotate);
var _bb = require("../../bb/bb");
var _previewSize = require("../ui/utils/preview-size");
const filterRotate = {
    getDialog (params) {
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        const fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 280, 200, 1);
        const w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        const previewFactor = w / klCanvas.getWidth();
        const tempCanvas = (0, _bb.BB).canvas(w, h);
        tempCanvas.style.display = 'block';
        (0, _bb.BB).ctx(tempCanvas).drawImage(klCanvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let deg = 0;
        function update() {
            canvasWrapper.style.transform = 'rotate(' + deg + 'deg)';
            if (Math.abs(deg % 180) === 90) {
                //height has to fit width because of rotation
                const fit = (0, _bb.BB).fitInto(h, w, 280, 200, 1);
                const scale = parseInt('' + fit.height) / w;
                canvasWrapper.style.transform = 'rotate(' + deg + 'deg) scale(' + scale + ')';
            }
        }
        const minusBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: [
                (0, _bb.BB).el({
                    tagName: 'span',
                    content: "\u27F2",
                    css: {
                        fontSize: '1.3em'
                    }
                }),
                " 90\xb0"
            ],
            onClick: ()=>{
                deg -= 90;
                update();
            },
            noRef: true
        });
        const plusBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: [
                (0, _bb.BB).el({
                    tagName: 'span',
                    content: "\u27F3",
                    css: {
                        fontSize: '1.3em'
                    }
                }),
                " 90\xb0"
            ],
            onClick: ()=>{
                deg += 90;
                update();
            },
            noRef: true,
            css: {
                marginLeft: '5px'
            }
        });
        rootEl.append(minusBtn, plusBtn);
        const previewWrapper = (0, _bb.BB).el({
            className: 'kl-preview-wrapper',
            css: {
                width: (0, _previewSize.SMALL_PREVIEW).width + 'px',
                height: (0, _previewSize.SMALL_PREVIEW).height + 'px',
                display: 'table'
            }
        });
        const previewcell = (0, _bb.BB).el({
            parent: previewWrapper,
            css: {
                display: 'table-cell',
                verticalAlign: 'middle'
            }
        });
        const canvasWrapper = (0, _bb.BB).el({
            parent: previewcell,
            content: tempCanvas,
            className: 'kl-preview-wrapper__canvas',
            css: {
                width: w + 'px',
                height: h + 'px',
                marginLeft: 'auto',
                marginRight: 'auto',
                overflow: 'hidden',
                background: 'var(--kl-checkerboard-background)',
                backgroundSize: '16px'
            }
        });
        canvasWrapper.style.transition = 'transform 0.2s ease-out';
        rootEl.append(previewWrapper);
        update();
        result.destroy = ()=>{};
        result.getInput = function() {
            result.destroy();
            return {
                deg: deg
            };
        };
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        klCanvas.rotate(params.input.deg);
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../ui/utils/preview-size":"eOdff","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8LMiw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterTiltShift", ()=>filterTiltShift);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/components/kl-slider");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _createMatrixFromTransform = require("../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
var _draggableInput = require("../ui/components/draggable-input");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
var _base = require("../../bb/base/base");
const filterTiltShift = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let blur = 20, gradient = 200;
        let fxPreviewRenderer = {
            destroy: ()=>{}
        };
        fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                fa.setTransform(preview.getTransform());
                fb.setTransform(preview.getTransform());
                const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(transform);
                const a = (0, _transformationMatrix.applyToPoint)(m, fa.getValue());
                const b = (0, _transformationMatrix.applyToPoint)(m, fb.getValue());
                return fxCanvas.multiplyAlpha().tiltShift(a.x, a.y, b.x, b.y, blur * transform.scaleX, gradient * transform.scaleX).unmultiplyAlpha();
            },
            selection: klCanvas.getSelection()
        });
        function update() {
            preview.render();
        }
        // focus line control points
        const fa = new (0, _draggableInput.DraggableInput)({
            value: {
                x: context.canvas.width / 4,
                y: context.canvas.height / 2
            },
            onChange: ()=>{
                update();
            }
        });
        const fb = new (0, _draggableInput.DraggableInput)({
            value: {
                x: 3 * context.canvas.width / 4,
                y: context.canvas.height / 2
            },
            onChange: ()=>{
                update();
            }
        });
        const gradientSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-tilt-shift-gradient'),
            width: 300,
            height: 30,
            min: 0,
            max: 1000,
            value: gradient,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                gradient = val;
                update();
            }
        });
        gradientSlider.getElement().style.marginBottom = '10px';
        rootEl.append(gradientSlider.getElement());
        const blurSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-tilt-shift-blur'),
            width: 300,
            height: 30,
            min: 0,
            max: 200,
            value: blur,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                blur = val;
                update();
            }
        });
        blurSlider.getElement().style.marginBottom = '10px';
        rootEl.append(blurSlider.getElement());
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            overflow: 'hidden',
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        preview.getElement().append(fa.getElement(), fb.getElement());
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            blurSlider.destroy();
            gradientSlider.destroy();
            fa.destroy();
            fb.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                a: fa.getValue(),
                b: fb.getValue(),
                blur: blur,
                gradient: gradient
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klHistory = params.klHistory;
        const a = params.input.a;
        const b = params.input.b;
        const blur = params.input.blur;
        const gradient = params.input.gradient;
        if (!context) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.multiplyAlpha().tiltShift(a.x, a.y, b.x, b.y, blur, gradient).unmultiplyAlpha();
        }, klHistory);
    }
};

},{"../../bb/bb":"3zOvT","./filters-consts":"gXypy","../ui/components/kl-slider":"fQOKQ","../../language/language":"mcywn","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","../ui/components/draggable-input":"kvq3O","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jVUiJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterTransform", ()=>filterTransform);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/components/checkbox");
var _freeTransform = require("../ui/components/free-transform");
var _select = require("../ui/components/select");
var _klTypes = require("../kl-types");
var _language = require("../../language/language");
var _base = require("../../bb/base/base");
var _preview = require("../ui/project-viewport/preview");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _getSelectionBounds = require("../select-tool/get-selection-bounds");
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _transformationMatrix = require("transformation-matrix");
var _matrixToTuple = require("../../bb/math/matrix-to-tuple");
var _transformMultiPolygon = require("../../bb/multi-polygon/transform-multi-polygon");
// preference expressed by user
let preferenceIsTransparentBg;
function getIsTransparentBg(isBgLayer, layerHasTransparency, preference) {
    if (!isBgLayer) return true;
    if (preference !== undefined) return preference;
    return layerHasTransparency;
}
function parseCssColor(colorString) {
    if (colorString.startsWith('#')) {
        let hex = colorString.slice(1);
        if (hex.length === 3) hex = hex.split('').map((c)=>c + c).join('');
        if (hex.length === 6) // assume full alpha
        hex += 'ff';
        const intVal = parseInt(hex, 16);
        return {
            r: intVal >> 24 & 255,
            g: intVal >> 16 & 255,
            b: intVal >> 8 & 255,
            a: (intVal & 255) / 255
        };
    }
    const rgbMatch = colorString.match(/rgba?\(([^)]+)\)/);
    if (rgbMatch) {
        const [r, g, b, a = 1] = rgbMatch[1].split(',').map((v)=>parseFloat(v.trim()));
        return {
            r,
            g,
            b,
            a
        };
    }
    return undefined;
}
function testComposedLayerHasTransparency(layer) {
    for (const tile of layer.tiles)if ((0, _klTypes.isLayerFill)(tile)) {
        const color = parseCssColor(tile.fill);
        if (color && color.a < 1) return true;
    } else {
        const data = tile.data.data;
        for(let i = 3; i < data.length; i += 4){
            if (data[i] < 255) return true;
        }
    }
    return false;
}
function drawTransform(ctx, copiedCanvas, isPixelated, transform, selection, boundsObj, doClone, isTransparentBg) {
    const width = ctx.canvas.width;
    const height = ctx.canvas.height;
    ctx.save();
    ctx.clearRect(0, 0, width, height);
    ctx.save();
    if (selection) {
        // draw original with clipped selection
        ctx.drawImage(copiedCanvas, 0, 0);
        if (!doClone) {
            const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(selection);
            ctx.clip(selectionPath);
            ctx.globalCompositeOperation = isTransparentBg ? 'destination-out' : 'source-atop';
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);
        }
    } else {
        if (isTransparentBg) {
            if (doClone) ctx.drawImage(copiedCanvas, 0, 0);
        } else {
            ctx.drawImage(copiedCanvas, 0, 0);
            if (!doClone) {
                ctx.fillStyle = 'white';
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillRect(0, 0, width, height);
            }
        }
    }
    ctx.restore();
    let matrix;
    if (selection) {
        const bounds = boundsObj ?? {
            x: 0,
            y: 0,
            width: ctx.canvas.width,
            height: ctx.canvas.height
        };
        if (isPixelated || (0, _bb.BB).testShouldPixelate(transform, transform.width / bounds.width, transform.height / bounds.height)) ctx.imageSmoothingEnabled = false;
        else {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        // derived from drawTransformedImageWithBounds
        matrix = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(transform.x, transform.y), (0, _transformationMatrix.rotate)(transform.angleDeg / 180 * Math.PI), (0, _transformationMatrix.scale)(transform.width > 0 ? 1 : -1, transform.height > 0 ? 1 : -1), (0, _transformationMatrix.translate)(-Math.abs(transform.width) / 2, -Math.abs(transform.height) / 2), (0, _transformationMatrix.scale)(Math.abs(transform.width / bounds.width), Math.abs(transform.height / bounds.height)), (0, _transformationMatrix.translate)(-bounds.x, -bounds.y));
        ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(matrix));
        const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(selection);
        ctx.clip(selectionPath);
        ctx.drawImage(copiedCanvas, 0, 0);
    } else (0, _bb.BB).drawTransformedImageWithBounds(ctx, copiedCanvas, transform, boundsObj, isPixelated);
    ctx.restore();
    return matrix;
}
const filterTransform = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const isBgLayer = selectedLayerIndex === 0;
        let hasTransparency = false;
        if (isBgLayer) {
            const layer = Object.entries(params.composed.layerMap).find(([_, layer])=>layer.index === selectedLayerIndex)[1];
            hasTransparency = testComposedLayerHasTransparency(layer);
        }
        const selection = klCanvas.getSelection();
        // determine bounds and initial transformation
        const boundsObj = selection ? (0, _getSelectionBounds.getSelectionBounds)(selection, context) : (0, _bb.BB).canvasBounds(context);
        if (!boundsObj) return {
            error: (0, _language.LANG)(selection ? 'filter-transform-empty-selection' : 'filter-transform-empty')
        };
        const initTransform = {
            x: boundsObj.x + boundsObj.width / 2,
            y: boundsObj.y + boundsObj.height / 2,
            width: boundsObj.width,
            height: boundsObj.height,
            angleDeg: 0
        };
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        if (!isSmall) result.width = (0, _previewSize.MEDIUM_PREVIEW).width;
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: function(keyStr) {
                if ((0, _bb.BB).isInputFocused(true)) return;
                if (keyStr === 'left') {
                    inputX.value = '' + (parseFloat(inputX.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === 'right') {
                    inputX.value = '' + (parseFloat(inputX.value) + 1);
                    onInputsChanged();
                }
                if (keyStr === 'up') {
                    inputY.value = '' + (parseFloat(inputY.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === 'down') {
                    inputY.value = '' + (parseFloat(inputY.value) + 1);
                    onInputsChanged();
                }
            }
        });
        const leftWrapper = (0, _bb.BB).el({
            css: {
                width: '100px',
                height: '30px',
                display: 'inline-block'
            }
        });
        const rightWrapper = (0, _bb.BB).el({
            css: {
                width: '100px',
                height: '30px',
                display: 'inline-block'
            }
        });
        const rotWrapper = (0, _bb.BB).el({
            css: {
                width: '150px',
                height: '30px',
                display: 'inline-block'
            }
        });
        const inputY = (0, _bb.BB).el({
            tagName: 'input'
        });
        const inputX = (0, _bb.BB).el({
            tagName: 'input'
        });
        const inputR = (0, _bb.BB).el({
            tagName: 'input'
        });
        inputY.type = 'number';
        inputX.type = 'number';
        inputR.type = 'number';
        inputX.style.width = "70px";
        inputY.style.width = "70px";
        inputR.style.width = "70px";
        inputY.value = '0';
        inputX.value = '0';
        inputR.value = '0';
        inputY.onclick = function() {
            inputY.focus();
            onInputsChanged();
        };
        inputX.onclick = function() {
            inputX.focus();
            onInputsChanged();
        };
        inputR.onclick = function() {
            inputR.focus();
            onInputsChanged();
        };
        inputY.onchange = function() {
            onInputsChanged();
        };
        inputX.onchange = function() {
            onInputsChanged();
        };
        inputR.onchange = function() {
            onInputsChanged();
        };
        inputY.onkeyup = function() {
            onInputsChanged();
        };
        inputX.onkeyup = function() {
            onInputsChanged();
        };
        inputR.onkeyup = function() {
            onInputsChanged();
        };
        leftWrapper.append('X: ', inputX);
        rightWrapper.append('Y: ', inputY);
        rotWrapper.append((0, _language.LANG)('filter-transform-rotation') + ': ', inputR);
        if (!isSmall) {
            const inputRow = (0, _bb.BB).el({
                parent: rootEl,
                css: {
                    marginTop: '10px'
                }
            });
            inputRow.append(leftWrapper, rightWrapper, rotWrapper);
        }
        // buttons
        const buttonRow = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                flexWrap: 'wrap',
                alignItems: 'center',
                gap: '10px',
                marginTop: '10px'
            }
        });
        const flipXBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: 'button',
            content: (0, _language.LANG)('filter-transform-flip') + ' X',
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setSize(-t.width, t.height);
            }
        });
        const flipYBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: 'button',
            content: (0, _language.LANG)('filter-transform-flip') + ' Y',
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setSize(t.width, -t.height);
            }
        });
        const scaleRotLeftBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: 'button',
            content: "-90\xb0",
            onClick: ()=>{
                const t = freeTransform.getValue();
                t.angleDeg -= 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = '' + Math.round(t.angleDeg);
                updatePreview();
            }
        });
        const scaleRotRightBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: 'button',
            content: "+90\xb0",
            onClick: ()=>{
                const t = freeTransform.getValue();
                t.angleDeg += 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = '' + Math.round(t.angleDeg);
                updatePreview();
            }
        });
        const scaleDoubleBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: 'button',
            content: '2x',
            onClick: ()=>{
                const t = freeTransform.getValue();
                if (constrainCheckbox.getValue()) freeTransform.setSize((t.width < 0 ? -1 : 1) * freeTransform.getRatio() * Math.abs(t.height) * 2, t.height * 2);
                else freeTransform.setSize(t.width * 2, t.height * 2);
            }
        });
        const scaleHalfBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: 'button',
            content: '1/2x',
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setSize(Math.round(t.width / 2), Math.round(t.height / 2));
            }
        });
        const centerBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: 'button',
            content: (0, _language.LANG)('center'),
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setPos({
                    x: context.canvas.width / 2,
                    y: context.canvas.height / 2
                });
                freeTransform.setAngleDeg(t.angleDeg);
                updatePreview();
            }
        });
        let doClone = false;
        const cloneCheckbox = new (0, _checkbox.Checkbox)({
            init: doClone,
            label: (0, _language.LANG)('select-transform-clone'),
            allowTab: true,
            callback: function(b) {
                doClone = b;
                updatePreview(true);
            },
            css: {
                display: 'inline-block'
            },
            name: 'clone-before-transforming'
        });
        let isTransparentBg = getIsTransparentBg(isBgLayer, hasTransparency, preferenceIsTransparentBg);
        let transparentBgCheckboxTouched = false;
        const transparentBgCheckbox = new (0, _checkbox.Checkbox)({
            init: isTransparentBg,
            label: (0, _language.LANG)('brush-eraser-transparent-bg'),
            allowTab: true,
            callback: function(b) {
                transparentBgCheckboxTouched = true;
                isTransparentBg = b;
                updatePreview(true);
            },
            css: {
                display: 'inline-block'
            },
            name: 'transparent-background'
        });
        buttonRow.append(cloneCheckbox.getElement());
        if (isBgLayer) buttonRow.append(transparentBgCheckbox.getElement());
        let isConstrained = true;
        const constrainCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)('filter-transform-constrain'),
            title: (0, _language.LANG)('constrain-proportions'),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                freeTransform.setIsConstrained(isConstrained);
            },
            css: {
                display: 'inline-block'
            },
            name: 'constrain-proportions'
        });
        let isSnapping = false;
        const snappingCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)('filter-transform-snap'),
            title: (0, _language.LANG)('filter-transform-snap-title'),
            allowTab: true,
            callback: function(b) {
                isSnapping = b;
                freeTransform.setSnapping(isSnapping);
            },
            css: {
                display: 'inline-block',
                marginLeft: '10px'
            },
            name: 'enable-snapping'
        });
        const checkboxWrapper = (0, _bb.BB).el();
        checkboxWrapper.append(constrainCheckbox.getElement(), snappingCheckbox.getElement());
        rootEl.append((0, _bb.BB).el({
            css: {
                clear: 'both',
                height: '10px'
            }
        }));
        const bottomRow = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '10px'
            }
        });
        const algorithmSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: [
                [
                    'smooth',
                    (0, _language.LANG)('algorithm-smooth')
                ],
                [
                    'pixelated',
                    (0, _language.LANG)('algorithm-pixelated')
                ]
            ],
            initValue: 'smooth',
            title: (0, _language.LANG)('scaling-algorithm'),
            onChange: ()=>{
                updatePreview(true);
            },
            name: 'interpolation-algorithm'
        });
        bottomRow.append(checkboxWrapper, algorithmSelect.getElement());
        const previewCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? previewCanvas : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            hasEditMode: true,
            onModeChange: (m)=>{
                freeTransform.getElement().style.pointerEvents = m === 'edit' ? '' : 'none';
                freeTransform.getElement().style.opacity = m === 'edit' ? '' : '0.5';
            },
            onTransformChange: (transform)=>{
                freeTransform.setViewportTransform(transform);
            },
            padding: 30
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            overflow: 'hidden',
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        let lastDrawnTransformStr = '';
        function updatePreview(doForce = false) {
            if (!freeTransform) return;
            const transform = freeTransform.getValue();
            if (JSON.stringify(transform) === lastDrawnTransformStr && !doForce) return;
            lastDrawnTransformStr = JSON.stringify(transform);
            const ctx = (0, _bb.BB).ctx(previewCanvas);
            drawTransform(ctx, layers[selectedLayerIndex].context.canvas, algorithmSelect.getValue() === 'pixelated', transform, selection, boundsObj, doClone, isTransparentBg || selectedLayerIndex > 0);
            preview.render();
        }
        const freeTransform = new (0, _freeTransform.FreeTransform)({
            x: initTransform.x,
            y: initTransform.y,
            width: initTransform.width,
            height: initTransform.height,
            angleDeg: initTransform.angleDeg,
            isConstrained: true,
            snapX: [
                0,
                context.canvas.width
            ],
            snapY: [
                0,
                context.canvas.height
            ],
            callback: function(t) {
                inputX.value = '' + Math.round(t.x - initTransform.x);
                inputY.value = '' + Math.round(t.y - initTransform.y);
                inputR.value = '' + Math.round(t.angleDeg);
                updatePreview();
            },
            viewportTransform: preview.getTransform()
        });
        (0, _base.css)(freeTransform.getElement(), {
            position: 'absolute',
            left: '0',
            top: '0'
        });
        preview.getElement().append(freeTransform.getElement());
        function onInputsChanged() {
            freeTransform.setPos({
                x: parseInt(inputX.value) + initTransform.x,
                y: parseInt(inputY.value) + initTransform.y
            });
            freeTransform.setAngleDeg(parseInt(inputR.value));
            updatePreview();
        }
        updatePreview();
        result.destroy = ()=>{
            keyListener.destroy();
            freeTransform.destroy();
            constrainCheckbox.destroy();
            snappingCheckbox.destroy();
            (0, _bb.BB).destroyEl(flipXBtn);
            (0, _bb.BB).destroyEl(flipYBtn);
            (0, _bb.BB).destroyEl(scaleRotLeftBtn);
            (0, _bb.BB).destroyEl(scaleRotRightBtn);
            (0, _bb.BB).destroyEl(scaleDoubleBtn);
            (0, _bb.BB).destroyEl(scaleHalfBtn);
            (0, _bb.BB).destroyEl(centerBtn);
            preview.destroy();
            (0, _bb.BB).freeCanvas(previewCanvas);
        };
        result.getInput = function() {
            const transform = freeTransform.getValue();
            if (transparentBgCheckboxTouched) preferenceIsTransparentBg = isTransparentBg;
            const input = {
                transform,
                bounds: boundsObj,
                isPixelated: algorithmSelect.getValue() === 'pixelated',
                doClone,
                isTransparentBg
            };
            result.destroy();
            return (0, _bb.BB).copyObj(input);
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klHistory = params.klHistory;
        if (!context) return false;
        klHistory.pause(true);
        const input = params.input;
        const selectedLayerIndex = params.klCanvas.getLayerIndex(context.canvas);
        const copyCanvas = (0, _bb.BB).copyCanvas(context.canvas);
        let selection = params.klCanvas.getSelection();
        const matrix = drawTransform(context, copyCanvas, input.isPixelated, input.transform, selection, input.bounds, input.doClone, input.isTransparentBg || selectedLayerIndex > 0);
        if (selection && matrix) {
            selection = (0, _transformMultiPolygon.transformMultiPolygon)(selection, matrix);
            params.klCanvas.setSelection(selection);
        }
        klHistory.pause(false);
        {
            const layerMap = Object.fromEntries(params.klCanvas.getLayers().map((layerItem)=>{
                if (layerItem.id === params.layer.id) return [
                    layerItem.id,
                    {
                        tiles: (0, _canvasToLayerTiles.canvasToLayerTiles)(params.layer.canvas)
                    }
                ];
                return [
                    layerItem.id,
                    {}
                ];
            }));
            klHistory.push({
                layerMap,
                ...selection ? {
                    selection: {
                        value: selection
                    }
                } : undefined
            });
        }
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../ui/components/checkbox":"9bXL6","../ui/components/free-transform":"2fR2j","../ui/components/select":"iuUFh","../kl-types":"E0RUG","../../language/language":"mcywn","../../bb/base/base":"it3mQ","../ui/project-viewport/preview":"j8zOr","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../select-tool/get-selection-bounds":"jrEMM","../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","transformation-matrix":"70QDB","../../bb/math/matrix-to-tuple":"8BP1P","../../bb/multi-polygon/transform-multi-polygon":"54b2I","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f8cQN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterBlur", ()=>filterBlur);
var _klSlider = require("../ui/components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
var _base = require("../../bb/base/base");
const filterBlur = {
    getDialog (params) {
        const klCanvas = params.klCanvas;
        const context = params.context;
        if (!klCanvas || !context) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let radius = 10;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                return fxCanvas.multiplyAlpha().triangleBlur(radius * transform.scaleX).unmultiplyAlpha();
            },
            selection: klCanvas.getSelection()
        });
        const radiusSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('radius'),
            width: 300,
            height: 30,
            min: 1,
            max: 200,
            value: radius,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: (val)=>{
                radius = val;
                preview.render();
            }
        });
        radiusSlider.getElement().style.marginBottom = '10px';
        rootEl.append(radiusSlider.getElement());
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            radiusSlider.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                radius: radius
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klHistory = params.klHistory;
        const radius = params.input.radius;
        if (!context || !radius) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.multiplyAlpha().triangleBlur(radius).unmultiplyAlpha();
        }, klHistory);
    }
};

},{"../ui/components/kl-slider":"fQOKQ","./filters-consts":"gXypy","../../language/language":"mcywn","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../../bb/bb":"3zOvT","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6bRZw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterUnsharpMask", ()=>filterUnsharpMask);
var _klSlider = require("../ui/components/kl-slider");
var _language = require("../../language/language");
var _preview = require("../ui/project-viewport/preview");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
var _base = require("../../bb/base/base");
const filterUnsharpMask = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let radius = 2, strength = 0.51;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                return fxCanvas.unsharpMask(radius * transform.scaleX, strength);
            },
            selection: klCanvas.getSelection()
        });
        function update() {
            preview.render();
        }
        const radiusSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('radius'),
            width: 300,
            height: 30,
            min: 0,
            max: 200,
            value: 2,
            //eventResMs: eventResMs,
            onChange: function(val) {
                radius = val;
                update();
            },
            curve: [
                [
                    0,
                    0
                ],
                [
                    0.1,
                    2
                ],
                [
                    0.5,
                    50
                ],
                [
                    1,
                    200
                ]
            ]
        });
        const strengthSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-unsharp-mask-strength'),
            width: 300,
            height: 30,
            min: 0,
            max: 50,
            value: 5.1,
            //eventResMs: eventResMs,
            onChange: function(val) {
                strength = val / 10;
                update();
            },
            curve: [
                [
                    0,
                    0
                ],
                [
                    0.1,
                    2
                ],
                [
                    0.5,
                    10
                ],
                [
                    1,
                    50
                ]
            ]
        });
        radiusSlider.getElement().style.marginBottom = '10px';
        strengthSlider.getElement().style.marginBottom = '10px';
        rootEl.append(radiusSlider.getElement());
        rootEl.append(strengthSlider.getElement());
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        update();
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            radiusSlider.destroy();
            strengthSlider.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                radius: radius,
                strength: strength
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klHistory = params.klHistory;
        const radius = params.input.radius;
        const strength = params.input.strength;
        if (!context || radius === null || strength === null) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.unsharpMask(radius, strength);
        }, klHistory);
    }
};

},{"../ui/components/kl-slider":"fQOKQ","../../language/language":"mcywn","../ui/project-viewport/preview":"j8zOr","../ui/project-viewport/fx-preview-renderer":"dp0s7","../../bb/bb":"3zOvT","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"75hoV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterToAlpha", ()=>filterToAlpha);
var _options = require("../ui/components/options");
var _colorOptions = require("../ui/components/color-options");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
var _base = require("../../bb/base/base");
const filterToAlpha = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas)=>{
                return fxCanvas.toAlpha(sourceId === 'inverted-luminance', selectedRgbaObj);
            },
            selection: klCanvas.getSelection()
        });
        // source
        let sourceId = 'inverted-luminance';
        const sourceOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'inverted-luminance',
                    label: (0, _language.LANG)('filter-to-alpha-inverted-lum')
                },
                {
                    id: 'luminance',
                    label: (0, _language.LANG)('filter-to-alpha-lum')
                }
            ],
            initId: sourceId,
            onChange: function(id) {
                sourceId = id;
                preview.render();
            }
        });
        rootEl.append(sourceOptions.getElement());
        // color
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        const colorOptionsArr = [
            null,
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            },
            {
                r: params.currentColorRgb.r,
                g: params.currentColorRgb.g,
                b: params.currentColorRgb.b,
                a: 1
            },
            {
                r: params.secondaryColorRgb.r,
                g: params.secondaryColorRgb.g,
                b: params.secondaryColorRgb.b,
                a: 1
            }
        ];
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)('filter-to-alpha-replace'),
            colorArr: colorOptionsArr,
            initialIndex: 1,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                preview.render();
            },
            css: {
                margin: '10px 0'
            }
        });
        rootEl.append(colorOptions.getElement());
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            sourceOptions.destroy();
            colorOptions.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                sourceId: sourceId,
                selectedRgbaObj: selectedRgbaObj
            };
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klHistory = params.klHistory;
        const sourceId = params.input.sourceId;
        const selectedRgbaObj = params.input.selectedRgbaObj;
        if (!context || !sourceId) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.toAlpha(sourceId === 'inverted-luminance', selectedRgbaObj);
        }, klHistory);
    }
};

},{"../ui/components/options":"7kiPU","../ui/components/color-options":"1nMl0","../../language/language":"mcywn","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../../bb/bb":"3zOvT","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ln3Cp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterGrid", ()=>filterGrid);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
var _input = require("../ui/components/input");
var _colorOptions = require("../ui/components/color-options");
var _drawGrid = require("../image-operations/draw-grid");
var _base = require("../../bb/base/base");
var _preview = require("../ui/project-viewport/preview");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
const filterGrid = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const settingsObj = {
            x: 2,
            y: 2,
            thickness: 8,
            color: '#000',
            opacity: 1
        };
        const line1 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                alignItems: 'center'
            }
        });
        const line2 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                alignItems: 'center',
                marginTop: '10px',
                marginBottom: '10px'
            }
        });
        const xInput = (0, _input.input)({
            init: 2,
            type: 'number',
            min: 1,
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                settingsObj.x = parseFloat(v);
                updatePreview();
            }
        });
        const yInput = (0, _input.input)({
            init: 2,
            type: 'number',
            min: 1,
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                settingsObj.y = parseFloat(v);
                updatePreview();
            }
        });
        const thicknessInput = (0, _input.input)({
            init: settingsObj.thickness,
            type: 'number',
            min: 1,
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                settingsObj.thickness = parseFloat(v);
                updatePreview();
            }
        });
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        settingsObj.color = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)('shape-stroke'),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                settingsObj.color = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
                updatePreview();
            }
        });
        const labelStyle = {
            display: 'inline-block',
            marginRight: '5px'
        };
        line1.append((0, _bb.BB).el({
            content: 'X:',
            css: labelStyle
        }), xInput, (0, _bb.BB).el({
            content: 'Y:',
            css: labelStyle
        }), yInput);
        line2.append((0, _bb.BB).el({
            content: (0, _language.LANG)('shape-line-width') + ':',
            css: labelStyle
        }), thicknessInput, (0, _bb.BB).el({
            css: {
                flexGrow: '1'
            }
        }), colorOptions.getElement());
        const previewCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
        const previewCtx = (0, _bb.BB).ctx(previewCanvas);
        const previewLayerArr = layers.map((item, i)=>{
            return {
                image: i === selectedLayerIndex ? previewCanvas : item.context.canvas,
                isVisible: item.isVisible,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr,
                hasClipping: false
            };
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            }
        });
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        function updatePreview() {
            const ctx = previewCtx;
            ctx.save();
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            ctx.drawImage(context.canvas, 0, 0);
            (0, _drawGrid.drawGrid)(ctx, settingsObj.x, settingsObj.y, Math.max(settingsObj.thickness, 1), settingsObj.color, settingsObj.opacity);
            ctx.restore();
            preview.render();
        }
        updatePreview();
        preview.render();
        result.destroy = ()=>{
            preview.destroy();
            (0, _bb.BB).freeCanvas(previewCanvas);
            colorOptions.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klCanvas = params.klCanvas;
        const klHistory = params.klHistory;
        if (!context || !klCanvas) return false;
        (0, _drawGrid.drawGrid)(context, params.input.x, params.input.y, params.input.thickness, params.input.color, params.input.opacity);
        {
            const layerMap = Object.fromEntries(params.klCanvas.getLayers().map((layerItem)=>{
                if (layerItem.id === params.layer.id) return [
                    layerItem.id,
                    {
                        tiles: (0, _canvasToLayerTiles.canvasToLayerTiles)(params.layer.canvas)
                    }
                ];
                return [
                    layerItem.id,
                    {}
                ];
            }));
            klHistory.push({
                layerMap
            });
        }
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../../language/language":"mcywn","../ui/components/input":"e8FQP","../ui/components/color-options":"1nMl0","../image-operations/draw-grid":"cJALy","../../bb/base/base":"it3mQ","../ui/project-viewport/preview":"j8zOr","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","../history/push-helpers/canvas-to-layer-tiles":"byCWA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cJALy":[function(require,module,exports,__globalThis) {
// ideas: padding, gutter, other shapes
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawGrid", ()=>drawGrid);
function drawGrid(ctx, cellsX, cellsY, thickness, color, opacity) {
    ctx.save();
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    thickness = Math.round(thickness);
    const thickIsRound = thickness % 2 === 0;
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.strokeStyle = color;
    ctx.globalAlpha = opacity;
    for(let i = 0; i < cellsX - 1; i++){
        const cw = w / cellsX;
        let pos = cw * (i + 1);
        if (thickIsRound) pos = Math.round(pos);
        else pos = Math.round(pos + 0.5) - 0.5;
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, h);
    }
    for(let i = 0; i < cellsY - 1; i++){
        const ch = h / cellsY;
        let pos = ch * (i + 1);
        if (thickIsRound) pos = Math.round(pos);
        else pos = Math.round(pos + 0.5) - 0.5;
        ctx.moveTo(0, pos);
        ctx.lineTo(w, pos);
    }
    ctx.stroke();
    ctx.restore();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eN32i":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterNoise", ()=>filterNoise);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
var _klSlider = require("../ui/components/kl-slider");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _options = require("../ui/components/options");
var _filtersConsts = require("./filters-consts");
var _select = require("../ui/components/select");
var _translateBlending = require("../canvas/translate-blending");
var _kl = require("../kl");
var _color = require("../../bb/color/color");
var _checkbox = require("../ui/components/checkbox");
var _base = require("../../bb/base/base");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _previewSize = require("../ui/utils/preview-size");
var _testIsSmall = require("../ui/utils/test-is-small");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
var _canvas = require("../../bb/base/canvas");
var _getPushableLayerChange = require("../history/push-helpers/get-pushable-layer-change");
var _math = require("../../bb/math/math");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
const presetArr = [
    // each pixel random value
    {
        type: 0,
        scaleX: 1,
        scaleY: 1,
        offsetX: 0,
        offsetY: 0,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0,
        contrast: 0,
        isReversed: true
    },
    // cloud
    {
        type: 1,
        scaleX: 166,
        scaleY: 164,
        offsetX: 105,
        offsetY: 30,
        octaves: 6,
        samples: 1,
        peaks: 0,
        brightness: 0.055,
        contrast: 0.23,
        isReversed: true
    },
    // thin lines
    {
        type: 1,
        scaleX: 235,
        scaleY: 190,
        offsetX: 3227,
        offsetY: 2156,
        octaves: 4,
        samples: 16,
        peaks: 22,
        brightness: -0.375,
        contrast: 1,
        isReversed: false
    },
    // soft large simplex, only 1 octave
    {
        type: 1,
        scaleX: 40,
        scaleY: 40,
        offsetX: 0,
        offsetY: 0,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0,
        contrast: 0,
        isReversed: false
    },
    // two value large pixels
    {
        type: 0,
        scaleX: 26,
        scaleY: 26,
        offsetX: 557,
        offsetY: 365,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0.02,
        contrast: 1,
        isReversed: true
    },
    // zebra
    {
        type: 1,
        scaleX: 1500,
        scaleY: 1500,
        offsetX: 745,
        offsetY: 2871,
        octaves: 5,
        samples: 16,
        peaks: 156.02,
        brightness: 0.03,
        contrast: 1,
        isReversed: true
    },
    // sparse dots / stars
    {
        type: 1,
        scaleX: 11,
        scaleY: 11,
        offsetX: 2940,
        offsetY: 2045,
        octaves: 1,
        samples: 16,
        peaks: 1,
        brightness: -0.045,
        contrast: 1,
        isReversed: true
    },
    // pseudo marble
    {
        type: 2,
        scaleX: 74,
        scaleY: 74,
        offsetX: 4816,
        offsetY: 1304,
        octaves: 3,
        samples: 1,
        peaks: 2.78,
        brightness: 0,
        contrast: 0,
        isReversed: false
    }
];
function createNoiseSettings(input) {
    const result = (0, _bb.BB).copyObj(presetArr[input.presetIndex]);
    result.seed = input.seed;
    result.scaleX = result.scaleX * input.scale / 50;
    result.scaleY = result.scaleY * input.scale / 50;
    result.colA = input.colA;
    result.colB = input.colB;
    result.isReversed = input.isReversed ? !result.isReversed : result.isReversed;
    result.channels = input.channels;
    return result;
}
function createNoiseParameters(settings) {
    return [
        settings.seed,
        settings.type,
        [
            settings.scaleX,
            settings.scaleY
        ],
        [
            settings.offsetX,
            settings.offsetY
        ],
        settings.octaves,
        settings.samples,
        settings.peaks,
        settings.brightness,
        settings.contrast,
        settings.isReversed,
        settings.colA,
        settings.colB,
        settings.channels ? settings.channels : 'rgb'
    ];
}
const filterNoise = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const thumbImgArr = [];
        const thumbSize = 32;
        {
            const fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
            const canvas = (0, _bb.BB).canvas(thumbSize, thumbSize);
            const ctx = (0, _bb.BB).ctx(canvas);
            const texture = fxCanvas.texture(canvas);
            fxCanvas.draw(texture).update(); // update fxCanvas size
            texture.destroy();
            presetArr.forEach((preset)=>{
                const thumbImg = new Image();
                const settings = (0, _bb.BB).copyObj(preset);
                settings.scaleX /= 10;
                settings.scaleY /= 10;
                fxCanvas.noise(...createNoiseParameters(settings)).update();
                ctx.drawImage(fxCanvas, 0, 0);
                thumbImg.src = canvas.toDataURL('image/png');
                thumbImgArr.push(thumbImg);
            });
            texture.destroy();
        }
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const noiseInput = {
            seed: Math.random() * 300,
            presetIndex: 0,
            scale: 50,
            opacity: 0.5,
            isReversed: false,
            channels: 'rgb',
            mixModeStr: 'source-over',
            colA: {
                r: 0,
                g: 0,
                b: 0
            },
            colB: {
                r: 255,
                g: 255,
                b: 255
            }
        };
        const presetOptions = new (0, _options.Options)({
            optionArr: thumbImgArr.map((img, index)=>{
                (0, _base.css)(img, {
                    margin: '1px',
                    borderRadius: '3px',
                    transition: 'all 0.1s ease-in-out'
                });
                return {
                    id: '' + index,
                    label: img
                };
            }),
            initId: '0',
            onChange: (id)=>{
                noiseInput.presetIndex = Number(id);
                update();
            },
            css: {
                marginBottom: '10px'
            }
        });
        rootEl.append(presetOptions.getElement());
        const scaleSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-noise-scale'),
            width: 300,
            height: 30,
            min: 1,
            max: 1000,
            value: noiseInput.scale,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            curve: (0, _bb.BB).powerSplineInput(1, 1000, 0.1),
            onChange: (value)=>{
                noiseInput.scale = value;
                update();
            }
        });
        scaleSlider.getElement().style.marginBottom = '10px';
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('opacity'),
            width: 300,
            height: 30,
            min: 0.01,
            max: 1,
            value: noiseInput.opacity,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: (value)=>{
                noiseInput.opacity = value;
                update();
            }
        });
        opacitySlider.getElement().style.marginBottom = '10px';
        const row1El = (0, _bb.BB).el({
            css: {
                display: 'flex',
                alignItems: 'center',
                marginBottom: '10px'
            }
        });
        const row2El = (0, _bb.BB).el({
            css: {
                display: 'flex',
                marginBottom: '10px'
            }
        });
        const channelsOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'rgb',
                    label: 'RGB'
                },
                {
                    id: 'alpha',
                    label: (0, _language.LANG)('filter-noise-alpha')
                }
            ],
            initId: 'rgb',
            onChange: (id)=>{
                noiseInput.channels = id;
                if (id === 'rgb') row2El.style.visibility = '';
                else row2El.style.visibility = 'hidden';
                update();
            }
        });
        const reverseToggle = new (0, _checkbox.Checkbox)({
            label: (0, _language.LANG)('reverse'),
            callback: (val)=>{
                noiseInput.isReversed = val;
                update();
            },
            allowTab: true,
            name: 'reverse-gradient'
        });
        const mixModes = [
            'source-over',
            undefined,
            'darken',
            'multiply',
            'color-burn',
            undefined,
            'lighten',
            'screen',
            'color-dodge',
            undefined,
            'overlay',
            'soft-light',
            'hard-light',
            undefined,
            'difference',
            'exclusion',
            undefined,
            'hue',
            'saturation',
            'color',
            'luminosity'
        ];
        const blendSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: mixModes.map((item)=>{
                return item ? [
                    item,
                    (0, _translateBlending.translateBlending)(item)
                ] : undefined;
            }),
            initValue: noiseInput.mixModeStr,
            onChange: (val)=>{
                noiseInput.mixModeStr = val;
                update();
            },
            name: 'blend-mode'
        });
        blendSelect.getElement().title = (0, _language.LANG)('layers-blending');
        const colorWrapper = (0, _bb.BB).el({
            css: {
                display: 'flex'
            }
        });
        const colInputStyle = {
            width: '34px',
            height: '34px',
            marginRight: '5px'
        };
        const colAInput = (0, _kl.KL).input({
            type: 'color',
            init: '#' + (0, _color.ColorConverter).toHexString(noiseInput.colA),
            callback: (val)=>{
                const newColor = (0, _color.ColorConverter).hexToRGB(val);
                if (newColor) {
                    noiseInput.colA = newColor;
                    update();
                }
            },
            css: colInputStyle
        });
        const colBInput = (0, _kl.KL).input({
            type: 'color',
            init: '#' + (0, _color.ColorConverter).toHexString(noiseInput.colB),
            callback: (val)=>{
                const newColor = (0, _color.ColorConverter).hexToRGB(val);
                if (newColor) {
                    noiseInput.colB = newColor;
                    update();
                }
            },
            css: colInputStyle
        });
        colorWrapper.append(colAInput, colBInput);
        row1El.append(channelsOptions.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: '1'
            }
        }), reverseToggle.getElement());
        row2El.append(blendSelect.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: '1'
            }
        }), colorWrapper);
        rootEl.append(scaleSlider.getElement(), opacitySlider.getElement(), row1El, row2El);
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                const settings = createNoiseSettings(noiseInput);
                settings.scaleX *= transform.scaleX;
                settings.scaleY *= transform.scaleY;
                settings.offsetX = context.canvas.width / 2 * transform.scaleX + transform.x;
                settings.offsetY = context.canvas.height / 2 * transform.scaleY + transform.y;
                return fxCanvas.noise(...createNoiseParameters(settings));
            },
            postMix: {
                opacity: noiseInput.opacity,
                operation: noiseInput.channels === 'alpha' ? 'destination-out' : noiseInput.mixModeStr
            },
            selection: klCanvas.getSelection(),
            isMaskingWithEmptyOriginal: true
        });
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        function update() {
            fxPreviewRenderer.setPostMix({
                opacity: noiseInput.opacity,
                operation: noiseInput.channels === 'alpha' ? 'destination-out' : noiseInput.mixModeStr
            });
            preview.render();
        }
        result.destroy = ()=>{
            presetOptions.destroy();
            scaleSlider.destroy();
            opacitySlider.destroy();
            reverseToggle.destroy();
            channelsOptions.destroy();
            blendSelect.destroy();
            preview.destroy();
            fxPreviewRenderer.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(noiseInput);
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klCanvas = params.klCanvas;
        const klHistory = params.klHistory;
        if (!context || !klCanvas) return false;
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const input = params.input;
        const selection = klCanvas.getSelection();
        let maskTexture;
        if (selection) {
            const maskCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
            const maskContext = (0, _bb.BB).ctx(maskCanvas);
            (0, _canvas.drawSelectionMask)(selection, maskContext);
            maskTexture = fxCanvas.texture(maskCanvas);
            (0, _bb.BB).freeCanvas(maskCanvas);
        }
        fxCanvas.initialize(context.canvas.width, context.canvas.height);
        {
            const settings = createNoiseSettings(input);
            settings.offsetX = context.canvas.width / 2;
            settings.offsetY = context.canvas.height / 2;
            fxCanvas.noise(...createNoiseParameters(settings)).update();
        }
        if (maskTexture) {
            fxCanvas.multiplyAlpha().mask(maskTexture).unmultiplyAlpha();
            maskTexture.destroy();
        }
        fxCanvas.update();
        context.save();
        context.globalAlpha = input.opacity;
        if (input.channels === 'alpha') context.globalCompositeOperation = 'destination-out';
        else context.globalCompositeOperation = input.mixModeStr;
        context.drawImage(fxCanvas, 0, 0);
        context.restore();
        klHistory.push((0, _getPushableLayerChange.getPushableLayerChange)(klHistory.getComposed(), (0, _canvasToLayerTiles.canvasToLayerTiles)(context.canvas, selection ? (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(selection)) : undefined)));
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../../language/language":"mcywn","../ui/components/kl-slider":"fQOKQ","../../fx-canvas/shared-fx":"agFAL","../ui/components/options":"7kiPU","./filters-consts":"gXypy","../ui/components/select":"iuUFh","../canvas/translate-blending":"l3XnR","../kl":"lHQKw","../../bb/color/color":"e0D0Q","../ui/components/checkbox":"9bXL6","../../bb/base/base":"it3mQ","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../ui/utils/preview-size":"eOdff","../ui/utils/test-is-small":"5jelf","../history/push-helpers/canvas-to-layer-tiles":"byCWA","../../bb/base/canvas":"86XNv","../history/push-helpers/get-pushable-layer-change":"cpxKS","../../bb/math/math":"7x9Fp","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kvwLX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterPattern", ()=>filterPattern);
var _bb = require("../../bb/bb");
var _input = require("../ui/components/input");
var _klSlider = require("../ui/components/kl-slider");
var _language = require("../../language/language");
var _filtersConsts = require("./filters-consts");
var _klCanvasPreview = require("../ui/project-viewport/kl-canvas-preview");
var _twoTabs = require("../ui/components/two-tabs");
var _base = require("../../bb/base/base");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
/**
 * Draws pattern onto context. Pattern generated from context.
 * Can use blending for smoother transition. Will use area outside of bounds for blending.
 *
 * @param context
 * @param settings
 */ function drawPattern(context, settings) {
    // keep bounds in center via offset
    // because blending done towards bottom right
    const blendOffsetX = settings.blend ? Math.round(settings.blend * settings.width / 2) : 0;
    const blendOffsetY = settings.blend ? Math.round(settings.blend * settings.height / 2) : 0;
    const finalPatternCanvas = (0, _bb.BB).canvas(settings.width, settings.height);
    if (settings.blend) {
        // construct pattern via linear blending
        const blendCanvas = (0, _bb.BB).canvas(settings.width * 2, settings.height * 2);
        const blendCtx = (0, _bb.BB).ctx(blendCanvas);
        const colTransparent = '#0000';
        const colOpaque = '#000';
        // transfer source to blendCanvas
        blendCtx.drawImage(context.canvas, -settings.x + blendOffsetX, -settings.y + blendOffsetY);
        // --- 1 cross-fade vertical ------------------------
        // erase vertical gradient bottom half
        blendCtx.save();
        let blendGradient = blendCtx.createLinearGradient(0, settings.height, 0, settings.height * 2);
        blendGradient.addColorStop(0, colOpaque);
        blendGradient.addColorStop(settings.blend, colTransparent);
        blendCtx.globalCompositeOperation = 'destination-in';
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, blendCanvas.width, blendCanvas.height);
        blendCtx.restore();
        // erase vertical gradient top half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(0, 0, 0, settings.height);
        blendGradient.addColorStop(0, colTransparent);
        blendGradient.addColorStop(settings.blend, colOpaque);
        blendCtx.globalCompositeOperation = 'destination-in';
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, settings.width * 2, settings.height * 2);
        blendCtx.restore();
        // draw bottom half over top half
        blendCtx.save();
        // lighter needed for accurate cross-fade
        blendCtx.globalCompositeOperation = 'lighter';
        blendCtx.drawImage(blendCanvas, 0, -settings.height);
        blendCtx.restore();
        // --- 2 cross-fade horizontal ------------------------
        // erase horizontal gradient right half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(settings.width, 0, settings.width * 2, 0);
        blendGradient.addColorStop(0, colOpaque);
        blendGradient.addColorStop(settings.blend, colTransparent);
        blendCtx.globalCompositeOperation = 'destination-in';
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, blendCanvas.width, blendCanvas.height);
        blendCtx.restore();
        // erase horizontal gradient left half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(0, 0, settings.width, 0);
        blendGradient.addColorStop(0, colTransparent);
        blendGradient.addColorStop(settings.blend, colOpaque);
        blendCtx.globalCompositeOperation = 'destination-in';
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, settings.width * 2, settings.height * 2);
        blendCtx.restore();
        // draw right half over left half
        blendCtx.save();
        // lighter needed for accurate cross-fade
        blendCtx.globalCompositeOperation = 'lighter';
        blendCtx.drawImage(blendCanvas, -settings.width, 0);
        blendCtx.restore();
        // transfer to pattern canvas
        (0, _bb.BB).ctx(finalPatternCanvas).drawImage(blendCanvas, 0, 0);
    } else (0, _bb.BB).ctx(finalPatternCanvas).drawImage(context.canvas, -settings.x, -settings.y);
    context.save();
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    context.translate(settings.offsetX - blendOffsetX, settings.offsetY - blendOffsetY);
    context.fillStyle = (0, _base.throwIfNull)(context.createPattern(finalPatternCanvas, 'repeat'));
    context.fillRect(-settings.offsetX + blendOffsetX, -settings.offsetY + blendOffsetY, context.canvas.width, context.canvas.height);
    context.restore();
}
const filterPattern = {
    getDialog (params) {
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const maxSize = 1024;
        const rootEl = (0, _bb.BB).el();
        const context = params.context;
        const width = context.canvas.width;
        const height = context.canvas.height;
        let settings = {
            x: 0,
            y: 0,
            width: width <= 250 ? Math.round(width / 4) : 200,
            height: height <= 250 ? Math.round(height / 4) : 200,
            blend: 0,
            offsetX: 0,
            offsetY: 0
        };
        let lastDrawnSettings;
        // determine bounds
        const bounds = (0, _bb.BB).canvasBounds(context);
        // adjust settings according to bounds
        if (// use layer bounds if:
        bounds && bounds.width <= maxSize && bounds.height <= maxSize && // don't exceed max size
        (bounds.width < width * 0.75 || bounds.height < height * 0.75 // aren't too large (heuristic)
        )) {
            settings.x = bounds.x;
            settings.y = bounds.y;
            settings.width = bounds.width;
            settings.height = bounds.height;
        } else {
            // otherwise use default size in center
            settings.x = Math.round(width / 2 - settings.width / 2);
            settings.y = Math.round(height / 2 - settings.height / 2);
        }
        // ---- controls ----
        const xInput = (0, _input.input)({
            init: settings.x,
            type: 'number',
            min: 0,
            max: width,
            css: {
                width: '100%'
            },
            callback: function(v) {
                settings.x = Number(v);
                updatePreview();
            }
        });
        const yInput = (0, _input.input)({
            init: settings.y,
            type: 'number',
            min: 0,
            max: height,
            css: {
                width: '100%'
            },
            callback: function(v) {
                settings.y = Number(v);
                updatePreview();
            }
        });
        const widthInput = (0, _input.input)({
            init: settings.width,
            type: 'number',
            min: 1,
            max: Math.min(maxSize, width),
            css: {
                width: '100%'
            },
            callback: function(v) {
                settings.width = Number(v);
                updatePreview();
            }
        });
        const heightInput = (0, _input.input)({
            init: settings.height,
            type: 'number',
            min: 1,
            max: Math.min(maxSize, height),
            css: {
                width: '100%'
            },
            callback: function(v) {
                settings.height = Number(v);
                updatePreview();
            }
        });
        const inputStyle = {
            marginLeft: '5px',
            flex: '1'
        };
        rootEl.append((0, _bb.BB).el({
            content: [
                (0, _bb.BB).el({
                    tagName: 'label',
                    content: [
                        'X:',
                        xInput
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: 'label',
                    content: [
                        'Y:',
                        yInput
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: 'label',
                    content: [
                        (0, _language.LANG)('width') + ':',
                        widthInput
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: 'label',
                    content: [
                        (0, _language.LANG)('height') + ':',
                        heightInput
                    ],
                    css: inputStyle
                })
            ],
            css: {
                display: 'flex',
                marginLeft: '-5px'
            }
        }));
        const blendSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('brush-blending'),
            width: 300,
            height: 30,
            min: 0,
            max: 1,
            value: settings.blend,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                settings.blend = val;
                updatePreview();
            },
            formatFunc: (val)=>{
                return (0, _bb.BB).round(val, 2);
            },
            manualInputRoundDigits: 2
        });
        (0, _base.css)(blendSlider.getElement(), {
            margin: '10px 0'
        });
        rootEl.append(blendSlider.getElement());
        // ---- preview tabs ----
        let previewMode = 1; // 0 before, 1 after
        const beforeAfterTabs = new (0, _twoTabs.TwoTabs)({
            left: (0, _language.LANG)('compare-before'),
            right: (0, _language.LANG)('compare-after'),
            init: previewMode,
            onChange: (val)=>{
                previewMode = val;
                overlayCanvas.style.display = val === 0 ? 'block' : 'none';
                updatePreview(true);
            }
        });
        rootEl.append(beforeAfterTabs.getElement());
        // ---- previews ----
        const klCanvas = params.klCanvas;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        const w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        const renderW = Math.min(w, context.canvas.width);
        const renderH = Math.min(h, context.canvas.height);
        // const renderFactor = renderW / context.canvas.width;
        const previewFactor = w / context.canvas.width;
        const previewWrapper = (0, _bb.BB).el({
            className: 'kl-preview-wrapper',
            css: {
                width: (0, _previewSize.getPreviewWidth)(isSmall) + 'px',
                height: (0, _previewSize.getPreviewHeight)(isSmall) + 'px',
                marginTop: '0'
            }
        });
        const previewLayer = {
            image: (0, _bb.BB).canvas(renderW, renderH),
            isVisible: layers[selectedLayerIndex].isVisible,
            opacity: layers[selectedLayerIndex].opacity,
            mixModeStr: layers[selectedLayerIndex].mixModeStr
        };
        const previewLayerArr = layers.map((item, i)=>{
            if (i === selectedLayerIndex) return previewLayer;
            else return {
                image: item.context.canvas,
                isVisible: item.isVisible,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr
            };
        });
        const klCanvasPreview = new (0, _klCanvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: previewLayerArr
        });
        const overlayCanvas = (0, _bb.BB).canvas(w, h);
        (0, _base.css)(overlayCanvas, {
            position: 'absolute',
            left: '0',
            top: '0',
            mixBlendMode: 'difference',
            imageRendering: 'pixelated'
        });
        const previewInnerWrapper = (0, _bb.BB).el({
            className: 'kl-preview-wrapper__canvas',
            css: {
                width: parseInt('' + w) + 'px',
                height: parseInt('' + h) + 'px'
            }
        });
        previewInnerWrapper.append(klCanvasPreview.getElement(), overlayCanvas);
        previewWrapper.append(previewInnerWrapper);
        rootEl.append(previewWrapper);
        // ---- preview input processing ----
        const inputs = {};
        function syncInputs() {
            xInput.value = '' + settings.x;
            yInput.value = '' + settings.y;
            widthInput.value = '' + settings.width;
            heightInput.value = '' + settings.height;
        }
        const keyListener = new (0, _bb.BB).KeyListener({});
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        previewInnerWrapper.style.touchAction = 'none';
        const pointerListener = new (0, _bb.BB).PointerListener({
            target: previewInnerWrapper,
            onPointer: (event)=>{
                if (previewMode === 0) {
                    if (event.type === 'pointerdown') {
                        if (!inputs.state) {
                            inputs.oldSettings = (0, _bb.BB).copyObj(settings);
                            const x = event.relX / previewFactor;
                            const y = event.relY / previewFactor;
                            if ((0, _bb.BB).isInsideRect({
                                x,
                                y
                            }, {
                                x: settings.x,
                                y: settings.y,
                                width: settings.width,
                                height: settings.height
                            })) inputs.state = 'move';
                            else inputs.state = 'select';
                            inputs.start = {
                                x,
                                y
                            };
                        }
                    } else if (event.type === 'pointermove') {
                        const x = event.relX / previewFactor;
                        const y = event.relY / previewFactor;
                        if (inputs.state === 'select') {
                            inputs.end = {
                                x,
                                y
                            };
                            const x1 = Math.max(0, Math.min(inputs.start.x, inputs.end.x));
                            const y1 = Math.max(0, Math.min(inputs.start.y, inputs.end.y));
                            const x2 = Math.min(width, Math.max(inputs.start.x, inputs.end.x));
                            const y2 = Math.min(height, Math.max(inputs.start.y, inputs.end.y));
                            settings.x = Math.floor(x1);
                            settings.y = Math.floor(y1);
                            settings.width = Math.min(maxSize, Math.ceil(x2 - settings.x));
                            settings.height = Math.min(maxSize, Math.ceil(y2 - settings.y));
                            if (keyListener.isPressed('shift')) {
                                settings.width = Math.min(settings.width, settings.height);
                                settings.height = Math.min(settings.width, settings.height);
                            }
                            if (settings.width === 0 || settings.height === 0) settings = (0, _bb.BB).copyObj(inputs.oldSettings);
                            syncInputs();
                            updatePreview();
                        } else if (inputs.state === 'move') {
                            const dX = Math.round(x - inputs.start.x);
                            const dY = Math.round(y - inputs.start.y);
                            settings.x = (0, _bb.BB).clamp(inputs.oldSettings.x + dX, 0, width - settings.width);
                            settings.y = (0, _bb.BB).clamp(inputs.oldSettings.y + dY, 0, height - settings.height);
                            syncInputs();
                            updatePreview();
                        }
                    } else if (event.type === 'pointerup') {
                        if (inputs.state) inputs.state = null;
                    }
                } else {
                    if (event.type === 'pointerdown') {
                        if (!inputs.state) {
                            inputs.state = 'move';
                            inputs.oldSettings = (0, _bb.BB).copyObj(settings);
                            inputs.start = {
                                x: event.relX / previewFactor,
                                y: event.relY / previewFactor
                            };
                            inputs.end = null;
                        }
                    } else if (event.type === 'pointermove') {
                        if (inputs.state) {
                            inputs.end = {
                                x: event.relX / previewFactor,
                                y: event.relY / previewFactor
                            };
                            settings.offsetX = Math.round(inputs.end.x - inputs.start.x) + inputs.oldSettings.offsetX;
                            settings.offsetY = Math.round(inputs.end.y - inputs.start.y) + inputs.oldSettings.offsetY;
                            updatePreview();
                        }
                    } else if (event.type === 'pointerup') {
                        if (inputs.state) {
                            if (!inputs.end) {
                                settings.offsetX = 0;
                                settings.offsetY = 0;
                                updatePreview();
                            }
                            inputs.state = null;
                        }
                    }
                }
            }
        });
        // ---------- rendering ---------------------
        const fullSizeCanvas = (0, _bb.BB).canvas(width, height);
        const fullSizeCtx = (0, _bb.BB).ctx(fullSizeCanvas);
        function sharpStrokeRect(context, x, y, width, height) {
            const drawX = Math.round(x + 0.5) - 0.5;
            const drawY = Math.round(y + 0.5) - 0.5;
            const drawWidth = Math.round(x + width - drawX);
            const drawHeight = Math.round(y + height - drawY);
            context.strokeRect(drawX, drawY, drawWidth, drawHeight);
        }
        function updatePreview(doForce) {
            if (!doForce && lastDrawnSettings && JSON.stringify(lastDrawnSettings) === JSON.stringify(settings)) return;
            if (previewMode === 0) {
                // before
                fullSizeCtx.clearRect(0, 0, width, height);
                fullSizeCtx.drawImage(context.canvas, 0, 0);
                const previewCanvas = previewLayer.image;
                const previewCtx = (0, _bb.BB).ctx(previewCanvas);
                previewCtx.save();
                previewCtx.clearRect(0, 0, renderW, renderH);
                previewCtx.drawImage(fullSizeCanvas, 0, 0, renderW, renderH);
                previewCtx.restore();
                const pW = settings.width * previewFactor;
                const pH = settings.height * previewFactor;
                const overlayCtx = (0, _bb.BB).ctx(overlayCanvas);
                overlayCtx.save();
                overlayCtx.clearRect(0, 0, w, h);
                overlayCtx.strokeStyle = '#fff';
                sharpStrokeRect(overlayCtx, settings.x * previewFactor, settings.y * previewFactor, pW, pH);
                if (settings.blend > 0.05) {
                    overlayCtx.strokeStyle = '#f0f';
                    sharpStrokeRect(overlayCtx, settings.x * previewFactor - pW / 2 * settings.blend, settings.y * previewFactor - pH / 2 * settings.blend, pW * (1 + settings.blend), pH * (1 + settings.blend));
                }
                overlayCtx.restore();
            } else {
                // after
                fullSizeCtx.clearRect(0, 0, width, height);
                fullSizeCtx.drawImage(context.canvas, 0, 0);
                drawPattern(fullSizeCtx, settings);
                const previewCanvas = previewLayer.image;
                const previewCtx = (0, _bb.BB).ctx(previewCanvas);
                previewCtx.clearRect(0, 0, renderW, renderH);
                previewCtx.drawImage(fullSizeCanvas, 0, 0, renderW, renderH);
            }
            klCanvasPreview.render();
            lastDrawnSettings = (0, _bb.BB).copyObj(settings);
        }
        updatePreview();
        // ----- result -------------------
        const destroy = ()=>{
            blendSlider.destroy();
            keyListener.destroy();
            pointerListener.destroy();
            klCanvasPreview.destroy();
        };
        const result = {
            element: rootEl,
            destroy,
            getInput: ()=>{
                destroy();
                return (0, _bb.BB).copyObj(settings);
            }
        };
        if (!isSmall) result.width = (0, _previewSize.MEDIUM_PREVIEW).width;
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const ctx = params.layer.context;
        const klHistory = params.klHistory;
        if (!klCanvas) return false;
        drawPattern(ctx, params.input);
        {
            const layerMap = Object.fromEntries(params.klCanvas.getLayers().map((layerItem)=>{
                if (layerItem.id === params.layer.id) return [
                    layerItem.id,
                    {
                        tiles: (0, _canvasToLayerTiles.canvasToLayerTiles)(params.layer.canvas)
                    }
                ];
                return [
                    layerItem.id,
                    {}
                ];
            }));
            klHistory.push({
                layerMap
            });
        }
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../ui/components/input":"e8FQP","../ui/components/kl-slider":"fQOKQ","../../language/language":"mcywn","./filters-consts":"gXypy","../ui/project-viewport/kl-canvas-preview":"2vGJF","../ui/components/two-tabs":"6neWo","../../bb/base/base":"it3mQ","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","../history/push-helpers/canvas-to-layer-tiles":"byCWA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aZ3yq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterDistort", ()=>filterDistort);
var _bb = require("../../bb/bb");
var _klSlider = require("../ui/components/kl-slider");
var _language = require("../../language/language");
var _filtersConsts = require("./filters-consts");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _options = require("../ui/components/options");
var _checkbox = require("../ui/components/checkbox");
var _base = require("../../bb/base/base");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _applyFxFilter = require("./apply-fx-filter");
const filterDistort = {
    getDialog (params) {
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const rootEl = (0, _bb.BB).el();
        const context = params.context;
        let isSynced = true;
        const settings = {
            stepSize: 1,
            distortType: 0,
            scale: {
                x: 100,
                y: 100
            },
            strength: {
                x: 20,
                y: 20
            },
            phase: {
                x: 0,
                y: 0
            },
            offset: {
                x: 0,
                y: 0
            }
        };
        // let lastDrawnSettings = null;
        // ---- thumb -------
        const thumbImgArr = [];
        const thumbSize = 32;
        {
            const canvas = (0, _bb.BB).canvas(thumbSize, thumbSize);
            const ctx = (0, _bb.BB).ctx(canvas);
            ctx.beginPath();
            ctx.arc(thumbSize / 2, thumbSize / 2, thumbSize / 2.5, 0, Math.PI * 2);
            ctx.fill();
            let gradient = ctx.createLinearGradient(0, 0, thumbSize, thumbSize);
            gradient.addColorStop(0, '#00f');
            gradient.addColorStop(0.5, '#f00');
            gradient.addColorStop(1, '#fff');
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = 'source-atop';
            ctx.fillRect(0, 0, thumbSize, thumbSize);
            gradient = ctx.createLinearGradient(thumbSize, 0, 0, thumbSize);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, '#000');
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = 'destination-atop';
            ctx.fillRect(0, 0, thumbSize, thumbSize);
            const fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
            const texture = fxCanvas.texture(canvas);
            fxCanvas.draw(texture).update(); // update fxCanvas size
            const scaleFactor = 20;
            [
                0,
                1,
                2
            ].forEach((item)=>{
                const thumbImg = new Image();
                const settingsCopy = (0, _bb.BB).copyObj(settings);
                settingsCopy.distortType = item;
                settingsCopy.scale.x /= scaleFactor;
                settingsCopy.scale.y /= scaleFactor;
                settingsCopy.strength.x /= scaleFactor;
                settingsCopy.strength.y /= scaleFactor;
                fxCanvas.draw(texture).multiplyAlpha().distort(settingsCopy).unmultiplyAlpha().update();
                ctx.clearRect(0, 0, thumbSize, thumbSize);
                ctx.drawImage(fxCanvas, 0, 0);
                thumbImg.src = canvas.toDataURL('image/png');
                thumbImgArr.push(thumbImg);
            });
            texture.destroy();
        }
        // ---- controls ----
        const topRowEl = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                alignItems: 'center'
            }
        });
        const typeOptions = new (0, _options.Options)({
            optionArr: thumbImgArr.map((img, index)=>{
                (0, _base.css)(img, {
                    margin: '1px',
                    borderRadius: '3px',
                    transition: 'all 0.1s ease-in-out'
                });
                return {
                    id: '' + index,
                    label: img
                };
            }),
            initId: '0',
            onChange: (id)=>{
                settings.distortType = Number(id);
                preview.render();
            }
        });
        function sync(from) {
            if (from === 'x') {
                settings.scale.y = settings.scale.x;
                settings.strength.y = settings.strength.x;
                settings.phase.y = settings.phase.x;
                sliderArr[3].setValue(settings.scale.y);
                sliderArr[4].setValue(settings.strength.y);
                sliderArr[5].setValue(settings.phase.y);
            } else {
                settings.scale.x = settings.scale.y;
                settings.strength.x = settings.strength.y;
                settings.phase.x = settings.phase.y;
                sliderArr[0].setValue(settings.scale.x);
                sliderArr[1].setValue(settings.strength.x);
                sliderArr[2].setValue(settings.phase.x);
            }
            preview.render();
        }
        const syncToggle = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)('filter-distort-sync-xy'),
            callback: (val)=>{
                isSynced = val;
                if (isSynced) sync('x');
            },
            name: 'sync-xy'
        });
        topRowEl.append(typeOptions.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: '1'
            }
        }), syncToggle.getElement());
        const xyRowEl = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                flexWrap: 'wrap'
            }
        });
        const leftCol = (0, _bb.BB).el({
            parent: xyRowEl,
            css: {
                marginRight: '10px'
            }
        });
        const rightCol = (0, _bb.BB).el({
            parent: xyRowEl
        });
        const sliderWidth = isSmall ? 300 : 245;
        const sliderArr = [];
        [
            'x',
            'y'
        ].forEach((item, index)=>{
            const targetEl = index === 0 ? leftCol : rightCol;
            const scaleSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('filter-noise-scale') + ' ' + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 1,
                max: 1000,
                curve: 'quadratic',
                value: settings.scale[item],
                eventResMs: (0, _filtersConsts.EVENT_RES_MS),
                onChange: (val)=>{
                    settings.scale[item] = val;
                    if (isSynced) sync(item);
                    else preview.render();
                }
            });
            scaleSlider.getElement().style.marginTop = '20px';
            targetEl.append(scaleSlider.getElement());
            const strengthSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('filter-unsharp-mask-strength') + ' ' + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 0,
                max: 200,
                curve: 'quadratic',
                value: settings.strength[item],
                eventResMs: (0, _filtersConsts.EVENT_RES_MS),
                onChange: (val)=>{
                    settings.strength[item] = val;
                    if (isSynced) sync(item);
                    else preview.render();
                }
            });
            strengthSlider.getElement().style.marginTop = '10px';
            targetEl.append(strengthSlider.getElement());
            const phaseSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)('filter-distort-phase') + ' ' + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 0,
                max: 1,
                value: settings.phase[item],
                manualInputRoundDigits: 2,
                eventResMs: (0, _filtersConsts.EVENT_RES_MS),
                formatFunc: (val)=>(0, _bb.BB).round(val, 2),
                onChange: (val)=>{
                    settings.phase[item] = val;
                    if (isSynced) sync(item);
                    else preview.render();
                }
            });
            phaseSlider.getElement().style.marginTop = '10px';
            targetEl.append(phaseSlider.getElement());
            sliderArr.push(scaleSlider);
            sliderArr.push(strengthSlider);
            sliderArr.push(phaseSlider);
        });
        const stepSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-distort-stepsize'),
            width: 300,
            height: 30,
            min: 1,
            max: 300,
            curve: 'quadratic',
            value: settings.stepSize,
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: (val)=>{
                settings.stepSize = Math.round(val);
                preview.render();
            }
        });
        stepSlider.getElement().style.marginTop = '20px';
        stepSlider.getElement().style.marginBottom = '10px';
        rootEl.append(stepSlider.getElement());
        // ---- preview ----
        const klCanvas = params.klCanvas;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                const scaledSettings = (0, _bb.BB).copyObj(settings);
                scaledSettings.stepSize *= transform.scaleX;
                scaledSettings.strength.x *= transform.scaleX;
                scaledSettings.strength.y *= transform.scaleY;
                if (scaledSettings.distortType !== 2) {
                    scaledSettings.scale.x *= transform.scaleX;
                    scaledSettings.scale.y *= transform.scaleY;
                }
                scaledSettings.offset.x = -transform.x;
                scaledSettings.offset.y = -transform.y;
                return fxCanvas.multiplyAlpha().distort(scaledSettings).unmultiplyAlpha();
            },
            selection: klCanvas.getSelection()
        });
        const previewLayerArr = layers.map((item, i)=>{
            return {
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : item.context.canvas,
                isVisible: item.isVisible,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr,
                hasClipping: false
            };
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            selection: klCanvas.getSelection()
        });
        preview.render();
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px'
        });
        rootEl.append(preview.getElement());
        const destroy = ()=>{
            typeOptions.destroy();
            sliderArr.forEach((item)=>item.destroy());
            stepSlider.destroy();
            syncToggle.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        // ----- result -------------------
        const result = {
            element: rootEl,
            destroy,
            getInput: ()=>{
                destroy();
                return (0, _bb.BB).copyObj(settings);
            }
        };
        if (!isSmall) result.width = (0, _previewSize.MEDIUM_PREVIEW).width;
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const context = params.layer.context;
        const klHistory = params.klHistory;
        if (!klCanvas) return false;
        return (0, _applyFxFilter.applyFxFilter)(context, params.klCanvas.getSelection(), (fxCanvas)=>{
            fxCanvas.multiplyAlpha().distort(params.input).unmultiplyAlpha();
        }, klHistory);
    }
};

},{"../../bb/bb":"3zOvT","../ui/components/kl-slider":"fQOKQ","../../language/language":"mcywn","./filters-consts":"gXypy","../../fx-canvas/shared-fx":"agFAL","../ui/components/options":"7kiPU","../ui/components/checkbox":"9bXL6","../../bb/base/base":"it3mQ","../ui/project-viewport/fx-preview-renderer":"dp0s7","../ui/project-viewport/preview":"j8zOr","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","./apply-fx-filter":"9sGVx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kggAL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterVanishPoint", ()=>filterVanishPoint);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
var _input = require("../ui/components/input");
var _colorOptions = require("../ui/components/color-options");
var _drawVanishPoint = require("../image-operations/draw-vanish-point");
var _klSlider = require("../ui/components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _base = require("../../bb/base/base");
var _preview = require("../ui/project-viewport/preview");
var _draggableInput = require("../ui/components/draggable-input");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
var _canvasToLayerTiles = require("../history/push-helpers/canvas-to-layer-tiles");
const filterVanishPoint = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const previewCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
        const previewCtx = (0, _bb.BB).ctx(previewCanvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const settingsObj = {
            x: context.canvas.width / 2,
            y: context.canvas.height / 2,
            lines: 8,
            thickness: 2,
            color: {
                r: 0,
                g: 0,
                b: 0
            },
            opacity: 1
        };
        const linesSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)('filter-vanish-point-lines'),
            width: 300,
            height: 30,
            min: 2,
            max: 20,
            value: settingsObj.lines,
            curve: 'quadratic',
            eventResMs: (0, _filtersConsts.EVENT_RES_MS),
            onChange: function(val) {
                settingsObj.lines = Math.round(val);
                update();
            }
        });
        linesSlider.getElement().style.marginBottom = '10px';
        rootEl.append(linesSlider.getElement());
        const line1 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                alignItems: 'center'
            }
        });
        const line2 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: 'flex',
                alignItems: 'center',
                marginTop: '10px',
                marginBottom: '10px'
            }
        });
        const xInput = (0, _input.input)({
            init: settingsObj.x,
            type: 'number',
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                settingsObj.x = parseFloat(v);
                dragInput.setValue({
                    x: settingsObj.x,
                    y: settingsObj.y
                });
                update();
            }
        });
        const yInput = (0, _input.input)({
            init: settingsObj.y,
            type: 'number',
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                settingsObj.y = parseFloat(v);
                dragInput.setValue({
                    x: settingsObj.x,
                    y: settingsObj.y
                });
                update();
            }
        });
        const thicknessInput = (0, _input.input)({
            init: 2,
            type: 'number',
            min: 1,
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                settingsObj.thickness = parseFloat(v);
                update();
            }
        });
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        settingsObj.color = (0, _bb.BB).copyObj(selectedRgbaObj);
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)('shape-stroke'),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                settingsObj.color = (0, _bb.BB).copyObj(selectedRgbaObj);
                update();
            }
        });
        const labelStyle = {
            display: 'inline-block',
            marginRight: '5px'
        };
        line1.append((0, _bb.BB).el({
            content: 'X:',
            css: labelStyle
        }), xInput, (0, _bb.BB).el({
            content: 'Y:',
            css: labelStyle
        }), yInput);
        line2.append((0, _bb.BB).el({
            content: (0, _language.LANG)('shape-line-width') + ':',
            css: labelStyle
        }), thicknessInput, (0, _bb.BB).el({
            css: {
                flexGrow: '1'
            }
        }), colorOptions.getElement());
        // ---- preview input processing ----
        function syncInputs() {
            xInput.value = '' + settingsObj.x;
            yInput.value = '' + settingsObj.y;
        }
        function update() {
            const ctx = previewCtx;
            const w = previewCanvas.width;
            const h = previewCanvas.height;
            ctx.save();
            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(context.canvas, 0, 0, w, h);
            (0, _drawVanishPoint.drawVanishPoint)(ctx, settingsObj.x, settingsObj.y, settingsObj.lines, Math.max(settingsObj.thickness, 1), settingsObj.color, settingsObj.opacity);
            ctx.restore();
            preview.render();
        }
        const onRender = ()=>{
            dragInput.setTransform(preview.getTransform());
            return previewCanvas;
        };
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? onRender : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            }
        });
        (0, _base.css)(preview.getElement(), {
            marginLeft: '-20px',
            marginRight: '-20px',
            overflow: 'hidden'
        });
        const dragInput = new (0, _draggableInput.DraggableInput)({
            value: {
                x: settingsObj.x,
                y: settingsObj.y
            },
            onChange: (val)=>{
                settingsObj.x = Math.round(val.x);
                settingsObj.y = Math.round(val.y);
                syncInputs();
                update();
            }
        });
        update();
        preview.getElement().append(dragInput.getElement());
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            linesSlider.destroy();
            colorOptions.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        const context = params.layer.context;
        const klCanvas = params.klCanvas;
        const klHistory = params.klHistory;
        if (!context || !klCanvas) return false;
        (0, _drawVanishPoint.drawVanishPoint)(context, params.input.x, params.input.y, params.input.lines, params.input.thickness, params.input.color, params.input.opacity);
        {
            const layerMap = Object.fromEntries(params.klCanvas.getLayers().map((layerItem)=>{
                if (layerItem.id === params.layer.id) return [
                    layerItem.id,
                    {
                        tiles: (0, _canvasToLayerTiles.canvasToLayerTiles)(params.layer.canvas)
                    }
                ];
                return [
                    layerItem.id,
                    {}
                ];
            }));
            klHistory.push({
                layerMap
            });
        }
        return true;
    }
};

},{"../../bb/bb":"3zOvT","../../language/language":"mcywn","../ui/components/input":"e8FQP","../ui/components/color-options":"1nMl0","../image-operations/draw-vanish-point":"cX0E0","../ui/components/kl-slider":"fQOKQ","./filters-consts":"gXypy","../../bb/base/base":"it3mQ","../ui/project-viewport/preview":"j8zOr","../ui/components/draggable-input":"kvq3O","../ui/utils/test-is-small":"5jelf","../ui/utils/preview-size":"eOdff","../history/push-helpers/canvas-to-layer-tiles":"byCWA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cX0E0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawVanishPoint", ()=>drawVanishPoint);
var _shapeTool = require("./shape-tool");
var _bb = require("../../bb/bb");
function drawVanishPoint(ctx, x, y, lines, thickness, color, opacity) {
    ctx.save();
    const degIncrement = 180 / lines;
    for(let deg = 0; deg < 180; deg += degIncrement){
        const p2 = (0, _bb.BB).rotateAround({
            x,
            y
        }, {
            x: x + 9999,
            y
        }, deg);
        (0, _shapeTool.drawShape)(ctx, {
            type: 'line',
            x1: x,
            y1: y,
            x2: p2.x,
            y2: p2.y,
            //angleRad: 0,
            isOutwards: true,
            opacity,
            //isEraser: false,
            strokeRgb: color,
            lineWidth: thickness
        });
    }
    ctx.restore();
}

},{"./shape-tool":"diljP","../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5AFDo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "klCanvasToPsdBlob", ()=>klCanvasToPsdBlob);
var _kl = require("../kl");
var _loadAgPsd = require("./load-ag-psd");
async function klCanvasToPsdBlob(klCanvas) {
    const layerArr = klCanvas.getLayersFast();
    const psdConfig = {
        width: klCanvas.getWidth(),
        height: klCanvas.getHeight(),
        //canvas: klCanvas.getCompleteCanvas(1), // preview, can be skipped
        children: layerArr.map((item)=>{
            // todo - can be optimized if layer mostly empty
            return {
                name: item.name,
                hidden: !item.isVisible,
                opacity: item.opacity,
                canvas: item.canvas,
                blendMode: (0, _kl.KL).PSD.blendKlToPsd(item.mixModeStr),
                left: 0,
                top: 0
            };
        })
    };
    const agPsd = await (0, _loadAgPsd.loadAgPsd)();
    const buffer = agPsd.writePsdBuffer(psdConfig);
    return new Blob([
        buffer
    ], {
        type: 'application/octet-stream'
    });
}

},{"../kl":"lHQKw","./load-ag-psd":"ZuAcA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bOWFD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Line smoothing. EventChain element. Smoothing via blending new position with old position.
 * for onDraw events from KlCanvasWorkspace.
 *
 * in some draw event
 * out some draw event
 *
 * type: 'line' Events are just passed through.
 */ parcelHelpers.export(exports, "LineSmoothing", ()=>LineSmoothing);
var _bb = require("../../bb/bb");
class LineSmoothing {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.smoothing = (0, _bb.BB).clamp(p.smoothing, 0, 1);
    }
    chainIn(event) {
        event = (0, _bb.BB).copyObj(event);
        clearTimeout(this.timeout);
        clearInterval(this.interval);
        if (event.type === 'down') this.lastMixedInput = {
            x: event.x,
            y: event.y,
            pressure: event.pressure
        };
        if (event.type === 'move') {
            const inputX = event.x;
            const inputY = event.y;
            const inputPressure = event.pressure;
            event.x = (0, _bb.BB).mix(event.x, this.lastMixedInput.x, this.smoothing);
            event.y = (0, _bb.BB).mix(event.y, this.lastMixedInput.y, this.smoothing);
            event.pressure = (0, _bb.BB).mix(event.pressure, this.lastMixedInput.pressure, this.smoothing);
            this.lastMixedInput = {
                x: event.x,
                y: event.y,
                pressure: event.pressure
            };
            if (this.smoothing > 0) this.timeout = setTimeout(()=>{
                this.interval = setInterval(()=>{
                    event = JSON.parse(JSON.stringify(event));
                    event.x = (0, _bb.BB).mix(inputX, this.lastMixedInput.x, this.smoothing);
                    event.y = (0, _bb.BB).mix(inputY, this.lastMixedInput.y, this.smoothing);
                    event.pressure = (0, _bb.BB).mix(inputPressure, this.lastMixedInput.pressure, this.smoothing);
                    this.lastMixedInput = {
                        x: event.x,
                        y: event.y,
                        pressure: event.pressure
                    };
                    this.chainOut?.(event);
                }, 35);
            }, 80);
        }
        return event;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    setSmoothing(s) {
        this.smoothing = (0, _bb.BB).clamp(s, 0, 1);
    }
}

},{"../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lV9Cb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * cleans up DrawEvents. More trustworthy events. EventChain element
 *
 * in some draw event?
 * out some draw event?
 *
 * that events can only go line this: down -> n x move -> up
 * so, sanitizes this: down, down, down. becomes only one down. the other downs are ignored/swallowed
 */ parcelHelpers.export(exports, "LineSanitizer", ()=>LineSanitizer);
class LineSanitizer {
    // ----------------------------------- public -----------------------------------
    chainIn(event) {
        if (event.type === 'down') {
            if (this.isDrawing) //console.log('line sanitizer - down, but already drawing');
            this.chainOut && this.chainOut({
                type: 'up',
                scale: event.scale,
                shiftIsPressed: event.shiftIsPressed,
                isCoalesced: false
            });
            else this.isDrawing = true;
        }
        if (!this.isDrawing && (event.type === 'move' || event.type === 'up')) //console.log('line sanitizer - ' + event.type + ' but not drawing');
        return null;
        if (event.type === 'up' && this.isDrawing) this.isDrawing = false;
        return event;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    constructor(){
        this.isDrawing = false;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6gQ7b":[function(require,module,exports,__globalThis) {
/**
 * from stabilizer dropdown value to line-smoothing value
 * @param s
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translateSmoothing", ()=>translateSmoothing);
function translateSmoothing(s) {
    if (s == 1) return 0.5;
    if (s == 2) return 0.84;
    if (s == 3) return 0.965;
    if (s == 4) return 0.9825;
    if (s == 5) return 0.99125;
    return s;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hOkpf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// todo later:
// onImage: (project: IKlProject) => void
// onLayer: (index: number, canvas: HMTLCanvasElement,layerName: string) => void
parcelHelpers.export(exports, "KlAppImportHandler", ()=>KlAppImportHandler);
var _kl = require("../klecks/kl");
var _language = require("../language/language");
var _bb = require("../bb/bb");
var _base = require("../bb/base/base");
var _getNextLayerId = require("../klecks/history/get-next-layer-id");
var _fileHeaderDetection = require("../klecks/storage/file-header-detection");
class KlAppImportHandler {
    importFinishedLoading(importedImage, filename, optionStr) {
        if (!importedImage || isNaN(importedImage.width) || isNaN(importedImage.height) || importedImage.width <= 0 || importedImage.height <= 0) {
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: 'error',
                message: (0, _language.LANG)('import-broken-file'),
                buttons: [
                    'Ok'
                ]
            });
            return;
        }
        const getResizedDimensions = (width, height)=>{
            let w = parseInt('' + width);
            let h = parseInt('' + height);
            if (w > this.klMaxCanvasSize) {
                h = this.klMaxCanvasSize / w * h;
                w = this.klMaxCanvasSize;
            }
            if (h > this.klMaxCanvasSize) {
                w = this.klMaxCanvasSize / h * w;
                h = this.klMaxCanvasSize;
            }
            w = parseInt('' + w);
            h = parseInt('' + h);
            return {
                width: w,
                height: h
            };
        };
        const importAsImage = (canvas)=>{
            this.applyUncommitted();
            const resizedDimensions = getResizedDimensions(canvas.width, canvas.height);
            //resize first
            const tempCanvas = (0, _bb.BB).canvas(canvas.width, canvas.height);
            const tempCanvasCtx = (0, _bb.BB).ctx(tempCanvas);
            tempCanvasCtx.drawImage(canvas, 0, 0);
            (0, _bb.BB).resizeCanvas(tempCanvas, resizedDimensions.width, resizedDimensions.height);
            this.klCanvas.reset({
                width: resizedDimensions.width,
                height: resizedDimensions.height,
                image: tempCanvas,
                layerName: filename
            });
            this.layersUi.update(0);
            this.setCurrentLayer(this.klCanvas.getLayer(0));
            this.onImportConfirm();
        };
        /**
         * convertedPsdObj has no layers if flattened
         */ const importAsImagePsd = (convertedPsdObj, cropObj)=>{
            this.applyUncommitted();
            // crop
            const crop = (targetCanvas, cropCanvas, cropObj)=>{
                // eslint-disable-next-line no-self-assign
                cropCanvas.width = cropCanvas.width;
                (0, _bb.BB).ctx(cropCanvas).drawImage(targetCanvas, -cropObj.x, -cropObj.y);
                targetCanvas.width = cropObj.width;
                targetCanvas.height = cropObj.height;
                (0, _bb.BB).ctx(targetCanvas).drawImage(cropCanvas, 0, 0);
            };
            if (cropObj && (cropObj.width !== convertedPsdObj.width || cropObj.height !== convertedPsdObj.height)) {
                const cropCanvas = (0, _bb.BB).canvas(cropObj.width, cropObj.height);
                convertedPsdObj.width = cropObj.width;
                convertedPsdObj.height = cropObj.height;
                if (!convertedPsdObj.layers) crop(convertedPsdObj.canvas, cropCanvas, cropObj);
                if (convertedPsdObj.layers) for(let i = 0; i < convertedPsdObj.layers.length; i++){
                    const item = convertedPsdObj.layers[i];
                    crop(item.image, cropCanvas, cropObj);
                }
            }
            // resize
            const resizedDimensions = getResizedDimensions(convertedPsdObj.width, convertedPsdObj.height);
            convertedPsdObj.width = resizedDimensions.width;
            convertedPsdObj.height = resizedDimensions.height;
            if (!convertedPsdObj.layers) (0, _bb.BB).resizeCanvas(convertedPsdObj.canvas, convertedPsdObj.width, convertedPsdObj.height);
            if (convertedPsdObj.layers) for(let i = 0; i < convertedPsdObj.layers.length; i++){
                const item = convertedPsdObj.layers[i];
                (0, _bb.BB).resizeCanvas(item.image, convertedPsdObj.width, convertedPsdObj.height);
            }
            let layerIndex;
            if (convertedPsdObj.layers) layerIndex = this.klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                layers: convertedPsdObj.layers.map((layer)=>{
                    return {
                        id: (0, _getNextLayerId.getNextLayerId)(),
                        name: layer.name,
                        isVisible: layer.isVisible,
                        opacity: layer.opacity,
                        mixModeStr: layer.mixModeStr,
                        image: layer.image
                    };
                })
            });
            else layerIndex = this.klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                image: convertedPsdObj.canvas
            });
            this.layersUi.update(layerIndex);
            this.setCurrentLayer(this.klCanvas.getLayer(layerIndex));
            this.onImportConfirm();
        };
        const importAsLayer = (canvas)=>{
            this.applyUncommitted();
            (0, _kl.KL).showImportAsLayerDialog({
                target: this.klRootEl,
                klCanvas: this.klCanvas,
                importImage: canvas,
                callback: (transformObj, isPixelated)=>{
                    if (!transformObj) return;
                    const operation = (ctx)=>{
                        (0, _bb.BB).drawTransformedImageWithBounds(ctx, canvas, transformObj, undefined, isPixelated);
                    };
                    if (!this.klCanvas.addLayer(undefined, {
                        name: filename,
                        isVisible: true,
                        opacity: 1,
                        image: operation
                    })) this.klCanvas.drawOperation(this.klCanvas.getLayers().length - 1, operation);
                    const layers = this.klCanvas.getLayers();
                    const activeLayerIndex = layers.length - 1;
                    this.setCurrentLayer(this.klCanvas.getLayer(activeLayerIndex));
                    this.layersUi.update(activeLayerIndex);
                }
            });
        };
        if (optionStr === 'default' || !optionStr) (0, _kl.KL).showImportImageDialog({
            image: importedImage,
            target: this.klRootEl,
            maxSize: this.klMaxCanvasSize,
            callback: (res)=>{
                if (res.type === 'as-image') importAsImage(res.image);
                else if (res.type === 'as-image-psd') importAsImagePsd(res.image, res.cropObj);
                else if (res.type === 'as-layer') importAsLayer(res.image);
                else res.type;
            }
        });
        if (optionStr === 'layer') importAsLayer(importedImage.canvas);
        if (optionStr === 'image') {
            if (importedImage.type === 'psd') importAsImagePsd(importedImage);
            else importAsImage(importedImage.canvas);
        }
    }
    // ----------------------------------- public -----------------------------------
    constructor(input, callback){
        this.klRootEl = input.klRootEl;
        this.klMaxCanvasSize = input.maxCanvasSize;
        this.layersUi = input.layersUi;
        this.setCurrentLayer = input.setCurrentLayer;
        this.klCanvas = input.klCanvas;
        this.onImportConfirm = input.onImportConfirm;
        this.applyUncommitted = input.applyUncommitted;
        this.onColor = callback.onColor;
    }
    // ---- interface ----
    async readClipboard() {
        try {
            /*if (Math.random() > 0.001) {
                throw new Error('haha');
            }*/ // May freeze the app until it read the clipboard
            // But if you show a loading indicator on this line, it will show up too early.
            const clipboardItems = await navigator.clipboard.read();
            // On this line it's already done freezing.
            let hasImage = false;
            for (const item of clipboardItems){
                for (const type of item.types)if (type.startsWith('image')) {
                    hasImage = true;
                    const blob = await item.getType(type);
                    const img = new Image();
                    img.onload = ()=>{
                        URL.revokeObjectURL(img.src);
                        this.importFinishedLoading({
                            type: 'image',
                            width: img.width,
                            height: img.height,
                            canvas: img
                        }, undefined, 'default');
                    };
                    img.src = URL.createObjectURL(blob);
                    return;
                }
            }
            if (!hasImage) (0, _kl.KL).popup({
                target: this.klRootEl,
                type: 'error',
                message: (0, _language.LANG)('clipboard-no-image'),
                buttons: [
                    'Ok'
                ]
            });
        } catch (error) {
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: 'error',
                message: (0, _language.LANG)('clipboard-read-fail'),
                buttons: [
                    'Ok'
                ]
            });
        }
    }
    onPaste(e) {
        if ((0, _kl.KL).DIALOG_COUNTER.get() > 0) return;
        const retrieveImageFromClipboardAsBlob = (items, callback)=>{
            if (!items) return;
            for(let i = 0; i < items.length; i++){
                if (items[i].type.indexOf('image') == -1) continue;
                const file = items[i].getAsFile();
                file && callback(file);
            }
        };
        e.stopPropagation();
        e.preventDefault();
        if (!e.clipboardData) return;
        if (e.clipboardData.files[0]) retrieveImageFromClipboardAsBlob(e.clipboardData.items, (imageBlob)=>{
            // If there's an image, display it in the canvas
            const img = new Image();
            img.onload = ()=>{
                URL.revokeObjectURL(img.src);
                this.importFinishedLoading({
                    type: 'image',
                    width: img.width,
                    height: img.height,
                    canvas: img
                }, undefined, 'default');
            };
            const URLObj = window.URL || window.webkitURL;
            img.src = URLObj.createObjectURL(imageBlob);
        });
        else if (e.clipboardData.items[0]) e.clipboardData.items[0].getAsString((pasteStr)=>{
            pasteStr = pasteStr.trim();
            if (pasteStr.match(/^https?/)) {
                // url
                const img = new Image();
                img.onload = ()=>{
                    this.importFinishedLoading({
                        type: 'image',
                        width: img.width,
                        height: img.height,
                        canvas: img
                    }, undefined, 'default');
                };
                img.onerror = (e)=>{
                    console.log('error loading', e);
                };
                img.crossOrigin = 'Anonymous';
                img.src = pasteStr;
            } else if (pasteStr.match(/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/)) {
                // url
                const rgbObj = (0, _bb.BB).ColorConverter.hexToRGB(pasteStr.replace('#', ''));
                rgbObj && this.onColor(rgbObj);
            }
        });
    }
    async handleFileSelect(files, optionStr) {
        const showWarningPsdFlattened = ()=>{
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: 'warning',
                message: (0, _language.LANG)('import-psd-unsupported') + '<br /><br />',
                buttons: [
                    'Ok'
                ]
            });
        };
        let hasUnsupportedFile = false;
        // files need to be copied, because the input is reset
        const fileArr = [
            ...files
        ];
        for(let i = 0; i < fileArr.length; i++){
            const file = fileArr[i];
            const fileType = await (0, _fileHeaderDetection.detectFiletype)(file);
            if (fileType === 'image') ((f)=>{
                window.URL = window.URL || window.webkitURL;
                const url = window.URL.createObjectURL(f);
                const im = new Image();
                im.src = url;
                (0, _bb.BB).loadImage(im, ()=>{
                    URL.revokeObjectURL(url);
                    this.importFinishedLoading({
                        type: 'image',
                        width: im.width,
                        height: im.height,
                        canvas: im
                    }, f.name, optionStr);
                });
            })(file);
            else if (fileType === 'psd') ((f)=>{
                const loaderSizeBytes = 26214400; // 25mb
                const maxSizeBytes = 1073741824; // 1gb
                const maxResolution = 4096;
                if (f.size >= maxSizeBytes) {
                    // pretty likely to break stuff
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        type: 'error',
                        message: 'File too big. Unable to import.<br /><br />',
                        buttons: [
                            'Ok'
                        ]
                    });
                    return;
                }
                const doShowLoader = fileArr.length === 1 && f.size >= loaderSizeBytes;
                let loaderIsOpen = true;
                let closeLoader;
                if (doShowLoader) (0, _kl.KL).popup({
                    target: this.klRootEl,
                    message: (0, _language.LANG)('import-opening'),
                    callback: (result)=>{
                        loaderIsOpen = false;
                        closeLoader = null;
                    },
                    closeFunc: (f)=>{
                        closeLoader = f;
                    }
                });
                const reader = new FileReader();
                reader.onload = (readerResult)=>{
                    const target = (0, _base.throwIfNull)(readerResult.target);
                    (0, _kl.KL).loadAgPsd().then((agPsdLazy)=>{
                        if (doShowLoader && !loaderIsOpen) return;
                        try {
                            let psd;
                            // first pass, only read metadata
                            psd = agPsdLazy.readPsd(target.result, {
                                skipLayerImageData: true,
                                skipThumbnail: true,
                                skipCompositeImageData: true
                            });
                            if (psd.width > maxResolution || psd.height > maxResolution) {
                                if (closeLoader) closeLoader();
                                (0, _kl.KL).popup({
                                    target: this.klRootEl,
                                    type: 'error',
                                    message: (0, _language.LANG)('import-psd-too-large').replace(/{x}/g, '' + maxResolution) + '<br /><br />' + (0, _language.LANG)('import-psd-size') + ': ' + psd.width + ' x ' + psd.height + ' pixels' + '<br /><br />',
                                    buttons: [
                                        'Ok'
                                    ]
                                });
                                return;
                            }
                            // second pass, now load actual data.
                            psd = null;
                            try {
                                psd = agPsdLazy.readPsd(target.result);
                            } catch (e) {
                            //console.log('failed regular psd import', e);
                            }
                            if (psd) {
                                //console.log('psd', psd);
                                const convertedPsd = (0, _kl.KL).PSD.readPsd(psd);
                                //console.log('converted', convertedPsd);
                                if (optionStr === 'image' && convertedPsd.error) showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                this.importFinishedLoading(convertedPsd, f.name, optionStr);
                            } else {
                                psd = agPsdLazy.readPsd(target.result, {
                                    skipLayerImageData: true,
                                    skipThumbnail: true
                                });
                                if (optionStr === 'image') showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                this.importFinishedLoading({
                                    type: 'psd',
                                    width: psd.width,
                                    height: psd.height,
                                    canvas: (0, _base.throwIfUndefined)(psd.canvas),
                                    error: true
                                }, f.name, optionStr);
                            }
                        } catch (e) {
                            closeLoader?.();
                            (0, _kl.KL).popup({
                                target: this.klRootEl,
                                type: 'error',
                                message: 'Failed to load PSD.<br /><br />',
                                buttons: [
                                    'Ok'
                                ]
                            });
                            console.log(e);
                            setTimeout(()=>{
                                throw new Error('psd load error');
                            });
                        }
                    }).catch((e)=>{
                        closeLoader?.();
                        alert('Error: failed to load PSD library');
                    });
                };
                reader.readAsArrayBuffer(f);
            })(file);
            else hasUnsupportedFile = true;
        }
        if (hasUnsupportedFile) (0, _kl.KL).popup({
            target: this.klRootEl,
            message: (0, _language.LANG)('import-unsupported-file'),
            type: 'error',
            buttons: [
                'OK'
            ]
        });
    }
}

},{"../klecks/kl":"lHQKw","../language/language":"mcywn","../bb/bb":"3zOvT","../bb/base/base":"it3mQ","../klecks/history/get-next-layer-id":"friOj","../klecks/storage/file-header-detection":"f63H5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f63H5":[function(require,module,exports,__globalThis) {
// image - png, jpg, webp, whatever the browser natively supports
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// undefined if unknown
parcelHelpers.export(exports, "detectFiletype", ()=>detectFiletype);
function isBufferMatch(buffer, bytes) {
    return bytes.every((byte, index)=>{
        if (byte === undefined) return true;
        return buffer[index] === byte;
    });
}
async function detectFiletype(file) {
    // photoshop is sub type of image.* - so check first
    const nameSplit = file.name.split('.');
    const extension = nameSplit[nameSplit.length - 1].toLowerCase();
    if (file.type.match('image/vnd.adobe.photoshop') || extension === 'psd') return 'psd';
    if (file.type.match('image.*')) return 'image';
    // check for headers
    try {
        const arr = await new Promise((resolve, reject)=>{
            const reader = new FileReader();
            reader.onload = ()=>{
                if (reader.result === null) {
                    reject();
                    return;
                }
                // we did read as array buffer
                resolve(new Uint8Array(reader.result));
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file.slice(0, 12));
        });
        // PSD: '8BPS'
        if (isBufferMatch(arr, [
            56,
            66,
            80,
            83
        ])) return 'psd';
        // PNG: 89 50 4E 47 0D 0A 1A 0A
        if (isBufferMatch(arr, [
            0x89,
            0x50,
            0x4e,
            0x47,
            0x0d,
            0x0a,
            0x1a,
            0x0a
        ])) return 'image';
        // JPEG: 0xFF 0xD8
        if (isBufferMatch(arr, [
            0xff,
            0xd8
        ])) return 'image';
        // WebP: 'RIFF....WEBP'
        if (isBufferMatch(arr, [
            0x52,
            0x49,
            0x46,
            0x46,
            undefined,
            undefined,
            undefined,
            undefined,
            0x57,
            0x45,
            0x42,
            0x50
        ])) return 'image';
    } catch (e) {
    // ...
    }
    return undefined;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"isNYb":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tab-settings.cf9aa953.svg") + "?" + Date.now();

},{}],"fe0Eb":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tab-layers.e8ab823a.svg") + "?" + Date.now();

},{}],"gqmdn":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("tab-edit.d5bcf521.svg") + "?" + Date.now();

},{}],"4llEN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createConsoleApi", ()=>createConsoleApi);
function createConsoleApi(p) {
    const output = [
        'Draw via the console! Learn more: %cKL.help()',
        'background: #000; color: #0f0;'
    ];
    'info' in console ? console.info(...output) : console.log(...output);
    return Object.freeze({
        draw: (path)=>{
            p.onDraw(path);
        },
        help: ()=>{
            console.log(`KL.draw({x: number; y: number}[]) // draw a line
KL.help() // print help
`);
        }
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kvtTs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An interactive project viewport, that also renders the selection. You interact with it through modes (aka tools).
 * One tool is active at a time. temp trigger can overwrite it temporarily.
 */ parcelHelpers.export(exports, "Easel", ()=>Easel);
var _c = require("../../../bb/base/c");
var _projectViewport = require("../project-viewport/project-viewport");
var _pointerListener = require("../../../bb/input/pointer-listener");
var _bb = require("../../../bb/bb");
var _toMetaTransform = require("../../../bb/transform/to-meta-transform");
var _createTransform = require("../../../bb/transform/create-transform");
var _createMatrixFromTransform = require("../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
var _easelPointerPreprocessor = require("./easel-pointer-preprocessor");
var _keyListener = require("../../../bb/input/key-listener");
var _zoomByStep = require("../project-viewport/utils/zoom-by-step");
var _selectionRenderer = require("./selection-renderer");
var _klConfig = require("../../kl-config");
var _math = require("../../../bb/math/math");
var _easelConfig = require("./easel.config");
var _isTransformEqual = require("../project-viewport/utils/is-transform-equal");
var _blendTransform = require("../project-viewport/utils/blend-transform");
var _base = require("../../../bb/base/base");
function getToolEntries(tools) {
    return Object.entries(tools);
}
class Easel {
    setTargetTransform(transform, isImmediate) {
        if (isImmediate) this.viewport.setTransform(transform);
        this.targetTransform = transform;
        this.doRender = true;
    }
    updateToolSvgs() {
        const tool = this.tempTool ?? this.tool;
        Object.keys(this.toolsMap).forEach((toolId)=>{
            this.toolsMap[toolId].getSvgElement().style.display = toolId === tool ? '' : 'none';
        });
    }
    // different tools allow different pointer types to trigger the gesture
    updateDoubleTapPointerTypes() {
        const pointerTypes = this.toolsMap[this.tempTool ?? this.tool].doubleTapPointerTypes ?? (0, _easelConfig.DEFAULT_DOUBLE_TAP_POINTER_TYPES);
        this.pointerPreprocessor.setDoubleTapPointerTypes(pointerTypes);
    }
    /**
     * Only call once from outside. Will perpetuate itself and render when doRender = true
     */ renderLoop() {
        const now = performance.now();
        const deltaMs = now - this.lastFrameTimestamp;
        this.lastFrameTimestamp = now;
        this.animationFrameId = requestAnimationFrame(()=>this.renderLoop());
        if (!this.doRender) return;
        const tool = this.getActiveTool();
        const oldTransform = this.viewport.getTransform();
        let newTransform = oldTransform;
        if ((0, _isTransformEqual.isTransformEqual)(oldTransform, this.targetTransform)) this.doRender = false;
        else {
            const defaultDeltaMs = 1000 / 60;
            const timeFactor = deltaMs / defaultDeltaMs;
            const easeFactor = 1 - 0.7 ** timeFactor;
            newTransform = (0, _blendTransform.blendTransform)(oldTransform, this.targetTransform, {
                width: this.project.width,
                height: this.project.height
            }, {
                x: this.width / 2,
                y: this.height / 2
            }, easeFactor);
            this.viewport.setTransform(newTransform);
        }
        // todo: is last renderedTransform needed?
        const isPositionChanged = newTransform.x !== this.lastRenderedTransform.x || newTransform.y !== this.lastRenderedTransform.y;
        const isScaleOrAngleChanged = newTransform.scale !== this.lastRenderedTransform.scale || newTransform.angleDeg !== this.lastRenderedTransform.angleDeg;
        this.viewport.render(!(0, _isTransformEqual.isTransformEqual)(oldTransform, newTransform));
        if (isPositionChanged || isScaleOrAngleChanged) {
            tool.onUpdateTransform?.(newTransform);
            this.selectionRenderer.setTransform(newTransform);
            this.onTransformChange(this.targetTransform, isScaleOrAngleChanged);
            this.lastRenderedTransform = newTransform;
        }
    }
    /**
     * activate temporary tool. Can only push one.
     */ pushTempTool(toolId) {
        if (this.tempTool !== undefined || toolId === undefined) return;
        const tool = this.toolsMap[this.tool];
        if (tool.getIsLocked?.()) return;
        this.tempTool = toolId;
        this.getActiveTool().activate?.(this.cursorPos);
        this.updateToolSvgs();
        this.updateDoubleTapPointerTypes();
    }
    /**
     * Turn off temporary tool
     */ popTempTool(toolId) {
        if (this.tempTool !== toolId || toolId === undefined) return;
        this.tempTool = undefined;
        this.getActiveTool().activate?.(this.cursorPos, true);
        this.updateToolSvgs();
        this.updateDoubleTapPointerTypes();
    }
    getActiveTool() {
        return this.toolsMap[this.tempTool ?? this.tool];
    }
    getResetTransform() {
        return (0, _createTransform.createTransform)({
            x: this.width / 2,
            y: this.height / 2
        }, {
            x: this.project.width / 2,
            y: this.project.height / 2
        }, 1, 0);
    }
    getFitTransform() {
        const oldTransform = this.viewport.getTransform();
        // rotate
        let newAngleDeg = oldTransform.angleDeg;
        if (newAngleDeg === 45) // would otherwise get rounded to 90
        newAngleDeg = 0;
        newAngleDeg = (0, _math.snapAngleDeg)(newAngleDeg, 90, 90);
        //calc width and height of bounds
        const projectWidth = this.project.width;
        const projectHeight = this.project.height;
        const canvasPointsArr = [
            [
                0,
                0
            ],
            [
                projectWidth,
                0
            ],
            [
                projectWidth,
                projectHeight
            ],
            [
                0,
                projectHeight
            ],
            [
                projectWidth / 2,
                projectHeight / 2
            ]
        ];
        //setup transformation matrix
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(newAngleDeg / 180 * Math.PI));
        //rotate points
        for(let i = 0; i < canvasPointsArr.length; i++){
            let coords = [
                canvasPointsArr[i][0],
                canvasPointsArr[i][1],
                0,
                1
            ];
            coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
            canvasPointsArr[i][0] = coords[0];
            canvasPointsArr[i][1] = coords[1];
        }
        const boundsObj = {};
        for(let i = 0; i < canvasPointsArr.length; i++){
            if (boundsObj.x1 === undefined || canvasPointsArr[i][0] < boundsObj.x1) boundsObj.x1 = canvasPointsArr[i][0];
            if (boundsObj.y1 === undefined || canvasPointsArr[i][1] < boundsObj.y1) boundsObj.y1 = canvasPointsArr[i][1];
            if (boundsObj.x2 === undefined || canvasPointsArr[i][0] > boundsObj.x2) boundsObj.x2 = canvasPointsArr[i][0];
            if (boundsObj.y2 === undefined || canvasPointsArr[i][1] > boundsObj.y2) boundsObj.y2 = canvasPointsArr[i][1];
        }
        const boundsWidth = boundsObj.x2 - boundsObj.x1;
        const boundsHeight = boundsObj.y2 - boundsObj.y1;
        //fit bounds
        const padding = 0;
        const { width: fitWidth } = (0, _bb.BB).fitInto(boundsWidth, boundsHeight, this.width - padding, this.height - padding, 1);
        //determine scale
        const factor = Math.min((0, _easelConfig.EASEL_MAX_SCALE), fitWidth / boundsWidth);
        const viewportRect = {
            width: this.width,
            height: this.height
        };
        const viewportCenterP = {
            x: viewportRect.width / 2,
            y: viewportRect.height / 2
        };
        return (0, _createTransform.createTransform)(viewportCenterP, {
            x: projectWidth / 2,
            y: projectHeight / 2
        }, factor, newAngleDeg);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.doRender = false // true -> will render on next renderLoop
        ;
        this.isFrozen = false // disable interaction with the easel whatsoever
        ;
        this.lastRenderedTransform = {} // previously rendered viewport transformation
        ;
        this.targetTransform = {};
        // custom interface passed to tools
        this.easelInterface = {
            setCursor: (cursor)=>this.rootEl.style.cursor = cursor,
            getTransform: ()=>this.viewport.getTransform(),
            getTargetTransform: ()=>this.targetTransform,
            getSize: ()=>({
                    width: this.width,
                    height: this.height
                }),
            getProjectSize: ()=>({
                    width: this.project.width,
                    height: this.project.height
                }),
            setTransform: (transform, isImmediate)=>this.setTargetTransform(transform, isImmediate),
            requestRender: ()=>this.requestRender(),
            isKeyPressed: (keyStr)=>this.keyListener.isPressed(keyStr),
            minScale: (0, _easelConfig.EASEL_MIN_SCALE),
            maxScale: (0, _easelConfig.EASEL_MAX_SCALE),
            setAngleDeg: (...args)=>this.setAngleDeg(...args),
            keyListener: {},
            updateDoubleTapPointerTypes: ()=>this.updateDoubleTapPointerTypes(),
            setRenderedSelection: (selection)=>this.selectionRenderer.setRenderedSelection(selection),
            clearRenderedSelection: (isImmediate)=>this.selectionRenderer.clearRenderedSelection(isImmediate)
        };
        this.lastFrameTimestamp = 0;
        this.project = p.project;
        this.width = p.width;
        this.height = p.height;
        this.tool = p.tool;
        this.toolsMap = {
            ...p.tools
        };
        this.onChangeTool = p.onChangeTool;
        this.onTransformChange = p.onTransformChange;
        this.onUndo = p.onUndo;
        this.onRedo = p.onRedo;
        this.tempTools = Object.fromEntries((0, _easelConfig.TEMP_TRIGGERS).map((trigger)=>{
            return [
                trigger,
                getToolEntries(this.toolsMap).filter(([toolName, tool])=>{
                    return tool.tempTriggers && tool.tempTriggers.includes(trigger);
                }).map((i)=>i[0])[0]
            ];
        }));
        this.viewport = new (0, _projectViewport.ProjectViewport)({
            width: this.width,
            height: this.height,
            project: {
                width: this.project.width,
                height: this.project.height,
                layers: this.project.layers
            },
            transform: this.getResetTransform(),
            renderAfter: (ctx, renderedTransform)=>{
                const tool = this.getActiveTool();
                tool.renderAfterViewport?.(ctx, renderedTransform);
            }
        });
        Object.values(this.toolsMap).forEach((tool)=>{
            tool.setEaselInterface?.(this.easelInterface);
            tool.onResize?.(this.width, this.height);
        });
        let mouseMiddleIsDown = false;
        let mouseRightIsDown = false;
        let angleIsExtraSticky = false;
        this.pointerPreprocessor = new (0, _easelPointerPreprocessor.EaselPointerPreprocessor)({
            onUndo: this.onUndo,
            onRedo: this.onRedo,
            onPinch: (event)=>{
                if (event.type === 'move') {
                    const transform = this.viewport.getTransform();
                    if (!this.pinchInitialTransform) {
                        this.pinchInitialTransform = (0, _bb.BB).copyObj(transform);
                        angleIsExtraSticky = this.pinchInitialTransform.angleDeg % 180 === 0;
                    }
                    let newAngleDeg = this.pinchInitialTransform.angleDeg + event.angleRad / Math.PI * 180;
                    newAngleDeg = (0, _math.minimizeAngleDeg)((0, _math.snapAngleDeg)(newAngleDeg, 90, angleIsExtraSticky ? 12 : 4));
                    if (newAngleDeg % 90 !== 0) angleIsExtraSticky = false;
                    const metaTransform = (0, _toMetaTransform.toMetaTransform)(this.pinchInitialTransform, {
                        x: event.downRelX,
                        y: event.downRelY
                    });
                    metaTransform.scale = (0, _bb.BB).clamp(this.pinchInitialTransform.scale * event.scale, (0, _easelConfig.EASEL_MIN_SCALE), (0, _easelConfig.EASEL_MAX_SCALE));
                    metaTransform.viewportP.x += event.relX - event.downRelX;
                    metaTransform.viewportP.y += event.relY - event.downRelY;
                    metaTransform.angleDeg = newAngleDeg;
                    this.setTargetTransform((0, _createTransform.createTransform)(metaTransform.viewportP, metaTransform.canvasP, metaTransform.scale, metaTransform.angleDeg), true);
                    this.requestRender();
                } else if (event.type === 'end') this.pinchInitialTransform = undefined;
            },
            onDoubleTap: (e)=>{
                if (this.fitTransform()) this.requestRender();
                else this.scale(2, e.relX, e.relY);
            },
            onChainOut: (e)=>{
                this.cursorPos = {
                    x: e.relX,
                    y: e.relY
                };
                if (e.type === 'pointerdown') {
                    if (e.button === 'middle') {
                        mouseMiddleIsDown = true;
                        this.pushTempTool(this.tempTools['mouse-middle']);
                    }
                    if (e.button === 'right') {
                        mouseRightIsDown = true;
                        this.pushTempTool(this.tempTools['mouse-right']);
                    }
                } else if (e.type === 'pointermove') ;
                else if (e.type === 'pointerup') {
                    if (mouseMiddleIsDown) {
                        mouseMiddleIsDown = false;
                        this.getActiveTool().onPointer(e);
                        this.popTempTool(this.tempTools['mouse-middle']);
                        return;
                    }
                    if (mouseRightIsDown) {
                        mouseRightIsDown = false;
                        this.getActiveTool().onPointer(e);
                        this.popTempTool(this.tempTools['mouse-right']);
                        return;
                    }
                }
                this.getActiveTool().onPointer(e);
            }
        });
        /*
        // My trackpad pinching (via PointerListener) doesn't currently work with Safari on macOS.
        // So I tried GestureListener, which works, but doesn't mesh well with the other event listeners.
        let lastScale = 0;
        this.gestureListener = new GestureListener({
            target: this.viewport.getElement(),
            onStart: (e) => {
                lastScale = e.scale;
            },
            onChange: (e) => {
                const deltaScale = e.scale / lastScale;
                lastScale = e.scale;

                // zoom
                const transform = this.viewport.getTransform();
                const viewportPoint = {
                    x: e.layerX,
                    y: e.layerY,
                };
                const mat = createMatrixFromTransform(transform);
                const canvasPoint = applyToPoint(inverse(mat), viewportPoint);
                const newScale = BB.clamp(
                    transform.scale * deltaScale,
                    EASEL_MIN_SCALE,
                    EASEL_MAX_SCALE,
                );
                this.setTransform(
                    createTransform(viewportPoint, canvasPoint, newScale, transform.angleDeg),
                );
                this.requestRender();
            },
        });*/ this.pointerListener = new (0, _pointerListener.PointerListener)({
            target: this.viewport.getElement(),
            onPointer: (e)=>{
                this.pointerPreprocessor.chainIn(e);
            },
            onWheel: (e)=>{
                e.event?.preventDefault();
                let isImmediate = false;
                if (Math.abs(e.deltaY) < 0.8) isImmediate = true;
                if (e.event && e.event.ctrlKey && !this.keyListener.isPressed('ctrl')) {
                    isImmediate = true;
                    let factor = 1;
                    if (e.event.deltaMode === 0) factor = 6;
                    e.deltaY *= factor;
                }
                if (this.keyListener.isPressed('shift')) e.deltaY /= 4;
                // zoom
                const transform = this.targetTransform;
                const viewportPoint = {
                    x: e.relX,
                    y: e.relY
                };
                const mat = (0, _createMatrixFromTransform.createMatrixFromTransform)(transform);
                const canvasPoint = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(mat), viewportPoint);
                const newScale = (0, _bb.BB).clamp(transform.scale * Math.pow(1.4, -e.deltaY), (0, _easelConfig.EASEL_MIN_SCALE), (0, _easelConfig.EASEL_MAX_SCALE));
                this.setTargetTransform((0, _createTransform.createTransform)(viewportPoint, canvasPoint, newScale, transform.angleDeg), isImmediate);
            },
            onEnterLeave: (isOver)=>{
                const tool = this.getActiveTool();
                if (!isOver) {
                    this.cursorPos = undefined;
                    tool.onPointerLeave?.();
                }
            },
            useDirtyWheel: true,
            isWheelPassive: false,
            maxPointers: 3
        });
        this.windowPointerListener = (e)=>{
            if (this.isFrozen) return;
            if (!this.rootEl.contains(e.target)) this.getActiveTool().onClickOutside?.();
        };
        window.addEventListener('pointerdown', this.windowPointerListener);
        this.keyListener = new (0, _keyListener.KeyListener)({
            onDown: (keyStr, e, comboStr, isRepeat)=>{
                if (this.isFrozen) return;
                if (comboStr === 'plus') {
                    const oldScale = this.getTransform().scale;
                    const newScale = (0, _zoomByStep.zoomByStep)(oldScale, this.keyListener.isPressed('shift') ? 1 / 8 : 0.5);
                    this.scale(newScale / oldScale);
                }
                if (comboStr === 'minus') {
                    const oldScale = this.getTransform().scale;
                    const newScale = (0, _zoomByStep.zoomByStep)(oldScale, this.keyListener.isPressed('shift') ? -1 / 8 : -0.5);
                    this.scale(newScale / oldScale);
                }
                if (this.keyListener.comboOnlyContains([
                    'left',
                    'right',
                    'up',
                    'down'
                ])) {
                    const activeTool = this.getActiveTool();
                    if (!activeTool.onArrowKeys?.(keyStr)) {
                        const stepSize = 40;
                        if (keyStr === 'left') this.translate(stepSize, 0);
                        if (keyStr === 'right') this.translate(-stepSize, 0);
                        if (keyStr === 'up') this.translate(0, stepSize);
                        if (keyStr === 'down') this.translate(0, -stepSize);
                    }
                }
                // activate temporary tool
                (0, _easelConfig.TEMP_TRIGGERS_KEYS).forEach((keyTrigger)=>{
                    if (comboStr === keyTrigger && this.toolsMap[this.tool].blockTrigger !== keyTrigger) this.pushTempTool(this.tempTools[keyTrigger]);
                });
                const tool = this.toolsMap[this.tempTool ?? this.tool];
                tool.onKeyDown?.(keyStr, e, comboStr, isRepeat);
            },
            onUp: (keyStr, e, oldComboStr)=>{
                if (this.isFrozen) return;
                // turn off temporary tool again
                (0, _easelConfig.TEMP_TRIGGERS_KEYS).forEach((keyTrigger)=>{
                    if (keyStr === keyTrigger && this.toolsMap[this.tool].blockTrigger !== keyTrigger) this.popTempTool(this.tempTools[keyTrigger]);
                });
                const tool = this.toolsMap[this.tempTool ?? this.tool];
                tool.onKeyUp?.(keyStr, e, oldComboStr);
            },
            onBlur: ()=>{
                const tool = this.toolsMap[this.tempTool ?? this.tool];
                tool.onBlur?.();
            }
        });
        this.easelInterface.keyListener = this.keyListener;
        this.selectionRenderer = new (0, _selectionRenderer.SelectionRenderer)({
            transform: this.viewport.getTransform(),
            selection: this.project.selection,
            width: this.width,
            height: this.height
        });
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'svg',
            width: '' + this.width,
            height: '' + this.height
        });
        (0, _base.css)(this.svgEl, {
            position: 'absolute',
            left: '0',
            top: '0',
            pointerEvents: 'none'
        });
        this.svgEl.append(this.selectionRenderer.getElement(), ...Object.values(this.toolsMap).map((item)=>item.getSvgElement()));
        this.updateToolSvgs();
        this.rootEl = (0, _c.c)({
            css: {
                userSelect: 'none',
                touchAction: 'none',
                overscrollBehaviorX: 'none'
            }
        }, [
            this.viewport.getElement(),
            this.svgEl
        ]);
        // prevent contextmenu
        this.rootEl.addEventListener('contextmenu', (e)=>{
            e.preventDefault();
            return false;
        }, {
            passive: false
        });
        // Carried over from old KlCanvasWorkspace. Prevent some default browser behavior. Todo what breaks if removed?
        this.rootEl.addEventListener('touchend', (e)=>{
            e.preventDefault();
            return false;
        });
        // Carried over from old KlCanvasWorkspace. Prevent some default browser behavior. Todo what breaks if removed?
        this.rootEl.addEventListener('dragstart', (e)=>{
            e.preventDefault();
            return false;
        });
        this.toolsMap[this.tool].activate?.(this.cursorPos);
        this.renderLoop();
    }
    /** update and render */ setProject(project) {
        this.project = project;
        this.viewport.setProject({
            width: this.project.width,
            height: this.project.height,
            layers: this.project.layers
        });
        this.selectionRenderer.setSelection(this.project.selection);
        this.getActiveTool().onUpdateSelection?.(this.project.selection);
        this.requestRender();
    }
    /** update and render */ setSize(width, height) {
        const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(this.viewport.getTransform());
        const canvasCenterPoint = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), {
            x: this.width / 2,
            y: this.height / 2
        });
        this.width = width;
        this.height = height;
        (0, _bb.BB).setAttributes(this.svgEl, {
            width: '' + this.width,
            height: '' + this.height
        });
        this.selectionRenderer.setSize(width, height);
        this.getActiveTool().onResize?.(width, height);
        this.viewport.setSize(width, height);
        const transform = this.viewport.getTransform();
        this.setTargetTransform((0, _createTransform.createTransform)({
            x: this.width / 2,
            y: this.height / 2
        }, canvasCenterPoint, transform.scale, transform.angleDeg), true);
        this.requestRender();
    }
    requestRender() {
        this.doRender = true;
    }
    getTransform() {
        return this.viewport.getTransform();
    }
    setTransform(transform) {
        this.setTargetTransform(transform, true);
    }
    setTool(toolId) {
        if (toolId === this.tool) return;
        this.tool = toolId;
        this.toolsMap[this.tool].activate?.(this.cursorPos);
        this.onChangeTool(toolId);
        this.updateToolSvgs();
        this.updateDoubleTapPointerTypes();
        this.requestRender();
    }
    getTool() {
        return this.tool;
    }
    translate(dX, dY) {
        const transform = this.targetTransform;
        this.setTargetTransform({
            ...transform,
            x: transform.x + dX,
            y: transform.y + dY
        });
    }
    scale(factor, viewportX, viewportY) {
        const before = this.targetTransform;
        const viewportRect = {
            width: this.width,
            height: this.height
        };
        viewportX = viewportX ?? viewportRect.width / 2;
        viewportY = viewportY ?? viewportRect.height / 2;
        const metaTransform = (0, _toMetaTransform.toMetaTransform)(before, {
            x: viewportX,
            y: viewportY
        });
        metaTransform.scale = (0, _bb.BB).clamp(metaTransform.scale * factor, (0, _easelConfig.EASEL_MIN_SCALE), (0, _easelConfig.EASEL_MAX_SCALE));
        this.setTargetTransform((0, _createTransform.createTransform)(metaTransform.viewportP, metaTransform.canvasP, metaTransform.scale, metaTransform.angleDeg));
    }
    resetTransform(isImmediate) {
        const transform = this.getResetTransform();
        this.setTargetTransform(transform, isImmediate);
        this.requestRender();
    }
    fitTransform(isImmediate) {
        const oldTransform = this.viewport.getTransform();
        const transform = this.getFitTransform();
        const isPositionChanged = transform.x !== oldTransform.x || transform.y !== oldTransform.y;
        const isScaleOrAngleChanged = transform.scale !== oldTransform.scale || transform.angleDeg !== oldTransform.angleDeg;
        if (!isPositionChanged && !isScaleOrAngleChanged) return false;
        this.setTargetTransform(transform, isImmediate);
        return true;
    }
    /**
     * Automatically decide what is best. E.g. if it's pixel art, Fit might be better.
     */ resetOrFitTransform(isImmediate) {
        const threshold = 4; // >= 400% zoom. pixelated, not blurry
        if (!(0, _klConfig.KL_CONFIG).disableAutoFit && this.project.width <= this.width / threshold && this.project.height <= this.height / threshold) this.fitTransform(isImmediate);
        else this.resetTransform(isImmediate);
    }
    setAngleDeg(angleDeg, isRelative) {
        const viewportTransform = this.targetTransform;
        const viewportMat = (0, _createMatrixFromTransform.createMatrixFromTransform)(viewportTransform);
        const viewportRect = {
            width: this.width,
            height: this.height
        };
        const viewportCenterP = {
            x: viewportRect.width / 2,
            y: viewportRect.height / 2
        };
        const newAngleDeg = (0, _math.minimizeAngleDeg)(isRelative ? viewportTransform.angleDeg + angleDeg : angleDeg);
        const newViewportTransform = (0, _createTransform.createTransform)(viewportCenterP, (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(viewportMat), viewportCenterP), viewportTransform.scale, newAngleDeg);
        this.setTargetTransform(newViewportTransform);
    }
    getIsLocked() {
        return this.getActiveTool().getIsLocked?.() ?? false;
    }
    setIsFrozen(b) {
        this.isFrozen = b;
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.viewport.destroy();
        this.pointerListener.destroy();
        this.keyListener.destroy();
        this.animationFrameId !== undefined && cancelAnimationFrame(this.animationFrameId);
        this.selectionRenderer.destroy();
        window.removeEventListener('pointerdown', this.windowPointerListener);
    }
}

},{"../../../bb/base/c":"3KmDH","../project-viewport/project-viewport":"cxBEj","../../../bb/input/pointer-listener":"kDObC","../../../bb/bb":"3zOvT","../../../bb/transform/to-meta-transform":"4mFA3","../../../bb/transform/create-transform":"kdXSP","../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","./easel-pointer-preprocessor":"GDkBY","../../../bb/input/key-listener":"fDHUR","../project-viewport/utils/zoom-by-step":"f7IyB","./selection-renderer":"eUVrm","../../kl-config":"4KrR1","../../../bb/math/math":"7x9Fp","./easel.config":"8wpI3","../project-viewport/utils/is-transform-equal":"945Dq","../project-viewport/utils/blend-transform":"3Z8D4","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"GDkBY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * lets pointer events go through an event chain,
 * which checks for double tapping and other gestures,
 * then filters to a single pointer
 */ parcelHelpers.export(exports, "EaselPointerPreprocessor", ()=>EaselPointerPreprocessor);
var _bb = require("../../../bb/bb");
var _eventChain = require("../../../bb/input/event-chain/event-chain");
class EaselPointerPreprocessor {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        const nFingerSubChain = [];
        if (p.onUndo) {
            this.twoFingerTap = new (0, _bb.BB).NFingerTapper({
                fingers: 2,
                onTap: p.onUndo
            });
            nFingerSubChain.push(this.twoFingerTap);
        }
        if (p.onRedo) {
            this.threeFingerTap = new (0, _bb.BB).NFingerTapper({
                fingers: 3,
                onTap: p.onRedo
            });
            nFingerSubChain.push(this.threeFingerTap);
        }
        this.mainDoubleTapper = new (0, _bb.BB).DoubleTapper({
            onDoubleTap: p.onDoubleTap
        });
        this.mainDoubleTapper.setAllowedPointerTypeArr([
            'touch'
        ]);
        this.middleDoubleTapper = new (0, _bb.BB).DoubleTapper({
            onDoubleTap: p.onDoubleTap
        });
        this.middleDoubleTapper.setAllowedButtonArr([
            'middle'
        ]);
        this.pinchZoomer = new (0, _bb.BB).PinchZoomer({
            onPinch: p.onPinch
        });
        this.pointerEventChain = new (0, _eventChain.EventChain)({
            chainArr: [
                ...nFingerSubChain,
                this.mainDoubleTapper,
                this.middleDoubleTapper,
                this.pinchZoomer,
                new (0, _bb.BB).OnePointerLimiter()
            ]
        });
        this.pointerEventChain.setChainOut(p.onChainOut);
    }
    chainIn(e) {
        this.pointerEventChain.chainIn(e);
    }
    setDoubleTapPointerTypes(p) {
        this.mainDoubleTapper.setAllowedPointerTypeArr(p);
    }
    destroy() {
    // todo
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/input/event-chain/event-chain":"eo2AB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8wpI3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_DOUBLE_TAP_POINTER_TYPES", ()=>DEFAULT_DOUBLE_TAP_POINTER_TYPES);
parcelHelpers.export(exports, "TEMP_TRIGGERS_KEYS", ()=>TEMP_TRIGGERS_KEYS);
parcelHelpers.export(exports, "TEMP_TRIGGERS", ()=>TEMP_TRIGGERS);
parcelHelpers.export(exports, "EASEL_MIN_SCALE", ()=>EASEL_MIN_SCALE);
parcelHelpers.export(exports, "EASEL_MAX_SCALE", ()=>EASEL_MAX_SCALE);
const DEFAULT_DOUBLE_TAP_POINTER_TYPES = [
    'touch'
];
const TEMP_TRIGGERS_KEYS = [
    'space',
    'alt',
    'r',
    'z'
];
const TEMP_TRIGGERS = [
    'mouse-middle',
    'mouse-right',
    ...TEMP_TRIGGERS_KEYS
];
const EASEL_MIN_SCALE = 1 / 16;
const EASEL_MAX_SCALE = Math.pow(2, 7);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"945Dq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTransformEqual", ()=>isTransformEqual);
function isTransformEqual(a, b) {
    const isPositionChanged = a.x !== b.x || a.y !== b.y;
    const isScaleOrAngleChanged = a.scale !== b.scale || a.angleDeg !== b.angleDeg;
    return !isPositionChanged && !isScaleOrAngleChanged;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Z8D4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendTransform", ()=>blendTransform);
var _isTransformEqual = require("./is-transform-equal");
var _bb = require("../../../../bb/bb");
var _toMetaTransform = require("../../../../bb/transform/to-meta-transform");
var _createTransform = require("../../../../bb/transform/create-transform");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
function blendTransform(currentTransform, targetTransform, projectSize, viewportCenter, easeFactor) {
    // equal
    if ((0, _isTransformEqual.isTransformEqual)(currentTransform, targetTransform)) return {
        ...targetTransform
    };
    // approximately equal
    if ((currentTransform.x === targetTransform.x || Math.abs(currentTransform.x - targetTransform.x) < 2) && (currentTransform.y === targetTransform.y || Math.abs(currentTransform.y - targetTransform.y) < 2) && (currentTransform.scale === targetTransform.scale || Math.abs(currentTransform.scale - targetTransform.scale) < 0.08 * targetTransform.scale)) return {
        ...targetTransform
    };
    // same angle, just translate and scale
    if (currentTransform.angleDeg === targetTransform.angleDeg) return {
        x: (0, _bb.BB).mix(currentTransform.x, targetTransform.x, easeFactor),
        y: (0, _bb.BB).mix(currentTransform.y, targetTransform.y, easeFactor),
        angleDeg: targetTransform.angleDeg,
        scale: (0, _bb.BB).mix(currentTransform.scale, targetTransform.scale, easeFactor)
    };
    // rotating around a point
    const currentMeta = (0, _toMetaTransform.toMetaTransform)(currentTransform, viewportCenter);
    const targetMeta = (0, _toMetaTransform.toMetaTransform)(targetTransform, viewportCenter);
    if ((0, _bb.BB).Vec2.dist(currentMeta.canvasP, targetMeta.canvasP) < 1) {
        // move angles closer to each other. assumes [-180, 180] angle range.
        let closerCurrentAngleDeg = currentMeta.angleDeg;
        // -180 180 -> 180 + 180 = 360
        // 180 -180 -> -180 - 180 = -360
        const angleDelta = targetMeta.angleDeg - currentMeta.angleDeg;
        if (angleDelta > 180) closerCurrentAngleDeg += 360;
        if (angleDelta < -180) closerCurrentAngleDeg -= 360;
        const mixedMeta = {
            viewportP: viewportCenter,
            canvasP: targetMeta.canvasP,
            scale: (0, _bb.BB).mix(currentTransform.scale, targetTransform.scale, easeFactor),
            angleDeg: (0, _bb.BB).mix(closerCurrentAngleDeg, targetTransform.angleDeg, easeFactor)
        };
        return (0, _createTransform.createTransform)(mixedMeta.viewportP, mixedMeta.canvasP, mixedMeta.scale, mixedMeta.angleDeg);
    }
    // rotate around center of canvas
    const canvasCenter = {
        x: projectSize.width / 2,
        y: projectSize.height / 2
    };
    const currentMatrix = (0, _createMatrixFromTransform.createMatrixFromTransform)(currentTransform);
    const targetMatrix = (0, _createMatrixFromTransform.createMatrixFromTransform)(targetTransform);
    const currentCenter = (0, _transformationMatrix.applyToPoint)(currentMatrix, canvasCenter);
    const targetCenter = (0, _transformationMatrix.applyToPoint)(targetMatrix, canvasCenter);
    const mixedCenter = {
        x: (0, _bb.BB).mix(currentCenter.x, targetCenter.x, easeFactor),
        y: (0, _bb.BB).mix(currentCenter.y, targetCenter.y, easeFactor)
    };
    const mixedScale = (0, _bb.BB).mix(currentTransform.scale, targetTransform.scale, easeFactor);
    const mixedAngleDeg = (0, _bb.BB).mix(currentTransform.angleDeg, targetTransform.angleDeg, easeFactor);
    const mixedAngleRad = mixedAngleDeg * (Math.PI / 180);
    // calculate the offset from the center to the top-left corner (origin)
    const offsetX = -canvasCenter.x * mixedScale;
    const offsetY = -canvasCenter.y * mixedScale;
    const rotatedOffsetX = offsetX * Math.cos(mixedAngleRad) - offsetY * Math.sin(mixedAngleRad);
    const rotatedOffsetY = offsetX * Math.sin(mixedAngleRad) + offsetY * Math.cos(mixedAngleRad);
    const origin = {
        x: mixedCenter.x + rotatedOffsetX,
        y: mixedCenter.y + rotatedOffsetY
    };
    return {
        x: origin.x,
        y: origin.y,
        scale: mixedScale,
        angleDeg: mixedAngleDeg
    };
}

},{"./is-transform-equal":"945Dq","../../../../bb/bb":"3zOvT","../../../../bb/transform/to-meta-transform":"4mFA3","../../../../bb/transform/create-transform":"kdXSP","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"krX6f":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselHand", ()=>EaselHand);
var _bb = require("../../../../bb/bb");
var _inertiaScrolling = require("../inertia-scrolling");
class EaselHand {
    constructor(p){
        this.easel = {};
        // ----------------------------------- public -----------------------------------
        this.doubleTapPointerTypes = [
            'touch',
            'mouse',
            'pen'
        ];
        this.tempTriggers = [
            'space',
            'mouse-middle'
        ];
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.inertiaScrolling = new (0, _inertiaScrolling.InertiaScrolling)({
            getTransform: ()=>this.easel.getTransform(),
            setTransform: (transform)=>this.easel.setTransform(transform, true)
        });
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.easel.setCursor('grab');
        if (e.type === 'pointerdown' && [
            'left',
            'middle'
        ].includes(e.button)) {
            this.inertiaScrolling.dragStart();
            this.easel.setCursor('grabbing');
        }
        if (e.type === 'pointermove' && [
            'left',
            'middle'
        ].includes(e.button)) {
            const vTransform = {
                ...this.easel.getTransform()
            };
            vTransform.x += e.dX;
            vTransform.y += e.dY;
            this.easel.setTransform(vTransform, true);
            this.easel.requestRender();
            this.easel.setCursor('grabbing');
            this.inertiaScrolling.dragMove(e.dX, e.dY);
        }
        if (e.type === 'pointerup' && e.button === undefined) this.inertiaScrolling.dragEnd();
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    activate(cursorPos) {
        this.easel.setCursor('grab');
    }
    setUseInertiaScrolling(b) {
        this.inertiaScrolling.setIsEnabled(b);
    }
}

},{"../../../../bb/bb":"3zOvT","../inertia-scrolling":"7urx8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7urx8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * flings the viewport into the direction the pointer was dragging
 */ parcelHelpers.export(exports, "InertiaScrolling", ()=>InertiaScrolling);
var _bb = require("../../../bb/bb");
class InertiaScrolling {
    stop() {
        if (this.animationFrameHandle === undefined) return;
        cancelAnimationFrame(this.animationFrameHandle);
        this.animationFrameHandle = undefined;
    }
    dampen(timeFactor) {
        const vecLen = (0, _bb.BB).Vec2.len(this.momentum);
        if (vecLen < 0.3) {
            this.momentum.x = 0;
            this.momentum.y = 0;
            this.stop();
        } else if (vecLen < 5) {
            this.momentum.x *= 0.85 ** timeFactor;
            this.momentum.y *= 0.85 ** timeFactor;
        } else {
            this.momentum.x *= 0.95 ** timeFactor;
            this.momentum.y *= 0.95 ** timeFactor;
        }
    }
    // only call through requestAnimationFrame when animationFrameHandle undefined
    physicsLoop() {
        this.animationFrameHandle = requestAnimationFrame(()=>this.physicsLoop());
        const nowMs = performance.now();
        const deltaMs = nowMs - this.lastTimestamp;
        const timeFactor = deltaMs / this.defaultDeltaMs;
        this.lastTimestamp = nowMs;
        if (this.momentum.x === 0 && this.momentum.y === 0 || this.isDragging) {
            if (this.isDragging) this.dampen(timeFactor);
            else this.stop();
            return;
        }
        const transform = this.getTransform();
        if (this.lastTransform && (this.lastTransform.x !== transform.x || this.lastTransform.y !== transform.y || this.lastTransform.x !== transform.x || this.lastTransform.x !== transform.x)) {
            this.momentum.x = 0;
            this.momentum.y = 0;
            this.lastTransform = undefined;
            this.stop();
            return;
        }
        transform.x += this.momentum.x;
        transform.y += this.momentum.y;
        this.lastTransform = transform;
        this.dampen(timeFactor);
        this.setTransform(transform);
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.defaultDeltaMs = 1000 / 60 // time factor is 1 for 60fps, 2 for 120fps
        ;
        this.momentum = {
            x: 0,
            y: 0
        };
        this.isDragging = false;
        this.lastDragTimestamp = 0;
        this.lastTimestamp = 0;
        this.isEnabled = false;
        this.getTransform = p.getTransform;
        this.setTransform = p.setTransform;
    }
    dragStart() {
        if (!this.isEnabled) return;
        this.isDragging = true;
        this.momentum.x = 0;
        this.momentum.y = 0;
        this.stop();
    }
    dragMove(dX, dY) {
        if (!this.isEnabled) return;
        this.momentum = {
            x: (0, _bb.BB).mix(this.momentum.x, dX, 0.6),
            y: (0, _bb.BB).mix(this.momentum.y, dY, 0.6)
        };
        this.lastDragTimestamp = new Date().getTime();
    }
    dragEnd() {
        if (!this.isEnabled) return;
        if (new Date().getTime() - this.lastDragTimestamp > 80) {
            this.momentum.x = 0;
            this.momentum.y = 0;
        } else {
            this.lastTimestamp = performance.now();
            this.animationFrameHandle = requestAnimationFrame(()=>this.physicsLoop());
        }
        this.lastTransform = undefined;
        this.lastDragTimestamp = 0;
        this.isDragging = false;
    }
    setIsEnabled(b) {
        this.isEnabled = b;
    }
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fF49U":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselBrush", ()=>EaselBrush);
var _bb = require("../../../../bb/bb");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
var _coalescedExploder = require("../../../../bb/input/event-chain/coalesced-exploder");
var _eventChain = require("../../../../bb/input/event-chain/event-chain");
var _brushCursorPixelSquare = require("./brush-cursor-pixel-square");
var _brushCursorRound = require("./brush-cursor-round");
class EaselBrush {
    onExplodedPointer(e) {
        const vTransform = this.easel.getTransform();
        const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(vTransform);
        // canvas coordinates
        const p = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), {
            x: e.relX,
            y: e.relY
        });
        const x = p.x;
        const y = p.y;
        if (vTransform.scale !== this.oldScale) this.oldScale = vTransform.scale;
        if (!e.isCoalesced) {
            this.lastPos.x = e.relX;
            this.lastPos.y = e.relY;
            this.currentCursor.update(this.easel.getTransform(), {
                x: e.relX,
                y: e.relY
            }, this.radius);
            if (!this.isOver && e.type !== 'pointerup') this._onPointerEnter();
        }
        const pressure = e.pressure ?? 1;
        const isCoalesced = e.isCoalesced;
        const shiftIsPressed = this.easel.keyListener.isPressed('shift');
        if (shiftIsPressed && !this.firstShiftPos) this.firstShiftPos = {
            x: e.relX,
            y: e.relY
        };
        if (!shiftIsPressed) {
            this.firstShiftPos = undefined;
            this.lineToolDirection = undefined;
        }
        if (e.type === 'pointerdown' && e.button === 'left') {
            if (shiftIsPressed) {
                if (this.lastLineEnd) this.onLine(this.lastLineEnd, {
                    x,
                    y
                });
                return;
            }
            this.onLineStart({
                x,
                y,
                pressure,
                isCoalesced
            });
            this.isDragging = true;
        }
        if (e.type === 'pointermove' && e.button === 'left') {
            if (shiftIsPressed) {
                if (!this.lineToolDirection) {
                    const dX = Math.abs(e.relX - this.firstShiftPos.x);
                    const dY = Math.abs(e.relY - this.firstShiftPos.y);
                    if (dX > 5 || dY > 5) this.lineToolDirection = dX > dY ? 'x' : 'y';
                }
                if (this.lineToolDirection) {
                    const viewportP = {
                        x: this.lineToolDirection === 'x' ? e.relX : this.firstShiftPos.x,
                        y: this.lineToolDirection === 'y' ? e.relY : this.firstShiftPos.y
                    };
                    const canvasP = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), viewportP);
                    this.onLineGo({
                        ...canvasP,
                        pressure,
                        isCoalesced
                    });
                }
            } else this.onLineGo({
                x,
                y,
                pressure,
                isCoalesced
            });
        }
        if (e.type === 'pointerup' && e.button === undefined && this.isDragging) {
            this.onLineEnd();
            this.isDragging = false;
            if (e.pointerType === 'touch') // due to delay of double-tap listener, pointerleave fires to early
            this.onPointerLeave();
        }
    }
    _onPointerEnter() {
        clearTimeout(this.hideCursorTimeout);
        this.svgEl.setAttribute('opacity', '1');
        this.isOver = true;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.easel = {};
        this.oldScale = 1;
        this.isDragging = false;
        this.lastPos = {
            x: 0,
            y: 0
        };
        this.isOver = false;
        this.radius = p.radius;
        this.onLineStart = p.onLineStart;
        this.onLineGo = p.onLineGo;
        this.onLineEnd = p.onLineEnd;
        this.onLine = p.onLine;
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.brushCursorRound = new (0, _brushCursorRound.BrushCursorRound)();
        this.brushCursorPixelSquare = new (0, _brushCursorPixelSquare.BrushCursorPixelSquare)();
        this.currentCursor = this.brushCursorRound;
        this.svgEl.append(this.currentCursor.getElement());
        this.eventChain = new (0, _eventChain.EventChain)({
            chainArr: [
                new (0, _coalescedExploder.CoalescedExploder)()
            ]
        });
        this.eventChain.setChainOut((e)=>{
            this.onExplodedPointer(e);
        });
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.eventChain.chainIn(e);
    }
    onPointerLeave() {
        clearTimeout(this.hideCursorTimeout);
        this.svgEl.setAttribute('opacity', '0');
        this.isOver = false;
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    onUpdateTransform(transform) {
        this.currentCursor.update(transform, {
            x: this.lastPos.x,
            y: this.lastPos.y
        }, this.radius);
    }
    getIsLocked() {
        return this.isDragging;
    }
    setBrush(p) {
        if (p.radius !== undefined) {
            this.radius = p.radius;
            if (!this.isOver) {
                this.svgEl.setAttribute('opacity', '1');
                clearTimeout(this.hideCursorTimeout);
                this.hideCursorTimeout = setTimeout(()=>{
                    this.svgEl.setAttribute('opacity', '0');
                }, 500);
            }
            const { width, height } = this.easel.getSize();
            this.currentCursor.update(this.easel.getTransform(), this.isOver ? this.lastPos : {
                x: width / 2,
                y: height / 2
            }, this.radius);
        }
        if (p.type !== undefined) {
            const newBrushCursor = p.type === 'round' ? this.brushCursorRound : this.brushCursorPixelSquare;
            if (newBrushCursor !== this.currentCursor) {
                this.currentCursor.getElement().remove();
                this.currentCursor = newBrushCursor;
                this.getSvgElement().append(this.currentCursor.getElement());
            }
        }
    }
    setLastDrawEvent(p) {
        this.lastLineEnd = p ? {
            ...p
        } : undefined;
    }
    activate(cursorPos) {
        this.easel.setCursor('crosshair');
        this.isDragging = false;
        if (cursorPos) {
            this.lastPos.x = cursorPos.x;
            this.lastPos.y = cursorPos.y;
            this.currentCursor.update(this.easel.getTransform(), {
                x: cursorPos.x,
                y: cursorPos.y
            }, this.radius);
        } else this.onPointerLeave();
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","../../../../bb/input/event-chain/coalesced-exploder":"gUydo","../../../../bb/input/event-chain/event-chain":"eo2AB","./brush-cursor-pixel-square":"9MqpU","./brush-cursor-round":"dnfAG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9MqpU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrushCursorPixelSquare", ()=>BrushCursorPixelSquare);
var _bb = require("../../../../bb/bb");
var _base = require("../../../../bb/base/base");
var _transformationMatrix = require("transformation-matrix");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
class BrushCursorPixelSquare {
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.rootEl = (0, _bb.BB).createSvg({
            elementType: 'g',
            childrenArr: [
                {
                    elementType: 'path',
                    fill: 'none',
                    stroke: 'rgba(255,255,255,0.7)',
                    'stroke-width': '1'
                },
                {
                    elementType: 'path',
                    fill: 'none',
                    stroke: 'rgba(0,0,0,0.7)',
                    'stroke-width': '1'
                }
            ]
        });
    }
    update(transform, position, size) {
        const mat = (0, _createMatrixFromTransform.createMatrixFromTransform)(transform);
        size = Math.round(size * 2) / 2;
        const width = Math.round(size * 2);
        const canvasCenter = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(mat), position);
        canvasCenter.x = width % 2 === 0 ? Math.round(canvasCenter.x) : Math.floor(canvasCenter.x) + 0.5;
        canvasCenter.y = width % 2 === 0 ? Math.round(canvasCenter.y) : Math.floor(canvasCenter.y) + 0.5;
        {
            const canvasPoints = [
                [
                    canvasCenter.x - size,
                    canvasCenter.y - size
                ],
                [
                    canvasCenter.x + size,
                    canvasCenter.y - size
                ],
                [
                    canvasCenter.x + size,
                    canvasCenter.y + size
                ],
                [
                    canvasCenter.x - size,
                    canvasCenter.y + size
                ],
                [
                    canvasCenter.x - size,
                    canvasCenter.y - size
                ]
            ];
            const viewportPoints = canvasPoints.map((point)=>{
                return (0, _transformationMatrix.applyToPoint)(mat, point);
            });
            let path = 'M ';
            viewportPoints.forEach((point)=>{
                path += point.join(',') + ' ';
            });
            (0, _base.setAttributes)(this.rootEl.children[1], {
                d: path
            });
        }
        {
            const viewport1px = 1 / transform.scale;
            const canvasPoints = [
                [
                    canvasCenter.x - size + viewport1px,
                    canvasCenter.y - size + viewport1px
                ],
                [
                    canvasCenter.x + size - viewport1px,
                    canvasCenter.y - size + viewport1px
                ],
                [
                    canvasCenter.x + size - viewport1px,
                    canvasCenter.y + size - viewport1px
                ],
                [
                    canvasCenter.x - size + viewport1px,
                    canvasCenter.y + size - viewport1px
                ],
                [
                    canvasCenter.x - size + viewport1px,
                    canvasCenter.y - size + viewport1px
                ]
            ];
            const viewportPoints = canvasPoints.map((point)=>{
                return (0, _transformationMatrix.applyToPoint)(mat, point);
            });
            let path = 'M ';
            viewportPoints.forEach((point)=>{
                path += point.join(',') + ' ';
            });
            (0, _base.setAttributes)(this.rootEl.firstChild, {
                d: path
            });
        }
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../bb/base/base":"it3mQ","transformation-matrix":"70QDB","../../../../bb/transform/create-matrix-from-transform":"6kvhU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dnfAG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrushCursorRound", ()=>BrushCursorRound);
var _bb = require("../../../../bb/bb");
class BrushCursorRound {
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.rootEl = (0, _bb.BB).createSvg({
            elementType: 'g',
            childrenArr: [
                {
                    elementType: 'circle',
                    cx: '0',
                    cy: '0',
                    fill: 'none',
                    stroke: 'rgba(255,255,255,0.7)',
                    'stroke-width': '1'
                },
                {
                    elementType: 'circle',
                    cx: '0',
                    cy: '0',
                    fill: 'none',
                    stroke: 'rgba(0,0,0,0.7)',
                    'stroke-width': '1'
                }
            ]
        });
    }
    update(transform, position, size) {
        (0, _bb.BB).setAttributes(this.rootEl.children[0], {
            r: '' + Math.max(0, size * transform.scale - 1)
        });
        (0, _bb.BB).setAttributes(this.rootEl.children[1], {
            r: '' + size * transform.scale
        });
        (0, _bb.BB).setAttributes(this.rootEl, {
            transform: `translate(${position.x} ${position.y})`
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8cv9J":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Allows KlCanvas to be rendered by Easel.
 * Call update when KlCanvas changed (added layer, moved layer, removed layer, changed selection, redo/undo)
 */ parcelHelpers.export(exports, "EaselProjectUpdater", ()=>EaselProjectUpdater);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
class EaselProjectUpdater {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.compositeCanvas = (0, _bb.BB).canvas(1, 1);
        this.klCanvas = p.klCanvas;
        this.easel = p.easel;
        this.update();
    }
    update() {
        const width = this.klCanvas.getWidth();
        const height = this.klCanvas.getHeight();
        this.easel.setProject({
            width,
            height,
            layers: this.klCanvas.getLayersFast().map((layer)=>{
                return {
                    image: layer.compositeObj ? ()=>{
                        if (this.compositeCanvas.width != width || this.compositeCanvas.height != height) {
                            this.compositeCanvas.width = width;
                            this.compositeCanvas.height = height;
                        }
                        const ctx = this.compositeCanvas.getContext('2d');
                        ctx.clearRect(0, 0, width, height);
                        ctx.drawImage(layer.canvas, 0, 0);
                        layer.compositeObj?.draw((0, _base.throwIfNull)(this.compositeCanvas.getContext('2d')));
                        return this.compositeCanvas;
                    } : layer.canvas,
                    isVisible: layer.isVisible,
                    opacity: layer.opacity,
                    mixModeStr: layer.mixModeStr,
                    hasClipping: false
                };
            }),
            selection: this.klCanvas.getSelection()
        });
    }
    // if you're not rendering easel for a while
    freeCompositeCanvas() {
        this.compositeCanvas.width = 1;
        this.compositeCanvas.height = 1;
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fQvEK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselEyedropper", ()=>EaselEyedropper);
var _bb = require("../../../../bb/bb");
var _cursorPickerPng = require("url:/src/app/img/ui/cursor-picker.png");
var _cursorPickerPngDefault = parcelHelpers.interopDefault(_cursorPickerPng);
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
class EaselEyedropper {
    constructor(p){
        this.easel = {};
        this.isDragging = false;
        // ----------------------------------- public -----------------------------------
        this.tempTriggers = [
            'mouse-right',
            'alt'
        ];
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.onPick = p.onPick;
        this.onPickEnd = p.onPickEnd;
        //color picker preview circle
        this.previewBorder = (0, _bb.BB).createSvg({
            elementType: 'circle',
            r: '47',
            stroke: 'black',
            'stroke-width': '22',
            fill: 'none'
        });
        this.previewColor = (0, _bb.BB).createSvg({
            elementType: 'circle',
            r: '47',
            stroke: 'black',
            'stroke-width': '20',
            fill: 'none'
        });
        this.svgEl.append(this.previewBorder, this.previewColor);
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.easel.setCursor("url('" + (0, _cursorPickerPngDefault.default) + "') 0 15, crosshair");
        const transform = this.easel.getTransform();
        const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(transform);
        const p = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), {
            x: e.relX,
            y: e.relY
        });
        let color = undefined;
        let isDown = [
            'left',
            'right'
        ].includes(e.button);
        if (isDown) {
            this.svgEl.setAttribute('transform', `translate(${e.relX},${e.relY})`);
            this.svgEl.style.opacity = '1';
        } else this.svgEl.style.opacity = '0';
        if (e.type === 'pointerdown' && isDown) {
            color = this.onPick(p);
            this.isDragging = true;
            isDown = true;
        }
        if (e.type === 'pointermove' && isDown) {
            color = this.onPick(p);
            isDown = true;
        }
        if (e.type === 'pointerup' && e.button === undefined && this.isDragging) {
            this.onPickEnd();
            this.isDragging = false;
        }
        if (color && isDown) {
            this.previewColor.setAttribute('stroke', (0, _bb.BB).ColorConverter.toRgbStr(color));
            const borderColor = (0, _bb.BB).testIsWhiteBestContrast(color) ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
            this.previewBorder.setAttribute('stroke', borderColor);
        }
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    activate(cursorPos) {
        this.easel.setCursor("url('" + (0, _cursorPickerPngDefault.default) + "') 0 15, crosshair");
        this.isDragging = false;
        this.svgEl.style.opacity = '0';
    }
    onPointerLeave() {
        if (this.isDragging) return;
        this.svgEl.style.opacity = '0';
    }
}

},{"../../../../bb/bb":"3zOvT","url:/src/app/img/ui/cursor-picker.png":"i6Ebf","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i6Ebf":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("cursor-picker.1ee2dcb5.png") + "?" + Date.now();

},{}],"bdCpZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselPaintBucket", ()=>EaselPaintBucket);
var _bb = require("../../../../bb/bb");
var _cursorFillPng = require("url:/src/app/img/ui/cursor-fill.png");
var _cursorFillPngDefault = parcelHelpers.interopDefault(_cursorFillPng);
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
class EaselPaintBucket {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.easel = {};
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.onFill = p.onFill;
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.easel.setCursor("url('" + (0, _cursorFillPngDefault.default) + "') 1 12, crosshair");
        const vTransform = this.easel.getTransform();
        const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(vTransform);
        const p = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), {
            x: e.relX,
            y: e.relY
        });
        if (e.type === 'pointerdown' && e.button === 'left') this.onFill({
            x: Math.floor(p.x),
            y: Math.floor(p.y)
        });
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    activate(cursorPos) {
        this.easel.setCursor("url('" + (0, _cursorFillPngDefault.default) + "') 1 12, crosshair");
    }
}

},{"../../../../bb/bb":"3zOvT","url:/src/app/img/ui/cursor-fill.png":"9I6UG","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9I6UG":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("cursor-fill.419e9951.png") + "?" + Date.now();

},{}],"4vmMl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselGradient", ()=>EaselGradient);
var _bb = require("../../../../bb/bb");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
class EaselGradient {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.easel = {};
        this.isDragging = false;
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.onDown = p.onDown;
        this.onMove = p.onMove;
        this.onUp = p.onUp;
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.easel.setCursor('crosshair');
        const vTransform = this.easel.getTransform();
        const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(vTransform);
        const p = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), {
            x: e.relX,
            y: e.relY
        });
        if (e.type === 'pointerdown' && e.button === 'left') {
            this.onDown(p, vTransform.angleDeg / 180 * Math.PI);
            this.isDragging = true;
        }
        if (e.type === 'pointermove' && e.button === 'left') this.onMove(p);
        if (e.type === 'pointerup' && e.button === undefined && this.isDragging) {
            this.onUp(p);
            this.isDragging = false;
        }
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    getIsLocked() {
        return this.isDragging;
    }
    activate(cursorPos) {
        this.easel.setCursor('crosshair');
        this.isDragging = false;
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lbC4o":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselText", ()=>EaselText);
var _bb = require("../../../../bb/bb");
var _cursorTextPng = require("url:/src/app/img/ui/cursor-text.png");
var _cursorTextPngDefault = parcelHelpers.interopDefault(_cursorTextPng);
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
class EaselText {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.easel = {};
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.onDown = p.onDown;
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.easel.setCursor("url('" + (0, _cursorTextPngDefault.default) + "') 1 12, crosshair");
        const vTransform = this.easel.getTransform();
        const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(vTransform);
        const p = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), {
            x: e.relX,
            y: e.relY
        });
        if (e.type === 'pointerdown' && e.button === 'left') this.onDown(p, vTransform.angleDeg / 180 * Math.PI);
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    activate(cursorPos) {
        this.easel.setCursor("url('" + (0, _cursorTextPngDefault.default) + "') 1 12, crosshair");
    }
}

},{"../../../../bb/bb":"3zOvT","url:/src/app/img/ui/cursor-text.png":"1UJ6t","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1UJ6t":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("cursor-text.84fce96d.png") + "?" + Date.now();

},{}],"2VHOF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselShape", ()=>EaselShape);
var _bb = require("../../../../bb/bb");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
var _cornerPanning = require("../corner-panning");
class EaselShape {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.easel = {};
        this.isDragging = false;
        this.doPan = false;
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.onDown = p.onDown;
        this.onMove = p.onMove;
        this.onUp = p.onUp;
        this.cornerPanning = new (0, _cornerPanning.CornerPanning)({
            getEaselSize: ()=>this.easel.getSize(),
            getTransform: ()=>this.easel.getTargetTransform(),
            setTransform: (transform)=>this.easel.setTransform(transform, true),
            testCanPan: (buttonIsPressed)=>{
                return buttonIsPressed;
            },
            onRepeatEvent: (e)=>{
                this.onPointer(e, true);
            }
        });
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e, isRepeat) {
        if (this.doPan && !isRepeat) this.cornerPanning.onPointer(e);
        this.easel.setCursor('crosshair');
        const vTransform = this.easel.getTransform();
        const m = (0, _createMatrixFromTransform.createMatrixFromTransform)(vTransform);
        const p = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), {
            x: e.relX,
            y: e.relY
        });
        if (e.type === 'pointerdown' && e.button === 'left') {
            this.onDown(p, vTransform.angleDeg / 180 * Math.PI);
            this.isDragging = true;
        }
        if (e.type === 'pointermove' && e.button === 'left') this.onMove(p);
        if (e.type === 'pointerup' && e.button === undefined && this.isDragging) {
            this.onUp(p);
            this.isDragging = false;
        }
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    getIsLocked() {
        return this.isDragging;
    }
    activate(cursorPos) {
        this.easel.setCursor('crosshair');
        this.isDragging = false;
    }
    setPanning(doPan) {
        this.doPan = doPan;
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","../corner-panning":"c3xwQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c3xwQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CornerPanning", ()=>CornerPanning);
class CornerPanning {
    // only call through requestAnimationFrame when animationFrameHandle undefined
    movementLoop() {
        if (!this.cornerDirection) {
            if (this.animationFrameHandle) cancelAnimationFrame(this.animationFrameHandle);
            this.animationFrameHandle = undefined;
            this.lastFrameTimestamp = 0;
            return;
        }
        this.animationFrameHandle = requestAnimationFrame(()=>this.movementLoop());
        const now = performance.now();
        const deltaMs = now - this.lastFrameTimestamp;
        const defaultDeltaMs = 1000 / 60;
        const timeFactor = Math.min(deltaMs / defaultDeltaMs, 10);
        this.lastFrameTimestamp = now;
        const transform = this.getTransform();
        transform.x += this.cornerDirection.x * timeFactor;
        transform.y += this.cornerDirection.y * timeFactor;
        this.setTransform(transform);
        this.onRepeatEvent(this.repeatEvent);
    }
    getSpeed(thresholdDelta) {
        return Math.min(thresholdDelta, this.thresholdPx) * 0.4;
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.thresholdPx = 25;
        this.lastFrameTimestamp = 0;
        this.repeatEvent = {};
        this.getEaselSize = p.getEaselSize;
        this.getTransform = p.getTransform;
        this.setTransform = p.setTransform;
        this.testCanPan = p.testCanPan;
        this.onRepeatEvent = p.onRepeatEvent;
    }
    onPointer(event) {
        let isMoving = false;
        this.cornerDirection = {
            x: 0,
            y: 0
        };
        if (this.testCanPan(event.button !== undefined) && event.type === 'pointermove') {
            if (event.relX > this.getEaselSize().width - this.thresholdPx) {
                this.cornerDirection.x -= this.getSpeed(event.relX - (this.getEaselSize().width - this.thresholdPx));
                isMoving = true;
            }
            if (event.relX < this.thresholdPx) {
                this.cornerDirection.x += this.getSpeed(this.thresholdPx - event.relX);
                isMoving = true;
            }
            if (event.relY > this.getEaselSize().height - this.thresholdPx) {
                this.cornerDirection.y -= this.getSpeed(event.relY - (this.getEaselSize().height - this.thresholdPx));
                isMoving = true;
            }
            if (event.relY < this.thresholdPx) {
                this.cornerDirection.y += this.getSpeed(this.thresholdPx - event.relY);
                isMoving = true;
            }
        }
        if (isMoving) {
            if (this.lastFrameTimestamp === 0) this.lastFrameTimestamp = performance.now();
            this.repeatEvent = event;
            this.animationFrameHandle = requestAnimationFrame(()=>this.movementLoop());
        } else this.cornerDirection = undefined;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Wzzw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselRotate", ()=>EaselRotate);
var _bb = require("../../../../bb/bb");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
var _createTransform = require("../../../../bb/transform/create-transform");
var _math = require("../../../../bb/math/math");
var _base = require("../../../../bb/base/base");
class EaselRotate {
    constructor(p){
        this.easel = {};
        this.downPos = undefined;
        // ----------------------------------- public -----------------------------------
        this.tempTriggers = [
            'r'
        ];
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        //rotation compass
        this.compassSize = 30;
        this.compass = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        (0, _base.css)(this.compass, {
            transition: 'opacity 0.25s ease-in-out'
        });
        this.compassInner = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
        this.compassBaseCircle = (0, _bb.BB).createSvg({
            elementType: 'circle',
            fill: 'rgba(0,0,0,0.9)',
            stroke: 'none',
            cx: '0',
            cy: '0',
            r: '' + this.compassSize
        });
        this.compassLineCircle = (0, _bb.BB).createSvg({
            elementType: 'circle',
            fill: 'none',
            stroke: 'rgba(255,255,255,0.75)',
            'stroke-width': '1',
            cx: '0',
            cy: '0',
            r: '' + this.compassSize * 0.9
        });
        (0, _base.css)(this.compassLineCircle, {
            transition: 'opacity 0.1s ease-in-out'
        });
        this.needleWrapper = (0, _bb.BB).createSvg({
            elementType: 'g',
            'transform-origin': '0 0'
        });
        this.compassUpperTriangle = (0, _bb.BB).createSvg({
            elementType: 'path',
            fill: '#f00',
            stroke: 'none',
            d: 'M -' + this.compassSize * 0.25 + ',0 ' + this.compassSize * 0.25 + ',0 0,-' + this.compassSize * 0.9 + ' z'
        });
        this.compassLowerTriangle = (0, _bb.BB).createSvg({
            elementType: 'path',
            fill: '#fff',
            stroke: 'none',
            d: 'M -' + this.compassSize * 0.25 + ',0 ' + this.compassSize * 0.25 + ',0 0,' + this.compassSize * 0.9 + ' z'
        });
        this.needleWrapper.append(this.compassUpperTriangle, this.compassLowerTriangle);
        this.compassInner.append(this.compassBaseCircle, this.compassLineCircle, this.needleWrapper);
        this.compass.append(this.compassInner);
        this.svgEl.append(this.compass);
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.easel.setCursor(e.button === 'left' ? 'grabbing' : 'grab');
        if (e.type === 'pointerdown' && e.button === 'left') {
            this.downPos = {
                x: e.relX,
                y: e.relY
            };
            this.downTransform = (0, _bb.BB).copyObj(this.easel.getTargetTransform());
        } else if (e.button === 'left' && this.downPos && this.downTransform) {
            const { width, height } = this.easel.getSize();
            const centerObj = {
                x: width / 2,
                y: height / 2
            };
            const startAngleRad = (0, _bb.BB).Vec2.angle(centerObj, this.downPos);
            const newAngleRad = (0, _bb.BB).Vec2.angle(centerObj, {
                x: e.relX,
                y: e.relY
            });
            const dAngleDeg = (newAngleRad - startAngleRad) / Math.PI * 180;
            let newAngleDeg = this.downTransform.angleDeg + dAngleDeg;
            if (this.easel.isKeyPressed('shift')) newAngleDeg = Math.round(newAngleDeg / 45) * 45;
            newAngleDeg = (0, _math.minimizeAngleDeg)(newAngleDeg);
            //rotate transform
            const mat = (0, _createMatrixFromTransform.createMatrixFromTransform)(this.downTransform);
            const canvasPoint = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(mat), centerObj);
            this.easel.setTransform((0, _createTransform.createTransform)(centerObj, canvasPoint, this.downTransform.scale, newAngleDeg), !this.easel.isKeyPressed('shift'));
            this.easel.requestRender();
        } else if (e.type === 'pointerup' && this.downPos) {
            this.downPos = undefined;
            this.downTransform = undefined;
        }
    }
    onUpdateTransform(transform) {
        const targetTransform = this.easel.getTargetTransform();
        this.needleWrapper.setAttribute('transform', 'rotate(' + transform.angleDeg + ')');
        this.compassLineCircle.style.opacity = targetTransform.angleDeg % 90 === 0 ? '1' : '0';
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    activate(cursorPos) {
        this.easel.setCursor('grab');
        const { width, height } = this.easel.getSize();
        this.compass.setAttribute('transform', 'translate(' + width / 2 + ', ' + height / 2 + ')');
        this.onUpdateTransform(this.easel.getTransform());
    }
    onKeyDown(keyStr, event, comboStr) {
        if ([
            'r+left',
            'r+right'
        ].includes(comboStr)) {
            if (keyStr === 'left') this.easel.setAngleDeg(-15, true);
            if (keyStr === 'right') this.easel.setAngleDeg(15, true);
        }
        if ([
            'r+up'
        ].includes(comboStr)) this.easel.setAngleDeg(0, false);
    }
    onResize(width, height) {
        this.compass.setAttribute('transform', 'translate(' + width / 2 + ', ' + height / 2 + ')');
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","../../../../bb/transform/create-transform":"kdXSP","../../../../bb/math/math":"7x9Fp","../../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iu2pb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EaselZoom", ()=>EaselZoom);
var _bb = require("../../../../bb/bb");
var _cursorZoomEwPng = require("url:/src/app/img/ui/cursor-zoom-ew.png");
var _cursorZoomEwPngDefault = parcelHelpers.interopDefault(_cursorZoomEwPng);
var _transformationMatrix = require("transformation-matrix");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _createTransform = require("../../../../bb/transform/create-transform");
class EaselZoom {
    constructor(p){
        this.easel = {};
        this.downPos = undefined;
        // ----------------------------------- public -----------------------------------
        this.tempTriggers = [
            'z'
        ];
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(e) {
        this.easel.setCursor("url('" + (0, _cursorZoomEwPngDefault.default) + "') 7 7, zoom-in");
        if (e.type === 'pointerdown' && [
            'left'
        ].includes(e.button)) {
            this.downPos = {
                x: e.relX,
                y: e.relY
            };
            this.downTransform = (0, _bb.BB).copyObj(this.easel.getTransform());
        }
        if (e.type === 'pointermove' && [
            'left'
        ].includes(e.button) && this.downPos && this.downTransform) {
            const viewportPoint = this.downPos;
            const mat = (0, _createMatrixFromTransform.createMatrixFromTransform)(this.downTransform);
            const canvasPoint = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(mat), viewportPoint);
            const dX = e.relX - this.downPos.x;
            const newScale = (0, _bb.BB).clamp(this.downTransform.scale * Math.pow(1 + 1 / 400, dX), this.easel.minScale, this.easel.maxScale);
            this.easel.setTransform((0, _createTransform.createTransform)(viewportPoint, canvasPoint, newScale, this.downTransform.angleDeg), true);
            this.easel.requestRender();
        }
        if (e.type === 'pointerup' && e.button === undefined) {
            this.downPos = undefined;
            this.downTransform = undefined;
        }
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
    }
    activate(cursorPos) {
        this.easel.setCursor("url('" + (0, _cursorZoomEwPngDefault.default) + "') 7 7, zoom-in");
    }
}

},{"../../../../bb/bb":"3zOvT","url:/src/app/img/ui/cursor-zoom-ew.png":"jXukD","transformation-matrix":"70QDB","../../../../bb/transform/create-matrix-from-transform":"6kvhU","../../../../bb/transform/create-transform":"kdXSP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jXukD":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("cursor-zoom-ew.fa152f6d.png") + "?" + Date.now();

},{}],"45gaA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Coordinates everything related to selection.
 */ parcelHelpers.export(exports, "KlAppSelect", ()=>KlAppSelect);
var _selectUi = require("../klecks/ui/tool-tabs/select-ui");
var _easelSelect = require("../klecks/ui/easel/tools/easel-select");
var _base = require("../bb/base/base");
var _selectTool = require("../klecks/select-tool/select-tool");
var _selectTransformTool = require("../klecks/select-tool/select-transform-tool");
var _transformationMatrix = require("transformation-matrix");
var _showModal = require("../klecks/ui/modals/base/showModal");
var _language = require("../language/language");
function isSelectTransformTempEntry(entry) {
    return entry.type === 'select-transform' && !!entry.data;
}
class KlAppSelect {
    isSourceLayerBackgroundTransparent() {
        const srcLayerCtx = this.getCurrentLayerCtx();
        const srcLayerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(srcLayerCtx.canvas));
        if (srcLayerIndex > 0) // not background layer
        return true;
        return this.backgroundIsTransparent;
    }
    /** reset KlCanvas layer composites **/ resetComposites() {
        const srcLayerCtx = this.getCurrentLayerCtx();
        const srcLayerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(srcLayerCtx.canvas));
        this.klCanvas.setComposite(srcLayerIndex, undefined);
        if (this.targetLayerIndex !== srcLayerIndex) this.klCanvas.setComposite(this.targetLayerIndex, undefined);
    }
    updateComposites() {
        const srcLayerCanvas = this.getCurrentLayerCtx().canvas;
        const srcLayerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(srcLayerCanvas));
        if (srcLayerIndex === this.targetLayerIndex) this.klCanvas.setComposite(srcLayerIndex, this.transformTool.createComposite(srcLayerCanvas));
        else {
            this.klCanvas.setComposite(srcLayerIndex, this.transformTool.createSourceComposite(srcLayerCanvas));
            this.klCanvas.setComposite(this.targetLayerIndex, this.transformTool.createTargetComposite(srcLayerCanvas));
        }
    }
    updateUiLayerList() {
        this.selectUi.setLayers(this.klCanvas.getLayers().map((layer)=>{
            return layer.name;
        }));
    }
    resetSelection() {
        this.selectTool.reset();
        const selection = this.selectTool.getSelection();
        this.klCanvas.setSelection(selection);
        this.selectUi.setHasSelection(!!selection);
    }
    tempHistoryReplaceTop() {
        this.tempHistory.replaceTop({
            type: 'select-transform',
            data: {
                transform: this.transformTool.getTransform(),
                doClone: this.transformTool.getDoClone(),
                targetLayerIndex: this.targetLayerIndex,
                backgroundIsTransparent: this.backgroundIsTransparent
            }
        });
    }
    // propagate from transformTool to everything else
    propagateTransformationChange() {
        const selection = this.transformTool.getTransformedSelection();
        this.easelSelect.setRenderedSelection(selection);
        this.updateComposites();
        this.onUpdateProject();
        this.tempHistoryReplaceTop();
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        // state
        this.selectMode = 'select';
        // transform state
        this.targetLayerIndex = 0;
        this.initialTransform = {
            // When you begin transforming (for undo, and comparing change).
            transform: (0, _transformationMatrix.identity)(),
            doClone: false,
            targetLayerIndex: 0,
            // Needs to be kept up to date.
            backgroundIsTransparent: false
        };
        this.backgroundIsTransparent = false;
        this.klCanvas = p.klCanvas;
        this.onUpdateProject = p.onUpdateProject;
        this.getCurrentLayerCtx = p.getCurrentLayerCtx;
        this.klHistory = p.klHistory;
        this.tempHistory = p.tempHistory;
        this.statusOverlay = p.statusOverlay;
        this.onFill = p.onFill;
        this.onErase = p.onErase;
        // keep layer list up-to-date
        this.klHistory.addListener(()=>{
            this.selectUi.setHasSelection(!!this.klCanvas.getSelection());
            if (this.selectMode === 'transform') this.updateUiLayerList();
        });
        this.selectTool = new (0, _selectTool.SelectTool)({
            klCanvas: this.klCanvas
        });
        this.transformTool = new (0, _selectTransformTool.SelectTransformTool)();
        this.easelSelect = new (0, _easelSelect.EaselSelect)({
            selectMode: this.selectMode,
            onStartSelect: (p, operation)=>this.selectTool.startSelect(p, operation),
            onGoSelect: (p)=>{
                this.selectTool.goSelect(p);
                this.easelSelect.setRenderedSelection(this.selectTool.getSelection());
            },
            onEndSelect: ()=>{
                this.selectTool.endSelect();
                const selection = this.selectTool.getSelection();
                this.easelSelect.clearRenderedSelection();
                this.klCanvas.setSelection(selection);
                this.selectUi.setHasSelection(!!selection);
            },
            onStartMoveSelect: (p)=>{
                this.selectTool.startMoveSelect(p);
            },
            onGoMoveSelect: (p)=>{
                this.selectTool.goMoveSelect(p);
                this.easelSelect.setRenderedSelection(this.selectTool.getSelection());
            },
            onEndMoveSelect: ()=>{
                this.selectTool.endMoveSelect();
                if (!this.selectTool.getDidMove()) return;
                const selection = this.selectTool.getSelection();
                this.easelSelect.clearRenderedSelection();
                this.klCanvas.setSelection(selection);
                this.selectUi.setHasSelection(!!selection);
            },
            onSelectAddPoly: (p, operation)=>{
                this.selectTool.addPoly(p, operation);
                const selection = this.selectTool.getSelection();
                this.klCanvas.setSelection(selection);
                this.selectUi.setHasSelection(!!selection);
            },
            onTranslateTransform: (d)=>{
                this.transformTool.translate(d);
                this.propagateTransformationChange();
            },
            onResetSelection: ()=>this.resetSelection()
        });
        this.selectUi = new (0, _selectUi.SelectUi)({
            onChangeMode: (mode)=>{
                this.selectMode = mode;
                if (this.selectMode === 'select') {
                    this.tempHistory.clear();
                    this.tempHistory.setIsActive(false);
                    const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(this.getCurrentLayerCtx().canvas));
                    if (this.transformTool.isTransformationChanged() || this.transformTool.getDoClone() || layerIndex !== this.targetLayerIndex) {
                        // something changed -> apply
                        if (this.transformTool.getDoClone()) this.klCanvas.transformCloneViaSelection({
                            sourceLayer: layerIndex,
                            targetLayer: this.targetLayerIndex,
                            transformation: this.transformTool.getTransform()
                        });
                        else this.klCanvas.transformViaSelection({
                            sourceLayer: layerIndex,
                            targetLayer: this.targetLayerIndex,
                            transformation: this.transformTool.getTransform(),
                            backgroundIsTransparent: this.backgroundIsTransparent
                        });
                        p.statusOverlay.out((0, _language.LANG)('select-transform-applied'), true);
                    }
                    this.klCanvas.clearSelectionSample();
                    this.klCanvas.setComposite(layerIndex, undefined);
                    this.klCanvas.setComposite(this.targetLayerIndex, undefined);
                    this.easelSelect.clearRenderedSelection(true);
                    const selection = this.klCanvas.getSelection();
                    this.selectTool.setSelection(selection);
                    this.selectUi.setHasSelection(!!selection);
                    this.onUpdateProject();
                } else {
                    // -> transform
                    this.tempHistory.setIsActive(true);
                    let selection = this.selectTool.getSelection() || [];
                    if (selection.length === 0) {
                        const width = this.klCanvas.getWidth();
                        const height = this.klCanvas.getHeight();
                        selection = [
                            [
                                [
                                    [
                                        0,
                                        0
                                    ],
                                    [
                                        width,
                                        0
                                    ],
                                    [
                                        width,
                                        height
                                    ],
                                    [
                                        0,
                                        height
                                    ],
                                    [
                                        0,
                                        0
                                    ]
                                ]
                            ]
                        ];
                    }
                    this.transformTool.setSelection(selection);
                    this.transformTool.setDoClone(false);
                    this.transformTool.setSelectionSample(this.klCanvas.getSelectionSample());
                    const currentLayerCanvas = this.getCurrentLayerCtx().canvas;
                    const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCanvas));
                    this.initialTransform.targetLayerIndex = layerIndex;
                    this.initialTransform.backgroundIsTransparent = this.backgroundIsTransparent;
                    this.targetLayerIndex = layerIndex;
                    this.transformTool.setBackgroundIsTransparent(this.isSourceLayerBackgroundTransparent());
                    this.updateComposites();
                    const transformedSelection = this.transformTool.getTransformedSelection();
                    this.easelSelect.setRenderedSelection(transformedSelection);
                    this.selectUi.setHasSelection(!!selection);
                    this.updateUiLayerList();
                    this.selectUi.setMoveToLayer(undefined);
                    this.onUpdateProject();
                }
                this.easelSelect.setMode(this.selectMode);
            },
            onChangeBooleanOperation: (operation)=>{
                this.easelSelect.setBooleanOperation(operation);
            },
            canTransform: ()=>{
                const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(this.getCurrentLayerCtx().canvas));
                const result = !!this.klCanvas.getSelectionArea(layerIndex);
                if (!result) setTimeout(()=>{
                    (0, _showModal.showModal)({
                        target: document.body,
                        message: (0, _language.LANG)('select-transform-empty'),
                        type: 'error'
                    });
                });
                return result;
            },
            select: {
                shape: this.selectTool.getShape(),
                onChangeShape: (shape)=>{
                    this.selectTool.setShape(shape);
                    this.easelSelect.setSelectShape(shape);
                },
                onReset: ()=>this.resetSelection(),
                onAll: ()=>{
                    this.selectTool.selectAll();
                    const selection = this.selectTool.getSelection();
                    this.klCanvas.setSelection(selection);
                    this.selectUi.setHasSelection(!!selection);
                },
                onInvert: ()=>{
                    this.selectTool.invertSelection();
                    const selection = this.selectTool.getSelection();
                    this.klCanvas.setSelection(selection);
                    this.selectUi.setHasSelection(!!selection);
                }
            },
            transform: {
                onFlipY: ()=>{
                    this.transformTool.flip('y');
                    this.propagateTransformationChange();
                },
                onFlipX: ()=>{
                    this.transformTool.flip('x');
                    this.propagateTransformationChange();
                },
                onRotateDeg: (deg)=>{
                    this.transformTool.rotateDeg(deg);
                    this.propagateTransformationChange();
                },
                onClone: ()=>{
                    // commit
                    this.tempHistory.clear();
                    const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(this.getCurrentLayerCtx().canvas));
                    // apply
                    // should always apply. user might want to make something more opaque.
                    if (this.transformTool.getDoClone()) this.klCanvas.transformCloneViaSelection({
                        sourceLayer: layerIndex,
                        targetLayer: this.targetLayerIndex,
                        transformation: this.transformTool.getTransform()
                    });
                    else if (this.transformTool.isTransformationChanged()) this.klCanvas.transformViaSelection({
                        sourceLayer: layerIndex,
                        targetLayer: this.targetLayerIndex,
                        transformation: this.transformTool.getTransform(),
                        backgroundIsTransparent: this.backgroundIsTransparent
                    });
                    const oldSelection = this.transformTool.getTransformedSelection();
                    // start another transform
                    const selection = this.klCanvas.getSelection() || oldSelection;
                    this.initialTransform.backgroundIsTransparent = this.backgroundIsTransparent;
                    this.transformTool.setSelection(selection);
                    this.transformTool.setDoClone(true);
                    this.transformTool.setSelectionSample(this.klCanvas.getSelectionSample());
                    this.updateComposites();
                    this.easelSelect.setRenderedSelection(this.transformTool.getTransformedSelection());
                    this.selectUi.setHasSelection(!!selection);
                    this.onUpdateProject();
                    this.statusOverlay.out((0, _language.LANG)('select-transform-clone-applied'), true);
                },
                onMoveToLayer: (index)=>{
                    this.resetComposites();
                    this.targetLayerIndex = index;
                    this.updateComposites();
                    this.onUpdateProject();
                    this.tempHistoryReplaceTop();
                },
                onChangeTransparentBackground: (isTransparent)=>{
                    this.backgroundIsTransparent = isTransparent;
                    this.transformTool.setBackgroundIsTransparent(this.isSourceLayerBackgroundTransparent());
                    this.updateComposites();
                    this.onUpdateProject();
                    this.tempHistoryReplaceTop();
                }
            },
            onErase: ()=>{
                this.onErase();
            },
            onFill: ()=>{
                this.onFill();
            }
        });
        this.klHistory.addListener(()=>{
            const selection = this.klCanvas.getSelection();
            if (this.selectMode === 'select') this.selectTool.setSelection(selection);
        });
    }
    getSelectUi() {
        return this.selectUi;
    }
    getEaselSelect() {
        return this.easelSelect;
    }
    /**
     * If transform changed something, changes are applied. -> return true
     * If no changes applied -> return false
     */ commitTransform() {
        let result = false;
        if (this.selectMode === 'transform') {
            this.selectUi.setMode('select'); // this triggers selectUi.onMode
            result = true;
        }
        return result;
    }
    /** if transforming, changes are discarded */ discardTransform() {
        if (this.selectMode === 'transform') {
            this.transformTool.reset();
            this.transformTool.setDoClone(false);
            const currentCanvas = this.getCurrentLayerCtx().canvas;
            this.targetLayerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentCanvas));
            this.selectUi.setMode('select'); // this triggers selectUi.onMode
            return true;
        }
        return false;
    }
    /**
     * feed type from KlHistoryExecutor.onExecuted.
     *
     * If regular undo step -> jump back to select tab
     * If temp undo/redo step -> update transformation state
     */ onHistory(type) {
        if (type === 'undo') // commit
        this.selectUi.setMode('select'); // this triggers selectUi.onMode
        else if (type === 'tempUndo' || type === 'tempRedo') {
            this.resetComposites();
            // recreate
            const entries = this.tempHistory.getEntries();
            const top = entries.at(-1);
            let state = {
                ...this.initialTransform,
                doClone: this.transformTool.getDoClone()
            };
            if (top && isSelectTransformTempEntry(top)) state = top.data;
            this.transformTool.setTransform(state.transform);
            this.transformTool.setDoClone(state.doClone);
            this.targetLayerIndex = state.targetLayerIndex;
            this.backgroundIsTransparent = state.backgroundIsTransparent;
            this.selectUi.setBackgroundIsTransparent(state.backgroundIsTransparent);
            this.transformTool.setBackgroundIsTransparent(this.isSourceLayerBackgroundTransparent());
            const selection = this.transformTool.getTransformedSelection();
            this.easelSelect.setRenderedSelection(selection);
            this.selectUi.setMoveToLayer(this.klCanvas.getLayerIndex(this.getCurrentLayerCtx().canvas) === state.targetLayerIndex ? undefined : state.targetLayerIndex);
            this.updateComposites();
            this.onUpdateProject();
        }
    }
    destroy() {
    // ...
    }
}

},{"../klecks/ui/tool-tabs/select-ui":"jLR0D","../klecks/ui/easel/tools/easel-select":"9KEMS","../bb/base/base":"it3mQ","../klecks/select-tool/select-tool":"63Z2a","../klecks/select-tool/select-transform-tool":"aHb2W","transformation-matrix":"70QDB","../klecks/ui/modals/base/showModal":"gy3iL","../language/language":"mcywn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jLR0D":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Select tool - tool tab
 */ parcelHelpers.export(exports, "SelectUi", ()=>SelectUi);
var _bb = require("../../../bb/bb");
var _options = require("../components/options");
var _selectModeSelectSvg = require("url:/src/app/img/ui/select-mode-select.svg");
var _selectModeSelectSvgDefault = parcelHelpers.interopDefault(_selectModeSelectSvg);
var _selectModeMoveSvg = require("url:/src/app/img/ui/select-mode-move.svg");
var _selectModeMoveSvgDefault = parcelHelpers.interopDefault(_selectModeMoveSvg);
var _c = require("../../../bb/base/c");
var _selectDefaultSvg = require("url:/src/app/img/ui/select-default.svg");
var _selectDefaultSvgDefault = parcelHelpers.interopDefault(_selectDefaultSvg);
var _selectUnionSvg = require("url:/src/app/img/ui/select-union.svg");
var _selectUnionSvgDefault = parcelHelpers.interopDefault(_selectUnionSvg);
var _selectSubtractSvg = require("url:/src/app/img/ui/select-subtract.svg");
var _selectSubtractSvgDefault = parcelHelpers.interopDefault(_selectSubtractSvg);
var _selectShapeRectSvg = require("url:/src/app/img/ui/select-shape-rect.svg");
var _selectShapeRectSvgDefault = parcelHelpers.interopDefault(_selectShapeRectSvg);
var _selectShapeEllipseSvg = require("url:/src/app/img/ui/select-shape-ellipse.svg");
var _selectShapeEllipseSvgDefault = parcelHelpers.interopDefault(_selectShapeEllipseSvg);
var _selectShapeLassoSvg = require("url:/src/app/img/ui/select-shape-lasso.svg");
var _selectShapeLassoSvgDefault = parcelHelpers.interopDefault(_selectShapeLassoSvg);
var _selectShapePolySvg = require("url:/src/app/img/ui/select-shape-poly.svg");
var _selectShapePolySvgDefault = parcelHelpers.interopDefault(_selectShapePolySvg);
var _removeLayerSvg = require("url:/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _select = require("../components/select");
var _language = require("../../../language/language");
var _checkbox = require("../components/checkbox");
var _ui = require("../../../bb/base/ui");
var _base = require("../../../bb/base/base");
class SelectUi {
    update() {
        this.selectResetBtn.style.display = this.hasSelection ? 'block' : 'none';
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.isVisible = true;
        this.hasSelection = false;
        this.onChangeMode = p.onChangeMode;
        this.modeOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'select',
                    label: (0, _c.c)('', [
                        (0, _c.c)({
                            content: "<img class='dark-invert' src='" + (0, _selectModeSelectSvgDefault.default) + "' height='20'/>" + '<span>' + (0, _language.LANG)('select-select') + '</span>',
                            css: {
                                display: 'flex',
                                gap: '5px',
                                alignItems: 'center',
                                height: '100%',
                                margin: '10px 4px',
                                justifyContent: 'center'
                            }
                        })
                    ])
                },
                {
                    id: 'transform',
                    label: (0, _c.c)('', [
                        (0, _c.c)({
                            content: "<img class='dark-invert' src='" + (0, _selectModeMoveSvgDefault.default) + "' height='20'/>" + '<span>' + (0, _language.LANG)('select-transform') + '</span>',
                            css: {
                                display: 'flex',
                                gap: '5px',
                                alignItems: 'center',
                                height: '100%',
                                margin: '10px 4px',
                                justifyContent: 'center'
                            }
                        })
                    ])
                }
            ],
            initId: 'select',
            onChange: (val)=>{
                if (val === 'select') this.operationOptions.setValue('new');
                this.onChangeMode(val);
                updateMode();
            },
            onBeforeChange: (val)=>{
                if (val === 'transform') return p.canTransform();
                return true;
            },
            optionCss: {
                flexGrow: '1',
                flexBasis: '0'
            },
            css: {
                marginBottom: '10px'
            }
        });
        // --- select ---
        const selectModeEl = (0, _bb.BB).el();
        const defaultIm = new Image();
        defaultIm.src = (0, _selectDefaultSvgDefault.default);
        defaultIm.classList.add('dark-invert');
        const unionIm = new Image();
        unionIm.src = (0, _selectUnionSvgDefault.default);
        unionIm.classList.add('dark-invert');
        const subtractIm = new Image();
        subtractIm.src = (0, _selectSubtractSvgDefault.default);
        subtractIm.classList.add('dark-invert');
        this.operationOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'new',
                    label: defaultIm,
                    title: (0, _language.LANG)('select-boolean-replace')
                },
                {
                    id: 'union',
                    label: unionIm,
                    title: (0, _language.LANG)('select-boolean-add')
                },
                {
                    id: 'difference',
                    label: subtractIm,
                    title: (0, _language.LANG)('select-boolean-subtract')
                }
            ],
            initId: 'new',
            onChange: (v)=>{
                p.onChangeBooleanOperation(v);
            },
            css: {
                marginBottom: '10px'
            }
        });
        const imStyle = {
            width: '32px',
            height: '32px'
        };
        const rectIm = new Image();
        rectIm.src = (0, _selectShapeRectSvgDefault.default);
        rectIm.classList.add('dark-invert');
        (0, _base.css)(rectIm, imStyle);
        const ellipseIm = new Image();
        ellipseIm.src = (0, _selectShapeEllipseSvgDefault.default);
        ellipseIm.classList.add('dark-invert');
        (0, _base.css)(ellipseIm, imStyle);
        const lassoIm = new Image();
        lassoIm.src = (0, _selectShapeLassoSvgDefault.default);
        lassoIm.classList.add('dark-invert');
        (0, _base.css)(lassoIm, imStyle);
        const polyIm = new Image();
        polyIm.src = (0, _selectShapePolySvgDefault.default);
        polyIm.classList.add('dark-invert');
        (0, _base.css)(polyIm, imStyle);
        const shapeOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'rect',
                    label: rectIm,
                    title: (0, _language.LANG)('shape-rect')
                },
                {
                    id: 'ellipse',
                    label: ellipseIm,
                    title: (0, _language.LANG)('shape-ellipse')
                },
                {
                    id: 'lasso',
                    label: lassoIm,
                    title: (0, _language.LANG)('select-lasso')
                },
                {
                    id: 'poly',
                    label: polyIm,
                    title: (0, _language.LANG)('select-polygon')
                }
            ],
            initId: p.select.shape,
            onChange: (val)=>{
                p.select.onChangeShape(val);
            },
            css: {
                marginBottom: '10px'
            }
        });
        selectModeEl.append(shapeOptions.getElement(), this.operationOptions.getElement());
        const actionRow = (0, _bb.BB).el({
            parent: selectModeEl,
            css: {
                display: 'flex',
                gap: '5px',
                flexWrap: 'wrap'
            }
        });
        const selectAllBtn = (0, _bb.BB).el({
            parent: actionRow,
            tagName: 'button',
            content: (0, _language.LANG)('select-all'),
            onClick: ()=>{
                p.select.onAll();
            },
            custom: {
                tabindex: '-1'
            },
            css: {
                minHeight: '30px'
            }
        });
        const selectInvertBtn = (0, _bb.BB).el({
            parent: actionRow,
            tagName: 'button',
            content: (0, _language.LANG)('select-invert'),
            onClick: ()=>{
                p.select.onInvert();
            },
            custom: {
                tabindex: '-1'
            },
            css: {
                minHeight: '30px'
            }
        });
        this.selectResetBtn = (0, _bb.BB).el({
            parent: actionRow,
            tagName: 'button',
            content: [
                (0, _ui.createImage)({
                    src: (0, _removeLayerSvgDefault.default),
                    alt: 'icon',
                    height: 20,
                    css: {
                        marginRight: '3px',
                        filter: 'invert(1)'
                    }
                }),
                (0, _language.LANG)('select-reset')
            ],
            className: 'kl-button kl-button-primary',
            css: {
                paddingRight: '8px',
                display: 'none'
            },
            onClick: ()=>{
                p.select.onReset();
            },
            custom: {
                tabindex: '-1'
            }
        });
        (0, _bb.BB).el({
            className: 'grid-hr',
            parent: selectModeEl,
            css: {
                margin: '10px 0'
            }
        });
        const actionsWrapper = (0, _bb.BB).el({
            parent: selectModeEl,
            css: {
                display: 'flex',
                gap: '5px'
            }
        });
        const eraseBtn = (0, _bb.BB).el({
            parent: actionsWrapper,
            tagName: 'button',
            content: (0, _language.LANG)('select-erase'),
            onClick: ()=>{
                p.onErase();
            },
            custom: {
                tabindex: '-1'
            }
        });
        const fillBtn = (0, _bb.BB).el({
            parent: actionsWrapper,
            tagName: 'button',
            content: (0, _language.LANG)('select-fill'),
            onClick: ()=>{
                p.onFill();
            },
            custom: {
                tabindex: '-1'
            }
        });
        // --- transform ---
        const transformModeEl = (0, _bb.BB).el();
        const transformFlipXBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: (0, _language.LANG)('filter-transform-flip') + ' X',
            className: 'kl-button',
            onClick: ()=>{
                p.transform.onFlipX();
            },
            custom: {
                tabindex: '-1'
            }
        });
        const transformFlipYBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: (0, _language.LANG)('filter-transform-flip') + ' Y',
            onClick: ()=>{
                p.transform.onFlipY();
            },
            custom: {
                tabindex: '-1'
            }
        });
        const rotateNegativeBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: "-90\xb0",
            onClick: ()=>{
                p.transform.onRotateDeg(-90);
            },
            custom: {
                tabindex: '-1'
            }
        });
        const rotatePositiveBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: "+90\xb0",
            onClick: ()=>{
                p.transform.onRotateDeg(90);
            },
            custom: {
                tabindex: '-1'
            }
        });
        this.transformDuplicateBtn = (0, _bb.BB).el({
            tagName: 'button',
            content: (0, _language.LANG)('select-transform-clone'),
            onClick: ()=>{
                p.transform.onClone();
            },
            custom: {
                tabindex: '-1'
            }
        });
        const actionsRow = (0, _bb.BB).el({
            parent: transformModeEl,
            content: [
                transformFlipXBtn,
                transformFlipYBtn,
                rotateNegativeBtn,
                rotatePositiveBtn,
                this.transformDuplicateBtn
            ],
            css: {
                display: 'flex',
                flexWrap: 'wrap',
                gap: '5px'
            }
        });
        this.moveToLayerSelect = new (0, _select.Select)({
            optionArr: [
                [
                    '1',
                    'Layer 2'
                ],
                [
                    '0',
                    'Layer 1'
                ]
            ],
            onChange: (val)=>{
                p.transform.onMoveToLayer(+val);
            },
            name: 'move-to-layer',
            css: {
                width: '100%'
            }
        });
        transformModeEl.append((0, _c.c)(',flex,items-center,gap-5,mt-10,flexWrap', [
            (0, _language.LANG)('select-transform-move-to-layer'),
            this.moveToLayerSelect.getElement()
        ]));
        this.transparentBackgroundToggle = new (0, _checkbox.Checkbox)({
            label: (0, _language.LANG)('brush-eraser-transparent-bg'),
            callback: (b)=>{
                p.transform.onChangeTransparentBackground(b);
            },
            name: 'enable-transparent-background'
        });
        (0, _base.css)(this.transparentBackgroundToggle.getElement(), {
            marginTop: '10px',
            display: 'inline-block'
        });
        transformModeEl.append(this.transparentBackgroundToggle.getElement());
        const updateMode = ()=>{
            if (this.modeOptions.getValue() === 'select') {
                this.rootEl.append(selectModeEl);
                transformModeEl.remove();
            } else {
                selectModeEl.remove();
                this.rootEl.append(transformModeEl);
            }
        };
        this.rootEl = (0, _bb.BB).el({
            content: [
                this.modeOptions.getElement()
            ],
            css: {
                margin: '10px'
            }
        });
        updateMode();
    }
    setIsVisible(isVisible) {
        this.isVisible = isVisible;
        this.rootEl.style.display = this.isVisible ? 'block' : 'none';
        if (this.isVisible) this.operationOptions.setValue('new');
    }
    setMode(mode) {
        this.modeOptions.setValue(mode);
    }
    setLayers(layers) {
        this.moveToLayerSelect.setOptionArr(layers.map((layer, index)=>{
            return [
                '' + index,
                layer
            ];
        }).reverse());
    }
    setMoveToLayer(targetIndex) {
        this.moveToLayerSelect.setValue(targetIndex === undefined ? undefined : '' + targetIndex);
    }
    setHasSelection(b) {
        this.hasSelection = b;
        this.update();
    }
    setBackgroundIsTransparent(b) {
        this.transparentBackgroundToggle.setValue(b);
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
    // ...
    }
}

},{"../../../bb/bb":"3zOvT","../components/options":"7kiPU","url:/src/app/img/ui/select-mode-select.svg":"lsvYV","url:/src/app/img/ui/select-mode-move.svg":"9Vswo","../../../bb/base/c":"3KmDH","url:/src/app/img/ui/select-default.svg":"gyqHi","url:/src/app/img/ui/select-union.svg":"cxwbP","url:/src/app/img/ui/select-subtract.svg":"2DlZ6","url:/src/app/img/ui/select-shape-rect.svg":"hm5gk","url:/src/app/img/ui/select-shape-ellipse.svg":"75A5D","url:/src/app/img/ui/select-shape-lasso.svg":"8SyTB","url:/src/app/img/ui/select-shape-poly.svg":"cz1MC","url:/src/app/img/ui/remove-layer.svg":"fV9n3","../components/select":"iuUFh","../../../language/language":"mcywn","../components/checkbox":"9bXL6","../../../bb/base/ui":"5dJJW","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lsvYV":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-mode-select.b07e2160.svg") + "?" + Date.now();

},{}],"9Vswo":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-mode-move.240e706d.svg") + "?" + Date.now();

},{}],"gyqHi":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-default.5511e197.svg") + "?" + Date.now();

},{}],"cxwbP":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-union.9af88fc2.svg") + "?" + Date.now();

},{}],"2DlZ6":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-subtract.1b053c9e.svg") + "?" + Date.now();

},{}],"hm5gk":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-shape-rect.69fe8734.svg") + "?" + Date.now();

},{}],"75A5D":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-shape-ellipse.f0d30be1.svg") + "?" + Date.now();

},{}],"8SyTB":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-shape-lasso.a10ce7c2.svg") + "?" + Date.now();

},{}],"cz1MC":[function(require,module,exports,__globalThis) {
module.exports = module.bundle.resolve("select-shape-poly.cc6d5150.svg") + "?" + Date.now();

},{}],"9KEMS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * for select tool and transform tool
 */ parcelHelpers.export(exports, "EaselSelect", ()=>EaselSelect);
var _bb = require("../../../../bb/bb");
var _createMatrixFromTransform = require("../../../../bb/transform/create-matrix-from-transform");
var _transformationMatrix = require("transformation-matrix");
var _math = require("../../../../bb/math/math");
var _getSelectionPath2D = require("../../../../bb/multi-polygon/get-selection-path-2d");
var _eventChain = require("../../../../bb/input/event-chain/event-chain");
var _doubleTapper = require("../../../../bb/input/event-chain/double-tapper");
var _cornerPanning = require("../corner-panning");
const modeToCursor = {
    select: 'default',
    transform: 'move'
};
const operationToCursor = {
    new: 'default',
    union: 'copy',
    difference: 'alias'
};
class EaselSelect {
    viewportToCanvas(p) {
        const matrix = (0, _transformationMatrix.inverse)((0, _createMatrixFromTransform.createMatrixFromTransform)(this.easel.getTransform()));
        return (0, _transformationMatrix.applyToPoint)(matrix, p);
    }
    updateSelectionPath() {
        this.selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(this.canvasSelection);
    }
    resetPolyShape() {
        if (this.polyShape.length === 0) return false;
        this.polyShape = [];
        this.doubleTapPointerTypes = [
            'touch'
        ];
        this.easel.updateDoubleTapPointerTypes();
        this.easel.requestRender(); // because polyShape might have changed
        return true;
    }
    /** boolean operation if you also consider keys */ getEffectiveBooleanOperation() {
        const isSubtract = this.defaultBooleanOperation === 'new' ? this.easel.keyListener.isPressed('alt') : this.defaultBooleanOperation === 'difference';
        const isAdd = this.defaultBooleanOperation === 'new' ? this.easel.keyListener.isPressed('shift') : this.defaultBooleanOperation === 'union';
        if (isSubtract) return 'difference';
        if (isAdd) return 'union';
        return 'new';
    }
    getDoMoveSelection(effectiveOperation, cursorCanvasPos) {
        const isOverSelection = this.polyShape.length < 2 && this.selectionPath && this.tempCtx.isPointInPath(this.selectionPath, cursorCanvasPos.x, cursorCanvasPos.y);
        return effectiveOperation === 'new' && isOverSelection;
    }
    // can be repeatedly called with the same event
    selectOnPointer(event) {
        const effectiveOperation = this.getEffectiveBooleanOperation();
        const wasDragging = this.isDragging;
        const cursorCanvasPos = this.viewportToCanvas({
            x: event.relX,
            y: event.relY
        });
        const doMove = this.getDoMoveSelection(effectiveOperation, cursorCanvasPos);
        if (event.type === 'pointerdown') {
            this.isDragging = true;
            if (doMove) this.selectSelectMode = 'move';
            else this.selectSelectMode = 'select';
        }
        if (event.type === 'pointerup') this.isDragging = false;
        if (this.selectSelectMode === 'move') {
            if (event.type === 'pointerdown' && event.button === 'left') {
                this.didSelectionMove = false;
                this.onStartMoveSelect(cursorCanvasPos);
            }
            if (event.type === 'pointermove' && event.button === 'left') {
                this.didSelectionMove = true;
                this.onGoMoveSelect(cursorCanvasPos);
            }
            if (event.type === 'pointerup') {
                this.onEndMoveSelect();
                if (!this.didSelectionMove) this.onResetSelection();
            }
        } else // select
        if (this.selectShape === 'poly') {
            if (event.type === 'pointermove') {
                if (this.polyShape[this.polyShape.length - 1]?.temp) this.polyShape.pop();
                this.polyShape.push({
                    ...cursorCanvasPos,
                    temp: true
                });
                this.easel.requestRender();
            }
            if (event.type === 'pointerup' && wasDragging) {
                if (this.polyShape.length < 2) this.appliedBooleanOperation = effectiveOperation;
                this.doubleTapPointerTypes = [];
                this.easel.updateDoubleTapPointerTypes();
                if (this.polyShape[this.polyShape.length - 1]?.temp) this.polyShape.pop();
                this.polyShape.push(cursorCanvasPos);
                const first = this.polyShape[0];
                const last = this.polyShape[this.polyShape.length - 1];
                if (this.polyShape.length > 2 && (0, _bb.BB).dist(first.x, first.y, last.x, last.y) * this.viewportTransform.scale < 4) {
                    this.polyShape.pop();
                    this.polyShape.push({
                        ...this.polyShape[0]
                    });
                    const shape = this.polyShape;
                    this.polyShape = [];
                    this.onSelectAddPoly(shape, this.appliedBooleanOperation);
                    this.appliedBooleanOperation = undefined;
                }
            }
        } else {
            if (event.type === 'pointerdown' && event.button === 'left') {
                this.appliedBooleanOperation = effectiveOperation;
                this.onStartSelect(cursorCanvasPos, this.appliedBooleanOperation);
            }
            if (event.type === 'pointermove' && event.button === 'left' && this.isDragging) this.onGoSelect(cursorCanvasPos);
            if (event.type === 'pointerup' && wasDragging) {
                this.onEndSelect();
                this.appliedBooleanOperation = undefined;
            }
        }
        if (!event.button) {
            if (doMove) this.selectSelectMode = 'move';
            else this.selectSelectMode = 'select';
        }
        if (this.selectSelectMode === 'move') this.easel.setCursor('move');
        else this.easel.setCursor(operationToCursor[this.appliedBooleanOperation ?? effectiveOperation]);
    }
    // can be repeatedly called with the same event
    transformOnPointer(event) {
        this.easel.setCursor('move');
        const transform = this.easel.getTransform();
        const matrix = (0, _transformationMatrix.inverse)((0, _createMatrixFromTransform.createMatrixFromTransform)(transform));
        if (event.type === 'pointerdown' && event.button === 'left') {
            this.transformPointerStart = (0, _transformationMatrix.applyToPoint)(matrix, {
                x: event.relX,
                y: event.relY
            });
            this.transformPreviousPointer = {
                ...this.transformPointerStart
            };
            this.updateSelectionPath();
            this.isDragging = true;
        }
        if (event.type === 'pointermove' && event.button === 'left') {
            const canvasPointer = (0, _transformationMatrix.applyToPoint)(matrix, {
                x: event.relX,
                y: event.relY
            });
            this.updateSelectionPath();
            const delta = {
                x: Math.round(canvasPointer.x - this.transformPreviousPointer.x),
                y: Math.round(canvasPointer.y - this.transformPreviousPointer.y)
            };
            if (delta.x === 0 && delta.y === 0) return;
            this.onTranslateTransform(delta);
            this.transformPreviousPointer = (0, _bb.BB).Vec2.add(this.transformPreviousPointer, delta);
        }
        if (event.type === 'pointerup' && event.button === undefined && this.isDragging) {
            this.updateSelectionPath();
            this.isDragging = false;
        }
    }
    onPointerChainOut(event) {
        this.cornerPanning.onPointer(event);
        if (this.mode === 'select') this.selectOnPointer(event);
        else this.transformOnPointer(event);
    }
    constructor(p){
        this.easel = {};
        this.viewportTransform = {};
        this.tempCtx = (0, _bb.BB).ctx((0, _bb.BB).canvas(1, 1)) // used for isPointInPath()
        ;
        // state
        this.canvasSelection = [];
        this.selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)([]);
        this.mode = 'select';
        this.isDragging = false;
        // select-mode state
        this.selectSelectMode = 'select';
        this.didSelectionMove = false;
        this.defaultBooleanOperation = 'new' // set by the UI
        ;
        this.selectShape = 'rect';
        this.polyShape = [];
        // transform-mode state
        this.transformPointerStart = {
            x: 0,
            y: 0
        } // initial position, canvas coordinate
        ;
        this.transformPreviousPointer = {
            x: 0,
            y: 0
        };
        // ----------------------------------- public -----------------------------------
        this.doubleTapPointerTypes = [
            'touch'
        ];
        this.blockTrigger = 'alt';
        this.onTranslateTransform = p.onTranslateTransform;
        this.mode = p.selectMode;
        this.onStartSelect = p.onStartSelect;
        this.onGoSelect = p.onGoSelect;
        this.onEndSelect = p.onEndSelect;
        this.onStartMoveSelect = p.onStartMoveSelect;
        this.onGoMoveSelect = p.onGoMoveSelect;
        this.onEndMoveSelect = p.onEndMoveSelect;
        this.onSelectAddPoly = p.onSelectAddPoly;
        this.onResetSelection = p.onResetSelection;
        this.cornerPanning = new (0, _cornerPanning.CornerPanning)({
            getEaselSize: ()=>this.easel.getSize(),
            getTransform: ()=>this.easel.getTargetTransform(),
            setTransform: (transform)=>this.easel.setTransform(transform, true),
            testCanPan: (buttonIsPressed)=>{
                return (buttonIsPressed || this.polyShape.length > 1) && !(this.selectShape === 'lasso' && this.selectSelectMode === 'select');
            },
            onRepeatEvent: (e)=>{
                if (this.mode === 'select') this.selectOnPointer(e);
                else this.transformOnPointer(e);
            }
        });
        this.pointerChain = new (0, _eventChain.EventChain)({
            chainArr: [
                new (0, _doubleTapper.DoubleTapper)({
                    onDoubleTap: (e)=>{
                        if (this.polyShape.length < 3) return;
                        const shape = this.polyShape.map((item)=>({
                                x: item.x,
                                y: item.y
                            }));
                        this.resetPolyShape();
                        if (shape.length > 1) {
                            shape.push({
                                ...shape[0]
                            });
                            p.onSelectAddPoly(shape, this.appliedBooleanOperation);
                        }
                    },
                    isInstant: true
                })
            ]
        });
        this.svgEl = (0, _bb.BB).createSvg({
            elementType: 'g'
        });
    }
    getSvgElement() {
        return this.svgEl;
    }
    onPointer(event) {
        this.onPointerChainOut(event);
        this.pointerChain.chainIn(event);
    }
    setEaselInterface(easelInterface) {
        this.easel = easelInterface;
        this.viewportTransform = this.easel.getTransform();
    }
    setMode(mode) {
        this.mode = mode;
        this.resetPolyShape();
    }
    activate(cursorPos, poppedTemp) {
        this.easel.setCursor(modeToCursor[this.mode]);
        this.isDragging = false;
        this.onUpdateTransform(this.easel.getTransform());
        if (!poppedTemp) this.resetPolyShape();
    }
    onUpdateTransform(transform) {
        this.viewportTransform = transform;
        this.updateSelectionPath();
    }
    onUpdateSelection(selection) {
        this.canvasSelection = selection || [];
        this.updateSelectionPath();
    }
    setRenderedSelection(selection) {
        this.easel.setRenderedSelection(selection);
    }
    clearRenderedSelection(isImmediate) {
        this.easel.clearRenderedSelection(isImmediate);
    }
    setBooleanOperation(operation) {
        this.defaultBooleanOperation = operation;
    }
    setSelectShape(shape) {
        this.resetPolyShape();
        this.selectShape = shape;
    }
    getIsLocked() {
        return this.isDragging;
    }
    renderAfterViewport(ctx, transform) {
        if (this.polyShape.length < 2) return;
        ctx.save();
        ctx.globalCompositeOperation = 'difference';
        ctx.beginPath();
        const shape = this.polyShape;
        ctx.moveTo(shape[0].x, shape[0].y);
        for(let i = 1; i < shape.length; i++)ctx.lineTo(shape[i].x, shape[i].y);
        ctx.lineWidth = 1 / transform.scaleX;
        ctx.strokeStyle = 'white';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        ctx.restore();
    }
    onKeyDown(keyStr, e) {
        if (keyStr === 'esc') {
            if (this.resetPolyShape()) e.preventDefault();
        }
    }
    onClickOutside() {
        this.resetPolyShape();
    }
    onBlur() {
        this.resetPolyShape();
    }
    onArrowKeys(direction) {
        if (this.mode === 'select') return false;
        let movement = {
            x: 0,
            y: 0
        };
        if (direction === 'left') movement = {
            x: -1,
            y: 0
        };
        if (direction === 'right') movement = {
            x: 1,
            y: 0
        };
        if (direction === 'up') movement = {
            x: 0,
            y: -1
        };
        if (direction === 'down') movement = {
            x: 0,
            y: 1
        };
        // accommodate easel rotation
        const rotatedDirection = (0, _math.rotate)(movement.x, movement.y, -(0, _math.snapAngleDeg)(this.easel.getTransform().angleDeg, 90, 90));
        this.onTranslateTransform(rotatedDirection);
        return true;
    }
}

},{"../../../../bb/bb":"3zOvT","../../../../bb/transform/create-matrix-from-transform":"6kvhU","transformation-matrix":"70QDB","../../../../bb/math/math":"7x9Fp","../../../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","../../../../bb/input/event-chain/event-chain":"eo2AB","../../../../bb/input/event-chain/double-tapper":"fPbPb","../corner-panning":"c3xwQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"63Z2a":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "POLYGON_PRECISION", ()=>POLYGON_PRECISION);
parcelHelpers.export(exports, "limitPrecision", ()=>limitPrecision);
parcelHelpers.export(exports, "limitPolygonPrecision", ()=>limitPolygonPrecision);
parcelHelpers.export(exports, "SelectTool", ()=>SelectTool);
var _translateMultiPolygon = require("../../bb/multi-polygon/translate-multi-polygon");
var _getEllipsePath = require("../../bb/multi-polygon/get-ellipse-path");
var _bb = require("../../bb/bb");
var _applyPolygonClipping = require("../../bb/multi-polygon/apply-polygon-clipping");
const POLYGON_PRECISION = 2;
function limitPrecision(num) {
    return parseFloat(num.toFixed(POLYGON_PRECISION));
}
function limitPolygonPrecision(poly) {
    return poly.map((ring)=>ring.map(([x, y])=>[
                limitPrecision(x),
                limitPrecision(y)
            ]));
}
class SelectTool {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.shape = 'rect';
        this.selectOperation = 'new';
        this.selectDragInputs = [];
        this.didMove = false // was selection moved
        ;
        this.klCanvas = p.klCanvas;
    }
    reset() {
        this.selection = undefined;
    }
    combineSelection(polygon) {
        let result = this.selection ?? [];
        if (this.selectOperation === 'new') result = [
            polygon
        ];
        else {
            if (this.selection && this.selection.length > 0) {
                const operation = this.selectOperation === 'difference' ? 'difference' : 'union';
                result = (0, _applyPolygonClipping.applyPolygonClipping)(operation, this.selection, polygon);
            } else if (this.selectOperation === 'union') result = [
                polygon
            ];
        }
        return result;
    }
    /** current state of selection */ getSelection() {
        // combine selections
        let selection = this.selection || [];
        if (this.selectDragInputs.length > 1) {
            // currently inputting
            const operation = this.selectOperation === 'difference' ? 'difference' : 'union';
            if (this.shape === 'rect') {
                const first = this.selectDragInputs[0];
                const last = this.selectDragInputs[this.selectDragInputs.length - 1];
                // floor and ceil already limit precision
                const minX = Math.floor(Math.min(first.x, last.x));
                const minY = Math.floor(Math.min(first.y, last.y));
                const maxX = Math.ceil(Math.max(first.x, last.x));
                const maxY = Math.ceil(Math.max(first.y, last.y));
                selection = this.combineSelection([
                    [
                        [
                            minX,
                            minY
                        ],
                        [
                            maxX,
                            minY
                        ],
                        [
                            maxX,
                            maxY
                        ],
                        [
                            minX,
                            maxY
                        ]
                    ]
                ]);
            } else if (this.shape === 'ellipse') {
                const first = this.selectDragInputs[0];
                const last = this.selectDragInputs[this.selectDragInputs.length - 1];
                const cx = (first.x + last.x) / 2;
                const cy = (first.y + last.y) / 2;
                const rx = Math.abs(last.x - first.x) / 2;
                const ry = Math.abs(last.y - first.y) / 2;
                selection = this.combineSelection(limitPolygonPrecision((0, _getEllipsePath.getEllipsePath)(cx, cy, rx, ry, 50)));
            } else if (this.shape === 'lasso') selection = this.combineSelection([
                this.selectDragInputs.map((p)=>[
                        limitPrecision(p.x),
                        limitPrecision(p.y)
                    ])
            ]);
        }
        return selection.length === 0 ? undefined : selection;
    }
    // --- selecting ---
    startSelect(pos, operation) {
        this.selectOperation = operation;
        if (this.selectOperation === 'new') this.reset();
        this.selectDragInputs = [
            pos
        ];
    }
    goSelect(pos) {
        this.selectDragInputs.push({
            x: pos.x,
            y: pos.y
        });
    }
    endSelect() {
        if (this.selectDragInputs.length > 1) // commit
        this.selection = this.getSelection();
        else this.reset();
        this.selectDragInputs = [];
    }
    addPoly(polygon, operation) {
        this.selectOperation = operation;
        this.selection = this.combineSelection([
            polygon.map((p)=>[
                    limitPrecision(p.x),
                    limitPrecision(p.y)
                ])
        ]);
    }
    // --- moving selection ---
    startMoveSelect(pos) {
        this.moveLastPos = pos;
        this.didMove = false;
    }
    goMoveSelect(pos) {
        if (!this.moveLastPos) return;
        this.didMove = true;
        const dx = Math.round(pos.x - this.moveLastPos.x);
        const dy = Math.round(pos.y - this.moveLastPos.y);
        if (this.selection) this.selection = (0, _translateMultiPolygon.translateMultiPolygon)(this.selection, dx, dy);
        this.moveLastPos = {
            x: this.moveLastPos.x + dx,
            y: this.moveLastPos.y + dy
        };
    }
    endMoveSelect() {
        this.moveLastPos = undefined;
    }
    getDidMove() {
        return this.didMove;
    }
    selectAll() {
        this.reset();
        const width = this.klCanvas.getWidth();
        const height = this.klCanvas.getHeight();
        this.selection = [
            [
                [
                    [
                        0,
                        0
                    ],
                    [
                        width,
                        0
                    ],
                    [
                        width,
                        height
                    ],
                    [
                        0,
                        height
                    ],
                    [
                        0,
                        0
                    ]
                ]
            ]
        ];
    }
    invertSelection() {
        const selection = this.selection ?? [];
        const width = this.klCanvas.getWidth();
        const height = this.klCanvas.getHeight();
        this.selection = (0, _applyPolygonClipping.applyPolygonClipping)('difference', [
            [
                [
                    0,
                    0
                ],
                [
                    width,
                    0
                ],
                [
                    width,
                    height
                ],
                [
                    0,
                    height
                ]
            ]
        ], selection);
    }
    setShape(shape) {
        this.shape = shape;
    }
    getShape() {
        return this.shape;
    }
    setSelection(selection) {
        this.selection = selection ? (0, _bb.BB).copyObj(selection).map(limitPolygonPrecision) : undefined;
    }
}

},{"../../bb/multi-polygon/translate-multi-polygon":"ciUlD","../../bb/multi-polygon/get-ellipse-path":"749FF","../../bb/bb":"3zOvT","../../bb/multi-polygon/apply-polygon-clipping":"iHG5e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"749FF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEllipsePath", ()=>getEllipsePath);
function getEllipsePath(cx, cy, rx, ry, steps) {
    const result = [];
    const d = 2 * Math.PI / steps;
    for(let i = 0; i < 2 * Math.PI; i += d)result.push([
        Math.cos(i) * rx + cx,
        Math.sin(i) * ry + cy
    ]);
    return [
        result
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aHb2W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * to facilitate KlCanvas.transformViaSelection and provide a preview (composite)
 */ parcelHelpers.export(exports, "SelectTransformTool", ()=>SelectTransformTool);
var _getSelectionPath2D = require("../../bb/multi-polygon/get-selection-path-2d");
var _transformationMatrix = require("transformation-matrix");
var _transformMultiPolygon = require("../../bb/multi-polygon/transform-multi-polygon");
var _getMultiPolygonBounds = require("../../bb/multi-polygon/get-multi-polygon-bounds");
var _bb = require("../../bb/bb");
var _freeTransformUtils = require("../ui/components/free-transform-utils");
var _math = require("../../bb/math/math");
var _matrixToTuple = require("../../bb/math/matrix-to-tuple");
function matrixToFreeTransform(transform, bounds) {
    const centerBefore = {
        x: bounds.x1 + (bounds.x2 - bounds.x1) / 2,
        y: bounds.y1 + (bounds.y2 - bounds.y1) / 2
    };
    const centerAfter = (0, _transformationMatrix.applyToPoint)(transform, centerBefore);
    const decomposed = (0, _transformationMatrix.decomposeTSR)(transform);
    const angleDeg = (0, _bb.BB).round(decomposed.rotation.angle / Math.PI * 180, 7);
    const tlBefore = {
        x: bounds.x1,
        y: bounds.y1
    };
    const trBefore = {
        x: bounds.x2,
        y: bounds.y1
    };
    const blBefore = {
        x: bounds.x1,
        y: bounds.y2
    };
    const [tlAfter, trAfter, blAfter] = [
        tlBefore,
        trBefore,
        blBefore
    ].map((p)=>{
        return (0, _transformationMatrix.applyToPoint)(transform, p);
    });
    let width = (0, _bb.BB).Vec2.dist(trAfter, tlAfter);
    let height = (0, _bb.BB).Vec2.dist(blAfter, tlAfter);
    if (decomposed.scale.sx < 0) width = -width;
    if (decomposed.scale.sy < 0) height = -height;
    return {
        ...centerAfter,
        width,
        height,
        angleDeg
    };
}
function freeTransformToMatrix(transform, bounds) {
    const centerBefore = {
        x: bounds.x1 + (bounds.x2 - bounds.x1) / 2,
        y: bounds.y1 + (bounds.y2 - bounds.y1) / 2
    };
    const widthBefore = bounds.x2 - bounds.x1;
    const heightBefore = bounds.y2 - bounds.y1;
    const scaleX = transform.width / widthBefore;
    const scaleY = transform.height / heightBefore;
    const angleRad = transform.angleDeg / 180 * Math.PI;
    return (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(transform.x, transform.y), (0, _transformationMatrix.rotate)(angleRad), (0, _transformationMatrix.scale)(scaleX, scaleY), (0, _transformationMatrix.translate)(-centerBefore.x, -centerBefore.y));
}
class SelectTransformTool {
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.selection = [];
        this.selectionBounds = {};
        this.transform = {};
        this.doClone = false // true -> draw selected area twice (original position, and transformed position)
        ;
        this.backgroundIsTransparent = false;
    }
    setBackgroundIsTransparent(isTransparent) {
        this.backgroundIsTransparent = isTransparent;
    }
    setSelection(selection) {
        this.selection = selection;
        this.selectionBounds = (0, _math.integerBounds)((0, _getMultiPolygonBounds.getMultiPolyBounds)(this.selection)); // floor & ceil to prevent blurriness
        this.transform = (0, _transformationMatrix.identity)();
    }
    isTransformationChanged() {
        const identityMatrix = (0, _transformationMatrix.identity)();
        const keys = Object.keys(identityMatrix);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (identityMatrix[key] !== this.transform[key]) return true;
        }
        return false;
    }
    reset() {
        this.transform = (0, _transformationMatrix.identity)();
        this.selection = [];
        this.selectionBounds = {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0
        };
    }
    // ---- transform ----
    translate(d) {
        this.transform = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(d.x, d.y), this.transform);
    }
    flip(axis) {
        const center = {
            x: (this.selectionBounds.x1 + this.selectionBounds.x2) / 2,
            y: (this.selectionBounds.y1 + this.selectionBounds.y2) / 2
        };
        const transformedCenter = (0, _transformationMatrix.applyToPoint)(this.transform, center);
        this.transform = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(transformedCenter.x, transformedCenter.y), (0, _transformationMatrix.scale)(axis === 'x' ? -1 : 1, axis === 'y' ? -1 : 1), (0, _transformationMatrix.translate)(-transformedCenter.x, -transformedCenter.y), this.transform);
    }
    rotateDeg(deg) {
        const center = {
            x: (this.selectionBounds.x1 + this.selectionBounds.x2) / 2,
            y: (this.selectionBounds.y1 + this.selectionBounds.y2) / 2
        };
        const transformedCenter = (0, _transformationMatrix.applyToPoint)(this.transform, center);
        this.transform = (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(transformedCenter.x, transformedCenter.y), (0, _transformationMatrix.rotate)(deg / 180 * Math.PI), (0, _transformationMatrix.translate)(-transformedCenter.x, -transformedCenter.y), this.transform);
    }
    // --------
    setDoClone(b) {
        this.doClone = b;
    }
    getDoClone() {
        return this.doClone;
    }
    getTransform() {
        const freeTransform = matrixToFreeTransform(this.transform, this.selectionBounds);
        (0, _freeTransformUtils.snapToPixel)(freeTransform);
        return freeTransformToMatrix(freeTransform, this.selectionBounds);
    }
    setTransform(transform) {
        this.transform = transform;
    }
    getTransformedSelection() {
        return (0, _transformMultiPolygon.transformMultiPolygon)(this.selection, this.getTransform());
    }
    setSelectionSample(selectionSample) {
        this.selectionSample = selectionSample;
    }
    /**
     * creates composite for KlCanvas layer
     * if source === target
     */ createComposite(originalSrcCanvas) {
        const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(this.selection);
        const transform = this.getTransform();
        return {
            draw: (ctx)=>{
                ctx.save();
                if (this.selectionSample && this.doClone) {
                    if (this.selectionSample.image) {
                        ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(transform));
                        ctx.clip(selectionPath);
                        const canvasTransform = (0, _transformationMatrix.compose)(transform, this.selectionSample.transformation);
                        ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(canvasTransform));
                        ctx.drawImage(this.selectionSample.image, 0, 0);
                    }
                } else {
                    //draw original with inverted selection before transformation
                    if (!this.doClone) {
                        ctx.save();
                        ctx.clip(selectionPath);
                        if (this.backgroundIsTransparent) ctx.clearRect(0, 0, originalSrcCanvas.width, originalSrcCanvas.height);
                        else {
                            ctx.globalCompositeOperation = 'source-in';
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(0, 0, originalSrcCanvas.width, originalSrcCanvas.height);
                        }
                        ctx.restore();
                    }
                    ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(transform));
                    ctx.clip(selectionPath);
                    ctx.drawImage(originalSrcCanvas, 0, 0);
                }
                ctx.restore();
            }
        };
    }
    /**
     * creates composite for source KlCanvas layer
     * if source != target
     */ createSourceComposite(originalSrcCanvas) {
        const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(this.selection);
        if (this.doClone) return undefined;
        return {
            draw: (ctx)=>{
                //draw original with inverted selection before transformation
                ctx.save();
                ctx.clip(selectionPath);
                if (this.backgroundIsTransparent) ctx.clearRect(0, 0, originalSrcCanvas.width, originalSrcCanvas.height);
                else {
                    ctx.globalCompositeOperation = 'source-in';
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, originalSrcCanvas.width, originalSrcCanvas.height);
                }
                ctx.restore();
            }
        };
    }
    /**
     * creates composite for target KlCanvas layer
     * if source != target
     */ createTargetComposite(originalSrcCanvas) {
        const selectionPath = (0, _getSelectionPath2D.getSelectionPath2d)(this.selection);
        const transform = this.getTransform();
        return {
            draw: (ctx)=>{
                ctx.save();
                if (this.selectionSample && this.doClone) {
                    if (this.selectionSample.image) {
                        ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(transform));
                        ctx.clip(selectionPath);
                        const canvasTransform = (0, _transformationMatrix.compose)(transform, this.selectionSample.transformation);
                        ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(canvasTransform));
                        ctx.drawImage(this.selectionSample.image, 0, 0);
                    }
                } else {
                    ctx.setTransform(...(0, _matrixToTuple.matrixToTuple)(transform));
                    ctx.clip(selectionPath);
                    ctx.drawImage(originalSrcCanvas, 0, 0);
                }
                ctx.restore();
            }
        };
    }
}

},{"../../bb/multi-polygon/get-selection-path-2d":"hDCCZ","transformation-matrix":"70QDB","../../bb/multi-polygon/transform-multi-polygon":"54b2I","../../bb/multi-polygon/get-multi-polygon-bounds":"6LgBa","../../bb/bb":"3zOvT","../ui/components/free-transform-utils":"9xZqc","../../bb/math/math":"7x9Fp","../../bb/math/matrix-to-tuple":"8BP1P","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gAbL2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * History of temporary actions that will either be committed (to KlHistory) or discarded.
 * E.g. transform via selection
 */ parcelHelpers.export(exports, "KlTempHistory", ()=>KlTempHistory);
class KlTempHistory {
    emit(type) {
        this.listeners.forEach((item)=>item(type));
    }
    // ----------------------------------- public -----------------------------------
    constructor(){
        this.entries = [];
        this.currentIndex = -1;
        this.listeners = [];
        this.isActive = false;
    }
    push(entry) {
        if (this.currentIndex < this.entries.length - 1) this.entries.splice(this.currentIndex + 1);
        this.entries.push(entry);
        this.currentIndex = this.entries.length - 1;
        setTimeout(()=>this.emit('push'));
    }
    replaceTop(newEntry) {
        this.entries.splice(this.currentIndex);
        this.entries.push(newEntry);
        this.currentIndex = this.entries.length - 1;
        setTimeout(()=>this.emit('push'));
    }
    canDecreaseIndex() {
        return this.currentIndex > -1;
    }
    canIncreaseIndex() {
        return this.currentIndex < this.entries.length - 1;
    }
    /** aka undo */ decreaseIndex() {
        if (!this.canDecreaseIndex()) return;
        this.currentIndex--;
        setTimeout(()=>this.emit('decrease'));
    }
    /** aka redo */ increaseIndex() {
        if (!this.canIncreaseIndex()) return;
        this.currentIndex++;
        setTimeout(()=>this.emit('increase'));
    }
    /**
     * all entries up to currentIndex
     */ getEntries() {
        return this.entries.slice(0, this.currentIndex + 1);
    }
    clear() {
        this.entries = [];
        this.currentIndex = -1;
        setTimeout(()=>this.emit('clear'));
    }
    /**
     * emits on push, decrease, increase, clear, or toggle active
     */ addListener(listener) {
        if (this.listeners.includes(listener)) return;
        this.listeners.push(listener);
    }
    removeListener(listener) {
        this.listeners.map((item, index)=>{
            if (item === listener) this.listeners.splice(index, 1);
        });
    }
    setIsActive(isActive) {
        if (this.isActive === isActive) return;
        this.isActive = isActive;
        this.emit('active');
    }
    getIsActive() {
        return this.isActive;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7hFUN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Users can get stuck when pinch-zooming in (via double tapping or pinching).
 * This overlay helps users zoom out again. It automatically shows up and hides
 * itself.
 */ parcelHelpers.export(exports, "PinchZoomWatcher", ()=>PinchZoomWatcher);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
class PinchZoomWatcher {
    // -------------------- public ----------------------
    constructor(){
        if (!('visualViewport' in window) || visualViewport === null) return;
        const viewport = visualViewport;
        let isDismissed = false;
        const rootEl = (0, _bb.BB).el({
            content: (0, _language.LANG)('browser-zoom-help'),
            className: 'kl-pinch-overlay',
            css: {
                position: 'fixed',
                pointerEvents: 'none',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                zIndex: '100',
                flexDirection: 'column',
                gap: '10px',
                padding: '10px',
                backdropFilter: 'blur(3px)'
            }
        });
        (0, _bb.BB).el({
            parent: rootEl,
            tagName: 'button',
            content: (0, _language.LANG)('dismiss'),
            onClick: ()=>{
                isDismissed = true;
                iframe.remove();
                rootEl.remove();
            },
            css: {
                pointerEvents: 'initial'
            }
        });
        // iframe allows pinch-zooming the page even if viewport meta tag set to user-scalable=no
        const iframe = (0, _bb.BB).el({
            tagName: 'iframe',
            css: {
                position: 'fixed',
                width: '100vw',
                height: '100vh',
                zIndex: '99',
                opacity: '0'
            }
        });
        let isInDom = false;
        function check() {
            if (isDismissed) return;
            const testEl = (0, _bb.BB).el({
                parent: document.body,
                css: {
                    position: 'fixed',
                    inset: '0',
                    zIndex: '-1'
                }
            });
            const rect = testEl.getBoundingClientRect();
            testEl.remove();
            const isZoomed = (viewport.width !== Math.round(rect.width) || viewport.height !== Math.round(rect.height)) && viewport.scale > 1;
            if (isZoomed) {
                (0, _base.css)(rootEl, {
                    left: viewport.offsetLeft + 'px',
                    top: viewport.offsetTop + 'px',
                    width: viewport.width + 'px',
                    height: viewport.height + 'px'
                });
                if (!isInDom) {
                    document.body.append(iframe);
                    document.body.append(rootEl);
                }
            } else if (isInDom) {
                iframe.remove();
                rootEl.remove();
            }
            isInDom = isZoomed;
        }
        viewport.addEventListener('resize', check);
        viewport.addEventListener('scroll', check);
        setTimeout(check);
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kXB2m":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * performs undo/redo in klHistory and tempHistory
 */ parcelHelpers.export(exports, "KlHistoryExecutor", ()=>KlHistoryExecutor);
class KlHistoryExecutor {
    /**
     * If UI is frozen while pressing undo/redo, the user might click multiple times
     * because they think the click wasn't registered.
     * This test prevents multiple undo/redo at once.
     * true = skip
     */ testShouldSkip() {
        if (this.doIgnore) return true;
        this.doIgnore = true;
        setTimeout(()=>{
            this.doIgnore = false;
        }, 0);
        return false;
    }
    canUndo() {
        return this.tempHistory.getIsActive() && this.tempHistory.canDecreaseIndex() || this.klHistory.canUndo();
    }
    canRedo() {
        if (this.tempHistory.getIsActive()) return this.tempHistory.canIncreaseIndex();
        return this.klHistory.canRedo();
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.doIgnore = false;
        this.lastCanUndo = false;
        this.lastCanRedo = false;
        this.klHistory = p.klHistory;
        this.tempHistory = p.tempHistory;
        this.onCanUndoRedoChange = p.onCanUndoRedoChange;
        const emitCanUndoRedo = ()=>{
            const canUndo = this.canUndo();
            const canRedo = this.canRedo();
            if (this.lastCanUndo === canUndo && this.lastCanRedo === canRedo) return;
            this.lastCanUndo = canUndo;
            this.lastCanRedo = canRedo;
            this.onCanUndoRedoChange(canUndo, canRedo);
        };
        this.klHistory.addListener(emitCanUndoRedo);
        this.tempHistory.addListener(emitCanUndoRedo);
    }
    // returns undefined if it can't undo
    undo() {
        if (this.testShouldSkip()) return undefined;
        if (this.tempHistory.getIsActive() && this.tempHistory.canDecreaseIndex()) {
            this.tempHistory.decreaseIndex();
            return {
                type: 'tempUndo'
            };
        }
        if (!this.klHistory.canUndo()) return undefined;
        this.klHistory.decreaseIndex();
        return {
            type: 'undo'
        };
    }
    // returns undefined if it can't redo
    redo() {
        if (this.testShouldSkip()) return undefined;
        if (this.tempHistory.getIsActive() && this.tempHistory.canIncreaseIndex()) {
            this.tempHistory.increaseIndex();
            return {
                type: 'tempRedo'
            };
        }
        if (!this.klHistory.canRedo()) return undefined;
        this.klHistory.increaseIndex();
        return {
            type: 'redo'
        };
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cB30s":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// does it exclusively change activeLayerId
parcelHelpers.export(exports, "isHistoryEntryActiveLayerChange", ()=>isHistoryEntryActiveLayerChange);
function isHistoryEntryActiveLayerChange(entry) {
    const keys = Object.keys(entry);
    return keys.length === 1 && keys[0] === 'activeLayerId';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7HnFm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MobileUi", ()=>MobileUi);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _localStorage = require("../../../bb/base/local-storage");
var _base = require("../../../bb/base/base");
class MobileUi {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.toolspaceIsOpen = true;
        this.orientation = 'right';
        this.isVisible = false;
        this.onShowToolspace = p.onShowToolspace;
        this.toolspaceCollapser = new (0, _kl.KL).ToolspaceCollapser({
            onChange: ()=>{
                this.toolspaceIsOpen = this.toolspaceCollapser.isOpen();
                this.onShowToolspace(this.toolspaceIsOpen);
                if (this.toolspaceIsOpen) (0, _localStorage.LocalStorage).removeItem('uiShowMobile');
                else (0, _localStorage.LocalStorage).setItem('uiShowMobile', 'true');
            }
        });
        this.mobileWrapperEl = (0, _bb.BB).el({
            css: {
                marginTop: '4px',
                display: 'flex',
                flexDirection: 'column',
                gap: '4px'
            }
        });
        this.mobileWrapperEl.append(...p.toolUis);
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: 'absolute',
                top: '0',
                userSelect: 'none'
            }
        });
        this.rootEl.append(this.toolspaceCollapser.getElement(), this.mobileWrapperEl);
        this.update();
    }
    update() {
        if (this.isVisible) {
            if (this.toolspaceIsOpen) {
                this.mobileWrapperEl.style.display = 'none';
                if (this.orientation === 'left') (0, _base.css)(this.rootEl, {
                    left: '271px',
                    right: ''
                });
                else (0, _base.css)(this.rootEl, {
                    left: '',
                    right: '271px'
                });
            } else {
                this.mobileWrapperEl.style.display = 'flex';
                if (this.orientation === 'left') (0, _base.css)(this.rootEl, {
                    left: '0',
                    right: ''
                });
                else (0, _base.css)(this.rootEl, {
                    left: '',
                    right: '0'
                });
            }
            this.rootEl.style.display = 'block';
        } else this.rootEl.style.display = 'none';
    }
    setOrientation(orientation) {
        this.orientation = orientation;
        this.toolspaceCollapser.setOrientation(orientation);
    }
    setIsVisible(b) {
        this.isVisible = b;
    }
    getToolspaceIsOpen() {
        return this.toolspaceIsOpen;
    }
    setToolspaceIsOpen(b) {
        this.toolspaceIsOpen = b;
        this.toolspaceCollapser.setIsOpen(b);
        this.onShowToolspace(b);
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","../../kl":"lHQKw","../../../bb/base/local-storage":"itqB1","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"89Xkb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MobileBrushUi", ()=>MobileBrushUi);
var _bb = require("../../../bb/bb");
var _options = require("../components/options");
var _language = require("../../../language/language");
var _toolPaintSvg = require("url:/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
var _brushEraserSvg = require("url:/src/app/img/ui/brush-eraser.svg");
var _brushEraserSvgDefault = parcelHelpers.interopDefault(_brushEraserSvg);
var _icon = require("../components/icon");
class MobileBrushUi {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        const brushIcon = new (0, _icon.Icon)({
            imageUrl: (0, _toolPaintSvgDefault.default),
            width: 28,
            height: 28,
            darkInvert: true,
            css: {
                margin: '4px'
            }
        });
        const eraserIcon = new (0, _icon.Icon)({
            imageUrl: (0, _brushEraserSvgDefault.default),
            width: 28,
            height: 28,
            darkInvert: true,
            css: {
                margin: '4px'
            }
        });
        this.brushOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: 'brush',
                    label: brushIcon.getElement(),
                    title: (0, _language.LANG)('tool-brush')
                },
                {
                    id: 'eraser',
                    label: eraserIcon.getElement(),
                    title: (0, _language.LANG)('eraser')
                }
            ],
            initId: 'brush',
            onChange: (id)=>{
                if (id === 'brush') p.onBrush();
                else p.onEraser();
            },
            isColumn: true
        });
        this.rootEl = (0, _bb.BB).el({
            css: {}
        });
        this.rootEl.append(this.brushOptions.getElement());
    }
    setIsVisible(b) {
        this.rootEl.style.display = b ? 'block' : 'none';
    }
    setType(type) {
        this.brushOptions.setValue(type, true);
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","../components/options":"7kiPU","../../../language/language":"mcywn","url:/src/app/img/ui/tool-paint.svg":"kLnEj","url:/src/app/img/ui/brush-eraser.svg":"5aXt2","../components/icon":"ioNz6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ioNz6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Icon", ()=>Icon);
var _bb = require("../../../bb/bb");
class Icon {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: p.darkInvert ? 'dark-invert' : '',
            css: {
                backgroundImage: `url("${p.imageUrl}")`,
                backgroundSize: 'contain',
                backgroundPosition: 'center',
                backgroundRepeat: 'no-repeat',
                width: p.width + 'px',
                height: p.height + 'px',
                ...p.css
            }
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bTdY6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "projectToComposed", ()=>projectToComposed);
var _klTypes = require("../../kl-types");
var _canvasToLayerTiles = require("./canvas-to-layer-tiles");
var _getNextLayerId = require("../get-next-layer-id");
var _bb = require("../../../bb/bb");
function projectToComposed(project) {
    let lastId = '';
    const layerMap = Object.fromEntries(project.layers.map((layer, index)=>{
        lastId = (0, _getNextLayerId.getNextLayerId)();
        let tiles = [];
        if (layer.image instanceof Array) tiles = [
            ...layer.image
        ];
        else {
            const canvas = (()=>{
                if (layer.image instanceof HTMLCanvasElement) return layer.image;
                const canvas = (0, _bb.BB).canvas(project.width, project.height);
                const ctx = (0, _bb.BB).ctx(canvas);
                if ((0, _klTypes.isLayerFill)(layer.image)) {
                    ctx.fillStyle = layer.image.fill;
                    ctx.fillRect(0, 0, project.width, project.height);
                } else ctx.drawImage(layer.image, 0, 0);
                return canvas;
            })();
            tiles = (0, _canvasToLayerTiles.canvasToLayerTiles)(canvas);
        }
        return [
            lastId,
            {
                name: layer.name,
                opacity: layer.opacity,
                isVisible: layer.isVisible,
                mixModeStr: layer.mixModeStr ?? 'source-over',
                index,
                tiles
            }
        ];
    }));
    return {
        projectId: {
            value: project.projectId
        },
        size: {
            width: project.width,
            height: project.height
        },
        selection: {},
        activeLayerId: lastId,
        layerMap
    };
}

},{"../../kl-types":"E0RUG","./canvas-to-layer-tiles":"byCWA","../get-next-layer-id":"friOj","../../../bb/bb":"3zOvT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f7U4Z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnloadWarningTrigger", ()=>UnloadWarningTrigger);
class UnloadWarningTrigger {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.onBeforeUnload = (e)=>{
            e.preventDefault();
            e.returnValue = '';
        };
        this.klHistory = p.klHistory;
        this.getLastSavedHistoryIndex = p.getLastSavedHistoryIndex;
        p.klHistory.addListener(()=>this.update());
    }
    update() {
        const historyIndex = this.klHistory.getTotalIndex();
        if (this.getLastSavedHistoryIndex() !== historyIndex) window.addEventListener('beforeunload', this.onBeforeUnload);
        else window.removeEventListener('beforeunload', this.onBeforeUnload);
    }
    destroy() {
    //...
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fUcDD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runBrowserStorageBanner", ()=>runBrowserStorageBanner);
var _bb = require("../../../bb/bb");
var _browserStorageBannerModuleScss = require("./browser-storage-banner.module.scss");
var _language = require("../../../language/language");
var _base = require("../../../bb/base/base");
var _crossTabChannel = require("../../../bb/base/cross-tab-channel");
var _cancelSvg = require("url:/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
async function runBrowserStorageBanner(p) {
    /*
    only show banner if all:
    - nothing was recovered
    - project store is not empty
    - no other tab has this project already open (prevent confusion)
     */ if (!p.projectStore) // no store -> noop
    return;
    const openedProjectIds = [];
    const crossTabChannel = new (0, _crossTabChannel.CrossTabChannel)('kl-tab-communication');
    {
        // subscription stays up during run of application
        crossTabChannel.subscribe((message)=>{
            if (message.type === 'request-project-ids') crossTabChannel.postMessage({
                type: 'response-project-id',
                id: p.klHistory.getComposed().projectId.value
            });
        });
        const otherIdListener = (message)=>{
            if (message.type === 'response-project-id') openedProjectIds.push(message.id);
        };
        crossTabChannel.subscribe(otherIdListener);
        crossTabChannel.postMessage({
            type: 'request-project-ids'
        });
        await (0, _base.sleep)(100);
        crossTabChannel.unsubscribe(otherIdListener);
    }
    if (p.klRecoveryManager?.getTabId() !== undefined) // something already recovered -> noop
    return;
    const meta = await p.projectStore.readMeta();
    if (!meta) // nothing stored -> noop
    return;
    if (openedProjectIds.includes(meta.projectId)) // already open in other tab -> noop
    return;
    const fit = (0, _base.fitInto)(meta.thumbnail.width, meta.thumbnail.height, 100, 100);
    (0, _base.css)(meta.thumbnail, {
        width: fit.width + 'px',
        height: fit.height + 'px'
    });
    const closeButton = (0, _bb.BB).el({
        tagName: 'button',
        className: _browserStorageBannerModuleScss.closeButton + ' popup-x',
        content: `<img alt="${(0, _language.LANG)('modal-close')}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
        title: (0, _language.LANG)('modal-close'),
        custom: {
            tabindex: '0'
        }
    });
    closeButton.onclick = close;
    const preview = (0, _bb.BB).el({
        className: _browserStorageBannerModuleScss.preview,
        content: meta.thumbnail,
        title: (0, _language.LANG)('file-storage-open')
    });
    preview.onclick = ()=>{
        close();
        p.onOpenBrowserStorage();
    };
    const title = (0, _bb.BB).el({
        content: (0, _language.LANG)('file-storage')
    });
    const buttonClass = _browserStorageBannerModuleScss.btn;
    const openBtn = (0, _bb.BB).el({
        tagName: 'button',
        className: [
            'kl-button-primary',
            buttonClass
        ].join(' '),
        content: (0, _language.LANG)('file-storage-open'),
        custom: {
            tabIndex: '-1'
        }
    });
    openBtn.onclick = ()=>{
        close();
        p.onOpenBrowserStorage();
    };
    const rightCol = (0, _bb.BB).el({
        className: _browserStorageBannerModuleScss.rightCol,
        content: [
            title,
            openBtn
        ]
    });
    const mainContent = (0, _bb.BB).el({
        className: _browserStorageBannerModuleScss.mainContent,
        content: [
            preview,
            rightCol
        ]
    });
    const closeArea = (0, _bb.BB).el({
        className: _browserStorageBannerModuleScss.closeArea
    });
    closeArea.onclick = close;
    const banner = (0, _bb.BB).el({
        className: _browserStorageBannerModuleScss.banner,
        content: [
            closeArea,
            mainContent,
            closeButton
        ]
    });
    banner.onclick = (0, _bb.BB).handleClick;
    const rootEl = (0, _bb.BB).el({
        content: [
            banner
        ],
        className: _browserStorageBannerModuleScss.root
    });
    document.body.append(rootEl);
    function close() {
        clearTimeout(timeout);
        document.removeEventListener('pointerdown', onPointerDown);
        (0, _base.css)(rootEl, {
            opacity: '0'
        });
        (0, _base.css)(banner, {
            pointerEvents: 'none'
        });
        setTimeout(()=>{
            rootEl.remove();
        }, 200);
    }
    const timeout = setTimeout(close, 4500);
    const onPointerDown = (e)=>{
        const target = e.target;
        if (banner.contains(target) || banner.contains(target)) return;
        close();
    };
    document.addEventListener('pointerdown', onPointerDown, {
        passive: false
    });
}

},{"../../../bb/bb":"3zOvT","./browser-storage-banner.module.scss":"fdGpe","../../../language/language":"mcywn","../../../bb/base/base":"it3mQ","../../../bb/base/cross-tab-channel":"czgd6","url:/src/app/img/ui/cancel.svg":"kcuhT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fdGpe":[function(require,module,exports,__globalThis) {
module.exports["banner"] = `RP219q_banner`;
module.exports["btn"] = `RP219q_btn`;
module.exports["closeArea"] = `RP219q_closeArea`;
module.exports["closeButton"] = `RP219q_closeButton`;
module.exports["mainContent"] = `RP219q_mainContent`;
module.exports["preview"] = `RP219q_preview`;
module.exports["rightCol"] = `RP219q_rightCol`;
module.exports["root"] = `RP219q_root`;
module.exports["rootAnim"] = `RP219q_rootAnim`;
module.exports["rootAnim"];

},{}],"hmxZ7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MobileColorUi", ()=>MobileColorUi);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _toolPickerSvg = require("url:/src/app/img/ui/tool-picker.svg");
var _toolPickerSvgDefault = parcelHelpers.interopDefault(_toolPickerSvg);
var _boxToggle = require("../components/box-toggle");
var _icon = require("../components/icon");
var _mobileFloatingWindow = require("./mobile-floating-window");
var _klColorSliderSmall = require("../components/kl-color-slider-small");
class MobileColorUi {
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.colorPickerPosition = {
            x: 100,
            y: 100
        };
        this.color = {
            r: 0,
            g: 0,
            b: 0
        };
        this.color = {
            ...p.color
        };
        this.colorCircle = (0, _bb.BB).el({
            css: {
                width: '30px',
                height: '30px',
                background: (0, _bb.BB).ColorConverter.toRgbStr(p.color),
                borderRadius: '100%',
                boxShadow: '0 0 0 1px rgba(0,0,0,0.5), inset 0 0 0 1px rgba(255,255,255,0.5)',
                alignSelf: 'center',
                cursor: 'pointer'
            },
            noRef: true,
            onClick: ()=>{
                if (this.colorPicker) {
                    this.closeColorPicker();
                    return;
                }
                this.colorPicker = new (0, _klColorSliderSmall.KlColorSliderSmall)({
                    width: 200,
                    heightSV: 200,
                    heightH: 30,
                    color: this.color,
                    callback: p.onColorChange
                });
                this.colorWindow = new (0, _mobileFloatingWindow.MobileFloatingWindow)({
                    content: (0, _bb.BB).el({
                        content: this.colorPicker.getElement()
                    }),
                    onClose: ()=>{
                        this.closeColorPicker();
                    },
                    position: this.colorPickerPosition
                });
                document.body.append(this.colorWindow.getElement());
            }
        });
        const icon = new (0, _icon.Icon)({
            imageUrl: (0, _toolPickerSvgDefault.default),
            width: 1,
            height: 1,
            css: {
                width: '100%',
                height: '100%'
            },
            darkInvert: true
        });
        this.eyedropperToggle = new (0, _boxToggle.BoxToggle)({
            init: false,
            title: (0, _language.LANG)('eyedropper'),
            onChange: (b)=>{
                p.onEyedropper(b);
            },
            label: (0, _bb.BB).el({
                content: icon.getElement(),
                css: {
                    padding: '6px',
                    height: '36px'
                }
            })
        });
        this.rootEl = (0, _bb.BB).el({
            css: {
                display: 'flex',
                flexDirection: 'column',
                gap: '4px'
            }
        });
        this.rootEl.append(this.colorCircle, this.eyedropperToggle.getElement());
    }
    getIsEyedropping() {
        return this.eyedropperToggle.getValue();
    }
    setIsEyedropping(b) {
        this.eyedropperToggle.setValue(b);
    }
    setColor(color) {
        this.color = {
            ...color
        };
        this.colorCircle.style.backgroundColor = (0, _bb.BB).ColorConverter.toRgbStr(color);
        this.colorPicker?.setColor(color);
    }
    closeColorPicker() {
        if (this.colorWindow) {
            this.colorPickerPosition = this.colorWindow.getPosition();
            this.colorWindow?.destroy();
            this.colorWindow?.getElement().remove();
            this.colorWindow = undefined;
        }
        this.colorPicker?.destroy();
        this.colorPicker = undefined;
    }
    setIsVisible(b) {
        this.rootEl.style.display = b ? 'flex' : 'none';
        if (!b) this.closeColorPicker();
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"3zOvT","../../../language/language":"mcywn","url:/src/app/img/ui/tool-picker.svg":"hq1oG","../components/box-toggle":"1YB1o","../components/icon":"ioNz6","./mobile-floating-window":"1JsIo","../components/kl-color-slider-small":"j88oi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1JsIo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MobileFloatingWindow", ()=>MobileFloatingWindow);
var _bb = require("../../../bb/bb");
var _math = require("../../../bb/math/math");
var _language = require("../../../language/language");
var _cancelSvg = require("url:/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
var _base = require("../../../bb/base/base");
class MobileFloatingWindow {
    applyPosition() {
        const rect = this.rootEl.getBoundingClientRect();
        this.position.x = (0, _math.clamp)(this.position.x, 0, window.innerWidth - rect.width);
        this.position.y = (0, _math.clamp)(this.position.y, 0, window.innerHeight - rect.height);
        (0, _base.css)(this.rootEl, {
            left: this.position.x + 'px',
            top: this.position.y + 'px'
        });
    }
    // ----------------------------------- public -----------------------------------
    constructor(p){
        this.position = {
            ...p.position
        };
        this.xButton = (0, _bb.BB).el({
            tagName: 'button',
            className: 'popup-x',
            content: `<img alt="${(0, _language.LANG)('modal-close')}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
            title: (0, _language.LANG)('modal-close'),
            noRef: true,
            onClick: ()=>{
                p.onClose();
            },
            css: {
                width: '32px',
                height: '32px',
                lineHeight: '32px',
                background: 'none',
                boxShadow: 'none'
            },
            custom: {
                tabindex: '0'
            }
        });
        const header = (0, _bb.BB).el({
            className: 'kl-floating-window-header'
        });
        header.append(this.xButton);
        const body = (0, _bb.BB).el({
            content: p.content
        });
        let downPosition = {
            x: 0,
            y: 0
        };
        this.pointerListener = new (0, _bb.BB).PointerListener({
            target: header,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.button === 'left' && event.type === 'pointerdown') downPosition = {
                    ...this.position
                };
                if (event.button === 'left' && event.type === 'pointermove') {
                    this.position.x = downPosition.x + event.pageX - event.downPageX;
                    this.position.y = downPosition.y + event.pageY - event.downPageY;
                    this.applyPosition();
                }
            }
        });
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: 'fixed',
                display: 'flex',
                flexDirection: 'column',
                left: this.position.x + 'px',
                top: this.position.y + 'px'
            }
        });
        this.rootEl.append(header, body);
        setTimeout(()=>this.applyPosition());
    }
    getElement() {
        return this.rootEl;
    }
    getPosition() {
        return {
            ...this.position
        };
    }
    destroy() {
        this.pointerListener.destroy();
    }
}

},{"../../../bb/bb":"3zOvT","../../../bb/math/math":"7x9Fp","../../../language/language":"mcywn","url:/src/app/img/ui/cancel.svg":"kcuhT","../../../bb/base/base":"it3mQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}]},["fsWvP","jcEgk"], "jcEgk", "parcelRequire94c2", {}, "./", "/")

//# sourceMappingURL=klecks-main.145099c5.js.map
